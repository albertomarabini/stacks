var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __glob = (map2) => (path) => {
  var fn3 = map2[path];
  if (fn3) return fn3();
  throw new Error("Module not found in bundle: " + path);
};
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to4, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to4, key) && key !== except)
        __defProp(to4, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to4;
};
var __reExport = (target, mod3, secondTarget) => (__copyProps(target, mod3, "default"), secondTarget && __copyProps(secondTarget, mod3, "default"));
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// node_modules/@scure/base/lib/esm/index.js
function isBytes(a5) {
  return a5 instanceof Uint8Array || ArrayBuffer.isView(a5) && a5.constructor.name === "Uint8Array";
}
function abytes(b7, ...lengths) {
  if (!isBytes(b7))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b7.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b7.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n12) {
  if (!Number.isSafeInteger(n12))
    throw new Error(`invalid integer: ${n12}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a5) => a5;
  const wrap = (a5, b7) => (c12) => a5(b7(c12));
  const encode6 = args.map((x7) => x7.encode).reduceRight(wrap, id);
  const decode7 = args.map((x7) => x7.decode).reduce(wrap, id);
  return { encode: encode6, decode: decode7 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l10, i11) => [l10, i11]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i11) => {
        if (!Number.isSafeInteger(i11) || i11 < 0 || i11 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i11}". Allowed: ${letters}`);
        return lettersA[i11];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i11 = indexes.get(letter);
        if (i11 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i11;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from3) => {
      astrArr("join.decode", from3);
      return from3.join(separator);
    },
    decode: (to4) => {
      astr("join.decode", to4);
      return to4.split(separator);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function convertRadix2(data, from3, to4, padding2) {
  aArr(data);
  if (from3 <= 0 || from3 > 32)
    throw new Error(`convertRadix2: wrong from=${from3}`);
  if (to4 <= 0 || to4 > 32)
    throw new Error(`convertRadix2: wrong to=${to4}`);
  if (/* @__PURE__ */ radix2carry(from3, to4) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from3} to=${to4} carryBits=${/* @__PURE__ */ radix2carry(from3, to4)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from3];
  const mask = powers[to4] - 1;
  const res = [];
  for (const n12 of data) {
    anumber(n12);
    if (n12 >= max)
      throw new Error(`convertRadix2: invalid data word=${n12} from=${from3}`);
    carry = carry << from3 | n12;
    if (pos + from3 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from3}`);
    pos += from3;
    for (; pos >= to4; pos -= to4)
      res.push((carry >> pos - to4 & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to4 - pos & mask;
  if (!padding2 && pos >= from3)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
// @__NO_SIDE_EFFECTS__
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
var gcd, radix2carry, powers, base32, hasBase64Builtin, decodeBase64Builtin, base64;
var init_esm = __esm({
  "node_modules/@scure/base/lib/esm/index.js"() {
    gcd = (a5, b7) => b7 === 0 ? a5 : gcd(b7, a5 % b7);
    radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from3, to4) => from3 + (to4 - gcd(from3, to4));
    powers = /* @__PURE__ */ (() => {
      let res = [];
      for (let i11 = 0; i11 < 40; i11++)
        res.push(2 ** i11);
      return res;
    })();
    base32 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(5), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ padding(5), /* @__PURE__ */ join(""));
    hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
    decodeBase64Builtin = (s8, isUrl) => {
      astr("base64", s8);
      const re4 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
      const alphabet3 = isUrl ? "base64url" : "base64";
      if (s8.length > 0 && !re4.test(s8))
        throw new Error("invalid base64");
      return Uint8Array.fromBase64(s8, { alphabet: alphabet3, lastChunkHandling: "strict" });
    };
    base64 = hasBase64Builtin ? {
      encode(b7) {
        abytes(b7);
        return b7.toBase64();
      },
      decode(s8) {
        return decodeBase64Builtin(s8, false);
      }
    } : /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join(""));
  }
});

// node_modules/@stacks/connect-ui/dist/esm/connect-modal.entry.js
var connect_modal_entry_exports = {};
__export(connect_modal_entry_exports, {
  connect_modal: () => Modal
});
var closeIconSvg, isChrome, getBrowser, getPlatform, modalCss, Modal;
var init_connect_modal_entry = __esm({
  "node_modules/@stacks/connect-ui/dist/esm/connect-modal.entry.js"() {
    init_index_BnFj5nlp();
    closeIconSvg = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTcgNyAxMCAxME0xNyA3IDcgMTciIHN0cm9rZT0iIzI0MjYyOSIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==";
    isChrome = () => {
      const isChromium = !!window["chrome"];
      const winNav = window.navigator;
      const vendorName = winNav.vendor;
      const isOpera = typeof window.opr !== "undefined";
      const isIEedge = winNav.userAgent.includes("Edge");
      const isIOSChrome = /CriOS/.exec(winNav.userAgent);
      const isMobile = winNav.userAgent.includes("Mobile");
      if (isIOSChrome) {
        return false;
      } else if (isChromium !== null && typeof isChromium !== "undefined" && vendorName === "Google Inc." && isOpera === false && isIEedge === false && isMobile === false) {
        return true;
      } else {
        return false;
      }
    };
    getBrowser = () => {
      if (isChrome()) {
        return "Chrome";
      } else if (window.navigator.userAgent.includes("Firefox")) {
        return "Firefox";
      }
      return null;
    };
    getPlatform = () => {
      if (!window.navigator.userAgent.includes("Mobile"))
        return null;
      if (window.navigator.userAgent.includes("iPhone")) {
        return "IOS";
      } else
        return "Android";
    };
    modalCss = '/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,::backdrop,:after,:before{--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1}}}@layer theme{:host,:root{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-gray-100:oklch(96.7% .003 264.542);--color-gray-700:oklch(37.3% .034 259.733);--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:1.33333;--text-sm:.875rem;--text-sm--line-height:1.42857;--text-xl:1.25rem;--text-xl--line-height:1.4;--font-weight-medium:500;--leading-snug:1.375;--radius-2xl:1rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,::backdrop,:after,:before{border:0 solid;box-sizing:border-box;margin:0;padding:0}::file-selector-button{appearance:button;background-color:#0000;border:0 solid;border-radius:0;box-sizing:border-box;color:inherit;font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;margin:0;margin-inline-end:4px;opacity:1;padding:0}:host,html{-webkit-text-size-adjust:100%;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);line-height:1.5;tab-size:4;-webkit-tap-highlight-color:transparent}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-size:1em;font-variation-settings:var(--default-mono-font-variation-settings,normal)}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}menu,ol,ul{list-style:none}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}button,input,optgroup,select,textarea{background-color:#0000;border-radius:0;color:inherit;font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;opacity:1}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex;padding-block:0}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field,::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-meridiem-field,::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.sr-only{clip:rect(0,0,0,0);border-width:0;height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.fixed{position:fixed}.inset-0{inset:calc(var(--spacing)*0)}.z-\\[8999\\]{z-index:8999}.z-\\[9000\\]{z-index:9000}.mt-6{margin-top:calc(var(--spacing)*6)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-5{margin-bottom:calc(var(--spacing)*5)}.box-border{box-sizing:border-box}.flex{display:flex}.aspect-square{aspect-ratio:1}.h-full{height:100%}.max-h-\\[calc\\(100\\%-24px\\)\\]{max-height:calc(100% - 24px)}.w-full{width:100%}.max-w-full{max-width:100%}.flex-1{flex:1}.basis-9{flex-basis:calc(var(--spacing)*9)}.cursor-default{cursor:default}.cursor-pointer{cursor:pointer}.flex-col{flex-direction:column}.items-center{align-items:center}.items-end{align-items:flex-end}.justify-between{justify-content:space-between}.gap-3{gap:calc(var(--spacing)*3)}:where(.space-y-3>:not(:last-child)){--tw-space-y-reverse:0;margin-block-end:calc(var(--spacing)*3*(1 - var(--tw-space-y-reverse)));margin-block-start:calc(var(--spacing)*3*var(--tw-space-y-reverse))}:where(.space-y-\\[10px\\]>:not(:last-child)){--tw-space-y-reverse:0;margin-block-end:calc(10px*(1 - var(--tw-space-y-reverse)));margin-block-start:calc(10px*var(--tw-space-y-reverse))}:where(.space-x-\\[5px\\]>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-end:calc(5px*(1 - var(--tw-space-x-reverse)));margin-inline-start:calc(5px*var(--tw-space-x-reverse))}.overflow-hidden{overflow:hidden}.overflow-y-scroll{overflow-y:scroll}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-\\[10px\\]{border-radius:10px}.rounded-full{border-radius:3.40282e+38px}.rounded-b-none{border-bottom-left-radius:0;border-bottom-right-radius:0}.border{border-style:var(--tw-border-style);border-width:1px}.border-\\[\\#333\\]{border-color:#333}.border-\\[\\#EFEFF2\\]{border-color:#efeff2}.bg-\\[\\#00000040\\]{background-color:#00000040}.bg-\\[\\#323232\\]{background-color:#323232}.bg-gray-700{background-color:var(--color-gray-700)}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.p-1{padding:calc(var(--spacing)*1)}.p-6{padding:calc(var(--spacing)*6)}.p-\\[14px\\]{padding:14px}.px-4{padding-inline:calc(var(--spacing)*4)}.py-2{padding-block:calc(var(--spacing)*2)}.align-text-bottom{vertical-align:text-bottom}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[9px\\]{font-size:9px}.leading-snug{--tw-leading:var(--leading-snug);line-height:var(--leading-snug)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.text-\\[\\#242629\\]{color:#242629}.text-\\[\\#EFEFEF\\]{color:#efefef}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a)}.shadow,.shadow-\\[0_1px_2px_0_\\#0000000A\\]{box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-\\[0_1px_2px_0_\\#0000000A\\]{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000a)}.shadow-\\[0_4px_5px_0_\\#00000005\\,0_16px_40px_0_\\#00000014\\]{--tw-shadow:0 4px 5px 0 var(--tw-shadow-color,#00000005),0 16px 40px 0 var(--tw-shadow-color,#00000014);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline-\\[\\#FFBD7A\\]{outline-color:#ffbd7a}.transition-all{transition-duration:var(--tw-duration,var(--default-transition-duration));transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function))}.transition-colors{transition-duration:var(--tw-duration,var(--default-transition-duration));transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function))}.focus\\:underline:focus{text-decoration-line:underline}.focus\\:outline:focus{outline-style:var(--tw-outline-style);outline-width:1px}.focus\\:outline-\\[3px\\]:focus{outline-style:var(--tw-outline-style);outline-width:3px}.active\\:scale-95:active{--tw-scale-x:95%;--tw-scale-y:95%;--tw-scale-z:95%;scale:var(--tw-scale-x)var(--tw-scale-y)}.animate-in{--tw-enter-opacity:initial;--tw-enter-scale:initial;--tw-enter-rotate:initial;--tw-enter-translate-x:initial;--tw-enter-translate-y:initial;animation-duration:.15s;animation-name:enter}.fade-in{--tw-enter-opacity:0}.slide-in-from-bottom{--tw-enter-translate-y:100%}} /*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */@layer properties{}@layer base{}@layer components;@layer utilities{}:host{all:initial;--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:rotateX(0);--tw-rotate-y:rotateY(0);--tw-rotate-z:rotateZ(0);--tw-skew-x:skewX(0);--tw-skew-y:skewY(0);--tw-border-style:solid;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-shadow:0 0 #0000;--tw-inset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid}.modal-container{color:#74777d;font-family:Inter,-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol}.modal-body{-ms-overflow-style:none;scrollbar-width:none}.modal-body::-webkit-scrollbar{display:none}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0))}}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-space-x-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@media (hover:hover){.hover\\:bg-\\[\\#0C0C0D\\]:hover{background-color:#0c0c0d}.hover\\:bg-gray-100:hover{background-color:var(--color-gray-100)}.hover\\:text-\\[\\#242629\\]:hover{color:#242629}.hover\\:text-white:hover{color:var(--color-white)}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:shadow-\\[0_1px_2px_0_\\#00000010\\]:hover{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#00000010)}.hover\\:shadow-\\[0_1px_2px_0_\\#00000010\\]:hover,.hover\\:shadow-\\[0_8px_16px_0_\\#00000020\\]:hover{box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:shadow-\\[0_8px_16px_0_\\#00000020\\]:hover{--tw-shadow:0 8px 16px 0 var(--tw-shadow-color,#00000020)}}@media (min-width:48rem){.md\\:max-h-\\[calc\\(100\\%-48px\\)\\]{max-height:calc(100% - 48px)}.md\\:w-\\[400px\\]{width:400px}.md\\:items-center{align-items:center}.md\\:justify-center{justify-content:center}.md\\:rounded-b-2xl{border-bottom-left-radius:var(--radius-2xl);border-bottom-right-radius:var(--radius-2xl)}.md\\:slide-in-from-bottom-0{--tw-enter-translate-y:0px}.md\\:zoom-in-50{--tw-enter-scale:.5}}';
    Modal = class {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      handleSelectProvider(providerId) {
        this.callback(providerId);
      }
      handleCloseModal() {
        this.cancelCallback();
      }
      // todo: nice to have:
      // getComment(provider: WebBTCProvider, browser: string, isMobile?: string) {
      //   if (!provider) return null;
      //   const hasExtension = this.getBrowserUrl(provider);
      //   const hasMobile = this.getMobileUrl(provider);
      //   if (isMobile && hasExtension && !hasMobile) return 'Extension Only';
      //   if (!isMobile && !hasExtension && hasMobile) return 'Mobile Only';
      //   if (!isMobile && !browser) return 'Current browser not supported';
      //   return null;
      // }
      getBrowserUrl(provider) {
        var _a2;
        return (_a2 = provider.chromeWebStoreUrl) !== null && _a2 !== void 0 ? _a2 : provider.mozillaAddOnsUrl;
      }
      getMobileUrl(provider) {
        var _a2;
        return (_a2 = provider.iOSAppStoreUrl) !== null && _a2 !== void 0 ? _a2 : provider.googlePlayStoreUrl;
      }
      getInstallUrl(provider, browser, platform) {
        var _a2, _b, _c2, _d, _e7, _f2, _g, _h, _j, _k;
        if (platform === "IOS") {
          return (_b = (_a2 = provider.iOSAppStoreUrl) !== null && _a2 !== void 0 ? _a2 : this.getBrowserUrl(provider)) !== null && _b !== void 0 ? _b : provider.webUrl;
        } else if (browser === "Chrome") {
          return (_d = (_c2 = provider.chromeWebStoreUrl) !== null && _c2 !== void 0 ? _c2 : this.getMobileUrl(provider)) !== null && _d !== void 0 ? _d : provider.webUrl;
        } else if (browser === "Firefox") {
          return (_f2 = (_e7 = provider.mozillaAddOnsUrl) !== null && _e7 !== void 0 ? _e7 : this.getMobileUrl(provider)) !== null && _f2 !== void 0 ? _f2 : provider.webUrl;
        } else if (platform === "Android") {
          return (_h = (_g = provider.googlePlayStoreUrl) !== null && _g !== void 0 ? _g : this.getBrowserUrl(provider)) !== null && _h !== void 0 ? _h : provider.webUrl;
        } else {
          return (_k = (_j = this.getBrowserUrl(provider)) !== null && _j !== void 0 ? _j : provider.webUrl) !== null && _k !== void 0 ? _k : this.getMobileUrl(provider);
        }
      }
      render() {
        const browser = getBrowser();
        const mobile = getPlatform();
        const notInstalledProviders = this.defaultProviders.filter(
          (p8) => this.installedProviders.findIndex((i11) => i11.id === p8.id) === -1
          // keep providers NOT already in installed list
        );
        const hasInstalled = this.installedProviders.length > 0;
        const hasMore = notInstalledProviders.length > 0;
        return h("div", { key: "486a8b0d4c08fb0f38d26584880b40975ce74939", class: "modal-container animate-in fade-in fixed inset-0 z-[8999] box-border flex h-full w-full items-end bg-[#00000040] md:items-center md:justify-center" }, h("div", { key: "54488652b87fb84e0bfc37e0dce83bdc252b2eee", class: "fixed inset-0 z-[8999]", onClick: () => this.handleCloseModal() }), h("div", { key: "21c5463a21e285951dee580db2b2e097fb071ece", class: "modal-body animate-in md:zoom-in-50 slide-in-from-bottom md:slide-in-from-bottom-0 z-[9000] box-border flex max-h-[calc(100%-24px)] w-full max-w-full cursor-default flex-col overflow-y-scroll rounded-2xl rounded-b-none bg-white p-6 text-sm leading-snug shadow-[0_4px_5px_0_#00000005,0_16px_40px_0_#00000014] md:max-h-[calc(100%-48px)] md:w-[400px] md:rounded-b-2xl" }, h("div", { key: "33064b362a40aafb47fa497bcfe12c7c0b9862e7", class: "flex flex-col space-y-[10px]" }, h("div", { key: "788b6280717355a38938750f5157eade7118ef7f", class: "flex items-center" }, h("div", { key: "327d62d08c8acc81692930cfb99a23e7b45cbae5", class: "flex-1 text-xl font-medium text-[#242629]" }, "Connect a wallet"), h("button", { key: "61e2400cc41284e4f6df15718578558dd1667efd", class: "rounded-full bg-transparent p-1 transition-colors hover:bg-gray-100 active:scale-95", onClick: () => this.handleCloseModal() }, h("span", { key: "5bda5e860b382e9aaf47b66c2e91759cfd02d736", class: "sr-only" }, "Close popup"), h("img", { key: "450a865711c1c31693d90f2cbcfe9763bae553db", src: closeIconSvg }))), hasInstalled ? h("p", null, "Select the wallet you want to connect to.") : h("p", null, "You don't have any wallets in your browser that support this app. You need to install a wallet to proceed.")), hasInstalled && h("div", { key: "2ee090d1eab36f553d6ed7565e2e2588eabcecd7", class: "mt-6" }, h("p", { key: "1bad5b095f034f12c0cfb88f76f0d7a02d23cc13", class: "mb-4 text-sm font-medium" }, "Available wallets"), h("ul", { key: "06140f18abb2ae4334d2c9bfd603246898eac7ef", class: "space-y-3" }, this.installedProviders.map((provider, i11) => {
          var _a2;
          return h("li", { class: "flex items-center gap-3 rounded-[10px] border border-[#EFEFF2] p-[14px]", key: (_a2 = provider === null || provider === void 0 ? void 0 : provider.id) !== null && _a2 !== void 0 ? _a2 : i11 }, h("div", { class: "aspect-square basis-9 overflow-hidden" }, h("img", { src: provider.icon, class: "h-full w-full rounded-[10px] bg-gray-700" })), h("div", { class: "flex-1" }, h("div", { class: "text-sm font-medium text-[#242629]" }, provider.name), provider.webUrl && h("a", { href: provider.webUrl, class: "text-sm", rel: "noopener noreferrer" }, new URL(provider.webUrl).hostname)), h("button", { class: "rounded-[10px] border border-[#333] bg-[#323232] px-4 py-2 text-sm font-medium text-[#EFEFEF] shadow-[0_1px_2px_0_#0000000A] outline-[#FFBD7A] transition-all hover:bg-[#0C0C0D] hover:text-white hover:shadow-[0_8px_16px_0_#00000020] focus:outline focus:outline-[3px] active:scale-95", onClick: () => this.handleSelectProvider(provider.id) }, "Connect"));
        }))), hasMore && h("div", { key: "e6869330825d48b2bb7a8bfc7f292dcd1c0cdf9b", class: "mt-6" }, hasInstalled ? h("p", { class: "mb-4 text-sm font-medium" }, "Other wallets") : h("div", { class: "mb-5 flex justify-between" }, h("p", { class: "text-sm font-medium" }, "Recommended wallets"), h("a", { class: "flex cursor-pointer items-center space-x-[5px] text-xs transition-colors hover:text-[#242629] hover:underline focus:underline", href: "https://docs.hiro.so/what-is-a-wallet", rel: "noopener noreferrer", target: "_blank" }, h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 16 16", fill: "none" }, h("path", { stroke: "#74777D", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "1.2", d: "M8.006 15a7 7 0 1 0 0-14 7 7 0 0 0 0 14Z" }), h("path", { stroke: "#74777D", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "1.2", d: "M5.97 5.9a2.1 2.1 0 0 1 4.08.7c0 1.4-2.1 2.1-2.1 2.1M8.006 11.5h.01" })), h("p", null, "What is a wallet?\u2009", h("span", { class: "align-text-bottom text-[9px]" }, "\u2197")))), h("ul", { key: "e8ede6e513ebe32e8aee0385a727f9c454b5f9f2", class: "space-y-3" }, notInstalledProviders.map((provider, i11) => {
          var _a2;
          return h("li", { class: "flex items-center gap-3 rounded-[10px] border border-[#EFEFF2] p-[14px]", key: (_a2 = provider === null || provider === void 0 ? void 0 : provider.id) !== null && _a2 !== void 0 ? _a2 : i11 }, h("div", { class: "aspect-square basis-9 overflow-hidden" }, h("img", { src: provider.icon, class: "h-full w-full rounded-[10px] bg-gray-700" })), h("div", { class: "flex-1" }, h("div", { class: "text-sm font-medium text-[#242629]" }, provider.name), provider.webUrl && h("a", { href: provider.webUrl, class: "text-sm", rel: "noopener noreferrer" }, new URL(provider.webUrl).hostname)), this.getInstallUrl(provider, browser, mobile) && h("a", { class: "rounded-[10px] border border-[#EFEFF2] px-4 py-2 text-sm font-medium shadow-[0_1px_2px_0_#0000000A] outline-[#FFBD7A] transition-colors hover:text-[#242629] hover:shadow-[0_1px_2px_0_#00000010] focus:outline focus:outline-[3px] active:scale-95", href: this.getInstallUrl(provider, browser, mobile), rel: "noopener noreferrer", target: "_blank" }, provider.id === "AsignaProvider" ? "Open" : "Install", " \u2192"));
        })))));
      }
      static get assetsDirs() {
        return ["assets"];
      }
      get modalEl() {
        return getElement(this);
      }
    };
    Modal.style = modalCss;
  }
});

// import("./**/*.entry.js") in node_modules/@stacks/connect-ui/dist/esm/index-BnFj5nlp.js
var globImport_entry_js;
var init_ = __esm({
  'import("./**/*.entry.js") in node_modules/@stacks/connect-ui/dist/esm/index-BnFj5nlp.js'() {
    globImport_entry_js = __glob({
      "./connect-modal.entry.js": () => Promise.resolve().then(() => (init_connect_modal_entry(), connect_modal_entry_exports))
    });
  }
});

// node_modules/@stacks/connect-ui/dist/esm/index-BnFj5nlp.js
function queryNonceMetaTagContent(doc) {
  var _a2, _b, _c2;
  return (_c2 = (_b = (_a2 = doc.head) == null ? void 0 : _a2.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c2 : void 0;
}
function map(result, fn3) {
  if (result.isOk) {
    const val = fn3(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
function createStyleSheetIfNeededAndSupported(styles2) {
  return void 0;
}
function createShadowRoot(cmpMeta) {
  var _a2;
  const shadowRoot = this.attachShadow({ mode: "open" });
  if (globalStyleSheet === void 0) globalStyleSheet = (_a2 = createStyleSheetIfNeededAndSupported()) != null ? _a2 : null;
  if (globalStyleSheet) {
    if (supportsMutableAdoptedStyleSheets) {
      shadowRoot.adoptedStyleSheets.push(globalStyleSheet);
    } else {
      shadowRoot.adoptedStyleSheets = [...shadowRoot.adoptedStyleSheets, globalStyleSheet];
    }
  }
}
function sortedAttrNames(attrNames) {
  return attrNames.includes("ref") ? (
    // we need to sort these to ensure that `'ref'` is the last attr
    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
  ) : (
    // no need to sort, return the original array
    attrNames
  );
}
var NAMESPACE, BUILD, __defProp2, __export2, SVG_NS, HTML_NS, getHostRef, registerInstance, registerHost, isMemberInElement, consoleError, cmpModules, loadModule, styles, HYDRATED_CSS, SLOT_FB_CSS, win, plt, promiseResolve, supportsConstructableStylesheets, supportsMutableAdoptedStyleSheets, queuePending, queueDomReads, queueDomWrites, queueTask, consume, flush, nextTick, writeTask, isComplexType, escapeRegExpSpecialCharacters, result_exports, ok, err, unwrap, unwrapErr, globalStyleSheet, createTime, uniqueTime, rootAppliedStyles, registerStyle, addStyle, attachStyles, getScopeId, h, newVNode, Host, isHost, createSupportsRuleRe, parsePropertyValue, getElement, emitEvent, setAccessor, parseClassListRegex, parseClassList, CAPTURE_EVENT_SUFFIX, CAPTURE_EVENT_REGEX, updateElement, hostTagName, isSvgMode, createElm, addVnodes, removeVnodes, updateChildren, isSameVnode, patch, insertBefore, renderVdom, attachToAncestor, scheduleUpdate, dispatchHooks, enqueue, isPromisey, updateComponent, callRender, postUpdateComponent, appDidLoad, safeCall, addHydratedFlag, getValue, setValue, proxyComponent, initializeComponent, fireConnectedCallback, connectedCallback, disconnectInstance, disconnectedCallback, bootstrapLazy;
var init_index_BnFj5nlp = __esm({
  "node_modules/@stacks/connect-ui/dist/esm/index-BnFj5nlp.js"() {
    /* @vite-ignore */
    /* webpackInclude: /\.entry\.js$/ */
    /* webpackExclude: /\.system\.entry\.js$/ */
    /* webpackMode: "lazy" */
    init_();
    NAMESPACE = "connect-ui";
    BUILD = /* connect-ui */
    { hydratedSelectorName: "hydrated", lazyLoad: true, updatable: true, watchCallback: false };
    __defProp2 = Object.defineProperty;
    __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    SVG_NS = "http://www.w3.org/2000/svg";
    HTML_NS = "http://www.w3.org/1999/xhtml";
    getHostRef = (ref2) => {
      if (ref2.__stencil__getHostRef) {
        return ref2.__stencil__getHostRef();
      }
      return void 0;
    };
    registerInstance = (lazyInstance, hostRef) => {
      lazyInstance.__stencil__getHostRef = () => hostRef;
      hostRef.$lazyInstance$ = lazyInstance;
    };
    registerHost = (hostElement, cmpMeta) => {
      const hostRef = {
        $flags$: 0,
        $hostElement$: hostElement,
        $cmpMeta$: cmpMeta,
        $instanceValues$: /* @__PURE__ */ new Map()
      };
      {
        hostRef.$onReadyPromise$ = new Promise((r9) => hostRef.$onReadyResolve$ = r9);
        hostElement["s-p"] = [];
        hostElement["s-rc"] = [];
      }
      const ref2 = hostRef;
      hostElement.__stencil__getHostRef = () => ref2;
      return ref2;
    };
    isMemberInElement = (elm, memberName) => memberName in elm;
    consoleError = (e10, el) => (0, console.error)(e10, el);
    cmpModules = /* @__PURE__ */ new Map();
    loadModule = (cmpMeta, hostRef, hmrVersionId) => {
      const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
      const bundleId = cmpMeta.$lazyBundleId$;
      if (!bundleId) {
        return void 0;
      }
      const module = cmpModules.get(bundleId);
      if (module) {
        return module[exportName];
      }
      if (!hmrVersionId || !BUILD.hotModuleReplacement) {
        const processMod = (importedModule) => {
          cmpModules.set(bundleId, importedModule);
          return importedModule[exportName];
        };
        switch (bundleId) {
          case "connect-modal":
            return Promise.resolve().then(() => (init_connect_modal_entry(), connect_modal_entry_exports)).then(processMod, consoleError);
        }
      }
      return globImport_entry_js(`./${bundleId}.entry.js${""}`).then(
        (importedModule) => {
          {
            cmpModules.set(bundleId, importedModule);
          }
          return importedModule[exportName];
        },
        (e10) => {
          consoleError(e10, hostRef.$hostElement$);
        }
      );
    };
    styles = /* @__PURE__ */ new Map();
    HYDRATED_CSS = "{visibility:hidden}.hydrated{visibility:inherit}";
    SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
    win = typeof window !== "undefined" ? window : {};
    plt = {
      $flags$: 0,
      $resourcesUrl$: "",
      jmp: (h22) => h22(),
      raf: (h22) => requestAnimationFrame(h22),
      ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
      rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
      ce: (eventName, opts) => new CustomEvent(eventName, opts)
    };
    promiseResolve = (v8) => Promise.resolve(v8);
    supportsConstructableStylesheets = /* @__PURE__ */ (() => {
      try {
        new CSSStyleSheet();
        return typeof new CSSStyleSheet().replaceSync === "function";
      } catch (e10) {
      }
      return false;
    })();
    supportsMutableAdoptedStyleSheets = supportsConstructableStylesheets ? /* @__PURE__ */ (() => !!win.document && Object.getOwnPropertyDescriptor(win.document.adoptedStyleSheets, "length").writable)() : false;
    queuePending = false;
    queueDomReads = [];
    queueDomWrites = [];
    queueTask = (queue, write) => (cb) => {
      queue.push(cb);
      if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4) {
          nextTick(flush);
        } else {
          plt.raf(flush);
        }
      }
    };
    consume = (queue) => {
      for (let i22 = 0; i22 < queue.length; i22++) {
        try {
          queue[i22](performance.now());
        } catch (e10) {
          consoleError(e10);
        }
      }
      queue.length = 0;
    };
    flush = () => {
      consume(queueDomReads);
      {
        consume(queueDomWrites);
        if (queuePending = queueDomReads.length > 0) {
          plt.raf(flush);
        }
      }
    };
    nextTick = (cb) => promiseResolve().then(cb);
    writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
    isComplexType = (o13) => {
      o13 = typeof o13;
      return o13 === "object" || o13 === "function";
    };
    escapeRegExpSpecialCharacters = (text) => {
      return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    result_exports = {};
    __export2(result_exports, {
      err: () => err,
      map: () => map,
      ok: () => ok,
      unwrap: () => unwrap,
      unwrapErr: () => unwrapErr
    });
    ok = (value) => ({
      isOk: true,
      isErr: false,
      value
    });
    err = (value) => ({
      isOk: false,
      isErr: true,
      value
    });
    unwrap = (result) => {
      if (result.isOk) {
        return result.value;
      } else {
        throw result.value;
      }
    };
    unwrapErr = (result) => {
      if (result.isErr) {
        return result.value;
      } else {
        throw result.value;
      }
    };
    createTime = (fnName, tagName = "") => {
      {
        return () => {
          return;
        };
      }
    };
    uniqueTime = (key, measureText) => {
      {
        return () => {
          return;
        };
      }
    };
    rootAppliedStyles = /* @__PURE__ */ new WeakMap();
    registerStyle = (scopeId2, cssText, allowCS) => {
      let style = styles.get(scopeId2);
      if (supportsConstructableStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        if (typeof style === "string") {
          style = cssText;
        } else {
          style.replaceSync(cssText);
        }
      } else {
        style = cssText;
      }
      styles.set(scopeId2, style);
    };
    addStyle = (styleContainerNode, cmpMeta, mode) => {
      var _a2;
      const scopeId2 = getScopeId(cmpMeta);
      const style = styles.get(scopeId2);
      if (!win.document) {
        return scopeId2;
      }
      styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : win.document;
      if (style) {
        if (typeof style === "string") {
          styleContainerNode = styleContainerNode.head || styleContainerNode;
          let appliedStyles = rootAppliedStyles.get(styleContainerNode);
          let styleElm;
          if (!appliedStyles) {
            rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
          }
          if (!appliedStyles.has(scopeId2)) {
            {
              styleElm = win.document.createElement("style");
              styleElm.innerHTML = style;
              const nonce = (_a2 = plt.$nonce$) != null ? _a2 : queryNonceMetaTagContent(win.document);
              if (nonce != null) {
                styleElm.setAttribute("nonce", nonce);
              }
              if (!(cmpMeta.$flags$ & 1)) {
                if (styleContainerNode.nodeName === "HEAD") {
                  const preconnectLinks = styleContainerNode.querySelectorAll("link[rel=preconnect]");
                  const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector("style");
                  styleContainerNode.insertBefore(
                    styleElm,
                    (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null
                  );
                } else if ("host" in styleContainerNode) {
                  if (supportsConstructableStylesheets) {
                    const stylesheet = new CSSStyleSheet();
                    stylesheet.replaceSync(style);
                    if (supportsMutableAdoptedStyleSheets) {
                      styleContainerNode.adoptedStyleSheets.unshift(stylesheet);
                    } else {
                      styleContainerNode.adoptedStyleSheets = [stylesheet, ...styleContainerNode.adoptedStyleSheets];
                    }
                  } else {
                    const existingStyleContainer = styleContainerNode.querySelector("style");
                    if (existingStyleContainer) {
                      existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;
                    } else {
                      styleContainerNode.prepend(styleElm);
                    }
                  }
                } else {
                  styleContainerNode.append(styleElm);
                }
              }
              if (cmpMeta.$flags$ & 1) {
                styleContainerNode.insertBefore(styleElm, null);
              }
            }
            if (cmpMeta.$flags$ & 4) {
              styleElm.innerHTML += SLOT_FB_CSS;
            }
            if (appliedStyles) {
              appliedStyles.add(scopeId2);
            }
          }
        } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
          if (supportsMutableAdoptedStyleSheets) {
            styleContainerNode.adoptedStyleSheets.push(style);
          } else {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
          }
        }
      }
      return scopeId2;
    };
    attachStyles = (hostRef) => {
      const cmpMeta = hostRef.$cmpMeta$;
      const elm = hostRef.$hostElement$;
      const flags = cmpMeta.$flags$;
      const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
      const scopeId2 = addStyle(
        elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),
        cmpMeta
      );
      if (flags & 10) {
        elm["s-sc"] = scopeId2;
        elm.classList.add(scopeId2 + "-h");
      }
      endAttachStyles();
    };
    getScopeId = (cmp, mode) => "sc-" + cmp.$tagName$;
    h = (nodeName, vnodeData, ...children) => {
      let child = null;
      let key = null;
      let simple = false;
      let lastSimple = false;
      const vNodeChildren = [];
      const walk3 = (c12) => {
        for (let i22 = 0; i22 < c12.length; i22++) {
          child = c12[i22];
          if (Array.isArray(child)) {
            walk3(child);
          } else if (child != null && typeof child !== "boolean") {
            if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
              child = String(child);
            }
            if (simple && lastSimple) {
              vNodeChildren[vNodeChildren.length - 1].$text$ += child;
            } else {
              vNodeChildren.push(simple ? newVNode(null, child) : child);
            }
            lastSimple = simple;
          }
        }
      };
      walk3(children);
      if (vnodeData) {
        if (vnodeData.key) {
          key = vnodeData.key;
        }
        {
          const classData = vnodeData.className || vnodeData.class;
          if (classData) {
            vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k7) => classData[k7]).join(" ");
          }
        }
      }
      const vnode = newVNode(nodeName, null);
      vnode.$attrs$ = vnodeData;
      if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
      }
      {
        vnode.$key$ = key;
      }
      return vnode;
    };
    newVNode = (tag, text) => {
      const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null
      };
      {
        vnode.$attrs$ = null;
      }
      {
        vnode.$key$ = null;
      }
      return vnode;
    };
    Host = {};
    isHost = (node) => node && node.$tag$ === Host;
    createSupportsRuleRe = (selector) => {
      const safeSelector2 = escapeRegExpSpecialCharacters(selector);
      return new RegExp(
        // First capture group: match any context before the selector that's not inside @supports selector()
        // Using negative lookahead to avoid matching inside @supports selector(...) condition
        `(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${safeSelector2}))(${safeSelector2}\\b)`,
        "g"
      );
    };
    createSupportsRuleRe("::slotted");
    createSupportsRuleRe(":host");
    createSupportsRuleRe(":host-context");
    parsePropertyValue = (propValue, propType, isFormAssociated) => {
      if (typeof propValue === "string" && (propType & 16 || propType & 8) && (propValue.startsWith("{") && propValue.endsWith("}") || propValue.startsWith("[") && propValue.endsWith("]"))) {
        try {
          return JSON.parse(propValue);
        } catch (e10) {
        }
      }
      if (propValue != null && !isComplexType(propValue)) {
        return propValue;
      }
      return propValue;
    };
    getElement = (ref2) => {
      var _a2;
      return (_a2 = getHostRef(ref2)) == null ? void 0 : _a2.$hostElement$;
    };
    emitEvent = (elm, name2, opts) => {
      const ev = plt.ce(name2, opts);
      elm.dispatchEvent(ev);
      return ev;
    };
    setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {
      if (oldValue === newValue) {
        return;
      }
      let isProp = isMemberInElement(elm, memberName);
      let ln3 = memberName.toLowerCase();
      if (memberName === "class") {
        const classList = elm.classList;
        const oldClasses = parseClassList(oldValue);
        let newClasses = parseClassList(newValue);
        {
          classList.remove(...oldClasses.filter((c12) => c12 && !newClasses.includes(c12)));
          classList.add(...newClasses.filter((c12) => c12 && !oldClasses.includes(c12)));
        }
      } else if (memberName === "key") ;
      else if (!isProp && memberName[0] === "o" && memberName[1] === "n") {
        if (memberName[2] === "-") {
          memberName = memberName.slice(3);
        } else if (isMemberInElement(win, ln3)) {
          memberName = ln3.slice(2);
        } else {
          memberName = ln3[2] + memberName.slice(3);
        }
        if (oldValue || newValue) {
          const capture2 = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
          memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
          if (oldValue) {
            plt.rel(elm, memberName, oldValue, capture2);
          }
          if (newValue) {
            plt.ael(elm, memberName, newValue, capture2);
          }
        }
      } else {
        const isComplex = isComplexType(newValue);
        if ((isProp || isComplex && newValue !== null) && !isSvg) {
          try {
            if (!elm.tagName.includes("-")) {
              const n12 = newValue == null ? "" : newValue;
              if (memberName === "list") {
                isProp = false;
              } else if (oldValue == null || elm[memberName] != n12) {
                if (typeof elm.__lookupSetter__(memberName) === "function") {
                  elm[memberName] = n12;
                } else {
                  elm.setAttribute(memberName, n12);
                }
              }
            } else if (elm[memberName] !== newValue) {
              elm[memberName] = newValue;
            }
          } catch (e10) {
          }
        }
        if (newValue == null || newValue === false) {
          if (newValue !== false || elm.getAttribute(memberName) === "") {
            {
              elm.removeAttribute(memberName);
            }
          }
        } else if ((!isProp || flags & 4 || isSvg) && !isComplex && elm.nodeType === 1) {
          newValue = newValue === true ? "" : newValue;
          {
            elm.setAttribute(memberName, newValue);
          }
        }
      }
    };
    parseClassListRegex = /\s/;
    parseClassList = (value) => {
      if (typeof value === "object" && value && "baseVal" in value) {
        value = value.baseVal;
      }
      if (!value || typeof value !== "string") {
        return [];
      }
      return value.split(parseClassListRegex);
    };
    CAPTURE_EVENT_SUFFIX = "Capture";
    CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");
    updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {
      const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
      const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};
      const newVnodeAttrs = newVnode.$attrs$ || {};
      {
        for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
          if (!(memberName in newVnodeAttrs)) {
            setAccessor(
              elm,
              memberName,
              oldVnodeAttrs[memberName],
              void 0,
              isSvgMode2,
              newVnode.$flags$
            );
          }
        }
      }
      for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
        setAccessor(
          elm,
          memberName,
          oldVnodeAttrs[memberName],
          newVnodeAttrs[memberName],
          isSvgMode2,
          newVnode.$flags$
        );
      }
    };
    isSvgMode = false;
    createElm = (oldParentVNode, newParentVNode, childIndex) => {
      const newVNode2 = newParentVNode.$children$[childIndex];
      let i22 = 0;
      let elm;
      let childNode;
      if (newVNode2.$text$ !== null) {
        elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);
      } else {
        if (!isSvgMode) {
          isSvgMode = newVNode2.$tag$ === "svg";
        }
        if (!win.document) {
          throw new Error(
            "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component."
          );
        }
        elm = newVNode2.$elm$ = win.document.createElementNS(
          isSvgMode ? SVG_NS : HTML_NS,
          newVNode2.$tag$
        );
        if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
          isSvgMode = false;
        }
        {
          updateElement(null, newVNode2, isSvgMode);
        }
        if (newVNode2.$children$) {
          for (i22 = 0; i22 < newVNode2.$children$.length; ++i22) {
            childNode = createElm(oldParentVNode, newVNode2, i22);
            if (childNode) {
              elm.appendChild(childNode);
            }
          }
        }
        {
          if (newVNode2.$tag$ === "svg") {
            isSvgMode = false;
          } else if (elm.tagName === "foreignObject") {
            isSvgMode = true;
          }
        }
      }
      elm["s-hn"] = hostTagName;
      return elm;
    };
    addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
      let containerElm = parentElm;
      let childNode;
      if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
      }
      for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
          childNode = createElm(null, parentVNode, startIdx);
          if (childNode) {
            vnodes[startIdx].$elm$ = childNode;
            insertBefore(containerElm, childNode, before);
          }
        }
      }
    };
    removeVnodes = (vnodes, startIdx, endIdx) => {
      for (let index2 = startIdx; index2 <= endIdx; ++index2) {
        const vnode = vnodes[index2];
        if (vnode) {
          const elm = vnode.$elm$;
          if (elm) {
            elm.remove();
          }
        }
      }
    };
    updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
      let oldStartIdx = 0;
      let newStartIdx = 0;
      let idxInOld = 0;
      let i22 = 0;
      let oldEndIdx = oldCh.length - 1;
      let oldStartVnode = oldCh[0];
      let oldEndVnode = oldCh[oldEndIdx];
      let newEndIdx = newCh.length - 1;
      let newStartVnode = newCh[0];
      let newEndVnode = newCh[newEndIdx];
      let node;
      let elmToMove;
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
          oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
          newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
          patch(oldStartVnode, newStartVnode, isInitialRender);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
          patch(oldEndVnode, newEndVnode, isInitialRender);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
          patch(oldStartVnode, newEndVnode, isInitialRender);
          insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
          patch(oldEndVnode, newStartVnode, isInitialRender);
          insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          idxInOld = -1;
          {
            for (i22 = oldStartIdx; i22 <= oldEndIdx; ++i22) {
              if (oldCh[i22] && oldCh[i22].$key$ !== null && oldCh[i22].$key$ === newStartVnode.$key$) {
                idxInOld = i22;
                break;
              }
            }
          }
          if (idxInOld >= 0) {
            elmToMove = oldCh[idxInOld];
            if (elmToMove.$tag$ !== newStartVnode.$tag$) {
              node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
            } else {
              patch(elmToMove, newStartVnode, isInitialRender);
              oldCh[idxInOld] = void 0;
              node = elmToMove.$elm$;
            }
            newStartVnode = newCh[++newStartIdx];
          } else {
            node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
            newStartVnode = newCh[++newStartIdx];
          }
          if (node) {
            {
              insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);
            }
          }
        }
      }
      if (oldStartIdx > oldEndIdx) {
        addVnodes(
          parentElm,
          newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
          newVNode2,
          newCh,
          newStartIdx,
          newEndIdx
        );
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
    };
    isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
      if (leftVNode.$tag$ === rightVNode.$tag$) {
        if (!isInitialRender) {
          return leftVNode.$key$ === rightVNode.$key$;
        }
        if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {
          leftVNode.$key$ = rightVNode.$key$;
        }
        return true;
      }
      return false;
    };
    patch = (oldVNode, newVNode2, isInitialRender = false) => {
      const elm = newVNode2.$elm$ = oldVNode.$elm$;
      const oldChildren = oldVNode.$children$;
      const newChildren = newVNode2.$children$;
      const tag = newVNode2.$tag$;
      const text = newVNode2.$text$;
      if (text === null) {
        {
          isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
        }
        {
          updateElement(oldVNode, newVNode2, isSvgMode);
        }
        if (oldChildren !== null && newChildren !== null) {
          updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
        } else if (newChildren !== null) {
          if (oldVNode.$text$ !== null) {
            elm.textContent = "";
          }
          addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
        } else if (
          // don't do this on initial render as it can cause non-hydrated content to be removed
          !isInitialRender && BUILD.updatable && oldChildren !== null
        ) {
          removeVnodes(oldChildren, 0, oldChildren.length - 1);
        } else ;
        if (isSvgMode && tag === "svg") {
          isSvgMode = false;
        }
      } else if (oldVNode.$text$ !== text) {
        elm.data = text;
      }
    };
    insertBefore = (parent, newNode, reference) => {
      {
        return parent == null ? void 0 : parent.insertBefore(newNode, reference);
      }
    };
    renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
      const hostElm = hostRef.$hostElement$;
      const oldVNode = hostRef.$vnode$ || newVNode(null, null);
      const isHostElement = isHost(renderFnResults);
      const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);
      hostTagName = hostElm.tagName;
      if (isInitialLoad && rootVnode.$attrs$) {
        for (const key of Object.keys(rootVnode.$attrs$)) {
          if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
            rootVnode.$attrs$[key] = hostElm[key];
          }
        }
      }
      rootVnode.$tag$ = null;
      rootVnode.$flags$ |= 4;
      hostRef.$vnode$ = rootVnode;
      rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
      patch(oldVNode, rootVnode, isInitialLoad);
    };
    attachToAncestor = (hostRef, ancestorComponent) => {
      if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
        const index2 = ancestorComponent["s-p"].push(
          new Promise(
            (r9) => hostRef.$onRenderResolve$ = () => {
              ancestorComponent["s-p"].splice(index2 - 1, 1);
              r9();
            }
          )
        );
      }
    };
    scheduleUpdate = (hostRef, isInitialLoad) => {
      {
        hostRef.$flags$ |= 16;
      }
      if (hostRef.$flags$ & 4) {
        hostRef.$flags$ |= 512;
        return;
      }
      attachToAncestor(hostRef, hostRef.$ancestorComponent$);
      const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
      if (isInitialLoad) {
        queueMicrotask(() => {
          dispatch();
        });
        return;
      }
      return writeTask(dispatch);
    };
    dispatchHooks = (hostRef, isInitialLoad) => {
      const elm = hostRef.$hostElement$;
      const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
      const instance = hostRef.$lazyInstance$;
      if (!instance) {
        throw new Error(
          `Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`
        );
      }
      let maybePromise;
      if (isInitialLoad) {
        maybePromise = safeCall(instance, "componentWillLoad", void 0, elm);
      } else {
        maybePromise = safeCall(instance, "componentWillUpdate", void 0, elm);
      }
      maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender", void 0, elm));
      endSchedule();
      return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
    };
    enqueue = (maybePromise, fn3) => isPromisey(maybePromise) ? maybePromise.then(fn3).catch((err2) => {
      console.error(err2);
      fn3();
    }) : fn3();
    isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
    updateComponent = async (hostRef, instance, isInitialLoad) => {
      var _a2;
      const elm = hostRef.$hostElement$;
      const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
      const rc2 = elm["s-rc"];
      if (isInitialLoad) {
        attachStyles(hostRef);
      }
      const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
      {
        callRender(hostRef, instance, elm, isInitialLoad);
      }
      if (rc2) {
        rc2.map((cb) => cb());
        elm["s-rc"] = void 0;
      }
      endRender();
      endUpdate();
      {
        const childrenPromises = (_a2 = elm["s-p"]) != null ? _a2 : [];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
          postUpdate();
        } else {
          Promise.all(childrenPromises).then(postUpdate);
          hostRef.$flags$ |= 4;
          childrenPromises.length = 0;
        }
      }
    };
    callRender = (hostRef, instance, elm, isInitialLoad) => {
      try {
        instance = instance.render();
        {
          hostRef.$flags$ &= -17;
        }
        {
          hostRef.$flags$ |= 2;
        }
        {
          {
            {
              renderVdom(hostRef, instance, isInitialLoad);
            }
          }
        }
      } catch (e10) {
        consoleError(e10, hostRef.$hostElement$);
      }
      return null;
    };
    postUpdateComponent = (hostRef) => {
      const tagName = hostRef.$cmpMeta$.$tagName$;
      const elm = hostRef.$hostElement$;
      const endPostUpdate = createTime("postUpdate", tagName);
      const instance = hostRef.$lazyInstance$;
      const ancestorComponent = hostRef.$ancestorComponent$;
      safeCall(instance, "componentDidRender", void 0, elm);
      if (!(hostRef.$flags$ & 64)) {
        hostRef.$flags$ |= 64;
        {
          addHydratedFlag(elm);
        }
        safeCall(instance, "componentDidLoad", void 0, elm);
        endPostUpdate();
        {
          hostRef.$onReadyResolve$(elm);
          if (!ancestorComponent) {
            appDidLoad();
          }
        }
      } else {
        safeCall(instance, "componentDidUpdate", void 0, elm);
        endPostUpdate();
      }
      {
        if (hostRef.$onRenderResolve$) {
          hostRef.$onRenderResolve$();
          hostRef.$onRenderResolve$ = void 0;
        }
        if (hostRef.$flags$ & 512) {
          nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= -517;
      }
    };
    appDidLoad = (who) => {
      nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
    };
    safeCall = (instance, method, arg, elm) => {
      if (instance && instance[method]) {
        try {
          return instance[method](arg);
        } catch (e10) {
          consoleError(e10, elm);
        }
      }
      return void 0;
    };
    addHydratedFlag = (elm) => {
      var _a2;
      return elm.classList.add((_a2 = BUILD.hydratedSelectorName) != null ? _a2 : "hydrated");
    };
    getValue = (ref2, propName) => getHostRef(ref2).$instanceValues$.get(propName);
    setValue = (ref2, propName, newVal, cmpMeta) => {
      const hostRef = getHostRef(ref2);
      if (!hostRef) {
        return;
      }
      if (!hostRef) {
        throw new Error(
          `Couldn't find host element for "${cmpMeta.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`
        );
      }
      const oldVal = hostRef.$instanceValues$.get(propName);
      const flags = hostRef.$flags$;
      const instance = hostRef.$lazyInstance$;
      newVal = parsePropertyValue(
        newVal,
        cmpMeta.$members$[propName][0]
      );
      const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
      const didValueChange = newVal !== oldVal && !areBothNaN;
      if ((!(flags & 8) || oldVal === void 0) && didValueChange) {
        hostRef.$instanceValues$.set(propName, newVal);
        if (instance) {
          if ((flags & (2 | 16)) === 2) {
            if (instance.componentShouldUpdate) {
              if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                return;
              }
            }
            scheduleUpdate(hostRef, false);
          }
        }
      }
    };
    proxyComponent = (Cstr, cmpMeta, flags) => {
      var _a2, _b;
      const prototype = Cstr.prototype;
      if (cmpMeta.$members$ || BUILD.watchCallback) {
        const members = Object.entries((_a2 = cmpMeta.$members$) != null ? _a2 : {});
        members.map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 || flags & 2 && memberFlags & 32) {
            const { get: origGetter, set: origSetter } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};
            if (origGetter) cmpMeta.$members$[memberName][0] |= 2048;
            if (origSetter) cmpMeta.$members$[memberName][0] |= 4096;
            if (flags & 1 || !origGetter) {
              Object.defineProperty(prototype, memberName, {
                get() {
                  {
                    if ((cmpMeta.$members$[memberName][0] & 2048) === 0) {
                      return getValue(this, memberName);
                    }
                    const ref2 = getHostRef(this);
                    const instance = ref2 ? ref2.$lazyInstance$ : prototype;
                    if (!instance) return;
                    return instance[memberName];
                  }
                },
                configurable: true,
                enumerable: true
              });
            }
            Object.defineProperty(prototype, memberName, {
              set(newValue) {
                const ref2 = getHostRef(this);
                if (!ref2) {
                  return;
                }
                if (origSetter) {
                  const currentValue = memberFlags & 32 ? this[memberName] : ref2.$hostElement$[memberName];
                  if (typeof currentValue === "undefined" && ref2.$instanceValues$.get(memberName)) {
                    newValue = ref2.$instanceValues$.get(memberName);
                  } else if (!ref2.$instanceValues$.get(memberName) && currentValue) {
                    ref2.$instanceValues$.set(memberName, currentValue);
                  }
                  origSetter.apply(this, [
                    parsePropertyValue(
                      newValue,
                      memberFlags
                    )
                  ]);
                  newValue = memberFlags & 32 ? this[memberName] : ref2.$hostElement$[memberName];
                  setValue(this, memberName, newValue, cmpMeta);
                  return;
                }
                {
                  if ((flags & 1) === 0 || (cmpMeta.$members$[memberName][0] & 4096) === 0) {
                    setValue(this, memberName, newValue, cmpMeta);
                    if (flags & 1 && !ref2.$lazyInstance$) {
                      ref2.$onReadyPromise$.then(() => {
                        if (cmpMeta.$members$[memberName][0] & 4096 && ref2.$lazyInstance$[memberName] !== ref2.$instanceValues$.get(memberName)) {
                          ref2.$lazyInstance$[memberName] = newValue;
                        }
                      });
                    }
                    return;
                  }
                  const setterSetVal = () => {
                    const currentValue = ref2.$lazyInstance$[memberName];
                    if (!ref2.$instanceValues$.get(memberName) && currentValue) {
                      ref2.$instanceValues$.set(memberName, currentValue);
                    }
                    ref2.$lazyInstance$[memberName] = parsePropertyValue(
                      newValue,
                      memberFlags
                    );
                    setValue(this, memberName, ref2.$lazyInstance$[memberName], cmpMeta);
                  };
                  if (ref2.$lazyInstance$) {
                    setterSetVal();
                  } else {
                    ref2.$onReadyPromise$.then(() => setterSetVal());
                  }
                }
              }
            });
          }
        });
        if (flags & 1) {
          const attrNameToPropName = /* @__PURE__ */ new Map();
          prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
            plt.jmp(() => {
              var _a22;
              const propName = attrNameToPropName.get(attrName);
              if (this.hasOwnProperty(propName) && BUILD.lazyLoad) {
                newValue = this[propName];
                delete this[propName];
              } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && // cast type to number to avoid TS compiler issues
              this[propName] == newValue) {
                return;
              } else if (propName == null) {
                const hostRef = getHostRef(this);
                const flags2 = hostRef == null ? void 0 : hostRef.$flags$;
                if (hostRef && flags2 && !(flags2 & 8) && flags2 & 128 && newValue !== oldValue) {
                  const instance = hostRef.$lazyInstance$;
                  const entry = (_a22 = cmpMeta.$watchers$) == null ? void 0 : _a22[attrName];
                  entry == null ? void 0 : entry.forEach((callbackName) => {
                    if (instance[callbackName] != null) {
                      instance[callbackName].call(instance, newValue, oldValue, attrName);
                    }
                  });
                }
                return;
              }
              const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);
              newValue = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
              if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {
                this[propName] = newValue;
              }
            });
          };
          Cstr.observedAttributes = Array.from(
            /* @__PURE__ */ new Set([
              ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),
              ...members.filter(
                ([_5, m6]) => m6[0] & 31
                /* HasAttribute */
              ).map(([propName, m6]) => {
                const attrName = m6[1] || propName;
                attrNameToPropName.set(attrName, propName);
                return attrName;
              })
            ])
          );
        }
      }
      return Cstr;
    };
    initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
      let Cstr;
      if ((hostRef.$flags$ & 32) === 0) {
        hostRef.$flags$ |= 32;
        const bundleId = cmpMeta.$lazyBundleId$;
        if (bundleId) {
          const CstrImport = loadModule(cmpMeta, hostRef);
          if (CstrImport && "then" in CstrImport) {
            const endLoad = uniqueTime();
            Cstr = await CstrImport;
            endLoad();
          } else {
            Cstr = CstrImport;
          }
          if (!Cstr) {
            throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
          }
          if (!Cstr.isProxied) {
            proxyComponent(
              Cstr,
              cmpMeta,
              2
              /* proxyState */
            );
            Cstr.isProxied = true;
          }
          const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
          {
            hostRef.$flags$ |= 8;
          }
          try {
            new Cstr(hostRef);
          } catch (e10) {
            consoleError(e10, elm);
          }
          {
            hostRef.$flags$ &= -9;
          }
          endNewInstance();
          fireConnectedCallback(hostRef.$lazyInstance$, elm);
        } else {
          Cstr = elm.constructor;
          const cmpTag = elm.localName;
          customElements.whenDefined(cmpTag).then(
            () => hostRef.$flags$ |= 128
            /* isWatchReady */
          );
        }
        if (Cstr && Cstr.style) {
          let style;
          if (typeof Cstr.style === "string") {
            style = Cstr.style;
          }
          const scopeId2 = getScopeId(cmpMeta);
          if (!styles.has(scopeId2)) {
            const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
            registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
            endRegisterStyles();
          }
        }
      }
      const ancestorComponent = hostRef.$ancestorComponent$;
      const schedule = () => scheduleUpdate(hostRef, true);
      if (ancestorComponent && ancestorComponent["s-rc"]) {
        ancestorComponent["s-rc"].push(schedule);
      } else {
        schedule();
      }
    };
    fireConnectedCallback = (instance, elm) => {
      {
        safeCall(instance, "connectedCallback", void 0, elm);
      }
    };
    connectedCallback = (elm) => {
      if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        if (!hostRef) {
          return;
        }
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1)) {
          hostRef.$flags$ |= 1;
          {
            let ancestorComponent = elm;
            while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
              if (ancestorComponent["s-p"]) {
                attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                break;
              }
            }
          }
          if (cmpMeta.$members$) {
            Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
              if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                const value = elm[memberName];
                delete elm[memberName];
                elm[memberName] = value;
              }
            });
          }
          {
            initializeComponent(elm, hostRef, cmpMeta);
          }
        } else {
          if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
            fireConnectedCallback(hostRef.$lazyInstance$, elm);
          } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
            hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$, elm));
          }
        }
        endConnected();
      }
    };
    disconnectInstance = (instance, elm) => {
      {
        safeCall(instance, "disconnectedCallback", void 0, elm || instance);
      }
    };
    disconnectedCallback = async (elm) => {
      if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
          disconnectInstance(hostRef.$lazyInstance$, elm);
        } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
          hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$, elm));
        }
      }
      if (rootAppliedStyles.has(elm)) {
        rootAppliedStyles.delete(elm);
      }
      if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {
        rootAppliedStyles.delete(elm.shadowRoot);
      }
    };
    bootstrapLazy = (lazyBundles, options = {}) => {
      var _a2;
      if (!win.document) {
        console.warn("Stencil: No document found. Skipping bootstrapping lazy components.");
        return;
      }
      const endBootstrap = createTime();
      const cmpTags = [];
      const exclude = options.exclude || [];
      const customElements2 = win.customElements;
      const head = win.document.head;
      const metaCharset = /* @__PURE__ */ head.querySelector("meta[charset]");
      const dataStyles = /* @__PURE__ */ win.document.createElement("style");
      const deferredConnectedCallbacks = [];
      let appLoadFallback;
      let isBootstrapping = true;
      Object.assign(plt, options);
      plt.$resourcesUrl$ = new URL(options.resourcesUrl || "./", win.document.baseURI).href;
      let hasSlotRelocation = false;
      lazyBundles.map((lazyBundle) => {
        lazyBundle[1].map((compactMeta) => {
          const cmpMeta = {
            $flags$: compactMeta[0],
            $tagName$: compactMeta[1],
            $members$: compactMeta[2],
            $listeners$: compactMeta[3]
          };
          if (cmpMeta.$flags$ & 4) {
            hasSlotRelocation = true;
          }
          {
            cmpMeta.$members$ = compactMeta[2];
          }
          const tagName = cmpMeta.$tagName$;
          const HostElement = class extends HTMLElement {
            // StencilLazyHost
            constructor(self2) {
              super(self2);
              this.hasRegisteredEventListeners = false;
              self2 = this;
              registerHost(self2, cmpMeta);
              if (cmpMeta.$flags$ & 1) {
                {
                  if (!self2.shadowRoot) {
                    createShadowRoot.call(self2, cmpMeta);
                  } else {
                    if (self2.shadowRoot.mode !== "open") {
                      throw new Error(
                        `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${self2.shadowRoot.mode} but Stencil only supports open shadow roots.`
                      );
                    }
                  }
                }
              }
            }
            connectedCallback() {
              const hostRef = getHostRef(this);
              if (!hostRef) {
                return;
              }
              if (!this.hasRegisteredEventListeners) {
                this.hasRegisteredEventListeners = true;
              }
              if (appLoadFallback) {
                clearTimeout(appLoadFallback);
                appLoadFallback = null;
              }
              if (isBootstrapping) {
                deferredConnectedCallbacks.push(this);
              } else {
                plt.jmp(() => connectedCallback(this));
              }
            }
            disconnectedCallback() {
              plt.jmp(() => disconnectedCallback(this));
              plt.raf(() => {
                var _a3;
                const hostRef = getHostRef(this);
                if (!hostRef) {
                  return;
                }
                const i22 = deferredConnectedCallbacks.findIndex((host) => host === this);
                if (i22 > -1) {
                  deferredConnectedCallbacks.splice(i22, 1);
                }
                if (((_a3 = hostRef == null ? void 0 : hostRef.$vnode$) == null ? void 0 : _a3.$elm$) instanceof Node && !hostRef.$vnode$.$elm$.isConnected) {
                  delete hostRef.$vnode$.$elm$;
                }
              });
            }
            componentOnReady() {
              var _a3;
              return (_a3 = getHostRef(this)) == null ? void 0 : _a3.$onReadyPromise$;
            }
          };
          cmpMeta.$lazyBundleId$ = lazyBundle[0];
          if (!exclude.includes(tagName) && !customElements2.get(tagName)) {
            cmpTags.push(tagName);
            customElements2.define(
              tagName,
              proxyComponent(
                HostElement,
                cmpMeta,
                1
                /* isElementConstructor */
              )
            );
          }
        });
      });
      if (cmpTags.length > 0) {
        if (hasSlotRelocation) {
          dataStyles.textContent += SLOT_FB_CSS;
        }
        {
          dataStyles.textContent += cmpTags.sort() + HYDRATED_CSS;
        }
        if (dataStyles.innerHTML.length) {
          dataStyles.setAttribute("data-styles", "");
          const nonce = (_a2 = plt.$nonce$) != null ? _a2 : queryNonceMetaTagContent(win.document);
          if (nonce != null) {
            dataStyles.setAttribute("nonce", nonce);
          }
          head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);
        }
      }
      isBootstrapping = false;
      if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map((host) => host.connectedCallback());
      } else {
        {
          plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
        }
      }
      endBootstrap();
    };
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/@noble/hashes/cryptoBrowser.js
var require_cryptoBrowser = __commonJS({
  "node_modules/@noble/hashes/cryptoBrowser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = {
      node: void 0,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_cryptoBrowser();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView3;
    var rotr3 = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr3;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes8 = Array.from({ length: 256 }, (v8, i11) => i11.toString(16).padStart(2, "0"));
    function bytesToHex7(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i11 = 0; i11 < uint8a.length; i11++) {
        hex += hexes8[uint8a[i11]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex7;
    function hexToBytes6(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i11 = 0; i11 < array.length; i11++) {
        const j7 = i11 * 2;
        const hexByte = hex.slice(j7, j7 + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i11] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes6;
    var nextTick2 = async () => {
    };
    exports.nextTick = nextTick2;
    async function asyncLoop(iters, tick, cb) {
      let ts2 = Date.now();
      for (let i11 = 0; i11 < iters; i11++) {
        cb(i11);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts2 += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes6(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes6;
    function toBytes4(data) {
      if (typeof data === "string")
        data = utf8ToBytes6(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes4;
    function concatBytes6(...arrays) {
      if (!arrays.every((a5) => a5 instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length2 = arrays.reduce((a5, arr) => a5 + arr.length, 0);
      const result = new Uint8Array(length2);
      for (let i11 = 0, pad3 = 0; i11 < arrays.length; i11++) {
        const arr = arrays[i11];
        result.set(arr, pad3);
        pad3 += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes6;
    var Hash3 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash3;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor2(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes4(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor2;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    }
    exports.randomBytes = randomBytes2;
  }
});

// node_modules/c32check/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/c32check/lib/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;
    var utils_1 = require_utils();
    exports.c32 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    var hex = "0123456789abcdef";
    function c32encode(inputHex, minLength) {
      if (!inputHex.match(/^[0-9a-fA-F]*$/)) {
        throw new Error("Not a hex-encoded string");
      }
      if (inputHex.length % 2 !== 0) {
        inputHex = `0${inputHex}`;
      }
      inputHex = inputHex.toLowerCase();
      let res = [];
      let carry = 0;
      for (let i11 = inputHex.length - 1; i11 >= 0; i11--) {
        if (carry < 4) {
          const currentCode = hex.indexOf(inputHex[i11]) >> carry;
          let nextCode = 0;
          if (i11 !== 0) {
            nextCode = hex.indexOf(inputHex[i11 - 1]);
          }
          const nextBits = 1 + carry;
          const nextLowBits = nextCode % (1 << nextBits) << 5 - nextBits;
          const curC32Digit = exports.c32[currentCode + nextLowBits];
          carry = nextBits;
          res.unshift(curC32Digit);
        } else {
          carry = 0;
        }
      }
      let C32leadingZeros = 0;
      for (let i11 = 0; i11 < res.length; i11++) {
        if (res[i11] !== "0") {
          break;
        } else {
          C32leadingZeros++;
        }
      }
      res = res.slice(C32leadingZeros);
      const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\u0000*/);
      const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;
      for (let i11 = 0; i11 < numLeadingZeroBytesInHex; i11++) {
        res.unshift(exports.c32[0]);
      }
      if (minLength) {
        const count = minLength - res.length;
        for (let i11 = 0; i11 < count; i11++) {
          res.unshift(exports.c32[0]);
        }
      }
      return res.join("");
    }
    exports.c32encode = c32encode;
    function c32normalize(c32input) {
      return c32input.toUpperCase().replace(/O/g, "0").replace(/L|I/g, "1");
    }
    exports.c32normalize = c32normalize;
    function c32decode(c32input, minLength) {
      c32input = c32normalize(c32input);
      if (!c32input.match(`^[${exports.c32}]*$`)) {
        throw new Error("Not a c32-encoded string");
      }
      const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);
      const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;
      let res = [];
      let carry = 0;
      let carryBits = 0;
      for (let i11 = c32input.length - 1; i11 >= 0; i11--) {
        if (carryBits === 4) {
          res.unshift(hex[carry]);
          carryBits = 0;
          carry = 0;
        }
        const currentCode = exports.c32.indexOf(c32input[i11]) << carryBits;
        const currentValue = currentCode + carry;
        const currentHexDigit = hex[currentValue % 16];
        carryBits += 1;
        carry = currentValue >> 4;
        if (carry > 1 << carryBits) {
          throw new Error("Panic error in decoding.");
        }
        res.unshift(currentHexDigit);
      }
      res.unshift(hex[carry]);
      if (res.length % 2 === 1) {
        res.unshift("0");
      }
      let hexLeadingZeros = 0;
      for (let i11 = 0; i11 < res.length; i11++) {
        if (res[i11] !== "0") {
          break;
        } else {
          hexLeadingZeros++;
        }
      }
      res = res.slice(hexLeadingZeros - hexLeadingZeros % 2);
      let hexStr = res.join("");
      for (let i11 = 0; i11 < numLeadingZeroBytes; i11++) {
        hexStr = `00${hexStr}`;
      }
      if (minLength) {
        const count = minLength * 2 - hexStr.length;
        for (let i11 = 0; i11 < count; i11 += 2) {
          hexStr = `00${hexStr}`;
        }
      }
      return hexStr;
    }
    exports.c32decode = c32decode;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number2(n12) {
      if (!Number.isSafeInteger(n12) || n12 < 0)
        throw new Error(`Wrong positive integer: ${n12}`);
    }
    exports.number = number2;
    function bool3(b7) {
      if (typeof b7 !== "boolean")
        throw new Error(`Expected boolean, not ${b7}`);
    }
    exports.bool = bool3;
    function bytes2(b7, ...lengths) {
      if (!(b7 instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b7.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b7.length}`);
    }
    exports.bytes = bytes2;
    function hash2(hash3) {
      if (typeof hash3 !== "function" || typeof hash3.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(hash3.outputLen);
      number2(hash3.blockLen);
    }
    exports.hash = hash2;
    function exists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists2;
    function output2(out, instance) {
      bytes2(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output2;
    var assert2 = {
      number: number2,
      bool: bool3,
      bytes: bytes2,
      hash: hash2,
      exists: exists2,
      output: output2
    };
    exports.default = assert2;
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint643(view, byteOffset, value, isLE3) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE3);
      const _32n3 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n3 & _u32_max);
      const wl = Number(value & _u32_max);
      const h12 = isLE3 ? 4 : 0;
      const l10 = isLE3 ? 0 : 4;
      view.setUint32(byteOffset + h12, wh, isLE3);
      view.setUint32(byteOffset + l10, wl, isLE3);
    }
    var SHA22 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE3) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE3;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer: buffer3, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer3.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
        let { pos } = this;
        buffer3[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i11 = pos; i11 < blockLen; i11++)
          buffer3[i11] = 0;
        setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE3);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state24 = this.get();
        if (outLen > state24.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i11 = 0; i11 < outLen; i11++)
          oview.setUint32(4 * i11, state24[i11], isLE3);
      }
      digest() {
        const { buffer: buffer3, outputLen } = this;
        this.digestInto(buffer3);
        const res = buffer3.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to4) {
        to4 || (to4 = new this.constructor());
        to4.set(...this.get());
        const { blockLen, buffer: buffer3, length: length2, finished, destroyed, pos } = this;
        to4.length = length2;
        to4.pos = pos;
        to4.finished = finished;
        to4.destroyed = destroyed;
        if (length2 % blockLen)
          to4.buffer.set(buffer3);
        return to4;
      }
    };
    exports.SHA2 = SHA22;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi3 = (a5, b7, c12) => a5 & b7 ^ ~a5 & c12;
    var Maj3 = (a5, b7, c12) => a5 & b7 ^ a5 & c12 ^ b7 & c12;
    var SHA256_K3 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV2 = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W3 = new Uint32Array(64);
    var SHA2563 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV2[0] | 0;
        this.B = IV2[1] | 0;
        this.C = IV2[2] | 0;
        this.D = IV2[3] | 0;
        this.E = IV2[4] | 0;
        this.F = IV2[5] | 0;
        this.G = IV2[6] | 0;
        this.H = IV2[7] | 0;
      }
      get() {
        const { A: A6, B: B5, C: C7, D: D4, E: E8, F: F4, G: G5, H: H5 } = this;
        return [A6, B5, C7, D4, E8, F4, G5, H5];
      }
      // prettier-ignore
      set(A6, B5, C7, D4, E8, F4, G5, H5) {
        this.A = A6 | 0;
        this.B = B5 | 0;
        this.C = C7 | 0;
        this.D = D4 | 0;
        this.E = E8 | 0;
        this.F = F4 | 0;
        this.G = G5 | 0;
        this.H = H5 | 0;
      }
      process(view, offset) {
        for (let i11 = 0; i11 < 16; i11++, offset += 4)
          SHA256_W3[i11] = view.getUint32(offset, false);
        for (let i11 = 16; i11 < 64; i11++) {
          const W15 = SHA256_W3[i11 - 15];
          const W22 = SHA256_W3[i11 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W22, 17) ^ (0, utils_js_1.rotr)(W22, 19) ^ W22 >>> 10;
          SHA256_W3[i11] = s1 + SHA256_W3[i11 - 7] + s0 + SHA256_W3[i11 - 16] | 0;
        }
        let { A: A6, B: B5, C: C7, D: D4, E: E8, F: F4, G: G5, H: H5 } = this;
        for (let i11 = 0; i11 < 64; i11++) {
          const sigma1 = (0, utils_js_1.rotr)(E8, 6) ^ (0, utils_js_1.rotr)(E8, 11) ^ (0, utils_js_1.rotr)(E8, 25);
          const T1 = H5 + sigma1 + Chi3(E8, F4, G5) + SHA256_K3[i11] + SHA256_W3[i11] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A6, 2) ^ (0, utils_js_1.rotr)(A6, 13) ^ (0, utils_js_1.rotr)(A6, 22);
          const T22 = sigma0 + Maj3(A6, B5, C7) | 0;
          H5 = G5;
          G5 = F4;
          F4 = E8;
          E8 = D4 + T1 | 0;
          D4 = C7;
          C7 = B5;
          B5 = A6;
          A6 = T1 + T22 | 0;
        }
        A6 = A6 + this.A | 0;
        B5 = B5 + this.B | 0;
        C7 = C7 + this.C | 0;
        D4 = D4 + this.D | 0;
        E8 = E8 + this.E | 0;
        F4 = F4 + this.F | 0;
        G5 = G5 + this.G | 0;
        H5 = H5 + this.H | 0;
        this.set(A6, B5, C7, D4, E8, F4, G5, H5);
      }
      roundClean() {
        SHA256_W3.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA2242 = class extends SHA2563 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2563());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA2242());
  }
});

// node_modules/c32check/lib/checksum.js
var require_checksum = __commonJS({
  "node_modules/c32check/lib/checksum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.c32checkDecode = exports.c32checkEncode = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils();
    var encoding_1 = require_encoding();
    function c32checksum(dataHex) {
      const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));
      const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));
      return checksum;
    }
    function c32checkEncode(version4, data) {
      if (version4 < 0 || version4 >= 32) {
        throw new Error("Invalid version (must be between 0 and 31)");
      }
      if (!data.match(/^[0-9a-fA-F]*$/)) {
        throw new Error("Invalid data (not a hex string)");
      }
      data = data.toLowerCase();
      if (data.length % 2 !== 0) {
        data = `0${data}`;
      }
      let versionHex = version4.toString(16);
      if (versionHex.length === 1) {
        versionHex = `0${versionHex}`;
      }
      const checksumHex = c32checksum(`${versionHex}${data}`);
      const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);
      return `${encoding_1.c32[version4]}${c32str}`;
    }
    exports.c32checkEncode = c32checkEncode;
    function c32checkDecode(c32data) {
      c32data = (0, encoding_1.c32normalize)(c32data);
      const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));
      const versionChar = c32data[0];
      const version4 = encoding_1.c32.indexOf(versionChar);
      const checksum = dataHex.slice(-8);
      let versionHex = version4.toString(16);
      if (versionHex.length === 1) {
        versionHex = `0${versionHex}`;
      }
      if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {
        throw new Error("Invalid c32check string: checksum mismatch");
      }
      return [version4, dataHex.substring(0, dataHex.length - 8)];
    }
    exports.c32checkDecode = c32checkDecode;
  }
});

// node_modules/c32check/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/c32check/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base3(ALPHABET2) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j7 = 0; j7 < BASE_MAP.length; j7++) {
        BASE_MAP[j7] = 255;
      }
      for (var i11 = 0; i11 < ALPHABET2.length; i11++) {
        var x7 = ALPHABET2.charAt(i11);
        var xc2 = x7.charCodeAt(0);
        if (BASE_MAP[xc2] !== 255) {
          throw new TypeError(x7 + " is ambiguous");
        }
        BASE_MAP[xc2] = i11;
      }
      var BASE = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode6(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size4);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i12 = 0;
          for (var it1 = size4 - 1; (carry !== 0 || i12 < length2) && it1 !== -1; it1--, i12++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i12;
          pbegin++;
        }
        var it22 = size4 - length2;
        while (it22 !== size4 && b58[it22] === 0) {
          it22++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it22 < size4; ++it22) {
          str += ALPHABET2.charAt(b58[it22]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size4 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size4);
        while (source[psz]) {
          var charCode = source.charCodeAt(psz);
          if (charCode > 255) {
            return;
          }
          var carry = BASE_MAP[charCode];
          if (carry === 255) {
            return;
          }
          var i12 = 0;
          for (var it32 = size4 - 1; (carry !== 0 || i12 < length2) && it32 !== -1; it32--, i12++) {
            carry += BASE * b256[it32] >>> 0;
            b256[it32] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i12;
          psz++;
        }
        var it4 = size4 - length2;
        while (it4 !== size4 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size4 - it4));
        var j8 = zeroes;
        while (it4 !== size4) {
          vch[j8++] = b256[it4++];
        }
        return vch;
      }
      function decode7(string2) {
        var buffer3 = decodeUnsafe(string2);
        if (buffer3) {
          return buffer3;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode6,
        decodeUnsafe,
        decode: decode7
      };
    }
    module.exports = base3;
  }
});

// node_modules/c32check/lib/base58check.js
var require_base58check = __commonJS({
  "node_modules/c32check/lib/base58check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils();
    var basex = require_src();
    var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    function encode6(data, prefix = "00") {
      const dataBytes = typeof data === "string" ? (0, utils_1.hexToBytes)(data) : data;
      const prefixBytes = typeof prefix === "string" ? (0, utils_1.hexToBytes)(prefix) : data;
      if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {
        throw new TypeError("Argument must be of type Uint8Array or string");
      }
      const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));
      return basex(ALPHABET2).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);
    }
    exports.encode = encode6;
    function decode7(string2) {
      const bytes2 = basex(ALPHABET2).decode(string2);
      const prefixBytes = bytes2.slice(0, 1);
      const dataBytes = bytes2.slice(1, -4);
      const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));
      bytes2.slice(-4).forEach((check, index2) => {
        if (check !== checksum[index2]) {
          throw new Error("Invalid checksum");
        }
      });
      return { prefix: prefixBytes, data: dataBytes };
    }
    exports.decode = decode7;
  }
});

// node_modules/c32check/lib/address.js
var require_address = __commonJS({
  "node_modules/c32check/lib/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;
    var checksum_1 = require_checksum();
    var base58check = require_base58check();
    var utils_1 = require_utils();
    exports.versions = {
      mainnet: {
        p2pkh: 22,
        p2sh: 20
        // 'M'
      },
      testnet: {
        p2pkh: 26,
        p2sh: 21
        // 'N'
      }
    };
    var ADDR_BITCOIN_TO_STACKS = {};
    ADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;
    ADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;
    ADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;
    ADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;
    var ADDR_STACKS_TO_BITCOIN = {};
    ADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;
    ADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;
    ADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;
    ADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;
    function c32address4(version4, hash160hex) {
      if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {
        throw new Error("Invalid argument: not a hash160 hex string");
      }
      const c32string = (0, checksum_1.c32checkEncode)(version4, hash160hex);
      return `S${c32string}`;
    }
    exports.c32address = c32address4;
    function c32addressDecode6(c32addr) {
      if (c32addr.length <= 5) {
        throw new Error("Invalid c32 address: invalid length");
      }
      if (c32addr[0] != "S") {
        throw new Error('Invalid c32 address: must start with "S"');
      }
      return (0, checksum_1.c32checkDecode)(c32addr.slice(1));
    }
    exports.c32addressDecode = c32addressDecode6;
    function b58ToC32(b58check, version4 = -1) {
      const addrInfo = base58check.decode(b58check);
      const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);
      const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);
      let stacksVersion;
      if (version4 < 0) {
        stacksVersion = addrVersion;
        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== void 0) {
          stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];
        }
      } else {
        stacksVersion = version4;
      }
      return c32address4(stacksVersion, hash160String);
    }
    exports.b58ToC32 = b58ToC32;
    function c32ToB58(c32string, version4 = -1) {
      const addrInfo = c32addressDecode6(c32string);
      const stacksVersion = addrInfo[0];
      const hash160String = addrInfo[1];
      let bitcoinVersion;
      if (version4 < 0) {
        bitcoinVersion = stacksVersion;
        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== void 0) {
          bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];
        }
      } else {
        bitcoinVersion = version4;
      }
      let prefix = bitcoinVersion.toString(16);
      if (prefix.length === 1) {
        prefix = `0${prefix}`;
      }
      return base58check.encode(hash160String, prefix);
    }
    exports.c32ToB58 = c32ToB58;
  }
});

// node_modules/c32check/lib/index.js
var require_lib = __commonJS({
  "node_modules/c32check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;
    var encoding_1 = require_encoding();
    Object.defineProperty(exports, "c32encode", { enumerable: true, get: function() {
      return encoding_1.c32encode;
    } });
    Object.defineProperty(exports, "c32decode", { enumerable: true, get: function() {
      return encoding_1.c32decode;
    } });
    Object.defineProperty(exports, "c32normalize", { enumerable: true, get: function() {
      return encoding_1.c32normalize;
    } });
    var checksum_1 = require_checksum();
    Object.defineProperty(exports, "c32checkEncode", { enumerable: true, get: function() {
      return checksum_1.c32checkEncode;
    } });
    Object.defineProperty(exports, "c32checkDecode", { enumerable: true, get: function() {
      return checksum_1.c32checkDecode;
    } });
    var address_1 = require_address();
    Object.defineProperty(exports, "c32address", { enumerable: true, get: function() {
      return address_1.c32address;
    } });
    Object.defineProperty(exports, "c32addressDecode", { enumerable: true, get: function() {
      return address_1.c32addressDecode;
    } });
    Object.defineProperty(exports, "c32ToB58", { enumerable: true, get: function() {
      return address_1.c32ToB58;
    } });
    Object.defineProperty(exports, "b58ToC32", { enumerable: true, get: function() {
      return address_1.b58ToC32;
    } });
    Object.defineProperty(exports, "versions", { enumerable: true, get: function() {
      return address_1.versions;
    } });
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map2, pair) {
      map2.set(pair[0], pair[1]);
      return map2;
    }
    function addSetEntry(set2, value) {
      set2.add(value);
      return set2;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length2 = array ? array.length : 0;
      while (++index2 < length2) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index2 = -1, length2 = values.length, offset = array.length;
      while (++index2 < length2) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array ? array.length : 0;
      if (initAccum && length2) {
        accumulator = array[++index2];
      }
      while (++index2 < length2) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function baseTimes(n12, iteratee) {
      var index2 = -1, result = Array(n12);
      while (++index2 < n12) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function getValue2(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e10) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash3(entries2) {
      var index2 = -1, length2 = entries2 ? entries2.length : 0;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash3.prototype.clear = hashClear;
    Hash3.prototype["delete"] = hashDelete;
    Hash3.prototype.get = hashGet;
    Hash3.prototype.has = hashHas;
    Hash3.prototype.set = hashSet;
    function ListCache(entries2) {
      var index2 = -1, length2 = entries2 ? entries2.length : 0;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries2) {
      var index2 = -1, length2 = entries2 ? entries2.length : 0;
      this.clear();
      while (++index2 < length2) {
        var entry = entries2[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash3(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash3()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries2) {
      this.__data__ = new ListCache(entries2);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length2 = result.length, skipIndexes = !!length2;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys2(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys2(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer3, isDeep) {
      if (isDeep) {
        return buffer3.slice();
      }
      var result = new buffer3.constructor(buffer3.length);
      buffer3.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer3 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer3, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map2), true) : mapToArray(map2);
      return arrayReduce(array, addMapEntry, new map2.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set2, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
      return arrayReduce(array, addSetEntry, new set2.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer3 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer3, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index2 = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index2 < length2) {
        array[index2] = source[index2];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue2(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length2 = array.length, result = array.constructor(length2);
      if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e10) {
        }
        try {
          return func + "";
        } catch (e10) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep2;
  }
});

// node_modules/cross-fetch/dist/browser-polyfill.js
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
    (function(self2) {
      var irrelevant = function(exports2) {
        var g5 = typeof globalThis !== "undefined" && globalThis || typeof self2 !== "undefined" && self2 || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g5,
          iterable: "Symbol" in g5 && "iterator" in Symbol,
          blob: "FileReader" in g5 && "Blob" in g5 && function() {
            try {
              new Blob();
              return true;
            } catch (e10) {
              return false;
            }
          }(),
          formData: "FormData" in g5,
          arrayBuffer: "ArrayBuffer" in g5
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers2.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers2.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers2.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i11 = 0; i11 < view.length; i11++) {
            chars[i11] = String.fromCharCode(view[i11]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode7);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g5) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode7(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes2) {
            if (bytes2) {
              var split3 = bytes2.split("=");
              var name2 = split3.shift().replace(/\+/g, " ");
              var value = split3.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error2) {
                console.warn("Response " + error2.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g5.DOMException;
        try {
          new exports2.DOMException();
        } catch (err2) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error2 = Error(message);
            this.stack = error2.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g5.location.href ? g5.location.href : url;
              } catch (e10) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g5.Headers && init.headers instanceof g5.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name2) {
                names.push(normalizeName(name2));
                xhr.setRequestHeader(name2, normalizeValue(init.headers[name2]));
              });
              request.headers.forEach(function(value, name2) {
                if (names.indexOf(name2) === -1) {
                  xhr.setRequestHeader(name2, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g5.fetch) {
          g5.fetch = fetch2;
          g5.Headers = Headers2;
          g5.Request = Request2;
          g5.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(typeof self !== "undefined" ? self : exports);
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R6 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R6 && typeof R6.apply === "function" ? R6.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R6 && typeof R6.ownKeys === "function") {
      ReflectOwnKeys = R6.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n12) {
      if (typeof n12 !== "number" || n12 < 0 || NumberIsNaN(n12)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n12 + ".");
      }
      this._maxListeners = n12;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i11 = 1; i11 < arguments.length; i11++) args.push(arguments[i11]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er3;
        if (args.length > 0)
          er3 = args[0];
        if (er3 instanceof Error) {
          throw er3;
        }
        var err2 = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
        err2.context = er3;
        throw err2;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i11 = 0; i11 < len; ++i11)
          ReflectApply(listeners[i11], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m6;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m6 = _getMaxListeners(target);
        if (m6 > 0 && existing.length > m6 && !existing.warned) {
          existing.warned = true;
          var w6 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w6.name = "MaxListenersExceededWarning";
          w6.emitter = target;
          w6.type = type;
          w6.count = existing.length;
          ProcessEmitWarning(w6);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state24 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state24);
      wrapped.listener = listener;
      state24.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list2, events, position, i11, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list2 = events[type];
      if (list2 === void 0)
        return this;
      if (list2 === listener || list2.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list2.listener || listener);
        }
      } else if (typeof list2 !== "function") {
        position = -1;
        for (i11 = list2.length - 1; i11 >= 0; i11--) {
          if (list2[i11] === listener || list2[i11].listener === listener) {
            originalListener = list2[i11].listener;
            position = i11;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list2.shift();
        else {
          spliceOne(list2, position);
        }
        if (list2.length === 1)
          events[type] = list2[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i11;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        var key;
        for (i11 = 0; i11 < keys2.length; ++i11) {
          key = keys2[i11];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i11 = listeners.length - 1; i11 >= 0; i11--) {
          this.removeListener(type, listeners[i11]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap2) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap2 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap2 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n12) {
      var copy = new Array(n12);
      for (var i11 = 0; i11 < n12; ++i11)
        copy[i11] = arr[i11];
      return copy;
    }
    function spliceOne(list2, index2) {
      for (; index2 + 1 < list2.length; index2++)
        list2[index2] = list2[index2 + 1];
      list2.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i11 = 0; i11 < ret.length; ++i11) {
        ret[i11] = arr[i11].listener || arr[i11];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err2) {
          emitter.removeListener(name2, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d7, b7) {
  extendStatics(d7, b7);
  function __() {
    this.constructor = d7;
  }
  d7.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
}
function __rest(s8, e10) {
  var t5 = {};
  for (var p8 in s8) if (Object.prototype.hasOwnProperty.call(s8, p8) && e10.indexOf(p8) < 0)
    t5[p8] = s8[p8];
  if (s8 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i11 = 0, p8 = Object.getOwnPropertySymbols(s8); i11 < p8.length; i11++) {
      if (e10.indexOf(p8[i11]) < 0 && Object.prototype.propertyIsEnumerable.call(s8, p8[i11]))
        t5[p8[i11]] = s8[p8[i11]];
    }
  return t5;
}
function __decorate(decorators, target, key, desc) {
  var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
  else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
  return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P8, generator) {
  function adopt(value) {
    return value instanceof P8 ? value : new P8(function(resolve) {
      resolve(value);
    });
  }
  return new (P8 || (P8 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e10) {
        reject(e10);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e10) {
        reject(e10);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _5 = { label: 0, sent: function() {
    if (t5[0] & 1) throw t5[1];
    return t5[1];
  }, trys: [], ops: [] }, f13, y9, t5, g5;
  return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n12) {
    return function(v8) {
      return step([n12, v8]);
    };
  }
  function step(op) {
    if (f13) throw new TypeError("Generator is already executing.");
    while (_5) try {
      if (f13 = 1, y9 && (t5 = op[0] & 2 ? y9["return"] : op[0] ? y9["throw"] || ((t5 = y9["return"]) && t5.call(y9), 0) : y9.next) && !(t5 = t5.call(y9, op[1])).done) return t5;
      if (y9 = 0, t5) op = [op[0] & 2, t5.value];
      switch (op[0]) {
        case 0:
        case 1:
          t5 = op;
          break;
        case 4:
          _5.label++;
          return { value: op[1], done: false };
        case 5:
          _5.label++;
          y9 = op[1];
          op = [0];
          continue;
        case 7:
          op = _5.ops.pop();
          _5.trys.pop();
          continue;
        default:
          if (!(t5 = _5.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _5 = 0;
            continue;
          }
          if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
            _5.label = op[1];
            break;
          }
          if (op[0] === 6 && _5.label < t5[1]) {
            _5.label = t5[1];
            t5 = op;
            break;
          }
          if (t5 && _5.label < t5[2]) {
            _5.label = t5[2];
            _5.ops.push(op);
            break;
          }
          if (t5[2]) _5.ops.pop();
          _5.trys.pop();
          continue;
      }
      op = body.call(thisArg, _5);
    } catch (e10) {
      op = [6, e10];
      y9 = 0;
    } finally {
      f13 = t5 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o13, m6, k7, k22) {
  if (k22 === void 0) k22 = k7;
  o13[k22] = m6[k7];
}
function __exportStar(m6, exports) {
  for (var p8 in m6) if (p8 !== "default" && !exports.hasOwnProperty(p8)) exports[p8] = m6[p8];
}
function __values(o13) {
  var s8 = typeof Symbol === "function" && Symbol.iterator, m6 = s8 && o13[s8], i11 = 0;
  if (m6) return m6.call(o13);
  if (o13 && typeof o13.length === "number") return {
    next: function() {
      if (o13 && i11 >= o13.length) o13 = void 0;
      return { value: o13 && o13[i11++], done: !o13 };
    }
  };
  throw new TypeError(s8 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o13, n12) {
  var m6 = typeof Symbol === "function" && o13[Symbol.iterator];
  if (!m6) return o13;
  var i11 = m6.call(o13), r9, ar3 = [], e10;
  try {
    while ((n12 === void 0 || n12-- > 0) && !(r9 = i11.next()).done) ar3.push(r9.value);
  } catch (error2) {
    e10 = { error: error2 };
  } finally {
    try {
      if (r9 && !r9.done && (m6 = i11["return"])) m6.call(i11);
    } finally {
      if (e10) throw e10.error;
    }
  }
  return ar3;
}
function __spread() {
  for (var ar3 = [], i11 = 0; i11 < arguments.length; i11++)
    ar3 = ar3.concat(__read(arguments[i11]));
  return ar3;
}
function __spreadArrays() {
  for (var s8 = 0, i11 = 0, il = arguments.length; i11 < il; i11++) s8 += arguments[i11].length;
  for (var r9 = Array(s8), k7 = 0, i11 = 0; i11 < il; i11++)
    for (var a5 = arguments[i11], j7 = 0, jl = a5.length; j7 < jl; j7++, k7++)
      r9[k7] = a5[j7];
  return r9;
}
function __await(v8) {
  return this instanceof __await ? (this.v = v8, this) : new __await(v8);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g5 = generator.apply(thisArg, _arguments || []), i11, q3 = [];
  return i11 = {}, verb("next"), verb("throw"), verb("return"), i11[Symbol.asyncIterator] = function() {
    return this;
  }, i11;
  function verb(n12) {
    if (g5[n12]) i11[n12] = function(v8) {
      return new Promise(function(a5, b7) {
        q3.push([n12, v8, a5, b7]) > 1 || resume(n12, v8);
      });
    };
  }
  function resume(n12, v8) {
    try {
      step(g5[n12](v8));
    } catch (e10) {
      settle(q3[0][3], e10);
    }
  }
  function step(r9) {
    r9.value instanceof __await ? Promise.resolve(r9.value.v).then(fulfill, reject) : settle(q3[0][2], r9);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f13, v8) {
    if (f13(v8), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncDelegator(o13) {
  var i11, p8;
  return i11 = {}, verb("next"), verb("throw", function(e10) {
    throw e10;
  }), verb("return"), i11[Symbol.iterator] = function() {
    return this;
  }, i11;
  function verb(n12, f13) {
    i11[n12] = o13[n12] ? function(v8) {
      return (p8 = !p8) ? { value: __await(o13[n12](v8)), done: n12 === "return" } : f13 ? f13(v8) : v8;
    } : f13;
  }
}
function __asyncValues(o13) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m6 = o13[Symbol.asyncIterator], i11;
  return m6 ? m6.call(o13) : (o13 = typeof __values === "function" ? __values(o13) : o13[Symbol.iterator](), i11 = {}, verb("next"), verb("throw"), verb("return"), i11[Symbol.asyncIterator] = function() {
    return this;
  }, i11);
  function verb(n12) {
    i11[n12] = o13[n12] && function(v8) {
      return new Promise(function(resolve, reject) {
        v8 = o13[n12](v8), settle(resolve, reject, v8.done, v8.value);
      });
    };
  }
  function settle(resolve, reject, d7, v8) {
    Promise.resolve(v8).then(function(v9) {
      resolve({ value: v9, done: d7 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod3) {
  if (mod3 && mod3.__esModule) return mod3;
  var result = {};
  if (mod3 != null) {
    for (var k7 in mod3) if (Object.hasOwnProperty.call(mod3, k7)) result[k7] = mod3[k7];
  }
  result.default = mod3;
  return result;
}
function __importDefault(mod3) {
  return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d7, b7) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d8, b8) {
        d8.__proto__ = b8;
      } || function(d8, b8) {
        for (var p8 in b8) if (b8.hasOwnProperty(p8)) d8[p8] = b8[p8];
      };
      return extendStatics(d7, b7);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t5) {
        for (var s8, i11 = 1, n12 = arguments.length; i11 < n12; i11++) {
          s8 = arguments[i11];
          for (var p8 in s8) if (Object.prototype.hasOwnProperty.call(s8, p8)) t5[p8] = s8[p8];
        }
        return t5;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    function delay(timeout) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout);
      });
    }
    exports.delay = delay;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
    exports.ONE_HUNDRED = 100;
    exports.ONE_THOUSAND = 1e3;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_time(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromMiliseconds = exports.toMiliseconds = void 0;
    var constants_1 = require_constants();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports.toMiliseconds = toMiliseconds;
    function fromMiliseconds(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports.fromMiliseconds = fromMiliseconds;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp = this.get(label);
        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, { started: timestamp.started, elapsed });
      }
      get(label) {
        const timestamp = this.timestamps.get(label);
        if (typeof timestamp === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp;
      }
      elapsed(label) {
        const timestamp = this.get(label);
        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    };
    exports.Watch = Watch;
    exports.default = Watch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWatch = void 0;
    var IWatch = class {
    };
    exports.IWatch = IWatch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils2(), exports);
    tslib_1.__exportStar(require_watch(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents;
var init_events = __esm({
  "node_modules/@walletconnect/events/dist/esm/events.js"() {
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/@walletconnect/events/dist/esm/index.js"() {
    init_events();
  }
});

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events, import_time, n, s, r, i;
var init_index_es = __esm({
  "node_modules/@walletconnect/heartbeat/dist/index.es.js"() {
    import_events = __toESM(require_events());
    import_time = __toESM(require_cjs());
    init_esm2();
    n = class extends IEvents {
      constructor(e10) {
        super();
      }
    };
    s = import_time.FIVE_SECONDS;
    r = { pulse: "heartbeat_pulse" };
    i = class _i3 extends n {
      constructor(e10) {
        super(e10), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = e10?.interval || s;
      }
      static async init(e10) {
        const t5 = new _i3(e10);
        return await t5.init(), t5;
      }
      async init() {
        await this.initialize();
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(e10, t5) {
        this.events.on(e10, t5);
      }
      once(e10, t5) {
        this.events.once(e10, t5);
      }
      off(e10, t5) {
        this.events.off(e10, t5);
      }
      removeListener(e10, t5) {
        this.events.removeListener(e10, t5);
      }
      async initialize() {
        this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
      }
      pulse() {
        this.events.emit(r.pulse);
      }
    };
  }
});

// node_modules/destr/dist/index.mjs
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error2) {
    if (options.strict) {
      throw error2;
    }
    return value;
  }
}
var suspectProtoRx, suspectConstructorRx, JsonSigRx;
var init_dist = __esm({
  "node_modules/destr/dist/index.mjs"() {
    suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
    suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
  }
});

// node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error2) {
    return Promise.reject(error2);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify3(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify3(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c12) => c12.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base3) {
  base3 = normalizeKey(base3);
  return base3 ? base3 + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index2 = key.indexOf(":");
  while (index2 > -1) {
    substrCount++;
    index2 = key.indexOf(":", index2 + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base3) {
  if (base3) {
    return key.startsWith(base3) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}
var BASE64_PREFIX;
var init_unstorage_zVDD2mZo = __esm({
  "node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs"() {
    BASE64_PREFIX = "base64:";
  }
});

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base3 of context.mountpoints) {
      if (key.startsWith(base3)) {
        return {
          base: base3,
          relativeKey: key.slice(base3.length),
          driver: context.mounts[base3]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base3, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base3) || includeParent && base3.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base3.length > mountpoint.length ? base3.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r9) => r9.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r9) => r9.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify3(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify3(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify3(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      const mounts = getMounts(base3, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!mount.driver.flags?.maxDepth) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p8) => fullKey.startsWith(p8))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p8) => !p8.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base3)
      );
    },
    // Utils
    async clear(base3, opts = {}) {
      base3 = normalizeBaseKey(base3);
      await Promise.all(
        getMounts(base3, false).map(async (m6) => {
          if (m6.driver.clear) {
            return asyncCall(m6.driver.clear, m6.relativeBase, opts);
          }
          if (m6.driver.removeItem) {
            const keys2 = await m6.driver.getKeys(m6.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m6.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base3, driver) {
      base3 = normalizeBaseKey(base3);
      if (base3 && context.mounts[base3]) {
        throw new Error(`already mounted at ${base3}`);
      }
      if (base3) {
        context.mountpoints.push(base3);
        context.mountpoints.sort((a5, b7) => b7.length - a5.length);
      }
      context.mounts[base3] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base3)).then((unwatcher) => {
          context.unwatch[base3] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base3, _dispose = true) {
      base3 = normalizeBaseKey(base3);
      if (!base3 || !context.mounts[base3]) {
        return;
      }
      if (context.watching && base3 in context.unwatch) {
        context.unwatch[base3]?.();
        delete context.unwatch[base3];
      }
      if (_dispose) {
        await dispose(context.mounts[base3]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base3);
      delete context.mounts[base3];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m6 = getMount(key);
      return {
        driver: m6.driver,
        base: m6.base
      };
    },
    getMounts(base3 = "", opts = {}) {
      base3 = normalizeKey(base3);
      const mounts = getMounts(base3, opts.parents);
      return mounts.map((m6) => ({
        driver: m6.driver,
        base: m6.mountpoint
      }));
    },
    // Aliases
    keys: (base3, opts = {}) => storage.getKeys(base3, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base3) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base3 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}
var DRIVER_NAME, memory;
var init_dist2 = __esm({
  "node_modules/unstorage/dist/index.mjs"() {
    init_dist();
    init_unstorage_zVDD2mZo();
    DRIVER_NAME = "memory";
    memory = defineDriver(() => {
      const data = /* @__PURE__ */ new Map();
      return {
        name: DRIVER_NAME,
        getInstance: () => data,
        hasItem(key) {
          return data.has(key);
        },
        getItem(key) {
          return data.get(key) ?? null;
        },
        getItemRaw(key) {
          return data.get(key) ?? null;
        },
        setItem(key, value) {
          data.set(key, value);
        },
        setItemRaw(key, value) {
          data.set(key, value);
        },
        removeItem(key) {
          data.delete(key);
        },
        getKeys() {
          return [...data.keys()];
        },
        clear() {
          data.clear();
        },
        dispose() {
          data.clear();
        }
      };
    });
  }
});

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}
var defaultGetStoreFunc;
var init_dist3 = __esm({
  "node_modules/idb-keyval/dist/index.js"() {
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}
var JSONStringify, JSONParse;
var init_esm3 = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
    JSONStringify = (data) => JSON.stringify(data, (_5, value) => typeof value === "bigint" ? value.toString() + "n" : value);
    JSONParse = (json) => {
      const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
      const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
      return JSON.parse(serializedData, (_5, value) => {
        const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
        if (isCustomFormatBigInt)
          return BigInt(value.substring(0, value.length - 1));
        return value;
      });
    };
  }
});

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
function k(i11) {
  var t5;
  return [i11[0], safeJsonParse((t5 = i11[1]) != null ? t5 : "")];
}
var x, z, D, E, _, l2, c, K, N, y, O, j, h2;
var init_index_es2 = __esm({
  "node_modules/@walletconnect/keyvaluestorage/dist/index.es.js"() {
    init_dist2();
    init_dist3();
    init_esm3();
    x = "idb-keyval";
    z = (i11 = {}) => {
      const t5 = i11.base && i11.base.length > 0 ? `${i11.base}:` : "", e10 = (s8) => t5 + s8;
      let n12;
      return i11.dbName && i11.storeName && (n12 = createStore(i11.dbName, i11.storeName)), { name: x, options: i11, async hasItem(s8) {
        return !(typeof await get(e10(s8), n12) > "u");
      }, async getItem(s8) {
        return await get(e10(s8), n12) ?? null;
      }, setItem(s8, a5) {
        return set(e10(s8), a5, n12);
      }, removeItem(s8) {
        return del(e10(s8), n12);
      }, getKeys() {
        return keys(n12);
      }, clear() {
        return clear(n12);
      } };
    };
    D = "WALLET_CONNECT_V2_INDEXED_DB";
    E = "keyvaluestorage";
    _ = class {
      constructor() {
        this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E }) });
      }
      async getKeys() {
        return this.indexedDb.getKeys();
      }
      async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t5) => [t5.key, t5.value]);
      }
      async getItem(t5) {
        const e10 = await this.indexedDb.getItem(t5);
        if (e10 !== null) return e10;
      }
      async setItem(t5, e10) {
        await this.indexedDb.setItem(t5, safeJsonStringify(e10));
      }
      async removeItem(t5) {
        await this.indexedDb.removeItem(t5);
      }
    };
    l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    c = { exports: {} };
    (function() {
      let i11;
      function t5() {
      }
      i11 = t5, i11.prototype.getItem = function(e10) {
        return this.hasOwnProperty(e10) ? String(this[e10]) : null;
      }, i11.prototype.setItem = function(e10, n12) {
        this[e10] = String(n12);
      }, i11.prototype.removeItem = function(e10) {
        delete this[e10];
      }, i11.prototype.clear = function() {
        const e10 = this;
        Object.keys(e10).forEach(function(n12) {
          e10[n12] = void 0, delete e10[n12];
        });
      }, i11.prototype.key = function(e10) {
        return e10 = e10 || 0, Object.keys(this)[e10];
      }, i11.prototype.__defineGetter__("length", function() {
        return Object.keys(this).length;
      }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t5();
    })();
    K = class {
      constructor() {
        this.localStorage = c.exports;
      }
      async getKeys() {
        return Object.keys(this.localStorage);
      }
      async getEntries() {
        return Object.entries(this.localStorage).map(k);
      }
      async getItem(t5) {
        const e10 = this.localStorage.getItem(t5);
        if (e10 !== null) return safeJsonParse(e10);
      }
      async setItem(t5, e10) {
        this.localStorage.setItem(t5, safeJsonStringify(e10));
      }
      async removeItem(t5) {
        this.localStorage.removeItem(t5);
      }
    };
    N = "wc_storage_version";
    y = 1;
    O = async (i11, t5, e10) => {
      const n12 = N, s8 = await t5.getItem(n12);
      if (s8 && s8 >= y) {
        e10(t5);
        return;
      }
      const a5 = await i11.getKeys();
      if (!a5.length) {
        e10(t5);
        return;
      }
      const m6 = [];
      for (; a5.length; ) {
        const r9 = a5.shift();
        if (!r9) continue;
        const o13 = r9.toLowerCase();
        if (o13.includes("wc@") || o13.includes("walletconnect") || o13.includes("wc_") || o13.includes("wallet_connect")) {
          const f13 = await i11.getItem(r9);
          await t5.setItem(r9, f13), m6.push(r9);
        }
      }
      await t5.setItem(n12, y), e10(t5), j(i11, m6);
    };
    j = async (i11, t5) => {
      t5.length && t5.forEach(async (e10) => {
        await i11.removeItem(e10);
      });
    };
    h2 = class {
      constructor() {
        this.initialized = false, this.setInitialized = (e10) => {
          this.storage = e10, this.initialized = true;
        };
        const t5 = new K();
        this.storage = t5;
        try {
          const e10 = new _();
          O(t5, e10, this.setInitialized);
        } catch {
          this.initialized = true;
        }
      }
      async getKeys() {
        return await this.initialize(), this.storage.getKeys();
      }
      async getEntries() {
        return await this.initialize(), this.storage.getEntries();
      }
      async getItem(t5) {
        return await this.initialize(), this.storage.getItem(t5);
      }
      async setItem(t5, e10) {
        return await this.initialize(), this.storage.setItem(t5, e10);
      }
      async removeItem(t5) {
        return await this.initialize(), this.storage.removeItem(t5);
      }
      async initialize() {
        this.initialized || await new Promise((t5) => {
          const e10 = setInterval(() => {
            this.initialized && (clearInterval(e10), t5());
          }, 20);
        });
      }
    };
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o13) {
      try {
        return JSON.stringify(o13);
      } catch (e10) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f13, args, opts) {
      var ss3 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f13 === "object" && f13 !== null) {
        var len = args.length + offset;
        if (len === 1) return f13;
        var objects = new Array(len);
        objects[0] = ss3(f13);
        for (var index2 = 1; index2 < len; index2++) {
          objects[index2] = ss3(args[index2]);
        }
        return objects.join(" ");
      }
      if (typeof f13 !== "string") {
        return f13;
      }
      var argLen = args.length;
      if (argLen === 0) return f13;
      var str = "";
      var a5 = 1 - offset;
      var lastPos = -1;
      var flen = f13 && f13.length || 0;
      for (var i11 = 0; i11 < flen; ) {
        if (f13.charCodeAt(i11) === 37 && i11 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f13.charCodeAt(i11 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a5 >= argLen)
                break;
              if (args[a5] == null) break;
              if (lastPos < i11)
                str += f13.slice(lastPos, i11);
              str += Number(args[a5]);
              lastPos = i11 + 2;
              i11++;
              break;
            case 105:
              if (a5 >= argLen)
                break;
              if (args[a5] == null) break;
              if (lastPos < i11)
                str += f13.slice(lastPos, i11);
              str += Math.floor(Number(args[a5]));
              lastPos = i11 + 2;
              i11++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a5 >= argLen)
                break;
              if (args[a5] === void 0) break;
              if (lastPos < i11)
                str += f13.slice(lastPos, i11);
              var type = typeof args[a5];
              if (type === "string") {
                str += "'" + args[a5] + "'";
                lastPos = i11 + 2;
                i11++;
                break;
              }
              if (type === "function") {
                str += args[a5].name || "<anonymous>";
                lastPos = i11 + 2;
                i11++;
                break;
              }
              str += ss3(args[a5]);
              lastPos = i11 + 2;
              i11++;
              break;
            case 115:
              if (a5 >= argLen)
                break;
              if (lastPos < i11)
                str += f13.slice(lastPos, i11);
              str += String(args[a5]);
              lastPos = i11 + 2;
              i11++;
              break;
            case 37:
              if (lastPos < i11)
                str += f13.slice(lastPos, i11);
              str += "%";
              lastPos = i11 + 2;
              i11++;
              a5--;
              break;
          }
          ++a5;
        }
        ++i11;
      }
      if (lastPos === -1)
        return f13;
      else if (lastPos < flen) {
        str += f13.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize2, serializers) {
      if (Array.isArray(serialize2)) {
        const hasToFilter = serialize2.filter(function(k7) {
          return k7 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize2 === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize2 = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize: serialize2,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize2;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize2 && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize2 && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize2;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback2) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop) return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts2 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i11 = 0; i11 < args.length; i11++) args[i11] = arguments[i11];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject) write.call(proto, asObject(this, level, args, ts2));
          else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts2) {
      if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o13 = {};
      if (ts2) {
        o13.time = ts2;
      }
      o13.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o13, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o13.msg = msg;
      return o13;
    }
    function applySerializers(args, serialize2, serializers, stdErrSerialize) {
      for (const i11 in args) {
        if (stdErrSerialize && args[i11] instanceof Error) {
          args[i11] = pino.stdSerializers.err(args[i11]);
        } else if (typeof args[i11] === "object" && !Array.isArray(args[i11])) {
          for (const k7 in args[i11]) {
            if (serialize2 && serialize2.indexOf(k7) > -1 && k7 in serializers) {
              args[i11][k7] = serializers[k7](args[i11][k7]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i11 = 1; i11 < args.length; i11++) {
          args[i11] = arguments[i11 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts2 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts2;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err2) {
      const obj = {
        type: err2.constructor.name,
        msg: err2.message,
        stack: err2.stack
      };
      for (const key in err2) {
        if (obj[key] === void 0) {
          obj[key] = err2[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a5) {
      return a5;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o13) {
        return typeof o13 !== "undefined" && o13;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e10) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/logger/dist/index.es.js
function k2(r9) {
  return g(i2({}, r9), { level: r9?.level || c2.level });
}
function v(r9, e10 = n2) {
  return r9[e10] || "";
}
function b(r9, e10, t5 = n2) {
  return r9[t5] = e10, r9;
}
function y2(r9, e10 = n2) {
  let t5 = "";
  return typeof r9.bindings > "u" ? t5 = v(r9, e10) : t5 = r9.bindings().context || "", t5;
}
function w(r9, e10, t5 = n2) {
  const o13 = y2(r9, t5);
  return o13.trim() ? `${o13}/${e10}` : e10;
}
function E2(r9, e10, t5 = n2) {
  const o13 = w(r9, e10, t5), a5 = r9.child({ context: o13 });
  return b(a5, o13, t5);
}
function C(r9) {
  var e10, t5;
  const o13 = new m((e10 = r9.opts) == null ? void 0 : e10.level, r9.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r9.opts), { level: "trace", browser: g(i2({}, (t5 = r9.opts) == null ? void 0 : t5.browser), { write: (a5) => o13.write(a5) }) })), chunkLoggerController: o13 };
}
function I(r9) {
  var e10;
  const t5 = new B((e10 = r9.opts) == null ? void 0 : e10.level, r9.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i2({}, r9.opts), { level: "trace" }), t5), chunkLoggerController: t5 };
}
function A(r9) {
  return typeof r9.loggerOverride < "u" && typeof r9.loggerOverride != "string" ? { logger: r9.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C(r9) : I(r9);
}
var import_pino, import_pino2, c2, n2, l3, O2, d, L, m, B, x2, S, _2, p, T, z2, f2, i2, g;
var init_index_es3 = __esm({
  "node_modules/@walletconnect/logger/dist/index.es.js"() {
    import_pino = __toESM(require_browser());
    import_pino2 = __toESM(require_browser());
    init_esm3();
    c2 = { level: "info" };
    n2 = "custom_context";
    l3 = 1e3 * 1024;
    O2 = class {
      constructor(e10) {
        this.nodeValue = e10, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
      }
      get value() {
        return this.nodeValue;
      }
      get size() {
        return this.sizeInBytes;
      }
    };
    d = class {
      constructor(e10) {
        this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e10, this.sizeInBytes = 0;
      }
      append(e10) {
        const t5 = new O2(e10);
        if (t5.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e10} with size ${t5.size}`);
        for (; this.size + t5.size > this.maxSizeInBytes; ) this.shift();
        this.head ? (this.tail && (this.tail.next = t5), this.tail = t5) : (this.head = t5, this.tail = t5), this.lengthInNodes++, this.sizeInBytes += t5.size;
      }
      shift() {
        if (!this.head) return;
        const e10 = this.head;
        this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e10.size;
      }
      toArray() {
        const e10 = [];
        let t5 = this.head;
        for (; t5 !== null; ) e10.push(t5.value), t5 = t5.next;
        return e10;
      }
      get length() {
        return this.lengthInNodes;
      }
      get size() {
        return this.sizeInBytes;
      }
      toOrderedArray() {
        return Array.from(this);
      }
      [Symbol.iterator]() {
        let e10 = this.head;
        return { next: () => {
          if (!e10) return { done: true, value: null };
          const t5 = e10.value;
          return e10 = e10.next, { done: false, value: t5 };
        } };
      }
    };
    L = class {
      constructor(e10, t5 = l3) {
        this.level = e10 ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t5, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
      }
      forwardToConsole(e10, t5) {
        t5 === import_pino.levels.values.error ? console.error(e10) : t5 === import_pino.levels.values.warn ? console.warn(e10) : t5 === import_pino.levels.values.debug ? console.debug(e10) : t5 === import_pino.levels.values.trace ? console.trace(e10) : console.log(e10);
      }
      appendToLogs(e10) {
        this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e10 }));
        const t5 = typeof e10 == "string" ? JSON.parse(e10).level : e10.level;
        t5 >= this.levelValue && this.forwardToConsole(e10, t5);
      }
      getLogs() {
        return this.logs;
      }
      clearLogs() {
        this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
      }
      getLogArray() {
        return Array.from(this.logs);
      }
      logsToBlob(e10) {
        const t5 = this.getLogArray();
        return t5.push(safeJsonStringify({ extraMetadata: e10 })), new Blob(t5, { type: "application/json" });
      }
    };
    m = class {
      constructor(e10, t5 = l3) {
        this.baseChunkLogger = new L(e10, t5);
      }
      write(e10) {
        this.baseChunkLogger.appendToLogs(e10);
      }
      getLogs() {
        return this.baseChunkLogger.getLogs();
      }
      clearLogs() {
        this.baseChunkLogger.clearLogs();
      }
      getLogArray() {
        return this.baseChunkLogger.getLogArray();
      }
      logsToBlob(e10) {
        return this.baseChunkLogger.logsToBlob(e10);
      }
      downloadLogsBlobInBrowser(e10) {
        const t5 = URL.createObjectURL(this.logsToBlob(e10)), o13 = document.createElement("a");
        o13.href = t5, o13.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o13), o13.click(), document.body.removeChild(o13), URL.revokeObjectURL(t5);
      }
    };
    B = class {
      constructor(e10, t5 = l3) {
        this.baseChunkLogger = new L(e10, t5);
      }
      write(e10) {
        this.baseChunkLogger.appendToLogs(e10);
      }
      getLogs() {
        return this.baseChunkLogger.getLogs();
      }
      clearLogs() {
        this.baseChunkLogger.clearLogs();
      }
      getLogArray() {
        return this.baseChunkLogger.getLogArray();
      }
      logsToBlob(e10) {
        return this.baseChunkLogger.logsToBlob(e10);
      }
    };
    x2 = Object.defineProperty;
    S = Object.defineProperties;
    _2 = Object.getOwnPropertyDescriptors;
    p = Object.getOwnPropertySymbols;
    T = Object.prototype.hasOwnProperty;
    z2 = Object.prototype.propertyIsEnumerable;
    f2 = (r9, e10, t5) => e10 in r9 ? x2(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    i2 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) T.call(e10, t5) && f2(r9, t5, e10[t5]);
      if (p) for (var t5 of p(e10)) z2.call(e10, t5) && f2(r9, t5, e10[t5]);
      return r9;
    };
    g = (r9, e10) => S(r9, _2(e10));
  }
});

// node_modules/@walletconnect/types/dist/index.es.js
var import_events4, a2, u, c3, h4, p2, b2, v2, I2, y3, m2, d2, f3, P, S2, M, O3, R, T2, k3, i3, J, V;
var init_index_es4 = __esm({
  "node_modules/@walletconnect/types/dist/index.es.js"() {
    init_esm2();
    import_events4 = __toESM(require_events());
    a2 = Object.defineProperty;
    u = (e10, s8, r9) => s8 in e10 ? a2(e10, s8, { enumerable: true, configurable: true, writable: true, value: r9 }) : e10[s8] = r9;
    c3 = (e10, s8, r9) => u(e10, typeof s8 != "symbol" ? s8 + "" : s8, r9);
    h4 = class extends IEvents {
      constructor(s8) {
        super(), this.opts = s8, c3(this, "protocol", "wc"), c3(this, "version", 2);
      }
    };
    p2 = Object.defineProperty;
    b2 = (e10, s8, r9) => s8 in e10 ? p2(e10, s8, { enumerable: true, configurable: true, writable: true, value: r9 }) : e10[s8] = r9;
    v2 = (e10, s8, r9) => b2(e10, typeof s8 != "symbol" ? s8 + "" : s8, r9);
    I2 = class extends IEvents {
      constructor(s8, r9) {
        super(), this.core = s8, this.logger = r9, v2(this, "records", /* @__PURE__ */ new Map());
      }
    };
    y3 = class {
      constructor(s8, r9) {
        this.logger = s8, this.core = r9;
      }
    };
    m2 = class extends IEvents {
      constructor(s8, r9) {
        super(), this.relayer = s8, this.logger = r9;
      }
    };
    d2 = class extends IEvents {
      constructor(s8) {
        super();
      }
    };
    f3 = class {
      constructor(s8, r9, t5, q3) {
        this.core = s8, this.logger = r9, this.name = t5;
      }
    };
    P = class extends IEvents {
      constructor(s8, r9) {
        super(), this.relayer = s8, this.logger = r9;
      }
    };
    S2 = class extends IEvents {
      constructor(s8, r9) {
        super(), this.core = s8, this.logger = r9;
      }
    };
    M = class {
      constructor(s8, r9, t5) {
        this.core = s8, this.logger = r9, this.store = t5;
      }
    };
    O3 = class {
      constructor(s8, r9) {
        this.projectId = s8, this.logger = r9;
      }
    };
    R = class {
      constructor(s8, r9, t5) {
        this.core = s8, this.logger = r9, this.telemetryEnabled = t5;
      }
    };
    T2 = Object.defineProperty;
    k3 = (e10, s8, r9) => s8 in e10 ? T2(e10, s8, { enumerable: true, configurable: true, writable: true, value: r9 }) : e10[s8] = r9;
    i3 = (e10, s8, r9) => k3(e10, typeof s8 != "symbol" ? s8 + "" : s8, r9);
    J = class {
      constructor(s8) {
        this.opts = s8, i3(this, "protocol", "wc"), i3(this, "version", 2);
      }
    };
    V = class {
      constructor(s8) {
        this.client = s8;
      }
    };
  }
});

// node_modules/@walletconnect/relay-auth/dist/index.es.js
function En(t5) {
  return t5 instanceof Uint8Array || ArrayBuffer.isView(t5) && t5.constructor.name === "Uint8Array";
}
function fe(t5, ...e10) {
  if (!En(t5)) throw new Error("Uint8Array expected");
  if (e10.length > 0 && !e10.includes(t5.length)) throw new Error("Uint8Array expected of length " + e10 + ", got length=" + t5.length);
}
function De(t5, e10 = true) {
  if (t5.destroyed) throw new Error("Hash instance has been destroyed");
  if (e10 && t5.finished) throw new Error("Hash#digest() has already been called");
}
function gn(t5, e10) {
  fe(t5);
  const n12 = e10.outputLen;
  if (t5.length < n12) throw new Error("digestInto() expects output buffer of length at least " + n12);
}
function yn(t5) {
  if (typeof t5 != "string") throw new Error("utf8ToBytes expected string, got " + typeof t5);
  return new Uint8Array(new TextEncoder().encode(t5));
}
function de(t5) {
  return typeof t5 == "string" && (t5 = yn(t5)), fe(t5), t5;
}
function Bn(t5) {
  const e10 = (r9) => t5().update(de(r9)).digest(), n12 = t5();
  return e10.outputLen = n12.outputLen, e10.blockLen = n12.blockLen, e10.create = () => t5(), e10;
}
function he(t5 = 32) {
  if (it && typeof it.getRandomValues == "function") return it.getRandomValues(new Uint8Array(t5));
  if (it && typeof it.randomBytes == "function") return it.randomBytes(t5);
  throw new Error("crypto.getRandomValues must be defined");
}
function Cn(t5, e10, n12, r9) {
  if (typeof t5.setBigUint64 == "function") return t5.setBigUint64(e10, n12, r9);
  const o13 = BigInt(32), s8 = BigInt(4294967295), a5 = Number(n12 >> o13 & s8), u6 = Number(n12 & s8), i11 = r9 ? 4 : 0, D4 = r9 ? 0 : 4;
  t5.setUint32(e10 + i11, a5, r9), t5.setUint32(e10 + D4, u6, r9);
}
function le(t5, e10 = false) {
  return e10 ? { h: Number(t5 & wt), l: Number(t5 >> St & wt) } : { h: Number(t5 >> St & wt) | 0, l: Number(t5 & wt) | 0 };
}
function mn(t5, e10 = false) {
  let n12 = new Uint32Array(t5.length), r9 = new Uint32Array(t5.length);
  for (let o13 = 0; o13 < t5.length; o13++) {
    const { h: s8, l: a5 } = le(t5[o13], e10);
    [n12[o13], r9[o13]] = [s8, a5];
  }
  return [n12, r9];
}
function qn(t5, e10, n12, r9) {
  const o13 = (e10 >>> 0) + (r9 >>> 0);
  return { h: t5 + n12 + (o13 / 2 ** 32 | 0) | 0, l: o13 | 0 };
}
function It(t5) {
  return t5 instanceof Uint8Array || ArrayBuffer.isView(t5) && t5.constructor.name === "Uint8Array";
}
function Ut(t5) {
  if (!It(t5)) throw new Error("Uint8Array expected");
}
function Tt(t5, e10) {
  if (typeof e10 != "boolean") throw new Error(t5 + " boolean expected, got " + e10);
}
function Ft(t5) {
  Ut(t5);
  let e10 = "";
  for (let n12 = 0; n12 < t5.length; n12++) e10 += Xn[t5[n12]];
  return e10;
}
function pe(t5) {
  if (typeof t5 != "string") throw new Error("hex string expected, got " + typeof t5);
  return t5 === "" ? vt : BigInt("0x" + t5);
}
function we(t5) {
  if (t5 >= K2._0 && t5 <= K2._9) return t5 - K2._0;
  if (t5 >= K2.A && t5 <= K2.F) return t5 - (K2.A - 10);
  if (t5 >= K2.a && t5 <= K2.f) return t5 - (K2.a - 10);
}
function Ee(t5) {
  if (typeof t5 != "string") throw new Error("hex string expected, got " + typeof t5);
  const e10 = t5.length, n12 = e10 / 2;
  if (e10 % 2) throw new Error("hex string expected, got unpadded hex of length " + e10);
  const r9 = new Uint8Array(n12);
  for (let o13 = 0, s8 = 0; o13 < n12; o13++, s8 += 2) {
    const a5 = we(t5.charCodeAt(s8)), u6 = we(t5.charCodeAt(s8 + 1));
    if (a5 === void 0 || u6 === void 0) {
      const i11 = t5[s8] + t5[s8 + 1];
      throw new Error('hex string expected, got non-hex character "' + i11 + '" at index ' + s8);
    }
    r9[o13] = a5 * 16 + u6;
  }
  return r9;
}
function Pn(t5) {
  return pe(Ft(t5));
}
function Et(t5) {
  return Ut(t5), pe(Ft(Uint8Array.from(t5).reverse()));
}
function ge(t5, e10) {
  return Ee(t5.toString(16).padStart(e10 * 2, "0"));
}
function Nt(t5, e10) {
  return ge(t5, e10).reverse();
}
function W(t5, e10, n12) {
  let r9;
  if (typeof e10 == "string") try {
    r9 = Ee(e10);
  } catch (s8) {
    throw new Error(t5 + " must be hex string or Uint8Array, cause: " + s8);
  }
  else if (It(e10)) r9 = Uint8Array.from(e10);
  else throw new Error(t5 + " must be hex string or Uint8Array");
  const o13 = r9.length;
  if (typeof n12 == "number" && o13 !== n12) throw new Error(t5 + " of length " + n12 + " expected, got " + o13);
  return r9;
}
function ye(...t5) {
  let e10 = 0;
  for (let r9 = 0; r9 < t5.length; r9++) {
    const o13 = t5[r9];
    Ut(o13), e10 += o13.length;
  }
  const n12 = new Uint8Array(e10);
  for (let r9 = 0, o13 = 0; r9 < t5.length; r9++) {
    const s8 = t5[r9];
    n12.set(s8, o13), o13 += s8.length;
  }
  return n12;
}
function Qn(t5, e10, n12) {
  return Lt(t5) && Lt(e10) && Lt(n12) && e10 <= t5 && t5 < n12;
}
function ft(t5, e10, n12, r9) {
  if (!Qn(e10, n12, r9)) throw new Error("expected valid " + t5 + ": " + n12 + " <= n < " + r9 + ", got " + e10);
}
function tr(t5) {
  let e10;
  for (e10 = 0; t5 > vt; t5 >>= be, e10 += 1) ;
  return e10;
}
function Ot(t5, e10, n12 = {}) {
  const r9 = (o13, s8, a5) => {
    const u6 = nr[s8];
    if (typeof u6 != "function") throw new Error("invalid validator function");
    const i11 = t5[o13];
    if (!(a5 && i11 === void 0) && !u6(i11, t5)) throw new Error("param " + String(o13) + " is invalid. Expected " + s8 + ", got " + i11);
  };
  for (const [o13, s8] of Object.entries(e10)) r9(o13, s8, false);
  for (const [o13, s8] of Object.entries(n12)) r9(o13, s8, true);
  return t5;
}
function xe(t5) {
  const e10 = /* @__PURE__ */ new WeakMap();
  return (n12, ...r9) => {
    const o13 = e10.get(n12);
    if (o13 !== void 0) return o13;
    const s8 = t5(n12, ...r9);
    return e10.set(n12, s8), s8;
  };
}
function H(t5, e10) {
  const n12 = t5 % e10;
  return n12 >= M2 ? n12 : e10 + n12;
}
function or(t5, e10, n12) {
  if (e10 < M2) throw new Error("invalid exponent, negatives unsupported");
  if (n12 <= M2) throw new Error("invalid modulus");
  if (n12 === N2) return M2;
  let r9 = N2;
  for (; e10 > M2; ) e10 & N2 && (r9 = r9 * t5 % n12), t5 = t5 * t5 % n12, e10 >>= N2;
  return r9;
}
function J2(t5, e10, n12) {
  let r9 = t5;
  for (; e10-- > M2; ) r9 *= r9, r9 %= n12;
  return r9;
}
function Ae(t5, e10) {
  if (t5 === M2) throw new Error("invert: expected non-zero number");
  if (e10 <= M2) throw new Error("invert: expected positive modulus, got " + e10);
  let n12 = H(t5, e10), r9 = e10, o13 = M2, s8 = N2;
  for (; n12 !== M2; ) {
    const u6 = r9 / n12, i11 = r9 % n12, D4 = o13 - s8 * u6;
    r9 = n12, n12 = i11, o13 = s8, s8 = D4;
  }
  if (r9 !== N2) throw new Error("invert: does not exist");
  return H(o13, e10);
}
function sr(t5) {
  const e10 = (t5 - N2) / nt;
  let n12, r9, o13;
  for (n12 = t5 - N2, r9 = 0; n12 % nt === M2; n12 /= nt, r9++) ;
  for (o13 = nt; o13 < t5 && or(o13, e10, t5) !== t5 - N2; o13++) if (o13 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r9 === 1) {
    const a5 = (t5 + N2) / Ht;
    return function(i11, D4) {
      const c12 = i11.pow(D4, a5);
      if (!i11.eql(i11.sqr(c12), D4)) throw new Error("Cannot find square root");
      return c12;
    };
  }
  const s8 = (n12 + N2) / nt;
  return function(u6, i11) {
    if (u6.pow(i11, e10) === u6.neg(u6.ONE)) throw new Error("Cannot find square root");
    let D4 = r9, c12 = u6.pow(u6.mul(u6.ONE, o13), n12), l10 = u6.pow(i11, s8), p8 = u6.pow(i11, n12);
    for (; !u6.eql(p8, u6.ONE); ) {
      if (u6.eql(p8, u6.ZERO)) return u6.ZERO;
      let w6 = 1;
      for (let g5 = u6.sqr(p8); w6 < D4 && !u6.eql(g5, u6.ONE); w6++) g5 = u6.sqr(g5);
      const h12 = u6.pow(c12, N2 << BigInt(D4 - w6 - 1));
      c12 = u6.sqr(h12), l10 = u6.mul(l10, h12), p8 = u6.mul(p8, c12), D4 = w6;
    }
    return l10;
  };
}
function ir(t5) {
  if (t5 % Ht === rr) {
    const e10 = (t5 + N2) / Ht;
    return function(r9, o13) {
      const s8 = r9.pow(o13, e10);
      if (!r9.eql(r9.sqr(s8), o13)) throw new Error("Cannot find square root");
      return s8;
    };
  }
  if (t5 % Ce === Be) {
    const e10 = (t5 - Be) / Ce;
    return function(r9, o13) {
      const s8 = r9.mul(o13, nt), a5 = r9.pow(s8, e10), u6 = r9.mul(o13, a5), i11 = r9.mul(r9.mul(u6, nt), a5), D4 = r9.mul(u6, r9.sub(i11, r9.ONE));
      if (!r9.eql(r9.sqr(D4), o13)) throw new Error("Cannot find square root");
      return D4;
    };
  }
  return sr(t5);
}
function ar(t5) {
  const e10 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n12 = cr.reduce((r9, o13) => (r9[o13] = "function", r9), e10);
  return Ot(t5, n12);
}
function fr(t5, e10, n12) {
  if (n12 < M2) throw new Error("invalid exponent, negatives unsupported");
  if (n12 === M2) return t5.ONE;
  if (n12 === N2) return e10;
  let r9 = t5.ONE, o13 = e10;
  for (; n12 > M2; ) n12 & N2 && (r9 = t5.mul(r9, o13)), o13 = t5.sqr(o13), n12 >>= N2;
  return r9;
}
function Dr(t5, e10) {
  const n12 = new Array(e10.length), r9 = e10.reduce((s8, a5, u6) => t5.is0(a5) ? s8 : (n12[u6] = s8, t5.mul(s8, a5)), t5.ONE), o13 = t5.inv(r9);
  return e10.reduceRight((s8, a5, u6) => t5.is0(a5) ? s8 : (n12[u6] = t5.mul(s8, n12[u6]), t5.mul(s8, a5)), o13), n12;
}
function me(t5, e10) {
  const n12 = e10 !== void 0 ? e10 : t5.toString(2).length, r9 = Math.ceil(n12 / 8);
  return { nBitLength: n12, nByteLength: r9 };
}
function _e(t5, e10, n12 = false, r9 = {}) {
  if (t5 <= M2) throw new Error("invalid field: expected ORDER > 0, got " + t5);
  const { nBitLength: o13, nByteLength: s8 } = me(t5, e10);
  if (s8 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a5;
  const u6 = Object.freeze({ ORDER: t5, isLE: n12, BITS: o13, BYTES: s8, MASK: er(o13), ZERO: M2, ONE: N2, create: (i11) => H(i11, t5), isValid: (i11) => {
    if (typeof i11 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof i11);
    return M2 <= i11 && i11 < t5;
  }, is0: (i11) => i11 === M2, isOdd: (i11) => (i11 & N2) === N2, neg: (i11) => H(-i11, t5), eql: (i11, D4) => i11 === D4, sqr: (i11) => H(i11 * i11, t5), add: (i11, D4) => H(i11 + D4, t5), sub: (i11, D4) => H(i11 - D4, t5), mul: (i11, D4) => H(i11 * D4, t5), pow: (i11, D4) => fr(u6, i11, D4), div: (i11, D4) => H(i11 * Ae(D4, t5), t5), sqrN: (i11) => i11 * i11, addN: (i11, D4) => i11 + D4, subN: (i11, D4) => i11 - D4, mulN: (i11, D4) => i11 * D4, inv: (i11) => Ae(i11, t5), sqrt: r9.sqrt || ((i11) => (a5 || (a5 = ir(t5)), a5(u6, i11))), invertBatch: (i11) => Dr(u6, i11), cmov: (i11, D4, c12) => c12 ? D4 : i11, toBytes: (i11) => n12 ? Nt(i11, s8) : ge(i11, s8), fromBytes: (i11) => {
    if (i11.length !== s8) throw new Error("Field.fromBytes: expected " + s8 + " bytes, got " + i11.length);
    return n12 ? Et(i11) : Pn(i11);
  } });
  return Object.freeze(u6);
}
function zt(t5, e10) {
  const n12 = e10.negate();
  return t5 ? n12 : e10;
}
function ve(t5, e10) {
  if (!Number.isSafeInteger(t5) || t5 <= 0 || t5 > e10) throw new Error("invalid window size, expected [1.." + e10 + "], got W=" + t5);
}
function Mt(t5, e10) {
  ve(t5, e10);
  const n12 = Math.ceil(e10 / t5) + 1, r9 = 2 ** (t5 - 1);
  return { windows: n12, windowSize: r9 };
}
function dr(t5, e10) {
  if (!Array.isArray(t5)) throw new Error("array expected");
  t5.forEach((n12, r9) => {
    if (!(n12 instanceof e10)) throw new Error("invalid point at index " + r9);
  });
}
function hr(t5, e10) {
  if (!Array.isArray(t5)) throw new Error("array of scalars expected");
  t5.forEach((n12, r9) => {
    if (!e10.isValid(n12)) throw new Error("invalid scalar at index " + r9);
  });
}
function $t(t5) {
  return Ie.get(t5) || 1;
}
function lr(t5, e10) {
  return { constTimeNegate: zt, hasPrecomputes(n12) {
    return $t(n12) !== 1;
  }, unsafeLadder(n12, r9, o13 = t5.ZERO) {
    let s8 = n12;
    for (; r9 > Se; ) r9 & gt && (o13 = o13.add(s8)), s8 = s8.double(), r9 >>= gt;
    return o13;
  }, precomputeWindow(n12, r9) {
    const { windows: o13, windowSize: s8 } = Mt(r9, e10), a5 = [];
    let u6 = n12, i11 = u6;
    for (let D4 = 0; D4 < o13; D4++) {
      i11 = u6, a5.push(i11);
      for (let c12 = 1; c12 < s8; c12++) i11 = i11.add(u6), a5.push(i11);
      u6 = i11.double();
    }
    return a5;
  }, wNAF(n12, r9, o13) {
    const { windows: s8, windowSize: a5 } = Mt(n12, e10);
    let u6 = t5.ZERO, i11 = t5.BASE;
    const D4 = BigInt(2 ** n12 - 1), c12 = 2 ** n12, l10 = BigInt(n12);
    for (let p8 = 0; p8 < s8; p8++) {
      const w6 = p8 * a5;
      let h12 = Number(o13 & D4);
      o13 >>= l10, h12 > a5 && (h12 -= c12, o13 += gt);
      const g5 = w6, S7 = w6 + Math.abs(h12) - 1, v8 = p8 % 2 !== 0, L6 = h12 < 0;
      h12 === 0 ? i11 = i11.add(zt(v8, r9[g5])) : u6 = u6.add(zt(L6, r9[S7]));
    }
    return { p: u6, f: i11 };
  }, wNAFUnsafe(n12, r9, o13, s8 = t5.ZERO) {
    const { windows: a5, windowSize: u6 } = Mt(n12, e10), i11 = BigInt(2 ** n12 - 1), D4 = 2 ** n12, c12 = BigInt(n12);
    for (let l10 = 0; l10 < a5; l10++) {
      const p8 = l10 * u6;
      if (o13 === Se) break;
      let w6 = Number(o13 & i11);
      if (o13 >>= c12, w6 > u6 && (w6 -= D4, o13 += gt), w6 === 0) continue;
      let h12 = r9[p8 + Math.abs(w6) - 1];
      w6 < 0 && (h12 = h12.negate()), s8 = s8.add(h12);
    }
    return s8;
  }, getPrecomputes(n12, r9, o13) {
    let s8 = qt.get(r9);
    return s8 || (s8 = this.precomputeWindow(r9, n12), n12 !== 1 && qt.set(r9, o13(s8))), s8;
  }, wNAFCached(n12, r9, o13) {
    const s8 = $t(n12);
    return this.wNAF(s8, this.getPrecomputes(s8, n12, o13), r9);
  }, wNAFCachedUnsafe(n12, r9, o13, s8) {
    const a5 = $t(n12);
    return a5 === 1 ? this.unsafeLadder(n12, r9, s8) : this.wNAFUnsafe(a5, this.getPrecomputes(a5, n12, o13), r9, s8);
  }, setWindowSize(n12, r9) {
    ve(r9, e10), Ie.set(n12, r9), qt.delete(n12);
  } };
}
function br(t5, e10, n12, r9) {
  if (dr(n12, t5), hr(r9, e10), n12.length !== r9.length) throw new Error("arrays of points and scalars must have equal length");
  const o13 = t5.ZERO, s8 = tr(BigInt(n12.length)), a5 = s8 > 12 ? s8 - 3 : s8 > 4 ? s8 - 2 : s8 ? 2 : 1, u6 = (1 << a5) - 1, i11 = new Array(u6 + 1).fill(o13), D4 = Math.floor((e10.BITS - 1) / a5) * a5;
  let c12 = o13;
  for (let l10 = D4; l10 >= 0; l10 -= a5) {
    i11.fill(o13);
    for (let w6 = 0; w6 < r9.length; w6++) {
      const h12 = r9[w6], g5 = Number(h12 >> BigInt(l10) & BigInt(u6));
      i11[g5] = i11[g5].add(n12[w6]);
    }
    let p8 = o13;
    for (let w6 = i11.length - 1, h12 = o13; w6 > 0; w6--) h12 = h12.add(i11[w6]), p8 = p8.add(h12);
    if (c12 = c12.add(p8), l10 !== 0) for (let w6 = 0; w6 < a5; w6++) c12 = c12.double();
  }
  return c12;
}
function pr(t5) {
  return ar(t5.Fp), Ot(t5, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...me(t5.n, t5.nBitLength), ...t5, p: t5.Fp.ORDER });
}
function gr(t5) {
  const e10 = pr(t5);
  return Ot(t5, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e10 });
}
function yr(t5) {
  const e10 = gr(t5), { Fp: n12, n: r9, prehash: o13, hash: s8, randomBytes: a5, nByteLength: u6, h: i11 } = e10, D4 = yt << BigInt(u6 * 8) - j2, c12 = n12.create, l10 = _e(e10.n, e10.nBitLength), p8 = e10.uvRatio || ((y9, f13) => {
    try {
      return { isValid: true, value: n12.sqrt(y9 * n12.inv(f13)) };
    } catch {
      return { isValid: false, value: G };
    }
  }), w6 = e10.adjustScalarBytes || ((y9) => y9), h12 = e10.domain || ((y9, f13, b7) => {
    if (Tt("phflag", b7), f13.length || b7) throw new Error("Contexts/pre-hash are not supported");
    return y9;
  });
  function g5(y9, f13) {
    ft("coordinate " + y9, f13, G, D4);
  }
  function S7(y9) {
    if (!(y9 instanceof d7)) throw new Error("ExtendedPoint expected");
  }
  const v8 = xe((y9, f13) => {
    const { ex: b7, ey: E8, ez: B5 } = y9, C7 = y9.is0();
    f13 == null && (f13 = C7 ? wr : n12.inv(B5));
    const A6 = c12(b7 * f13), U4 = c12(E8 * f13), _5 = c12(B5 * f13);
    if (C7) return { x: G, y: j2 };
    if (_5 !== j2) throw new Error("invZ was invalid");
    return { x: A6, y: U4 };
  }), L6 = xe((y9) => {
    const { a: f13, d: b7 } = e10;
    if (y9.is0()) throw new Error("bad point: ZERO");
    const { ex: E8, ey: B5, ez: C7, et: A6 } = y9, U4 = c12(E8 * E8), _5 = c12(B5 * B5), T6 = c12(C7 * C7), $6 = c12(T6 * T6), R6 = c12(U4 * f13), V6 = c12(T6 * c12(R6 + _5)), Y5 = c12($6 + c12(b7 * c12(U4 * _5)));
    if (V6 !== Y5) throw new Error("bad point: equation left != right (1)");
    const Z5 = c12(E8 * B5), X5 = c12(C7 * A6);
    if (Z5 !== X5) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class d7 {
    constructor(f13, b7, E8, B5) {
      this.ex = f13, this.ey = b7, this.ez = E8, this.et = B5, g5("x", f13), g5("y", b7), g5("z", E8), g5("t", B5), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f13) {
      if (f13 instanceof d7) throw new Error("extended point not allowed");
      const { x: b7, y: E8 } = f13 || {};
      return g5("x", b7), g5("y", E8), new d7(b7, E8, j2, c12(b7 * E8));
    }
    static normalizeZ(f13) {
      const b7 = n12.invertBatch(f13.map((E8) => E8.ez));
      return f13.map((E8, B5) => E8.toAffine(b7[B5])).map(d7.fromAffine);
    }
    static msm(f13, b7) {
      return br(d7, l10, f13, b7);
    }
    _setWindowSize(f13) {
      q3.setWindowSize(this, f13);
    }
    assertValidity() {
      L6(this);
    }
    equals(f13) {
      S7(f13);
      const { ex: b7, ey: E8, ez: B5 } = this, { ex: C7, ey: A6, ez: U4 } = f13, _5 = c12(b7 * U4), T6 = c12(C7 * B5), $6 = c12(E8 * U4), R6 = c12(A6 * B5);
      return _5 === T6 && $6 === R6;
    }
    is0() {
      return this.equals(d7.ZERO);
    }
    negate() {
      return new d7(c12(-this.ex), this.ey, this.ez, c12(-this.et));
    }
    double() {
      const { a: f13 } = e10, { ex: b7, ey: E8, ez: B5 } = this, C7 = c12(b7 * b7), A6 = c12(E8 * E8), U4 = c12(yt * c12(B5 * B5)), _5 = c12(f13 * C7), T6 = b7 + E8, $6 = c12(c12(T6 * T6) - C7 - A6), R6 = _5 + A6, V6 = R6 - U4, Y5 = _5 - A6, Z5 = c12($6 * V6), X5 = c12(R6 * Y5), et2 = c12($6 * Y5), pt4 = c12(V6 * R6);
      return new d7(Z5, X5, pt4, et2);
    }
    add(f13) {
      S7(f13);
      const { a: b7, d: E8 } = e10, { ex: B5, ey: C7, ez: A6, et: U4 } = this, { ex: _5, ey: T6, ez: $6, et: R6 } = f13;
      if (b7 === BigInt(-1)) {
        const re4 = c12((C7 - B5) * (T6 + _5)), oe3 = c12((C7 + B5) * (T6 - _5)), mt4 = c12(oe3 - re4);
        if (mt4 === G) return this.double();
        const se5 = c12(A6 * yt * R6), ie5 = c12(U4 * yt * $6), ue4 = ie5 + se5, ce4 = oe3 + re4, ae5 = ie5 - se5, Dn3 = c12(ue4 * mt4), dn3 = c12(ce4 * ae5), hn3 = c12(ue4 * ae5), ln3 = c12(mt4 * ce4);
        return new d7(Dn3, dn3, ln3, hn3);
      }
      const V6 = c12(B5 * _5), Y5 = c12(C7 * T6), Z5 = c12(U4 * E8 * R6), X5 = c12(A6 * $6), et2 = c12((B5 + C7) * (_5 + T6) - V6 - Y5), pt4 = X5 - Z5, ee5 = X5 + Z5, ne5 = c12(Y5 - b7 * V6), un3 = c12(et2 * pt4), cn3 = c12(ee5 * ne5), an3 = c12(et2 * ne5), fn3 = c12(pt4 * ee5);
      return new d7(un3, cn3, fn3, an3);
    }
    subtract(f13) {
      return this.add(f13.negate());
    }
    wNAF(f13) {
      return q3.wNAFCached(this, f13, d7.normalizeZ);
    }
    multiply(f13) {
      const b7 = f13;
      ft("scalar", b7, j2, r9);
      const { p: E8, f: B5 } = this.wNAF(b7);
      return d7.normalizeZ([E8, B5])[0];
    }
    multiplyUnsafe(f13, b7 = d7.ZERO) {
      const E8 = f13;
      return ft("scalar", E8, G, r9), E8 === G ? F4 : this.is0() || E8 === j2 ? this : q3.wNAFCachedUnsafe(this, E8, d7.normalizeZ, b7);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i11).is0();
    }
    isTorsionFree() {
      return q3.unsafeLadder(this, r9).is0();
    }
    toAffine(f13) {
      return v8(this, f13);
    }
    clearCofactor() {
      const { h: f13 } = e10;
      return f13 === j2 ? this : this.multiplyUnsafe(f13);
    }
    static fromHex(f13, b7 = false) {
      const { d: E8, a: B5 } = e10, C7 = n12.BYTES;
      f13 = W("pointHex", f13, C7), Tt("zip215", b7);
      const A6 = f13.slice(), U4 = f13[C7 - 1];
      A6[C7 - 1] = U4 & -129;
      const _5 = Et(A6), T6 = b7 ? D4 : n12.ORDER;
      ft("pointHex.y", _5, G, T6);
      const $6 = c12(_5 * _5), R6 = c12($6 - j2), V6 = c12(E8 * $6 - B5);
      let { isValid: Y5, value: Z5 } = p8(R6, V6);
      if (!Y5) throw new Error("Point.fromHex: invalid y coordinate");
      const X5 = (Z5 & j2) === j2, et2 = (U4 & 128) !== 0;
      if (!b7 && Z5 === G && et2) throw new Error("Point.fromHex: x=0 and x_0=1");
      return et2 !== X5 && (Z5 = c12(-Z5)), d7.fromAffine({ x: Z5, y: _5 });
    }
    static fromPrivateKey(f13) {
      return O8(f13).point;
    }
    toRawBytes() {
      const { x: f13, y: b7 } = this.toAffine(), E8 = Nt(b7, n12.BYTES);
      return E8[E8.length - 1] |= f13 & j2 ? 128 : 0, E8;
    }
    toHex() {
      return Ft(this.toRawBytes());
    }
  }
  d7.BASE = new d7(e10.Gx, e10.Gy, j2, c12(e10.Gx * e10.Gy)), d7.ZERO = new d7(G, j2, j2, G);
  const { BASE: m6, ZERO: F4 } = d7, q3 = lr(d7, u6 * 8);
  function z5(y9) {
    return H(y9, r9);
  }
  function I6(y9) {
    return z5(Et(y9));
  }
  function O8(y9) {
    const f13 = n12.BYTES;
    y9 = W("private key", y9, f13);
    const b7 = W("hashed private key", s8(y9), 2 * f13), E8 = w6(b7.slice(0, f13)), B5 = b7.slice(f13, 2 * f13), C7 = I6(E8), A6 = m6.multiply(C7), U4 = A6.toRawBytes();
    return { head: E8, prefix: B5, scalar: C7, point: A6, pointBytes: U4 };
  }
  function ot3(y9) {
    return O8(y9).pointBytes;
  }
  function tt3(y9 = new Uint8Array(), ...f13) {
    const b7 = ye(...f13);
    return I6(s8(h12(b7, W("context", y9), !!o13)));
  }
  function st(y9, f13, b7 = {}) {
    y9 = W("message", y9), o13 && (y9 = o13(y9));
    const { prefix: E8, scalar: B5, pointBytes: C7 } = O8(f13), A6 = tt3(b7.context, E8, y9), U4 = m6.multiply(A6).toRawBytes(), _5 = tt3(b7.context, U4, C7, y9), T6 = z5(A6 + _5 * B5);
    ft("signature.s", T6, G, r9);
    const $6 = ye(U4, Nt(T6, n12.BYTES));
    return W("result", $6, n12.BYTES * 2);
  }
  const at3 = Er;
  function Ct4(y9, f13, b7, E8 = at3) {
    const { context: B5, zip215: C7 } = E8, A6 = n12.BYTES;
    y9 = W("signature", y9, 2 * A6), f13 = W("message", f13), b7 = W("publicKey", b7, A6), C7 !== void 0 && Tt("zip215", C7), o13 && (f13 = o13(f13));
    const U4 = Et(y9.slice(A6, 2 * A6));
    let _5, T6, $6;
    try {
      _5 = d7.fromHex(b7, C7), T6 = d7.fromHex(y9.slice(0, A6), C7), $6 = m6.multiplyUnsafe(U4);
    } catch {
      return false;
    }
    if (!C7 && _5.isSmallOrder()) return false;
    const R6 = tt3(B5, T6.toRawBytes(), _5.toRawBytes(), f13);
    return T6.add(_5.multiplyUnsafe(R6)).subtract($6).clearCofactor().equals(d7.ZERO);
  }
  return m6._setWindowSize(8), { CURVE: e10, getPublicKey: ot3, sign: st, verify: Ct4, ExtendedPoint: d7, utils: { getExtendedPublicKey: O8, randomPrivateKey: () => a5(n12.BYTES), precompute(y9 = 8, f13 = d7.BASE) {
    return f13._setWindowSize(y9), f13.multiply(BigInt(3)), f13;
  } } };
}
function Ar(t5) {
  const e10 = BigInt(10), n12 = BigInt(20), r9 = BigInt(40), o13 = BigInt(80), s8 = kt, u6 = t5 * t5 % s8 * t5 % s8, i11 = J2(u6, Te, s8) * u6 % s8, D4 = J2(i11, xr, s8) * t5 % s8, c12 = J2(D4, Br, s8) * D4 % s8, l10 = J2(c12, e10, s8) * c12 % s8, p8 = J2(l10, n12, s8) * l10 % s8, w6 = J2(p8, r9, s8) * p8 % s8, h12 = J2(w6, o13, s8) * w6 % s8, g5 = J2(h12, o13, s8) * w6 % s8, S7 = J2(g5, e10, s8) * c12 % s8;
  return { pow_p_5_8: J2(S7, Te, s8) * t5 % s8, b2: u6 };
}
function mr(t5) {
  return t5[0] &= 248, t5[31] &= 127, t5[31] |= 64, t5;
}
function _r(t5, e10) {
  const n12 = kt, r9 = H(e10 * e10 * e10, n12), o13 = H(r9 * r9 * e10, n12), s8 = Ar(t5 * o13).pow_p_5_8;
  let a5 = H(t5 * r9 * s8, n12);
  const u6 = H(e10 * a5 * a5, n12), i11 = a5, D4 = H(a5 * Ue, n12), c12 = u6 === t5, l10 = u6 === H(-t5, n12), p8 = u6 === H(-t5 * Ue, n12);
  return c12 && (a5 = i11), (l10 || p8) && (a5 = D4), ur(a5, n12) && (a5 = H(-a5, n12)), { isValid: c12 || l10, value: a5 };
}
function Xt(t5) {
  return globalThis.Buffer != null ? new Uint8Array(t5.buffer, t5.byteOffset, t5.byteLength) : t5;
}
function Le(t5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt(globalThis.Buffer.allocUnsafe(t5)) : new Uint8Array(t5);
}
function Oe(t5, e10) {
  e10 || (e10 = t5.reduce((o13, s8) => o13 + s8.length, 0));
  const n12 = Le(e10);
  let r9 = 0;
  for (const o13 of t5) n12.set(o13, r9), r9 += o13.length;
  return Xt(n12);
}
function Ir(t5, e10) {
  if (t5.length >= 255) throw new TypeError("Alphabet too long");
  for (var n12 = new Uint8Array(256), r9 = 0; r9 < n12.length; r9++) n12[r9] = 255;
  for (var o13 = 0; o13 < t5.length; o13++) {
    var s8 = t5.charAt(o13), a5 = s8.charCodeAt(0);
    if (n12[a5] !== 255) throw new TypeError(s8 + " is ambiguous");
    n12[a5] = o13;
  }
  var u6 = t5.length, i11 = t5.charAt(0), D4 = Math.log(u6) / Math.log(256), c12 = Math.log(256) / Math.log(u6);
  function l10(h12) {
    if (h12 instanceof Uint8Array || (ArrayBuffer.isView(h12) ? h12 = new Uint8Array(h12.buffer, h12.byteOffset, h12.byteLength) : Array.isArray(h12) && (h12 = Uint8Array.from(h12))), !(h12 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (h12.length === 0) return "";
    for (var g5 = 0, S7 = 0, v8 = 0, L6 = h12.length; v8 !== L6 && h12[v8] === 0; ) v8++, g5++;
    for (var d7 = (L6 - v8) * c12 + 1 >>> 0, m6 = new Uint8Array(d7); v8 !== L6; ) {
      for (var F4 = h12[v8], q3 = 0, z5 = d7 - 1; (F4 !== 0 || q3 < S7) && z5 !== -1; z5--, q3++) F4 += 256 * m6[z5] >>> 0, m6[z5] = F4 % u6 >>> 0, F4 = F4 / u6 >>> 0;
      if (F4 !== 0) throw new Error("Non-zero carry");
      S7 = q3, v8++;
    }
    for (var I6 = d7 - S7; I6 !== d7 && m6[I6] === 0; ) I6++;
    for (var O8 = i11.repeat(g5); I6 < d7; ++I6) O8 += t5.charAt(m6[I6]);
    return O8;
  }
  function p8(h12) {
    if (typeof h12 != "string") throw new TypeError("Expected String");
    if (h12.length === 0) return new Uint8Array();
    var g5 = 0;
    if (h12[g5] !== " ") {
      for (var S7 = 0, v8 = 0; h12[g5] === i11; ) S7++, g5++;
      for (var L6 = (h12.length - g5) * D4 + 1 >>> 0, d7 = new Uint8Array(L6); h12[g5]; ) {
        var m6 = n12[h12.charCodeAt(g5)];
        if (m6 === 255) return;
        for (var F4 = 0, q3 = L6 - 1; (m6 !== 0 || F4 < v8) && q3 !== -1; q3--, F4++) m6 += u6 * d7[q3] >>> 0, d7[q3] = m6 % 256 >>> 0, m6 = m6 / 256 >>> 0;
        if (m6 !== 0) throw new Error("Non-zero carry");
        v8 = F4, g5++;
      }
      if (h12[g5] !== " ") {
        for (var z5 = L6 - v8; z5 !== L6 && d7[z5] === 0; ) z5++;
        for (var I6 = new Uint8Array(S7 + (L6 - z5)), O8 = S7; z5 !== L6; ) I6[O8++] = d7[z5++];
        return I6;
      }
    }
  }
  function w6(h12) {
    var g5 = p8(h12);
    if (g5) return g5;
    throw new Error(`Non-${e10} character`);
  }
  return { encode: l10, decodeUnsafe: p8, decode: w6 };
}
function xo(t5) {
  return t5.reduce((e10, n12) => (e10 += go[n12], e10), "");
}
function Bo(t5) {
  const e10 = [];
  for (const n12 of t5) {
    const r9 = yo[n12.codePointAt(0)];
    if (r9 === void 0) throw new Error(`Non-base256emoji character: ${n12}`);
    e10.push(r9);
  }
  return new Uint8Array(e10);
}
function $e(t5, e10, n12) {
  e10 = e10 || [], n12 = n12 || 0;
  for (var r9 = n12; t5 >= vo; ) e10[n12++] = t5 & 255 | qe, t5 /= 128;
  for (; t5 & So; ) e10[n12++] = t5 & 255 | qe, t5 >>>= 7;
  return e10[n12] = t5 | 0, $e.bytes = n12 - r9 + 1, e10;
}
function Pt(t5, r9) {
  var n12 = 0, r9 = r9 || 0, o13 = 0, s8 = r9, a5, u6 = t5.length;
  do {
    if (s8 >= u6) throw Pt.bytes = 0, new RangeError("Could not decode varint");
    a5 = t5[s8++], n12 += o13 < 28 ? (a5 & ke) << o13 : (a5 & ke) * Math.pow(2, o13), o13 += 7;
  } while (a5 >= Uo);
  return Pt.bytes = s8 - r9, n12;
}
function We(t5, e10, n12, r9) {
  return { name: t5, prefix: e10, encoder: { name: t5, prefix: e10, encode: n12 }, decoder: { decode: r9 } };
}
function ct(t5, e10 = "utf8") {
  const n12 = Pe[e10];
  if (!n12) throw new Error(`Unsupported encoding "${e10}"`);
  return (e10 === "utf8" || e10 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t5.buffer, t5.byteOffset, t5.byteLength).toString("utf8") : n12.encoder.encode(t5).substring(1);
}
function rt(t5, e10 = "utf8") {
  const n12 = Pe[e10];
  if (!n12) throw new Error(`Unsupported encoding "${e10}"`);
  return (e10 === "utf8" || e10 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt(globalThis.Buffer.from(t5, "utf-8")) : n12.decoder.decode(`${n12.prefix}${t5}`);
}
function lt(t5) {
  return safeJsonParse(ct(rt(t5, Dt), Gt));
}
function bt(t5) {
  return ct(rt(safeJsonStringify(t5), Gt), Dt);
}
function Qe(t5) {
  const e10 = rt(Wt, dt), n12 = Kt + ct(Oe([e10, t5]), dt);
  return [Yt, Jt, n12].join(Vt);
}
function en(t5) {
  return ct(t5, Dt);
}
function nn(t5) {
  return rt(t5, Dt);
}
function rn(t5) {
  return rt([bt(t5.header), bt(t5.payload)].join(ut), xt);
}
function on(t5) {
  return [bt(t5.header), bt(t5.payload), en(t5.signature)].join(ut);
}
function sn(t5) {
  const e10 = t5.split(ut), n12 = lt(e10[0]), r9 = lt(e10[1]), o13 = nn(e10[2]), s8 = rt(e10.slice(0, 2).join(ut), xt);
  return { header: n12, payload: r9, signature: o13, data: s8 };
}
function Po(t5 = he(Ne)) {
  const e10 = Rt.getPublicKey(t5);
  return { secretKey: Oe([t5, e10]), publicKey: e10 };
}
async function Qo(t5, e10, n12, r9, o13 = (0, import_time2.fromMiliseconds)(Date.now())) {
  const s8 = { alg: jt, typ: Zt }, a5 = Qe(r9.publicKey), u6 = o13 + n12, i11 = { iss: a5, sub: t5, aud: e10, iat: o13, exp: u6 }, D4 = rn({ header: s8, payload: i11 }), c12 = Rt.sign(D4, r9.secretKey.slice(0, 32));
  return on({ header: s8, payload: i11, signature: c12 });
}
var import_time2, it, _t, xn, An, wt, St, _n, Sn, vn, In, Un, Tn, Fn, Nn, Ln, On, Hn, zn, Mn, $n, kn, Rn, jn, Zn, Gn, x3, Vn, Yn, P2, Q, Jn, Kn, vt, be, Wn, Xn, K2, Lt, er, nr, M2, N2, nt, rr, Ht, Be, Ce, ur, cr, Se, gt, qt, Ie, G, j2, yt, wr, Er, kt, Ue, xr, Te, Br, Cr, Sr, vr, Rt, jt, Zt, ut, Dt, Gt, xt, Vt, Yt, Jt, dt, Kt, Wt, Ne, Ur, Tr, He, Fr, Nr, Lr, Or, Hr, ze, zr, Bt, ht, Mr, qr, k4, $r, kr, Rr, jr, Zr, Gr, Vr, Yr, Jr, Kr2, Wr, Xr, Pr, Qr, to, eo, no, ro, oo, so, io, uo, co, ao, fo, Do, ho, lo, bo, po, wo, Eo, Me, go, yo, Co, Ao, mo, qe, _o, So, vo, Io, Uo, ke, To, Fo, No, Lo, Oo, Ho, zo, Mo, qo, $o, ko, Re, je, Ze, Qt, Ro, Ge, jo, Ve, Zo, Go, Vo, Ye, Yo, Je, Jo, Ko, Wo, Ke, Xe, te, Pe;
var init_index_es5 = __esm({
  "node_modules/@walletconnect/relay-auth/dist/index.es.js"() {
    import_time2 = __toESM(require_cjs());
    init_esm3();
    it = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    _t = (t5) => new DataView(t5.buffer, t5.byteOffset, t5.byteLength);
    xn = class {
      clone() {
        return this._cloneInto();
      }
    };
    An = class extends xn {
      constructor(e10, n12, r9, o13) {
        super(), this.blockLen = e10, this.outputLen = n12, this.padOffset = r9, this.isLE = o13, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e10), this.view = _t(this.buffer);
      }
      update(e10) {
        De(this);
        const { view: n12, buffer: r9, blockLen: o13 } = this;
        e10 = de(e10);
        const s8 = e10.length;
        for (let a5 = 0; a5 < s8; ) {
          const u6 = Math.min(o13 - this.pos, s8 - a5);
          if (u6 === o13) {
            const i11 = _t(e10);
            for (; o13 <= s8 - a5; a5 += o13) this.process(i11, a5);
            continue;
          }
          r9.set(e10.subarray(a5, a5 + u6), this.pos), this.pos += u6, a5 += u6, this.pos === o13 && (this.process(n12, 0), this.pos = 0);
        }
        return this.length += e10.length, this.roundClean(), this;
      }
      digestInto(e10) {
        De(this), gn(e10, this), this.finished = true;
        const { buffer: n12, view: r9, blockLen: o13, isLE: s8 } = this;
        let { pos: a5 } = this;
        n12[a5++] = 128, this.buffer.subarray(a5).fill(0), this.padOffset > o13 - a5 && (this.process(r9, 0), a5 = 0);
        for (let l10 = a5; l10 < o13; l10++) n12[l10] = 0;
        Cn(r9, o13 - 8, BigInt(this.length * 8), s8), this.process(r9, 0);
        const u6 = _t(e10), i11 = this.outputLen;
        if (i11 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const D4 = i11 / 4, c12 = this.get();
        if (D4 > c12.length) throw new Error("_sha2: outputLen bigger than state");
        for (let l10 = 0; l10 < D4; l10++) u6.setUint32(4 * l10, c12[l10], s8);
      }
      digest() {
        const { buffer: e10, outputLen: n12 } = this;
        this.digestInto(e10);
        const r9 = e10.slice(0, n12);
        return this.destroy(), r9;
      }
      _cloneInto(e10) {
        e10 || (e10 = new this.constructor()), e10.set(...this.get());
        const { blockLen: n12, buffer: r9, length: o13, finished: s8, destroyed: a5, pos: u6 } = this;
        return e10.length = o13, e10.pos = u6, e10.finished = s8, e10.destroyed = a5, o13 % n12 && e10.buffer.set(r9), e10;
      }
    };
    wt = BigInt(2 ** 32 - 1);
    St = BigInt(32);
    _n = (t5, e10) => BigInt(t5 >>> 0) << St | BigInt(e10 >>> 0);
    Sn = (t5, e10, n12) => t5 >>> n12;
    vn = (t5, e10, n12) => t5 << 32 - n12 | e10 >>> n12;
    In = (t5, e10, n12) => t5 >>> n12 | e10 << 32 - n12;
    Un = (t5, e10, n12) => t5 << 32 - n12 | e10 >>> n12;
    Tn = (t5, e10, n12) => t5 << 64 - n12 | e10 >>> n12 - 32;
    Fn = (t5, e10, n12) => t5 >>> n12 - 32 | e10 << 64 - n12;
    Nn = (t5, e10) => e10;
    Ln = (t5, e10) => t5;
    On = (t5, e10, n12) => t5 << n12 | e10 >>> 32 - n12;
    Hn = (t5, e10, n12) => e10 << n12 | t5 >>> 32 - n12;
    zn = (t5, e10, n12) => e10 << n12 - 32 | t5 >>> 64 - n12;
    Mn = (t5, e10, n12) => t5 << n12 - 32 | e10 >>> 64 - n12;
    $n = (t5, e10, n12) => (t5 >>> 0) + (e10 >>> 0) + (n12 >>> 0);
    kn = (t5, e10, n12, r9) => e10 + n12 + r9 + (t5 / 2 ** 32 | 0) | 0;
    Rn = (t5, e10, n12, r9) => (t5 >>> 0) + (e10 >>> 0) + (n12 >>> 0) + (r9 >>> 0);
    jn = (t5, e10, n12, r9, o13) => e10 + n12 + r9 + o13 + (t5 / 2 ** 32 | 0) | 0;
    Zn = (t5, e10, n12, r9, o13) => (t5 >>> 0) + (e10 >>> 0) + (n12 >>> 0) + (r9 >>> 0) + (o13 >>> 0);
    Gn = (t5, e10, n12, r9, o13, s8) => e10 + n12 + r9 + o13 + s8 + (t5 / 2 ** 32 | 0) | 0;
    x3 = { fromBig: le, split: mn, toBig: _n, shrSH: Sn, shrSL: vn, rotrSH: In, rotrSL: Un, rotrBH: Tn, rotrBL: Fn, rotr32H: Nn, rotr32L: Ln, rotlSH: On, rotlSL: Hn, rotlBH: zn, rotlBL: Mn, add: qn, add3L: $n, add3H: kn, add4L: Rn, add4H: jn, add5H: Gn, add5L: Zn };
    [Vn, Yn] = (() => x3.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t5) => BigInt(t5))))();
    P2 = new Uint32Array(80);
    Q = new Uint32Array(80);
    Jn = class extends An {
      constructor() {
        super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
      }
      get() {
        const { Ah: e10, Al: n12, Bh: r9, Bl: o13, Ch: s8, Cl: a5, Dh: u6, Dl: i11, Eh: D4, El: c12, Fh: l10, Fl: p8, Gh: w6, Gl: h12, Hh: g5, Hl: S7 } = this;
        return [e10, n12, r9, o13, s8, a5, u6, i11, D4, c12, l10, p8, w6, h12, g5, S7];
      }
      set(e10, n12, r9, o13, s8, a5, u6, i11, D4, c12, l10, p8, w6, h12, g5, S7) {
        this.Ah = e10 | 0, this.Al = n12 | 0, this.Bh = r9 | 0, this.Bl = o13 | 0, this.Ch = s8 | 0, this.Cl = a5 | 0, this.Dh = u6 | 0, this.Dl = i11 | 0, this.Eh = D4 | 0, this.El = c12 | 0, this.Fh = l10 | 0, this.Fl = p8 | 0, this.Gh = w6 | 0, this.Gl = h12 | 0, this.Hh = g5 | 0, this.Hl = S7 | 0;
      }
      process(e10, n12) {
        for (let d7 = 0; d7 < 16; d7++, n12 += 4) P2[d7] = e10.getUint32(n12), Q[d7] = e10.getUint32(n12 += 4);
        for (let d7 = 16; d7 < 80; d7++) {
          const m6 = P2[d7 - 15] | 0, F4 = Q[d7 - 15] | 0, q3 = x3.rotrSH(m6, F4, 1) ^ x3.rotrSH(m6, F4, 8) ^ x3.shrSH(m6, F4, 7), z5 = x3.rotrSL(m6, F4, 1) ^ x3.rotrSL(m6, F4, 8) ^ x3.shrSL(m6, F4, 7), I6 = P2[d7 - 2] | 0, O8 = Q[d7 - 2] | 0, ot3 = x3.rotrSH(I6, O8, 19) ^ x3.rotrBH(I6, O8, 61) ^ x3.shrSH(I6, O8, 6), tt3 = x3.rotrSL(I6, O8, 19) ^ x3.rotrBL(I6, O8, 61) ^ x3.shrSL(I6, O8, 6), st = x3.add4L(z5, tt3, Q[d7 - 7], Q[d7 - 16]), at3 = x3.add4H(st, q3, ot3, P2[d7 - 7], P2[d7 - 16]);
          P2[d7] = at3 | 0, Q[d7] = st | 0;
        }
        let { Ah: r9, Al: o13, Bh: s8, Bl: a5, Ch: u6, Cl: i11, Dh: D4, Dl: c12, Eh: l10, El: p8, Fh: w6, Fl: h12, Gh: g5, Gl: S7, Hh: v8, Hl: L6 } = this;
        for (let d7 = 0; d7 < 80; d7++) {
          const m6 = x3.rotrSH(l10, p8, 14) ^ x3.rotrSH(l10, p8, 18) ^ x3.rotrBH(l10, p8, 41), F4 = x3.rotrSL(l10, p8, 14) ^ x3.rotrSL(l10, p8, 18) ^ x3.rotrBL(l10, p8, 41), q3 = l10 & w6 ^ ~l10 & g5, z5 = p8 & h12 ^ ~p8 & S7, I6 = x3.add5L(L6, F4, z5, Yn[d7], Q[d7]), O8 = x3.add5H(I6, v8, m6, q3, Vn[d7], P2[d7]), ot3 = I6 | 0, tt3 = x3.rotrSH(r9, o13, 28) ^ x3.rotrBH(r9, o13, 34) ^ x3.rotrBH(r9, o13, 39), st = x3.rotrSL(r9, o13, 28) ^ x3.rotrBL(r9, o13, 34) ^ x3.rotrBL(r9, o13, 39), at3 = r9 & s8 ^ r9 & u6 ^ s8 & u6, Ct4 = o13 & a5 ^ o13 & i11 ^ a5 & i11;
          v8 = g5 | 0, L6 = S7 | 0, g5 = w6 | 0, S7 = h12 | 0, w6 = l10 | 0, h12 = p8 | 0, { h: l10, l: p8 } = x3.add(D4 | 0, c12 | 0, O8 | 0, ot3 | 0), D4 = u6 | 0, c12 = i11 | 0, u6 = s8 | 0, i11 = a5 | 0, s8 = r9 | 0, a5 = o13 | 0;
          const At4 = x3.add3L(ot3, st, Ct4);
          r9 = x3.add3H(At4, O8, tt3, at3), o13 = At4 | 0;
        }
        ({ h: r9, l: o13 } = x3.add(this.Ah | 0, this.Al | 0, r9 | 0, o13 | 0)), { h: s8, l: a5 } = x3.add(this.Bh | 0, this.Bl | 0, s8 | 0, a5 | 0), { h: u6, l: i11 } = x3.add(this.Ch | 0, this.Cl | 0, u6 | 0, i11 | 0), { h: D4, l: c12 } = x3.add(this.Dh | 0, this.Dl | 0, D4 | 0, c12 | 0), { h: l10, l: p8 } = x3.add(this.Eh | 0, this.El | 0, l10 | 0, p8 | 0), { h: w6, l: h12 } = x3.add(this.Fh | 0, this.Fl | 0, w6 | 0, h12 | 0), { h: g5, l: S7 } = x3.add(this.Gh | 0, this.Gl | 0, g5 | 0, S7 | 0), { h: v8, l: L6 } = x3.add(this.Hh | 0, this.Hl | 0, v8 | 0, L6 | 0), this.set(r9, o13, s8, a5, u6, i11, D4, c12, l10, p8, w6, h12, g5, S7, v8, L6);
      }
      roundClean() {
        P2.fill(0), Q.fill(0);
      }
      destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    Kn = Bn(() => new Jn());
    vt = BigInt(0);
    be = BigInt(1);
    Wn = BigInt(2);
    Xn = Array.from({ length: 256 }, (t5, e10) => e10.toString(16).padStart(2, "0"));
    K2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    Lt = (t5) => typeof t5 == "bigint" && vt <= t5;
    er = (t5) => (Wn << BigInt(t5 - 1)) - be;
    nr = { bigint: (t5) => typeof t5 == "bigint", function: (t5) => typeof t5 == "function", boolean: (t5) => typeof t5 == "boolean", string: (t5) => typeof t5 == "string", stringOrUint8Array: (t5) => typeof t5 == "string" || It(t5), isSafeInteger: (t5) => Number.isSafeInteger(t5), array: (t5) => Array.isArray(t5), field: (t5, e10) => e10.Fp.isValid(t5), hash: (t5) => typeof t5 == "function" && Number.isSafeInteger(t5.outputLen) };
    M2 = BigInt(0);
    N2 = BigInt(1);
    nt = BigInt(2);
    rr = BigInt(3);
    Ht = BigInt(4);
    Be = BigInt(5);
    Ce = BigInt(8);
    ur = (t5, e10) => (H(t5, e10) & N2) === N2;
    cr = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
    Se = BigInt(0);
    gt = BigInt(1);
    qt = /* @__PURE__ */ new WeakMap();
    Ie = /* @__PURE__ */ new WeakMap();
    G = BigInt(0);
    j2 = BigInt(1);
    yt = BigInt(2);
    wr = BigInt(8);
    Er = { zip215: true };
    BigInt(0), BigInt(1);
    kt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
    Ue = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    BigInt(0);
    xr = BigInt(1);
    Te = BigInt(2);
    BigInt(3);
    Br = BigInt(5);
    Cr = BigInt(8);
    Sr = (() => _e(kt, void 0, true))();
    vr = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: Sr, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: Cr, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Kn, randomBytes: he, adjustScalarBytes: mr, uvRatio: _r }))();
    Rt = (() => yr(vr))();
    jt = "EdDSA";
    Zt = "JWT";
    ut = ".";
    Dt = "base64url";
    Gt = "utf8";
    xt = "utf8";
    Vt = ":";
    Yt = "did";
    Jt = "key";
    dt = "base58btc";
    Kt = "z";
    Wt = "K36";
    Ne = 32;
    Ur = Ir;
    Tr = Ur;
    He = (t5) => {
      if (t5 instanceof Uint8Array && t5.constructor.name === "Uint8Array") return t5;
      if (t5 instanceof ArrayBuffer) return new Uint8Array(t5);
      if (ArrayBuffer.isView(t5)) return new Uint8Array(t5.buffer, t5.byteOffset, t5.byteLength);
      throw new Error("Unknown type, must be binary type");
    };
    Fr = (t5) => new TextEncoder().encode(t5);
    Nr = (t5) => new TextDecoder().decode(t5);
    Lr = class {
      constructor(e10, n12, r9) {
        this.name = e10, this.prefix = n12, this.baseEncode = r9;
      }
      encode(e10) {
        if (e10 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e10)}`;
        throw Error("Unknown type, must be binary type");
      }
    };
    Or = class {
      constructor(e10, n12, r9) {
        if (this.name = e10, this.prefix = n12, n12.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = n12.codePointAt(0), this.baseDecode = r9;
      }
      decode(e10) {
        if (typeof e10 == "string") {
          if (e10.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e10)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(e10.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e10) {
        return ze(this, e10);
      }
    };
    Hr = class {
      constructor(e10) {
        this.decoders = e10;
      }
      or(e10) {
        return ze(this, e10);
      }
      decode(e10) {
        const n12 = e10[0], r9 = this.decoders[n12];
        if (r9) return r9.decode(e10);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    };
    ze = (t5, e10) => new Hr({ ...t5.decoders || { [t5.prefix]: t5 }, ...e10.decoders || { [e10.prefix]: e10 } });
    zr = class {
      constructor(e10, n12, r9, o13) {
        this.name = e10, this.prefix = n12, this.baseEncode = r9, this.baseDecode = o13, this.encoder = new Lr(e10, n12, r9), this.decoder = new Or(e10, n12, o13);
      }
      encode(e10) {
        return this.encoder.encode(e10);
      }
      decode(e10) {
        return this.decoder.decode(e10);
      }
    };
    Bt = ({ name: t5, prefix: e10, encode: n12, decode: r9 }) => new zr(t5, e10, n12, r9);
    ht = ({ prefix: t5, name: e10, alphabet: n12 }) => {
      const { encode: r9, decode: o13 } = Tr(n12, e10);
      return Bt({ prefix: t5, name: e10, encode: r9, decode: (s8) => He(o13(s8)) });
    };
    Mr = (t5, e10, n12, r9) => {
      const o13 = {};
      for (let c12 = 0; c12 < e10.length; ++c12) o13[e10[c12]] = c12;
      let s8 = t5.length;
      for (; t5[s8 - 1] === "="; ) --s8;
      const a5 = new Uint8Array(s8 * n12 / 8 | 0);
      let u6 = 0, i11 = 0, D4 = 0;
      for (let c12 = 0; c12 < s8; ++c12) {
        const l10 = o13[t5[c12]];
        if (l10 === void 0) throw new SyntaxError(`Non-${r9} character`);
        i11 = i11 << n12 | l10, u6 += n12, u6 >= 8 && (u6 -= 8, a5[D4++] = 255 & i11 >> u6);
      }
      if (u6 >= n12 || 255 & i11 << 8 - u6) throw new SyntaxError("Unexpected end of data");
      return a5;
    };
    qr = (t5, e10, n12) => {
      const r9 = e10[e10.length - 1] === "=", o13 = (1 << n12) - 1;
      let s8 = "", a5 = 0, u6 = 0;
      for (let i11 = 0; i11 < t5.length; ++i11) for (u6 = u6 << 8 | t5[i11], a5 += 8; a5 > n12; ) a5 -= n12, s8 += e10[o13 & u6 >> a5];
      if (a5 && (s8 += e10[o13 & u6 << n12 - a5]), r9) for (; s8.length * n12 & 7; ) s8 += "=";
      return s8;
    };
    k4 = ({ name: t5, prefix: e10, bitsPerChar: n12, alphabet: r9 }) => Bt({ prefix: e10, name: t5, encode(o13) {
      return qr(o13, r9, n12);
    }, decode(o13) {
      return Mr(o13, r9, n12, t5);
    } });
    $r = Bt({ prefix: "\0", name: "identity", encode: (t5) => Nr(t5), decode: (t5) => Fr(t5) });
    kr = Object.freeze({ __proto__: null, identity: $r });
    Rr = k4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
    jr = Object.freeze({ __proto__: null, base2: Rr });
    Zr = k4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
    Gr = Object.freeze({ __proto__: null, base8: Zr });
    Vr = ht({ prefix: "9", name: "base10", alphabet: "0123456789" });
    Yr = Object.freeze({ __proto__: null, base10: Vr });
    Jr = k4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
    Kr2 = k4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
    Wr = Object.freeze({ __proto__: null, base16: Jr, base16upper: Kr2 });
    Xr = k4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
    Pr = k4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
    Qr = k4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
    to = k4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
    eo = k4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
    no = k4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
    ro = k4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
    oo = k4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
    so = k4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
    io = Object.freeze({ __proto__: null, base32: Xr, base32upper: Pr, base32pad: Qr, base32padupper: to, base32hex: eo, base32hexupper: no, base32hexpad: ro, base32hexpadupper: oo, base32z: so });
    uo = ht({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
    co = ht({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
    ao = Object.freeze({ __proto__: null, base36: uo, base36upper: co });
    fo = ht({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
    Do = ht({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
    ho = Object.freeze({ __proto__: null, base58btc: fo, base58flickr: Do });
    lo = k4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
    bo = k4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
    po = k4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
    wo = k4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
    Eo = Object.freeze({ __proto__: null, base64: lo, base64pad: bo, base64url: po, base64urlpad: wo });
    Me = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    go = Me.reduce((t5, e10, n12) => (t5[n12] = e10, t5), []);
    yo = Me.reduce((t5, e10, n12) => (t5[e10.codePointAt(0)] = n12, t5), []);
    Co = Bt({ prefix: "\u{1F680}", name: "base256emoji", encode: xo, decode: Bo });
    Ao = Object.freeze({ __proto__: null, base256emoji: Co });
    mo = $e;
    qe = 128;
    _o = 127;
    So = ~_o;
    vo = Math.pow(2, 31);
    Io = Pt;
    Uo = 128;
    ke = 127;
    To = Math.pow(2, 7);
    Fo = Math.pow(2, 14);
    No = Math.pow(2, 21);
    Lo = Math.pow(2, 28);
    Oo = Math.pow(2, 35);
    Ho = Math.pow(2, 42);
    zo = Math.pow(2, 49);
    Mo = Math.pow(2, 56);
    qo = Math.pow(2, 63);
    $o = function(t5) {
      return t5 < To ? 1 : t5 < Fo ? 2 : t5 < No ? 3 : t5 < Lo ? 4 : t5 < Oo ? 5 : t5 < Ho ? 6 : t5 < zo ? 7 : t5 < Mo ? 8 : t5 < qo ? 9 : 10;
    };
    ko = { encode: mo, decode: Io, encodingLength: $o };
    Re = ko;
    je = (t5, e10, n12 = 0) => (Re.encode(t5, e10, n12), e10);
    Ze = (t5) => Re.encodingLength(t5);
    Qt = (t5, e10) => {
      const n12 = e10.byteLength, r9 = Ze(t5), o13 = r9 + Ze(n12), s8 = new Uint8Array(o13 + n12);
      return je(t5, s8, 0), je(n12, s8, r9), s8.set(e10, o13), new Ro(t5, n12, e10, s8);
    };
    Ro = class {
      constructor(e10, n12, r9, o13) {
        this.code = e10, this.size = n12, this.digest = r9, this.bytes = o13;
      }
    };
    Ge = ({ name: t5, code: e10, encode: n12 }) => new jo(t5, e10, n12);
    jo = class {
      constructor(e10, n12, r9) {
        this.name = e10, this.code = n12, this.encode = r9;
      }
      digest(e10) {
        if (e10 instanceof Uint8Array) {
          const n12 = this.encode(e10);
          return n12 instanceof Uint8Array ? Qt(this.code, n12) : n12.then((r9) => Qt(this.code, r9));
        } else throw Error("Unknown type, must be binary type");
      }
    };
    Ve = (t5) => async (e10) => new Uint8Array(await crypto.subtle.digest(t5, e10));
    Zo = Ge({ name: "sha2-256", code: 18, encode: Ve("SHA-256") });
    Go = Ge({ name: "sha2-512", code: 19, encode: Ve("SHA-512") });
    Vo = Object.freeze({ __proto__: null, sha256: Zo, sha512: Go });
    Ye = 0;
    Yo = "identity";
    Je = He;
    Jo = (t5) => Qt(Ye, Je(t5));
    Ko = { code: Ye, name: Yo, encode: Je, digest: Jo };
    Wo = Object.freeze({ __proto__: null, identity: Ko });
    new TextEncoder(), new TextDecoder();
    Ke = { ...kr, ...jr, ...Gr, ...Yr, ...Wr, ...io, ...ao, ...ho, ...Eo, ...Ao };
    ({ ...Vo, ...Wo });
    Xe = We("utf8", "u", (t5) => "u" + new TextDecoder("utf8").decode(t5), (t5) => new TextEncoder().encode(t5.substring(1)));
    te = We("ascii", "a", (t5) => {
      let e10 = "a";
      for (let n12 = 0; n12 < t5.length; n12++) e10 += String.fromCharCode(t5[n12]);
      return e10;
    }, (t5) => {
      t5 = t5.substring(1);
      const e10 = Le(t5.length);
      for (let n12 = 0; n12 < t5.length; n12++) e10[n12] = t5.charCodeAt(n12);
      return e10;
    });
    Pe = { utf8: Xe, "utf-8": Xe, hex: Ke.base16, latin1: te, ascii: te, binary: te, ...Ke };
  }
});

// node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser = _a2[0], regex2 = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua2);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version4 = versionParts.join(".");
  var os3 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version4, os3, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version4, os3);
}
function detectOS(ua2) {
  for (var ii4 = 0, count = operatingSystemRules.length; ii4 < count; ii4++) {
    var _a2 = operatingSystemRules[ii4], os3 = _a2[0], regex2 = _a2[1];
    var match = regex2.exec(ua2);
    if (match) {
      return os3;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii4 = 0; ii4 < count; ii4++) {
    output2.push("0");
  }
  return output2;
}
var __spreadArray, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/detect-browser/es/index.js"() {
    __spreadArray = function(to4, from3, pack) {
      if (pack || arguments.length === 2) for (var i11 = 0, l10 = from3.length, ar3; i11 < l10; i11++) {
        if (ar3 || !(i11 in from3)) {
          if (!ar3) ar3 = Array.prototype.slice.call(from3, 0, i11);
          ar3[i11] = from3[i11];
        }
      }
      return to4.concat(ar3 || Array.prototype.slice.call(from3));
    };
    BrowserInfo = /** @class */
    /* @__PURE__ */ function() {
      function BrowserInfo2(name2, version4, os3) {
        this.name = name2;
        this.version = version4;
        this.os = os3;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = /** @class */
    /* @__PURE__ */ function() {
      function NodeInfo2(version4) {
        this.version = version4;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = /** @class */
    /* @__PURE__ */ function() {
      function SearchBotDeviceInfo2(name2, version4, os3, bot) {
        this.name = name2;
        this.version = version4;
        this.os = os3;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = /** @class */
    /* @__PURE__ */ function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = /** @class */
    /* @__PURE__ */ function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
      ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
      ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FB[AS]V\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["curl", /^curl\/([0-9\.]+)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name2) {
      const res = getFromWindow(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e10) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i11 = 0; i11 < links.length; i11++) {
          const link = links[i11];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i11 = 0; i11 < metaTags.length; i11++) {
          const tag = metaTags[i11];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js"() {
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js"() {
    init_isHex();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js
var version;
var init_version = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js"() {
    version = "2.31.0";
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js
function walk(err2, fn3) {
  if (fn3?.(err2))
    return err2;
  if (err2 && typeof err2 === "object" && "cause" in err2 && err2.cause !== void 0)
    return walk(err2.cause, fn3);
  return fn3 ? null : err2;
}
var errorConfig, BaseError;
var init_base = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js"() {
    init_version();
    errorConfig = {
      getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
      version: `viem@${version}`
    };
    BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        const details = (() => {
          if (args.cause instanceof _BaseError)
            return args.cause.details;
          if (args.cause?.message)
            return args.cause.message;
          return args.details;
        })();
        const docsPath = (() => {
          if (args.cause instanceof _BaseError)
            return args.cause.docsPath || args.docsPath;
          return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsUrl ? [`Docs: ${docsUrl}`] : [],
          ...details ? [`Details: ${details}`] : [],
          ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
        ].join("\n");
        super(message, args.cause ? { cause: args.cause } : void 0);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseError"
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version;
      }
      walk(fn3) {
        return walk(this, fn3);
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js
var SizeExceedsPaddingSizeError;
var init_data = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js"() {
    init_base();
    SizeExceedsPaddingSizeError = class extends BaseError {
      constructor({ size: size4, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size4}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size4 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size4 });
  return padBytes(hexOrBytes, { dir, size: size4 });
}
function padHex(hex_, { dir, size: size4 = 32 } = {}) {
  if (size4 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}
function padBytes(bytes2, { dir, size: size4 = 32 } = {}) {
  if (size4 === null)
    return bytes2;
  if (bytes2.length > size4)
    throw new SizeExceedsPaddingSizeError({
      size: bytes2.length,
      targetSize: size4,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size4);
  for (let i11 = 0; i11 < size4; i11++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i11 : size4 - i11 - 1] = bytes2[padEnd ? i11 : bytes2.length - i11 - 1];
  }
  return paddedBytes;
}
var init_pad = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js"() {
    init_data();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, SizeOverflowError;
var init_encoding = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js"() {
    init_base();
    IntegerOutOfRangeError = class extends BaseError {
      constructor({ max, min, signed, size: size4, value }) {
        super(`Number "${value}" is not in safe ${size4 ? `${size4 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
      }
    };
    SizeOverflowError = class extends BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size4 }) {
  if (size(hexOrBytes) > size4)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size4
    });
}
function hexToBigInt2(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size4 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size4) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size4 * 2, "f")}`) - 1n;
}
function hexToNumber2(hex, opts = {}) {
  return Number(hexToBigInt2(hex, opts));
}
var init_fromHex = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js"() {
    init_encoding();
    init_size();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex4(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex4(value, opts = {}) {
  let string2 = "";
  for (let i11 = 0; i11 < value.length; i11++) {
    string2 += hexes5[value[i11]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size4 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size4)
    return pad(hex, { size: size4 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex4(value, opts);
}
var hexes5, encoder;
var init_toHex = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js"() {
    init_encoding();
    init_pad();
    init_fromHex();
    hexes5 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i11) => i11.toString(16).padStart(2, "0"));
    encoder = /* @__PURE__ */ new TextEncoder();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes4(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { size: opts.size });
  }
  return bytes2;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes4(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length2 = hexString.length / 2;
  const bytes2 = new Uint8Array(length2);
  for (let index2 = 0, j7 = 0; index2 < length2; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j7++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j7++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j7 - 2]}${hexString[j7 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes4(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes2 = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return pad(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}
var encoder2, charCodeMap;
var init_toBytes = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js"() {
    init_base();
    init_isHex();
    init_pad();
    init_fromHex();
    init_toHex();
    encoder2 = /* @__PURE__ */ new TextEncoder();
    charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_u64.js
function fromBig2(n12, le5 = false) {
  if (le5)
    return { h: Number(n12 & U32_MASK642), l: Number(n12 >> _32n2 & U32_MASK642) };
  return { h: Number(n12 >> _32n2 & U32_MASK642) | 0, l: Number(n12 & U32_MASK642) | 0 };
}
function split2(lst, le5 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i11 = 0; i11 < len; i11++) {
    const { h: h12, l: l10 } = fromBig2(lst[i11], le5);
    [Ah[i11], Al[i11]] = [h12, l10];
  }
  return [Ah, Al];
}
var U32_MASK642, _32n2, rotlSH2, rotlSL2, rotlBH2, rotlBL2;
var init_u64 = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n2 = /* @__PURE__ */ BigInt(32);
    rotlSH2 = (h12, l10, s8) => h12 << s8 | l10 >>> 32 - s8;
    rotlSL2 = (h12, l10, s8) => l10 << s8 | h12 >>> 32 - s8;
    rotlBH2 = (h12, l10, s8) => l10 << s8 - 32 | h12 >>> 64 - s8;
    rotlBL2 = (h12, l10, s8) => h12 << s8 - 32 | l10 >>> 64 - s8;
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/crypto.js
var crypto4;
var init_crypto = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/crypto.js"() {
    crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/utils.js
function isBytes2(a5) {
  return a5 instanceof Uint8Array || ArrayBuffer.isView(a5) && a5.constructor.name === "Uint8Array";
}
function anumber2(n12) {
  if (!Number.isSafeInteger(n12) || n12 < 0)
    throw new Error("positive integer expected, got " + n12);
}
function abytes2(b7, ...lengths) {
  if (!isBytes2(b7))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b7.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b7.length);
}
function ahash(h12) {
  if (typeof h12 !== "function" || typeof h12.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber2(h12.outputLen);
  anumber2(h12.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i11 = 0; i11 < arrays.length; i11++) {
    arrays[i11].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i11 = 0; i11 < arr.length; i11++) {
    arr[i11] = byteSwap(arr[i11]);
  }
  return arr;
}
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  abytes2(data);
  return data;
}
function concatBytes4(...arrays) {
  let sum = 0;
  for (let i11 = 0; i11 < arrays.length; i11++) {
    const a5 = arrays[i11];
    abytes2(a5);
    sum += a5.length;
  }
  const res = new Uint8Array(sum);
  for (let i11 = 0, pad3 = 0; i11 < arrays.length; i11++) {
    const a5 = arrays[i11];
    res.set(a5, pad3);
    pad3 += a5.length;
  }
  return res;
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto4 && typeof crypto4.getRandomValues === "function") {
    return crypto4.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto4 && typeof crypto4.randomBytes === "function") {
    return Uint8Array.from(crypto4.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var isLE2, swap32IfBE, Hash2;
var init_utils = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto();
    isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    swap32IfBE = isLE2 ? (u6) => u6 : byteSwap32;
    Hash2 = class {
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha3.js
function keccakP(s8, rounds = 24) {
  const B5 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x7 = 0; x7 < 10; x7++)
      B5[x7] = s8[x7] ^ s8[x7 + 10] ^ s8[x7 + 20] ^ s8[x7 + 30] ^ s8[x7 + 40];
    for (let x7 = 0; x7 < 10; x7 += 2) {
      const idx1 = (x7 + 8) % 10;
      const idx0 = (x7 + 2) % 10;
      const B0 = B5[idx0];
      const B1 = B5[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B5[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B5[idx1 + 1];
      for (let y9 = 0; y9 < 50; y9 += 10) {
        s8[x7 + y9] ^= Th;
        s8[x7 + y9 + 1] ^= Tl;
      }
    }
    let curH = s8[2];
    let curL = s8[3];
    for (let t5 = 0; t5 < 24; t5++) {
      const shift = SHA3_ROTL[t5];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t5];
      curH = s8[PI];
      curL = s8[PI + 1];
      s8[PI] = Th;
      s8[PI + 1] = Tl;
    }
    for (let y9 = 0; y9 < 50; y9 += 10) {
      for (let x7 = 0; x7 < 10; x7++)
        B5[x7] = s8[y9 + x7];
      for (let x7 = 0; x7 < 10; x7++)
        s8[y9 + x7] ^= ~B5[(x7 + 2) % 10] & B5[(x7 + 4) % 10];
    }
    s8[0] ^= SHA3_IOTA_H[round2];
    s8[1] ^= SHA3_IOTA_L[round2];
  }
  clean(B5);
}
var _0n2, _1n2, _2n2, _7n, _256n, _0x71n, SHA3_PI, SHA3_ROTL, _SHA3_IOTA, IOTAS, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, keccak_256;
var init_sha3 = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha3.js"() {
    init_u64();
    init_utils();
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n2 = BigInt(2);
    _7n = BigInt(7);
    _256n = BigInt(256);
    _0x71n = BigInt(113);
    SHA3_PI = [];
    SHA3_ROTL = [];
    _SHA3_IOTA = [];
    for (let round2 = 0, R6 = _1n2, x7 = 1, y9 = 0; round2 < 24; round2++) {
      [x7, y9] = [y9, (2 * x7 + 3 * y9) % 5];
      SHA3_PI.push(2 * (5 * y9 + x7));
      SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
      let t5 = _0n2;
      for (let j7 = 0; j7 < 7; j7++) {
        R6 = (R6 << _1n2 ^ (R6 >> _7n) * _0x71n) % _256n;
        if (R6 & _2n2)
          t5 ^= _1n2 << (_1n2 << /* @__PURE__ */ BigInt(j7)) - _1n2;
      }
      _SHA3_IOTA.push(t5);
    }
    IOTAS = split2(_SHA3_IOTA, true);
    SHA3_IOTA_H = IOTAS[0];
    SHA3_IOTA_L = IOTAS[1];
    rotlH = (h12, l10, s8) => s8 > 32 ? rotlBH2(h12, l10, s8) : rotlSH2(h12, l10, s8);
    rotlL = (h12, l10, s8) => s8 > 32 ? rotlBL2(h12, l10, s8) : rotlSL2(h12, l10, s8);
    Keccak = class _Keccak extends Hash2 {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        anumber2(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        swap32IfBE(this.state32);
        keccakP(this.state32, this.rounds);
        swap32IfBE(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        aexists(this);
        data = toBytes3(data);
        abytes2(data);
        const { blockLen, state: state24 } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i11 = 0; i11 < take; i11++)
            state24[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state: state24, suffix, pos, blockLen } = this;
        state24[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state24[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        aexists(this, false);
        abytes2(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes2) {
        anumber2(bytes2);
        return this.xofInto(new Uint8Array(bytes2));
      }
      digestInto(out) {
        aoutput(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        clean(this.state);
      }
      _cloneInto(to4) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to4 || (to4 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to4.state32.set(this.state32);
        to4.pos = this.pos;
        to4.posOut = this.posOut;
        to4.finished = this.finished;
        to4.rounds = rounds;
        to4.suffix = suffix;
        to4.outputLen = outputLen;
        to4.enableXOF = enableXOF;
        to4.destroyed = this.destroyed;
        return to4;
      }
    };
    gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
    keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to4 = to_ || "hex";
  const bytes2 = keccak_256(isHex(value, { strict: false }) ? toBytes2(value) : value);
  if (to4 === "bytes")
    return bytes2;
  return toHex(bytes2);
}
var init_keccak256 = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js"() {
    init_sha3();
    init_isHex();
    init_toBytes();
    init_toHex();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js
var LruMap;
var init_lru = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js"() {
    LruMap = class extends Map {
      constructor(size4) {
        super();
        Object.defineProperty(this, "maxSize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxSize = size4;
      }
      get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== void 0) {
          this.delete(key);
          super.set(key, value);
        }
        return value;
      }
      set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
          const firstKey = this.keys().next().value;
          if (firstKey)
            this.delete(firstKey);
        }
        return this;
      }
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address2 = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i11 = 0; i11 < 40; i11 += 2) {
    if (hash2[i11 >> 1] >> 4 >= 8 && address2[i11]) {
      address2[i11] = address2[i11].toUpperCase();
    }
    if ((hash2[i11 >> 1] & 15) >= 8 && address2[i11 + 1]) {
      address2[i11 + 1] = address2[i11 + 1].toUpperCase();
    }
  }
  const result = `0x${address2.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
var checksumAddressCache;
var init_getAddress = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js"() {
    init_toBytes();
    init_keccak256();
    init_lru();
    checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address2 = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address2}`);
}
var init_publicKeyToAddress = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js"() {
    init_getAddress();
    init_keccak256();
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h12 = isLE3 ? 4 : 0;
  const l10 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h12, wh, isLE3);
  view.setUint32(byteOffset + l10, wl, isLE3);
}
function Chi2(a5, b7, c12) {
  return a5 & b7 ^ ~a5 & c12;
}
function Maj2(a5, b7, c12) {
  return a5 & b7 ^ a5 & c12 ^ b7 & c12;
}
var HashMD, SHA256_IV;
var init_md = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_md.js"() {
    init_utils();
    HashMD = class extends Hash2 {
      constructor(blockLen, outputLen, padOffset, isLE3) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE3;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView2(this.buffer);
      }
      update(data) {
        aexists(this);
        data = toBytes3(data);
        abytes2(data);
        const { view, buffer: buffer3, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView2(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer3.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
        let { pos } = this;
        buffer3[pos++] = 128;
        clean(this.buffer.subarray(pos));
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i11 = pos; i11 < blockLen; i11++)
          buffer3[i11] = 0;
        setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
        this.process(view, 0);
        const oview = createView2(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state24 = this.get();
        if (outLen > state24.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i11 = 0; i11 < outLen; i11++)
          oview.setUint32(4 * i11, state24[i11], isLE3);
      }
      digest() {
        const { buffer: buffer3, outputLen } = this;
        this.digestInto(buffer3);
        const res = buffer3.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to4) {
        to4 || (to4 = new this.constructor());
        to4.set(...this.get());
        const { blockLen, buffer: buffer3, length: length2, finished, destroyed, pos } = this;
        to4.destroyed = destroyed;
        to4.finished = finished;
        to4.length = length2;
        to4.pos = pos;
        if (length2 % blockLen)
          to4.buffer.set(buffer3);
        return to4;
      }
      clone() {
        return this._cloneInto();
      }
    };
    SHA256_IV = /* @__PURE__ */ Uint32Array.from([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K2, SHA256_W2, SHA2562, sha2562;
var init_sha2 = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha2.js"() {
    init_md();
    init_utils();
    SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
    SHA2562 = class extends HashMD {
      constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A6, B: B5, C: C7, D: D4, E: E8, F: F4, G: G5, H: H5 } = this;
        return [A6, B5, C7, D4, E8, F4, G5, H5];
      }
      // prettier-ignore
      set(A6, B5, C7, D4, E8, F4, G5, H5) {
        this.A = A6 | 0;
        this.B = B5 | 0;
        this.C = C7 | 0;
        this.D = D4 | 0;
        this.E = E8 | 0;
        this.F = F4 | 0;
        this.G = G5 | 0;
        this.H = H5 | 0;
      }
      process(view, offset) {
        for (let i11 = 0; i11 < 16; i11++, offset += 4)
          SHA256_W2[i11] = view.getUint32(offset, false);
        for (let i11 = 16; i11 < 64; i11++) {
          const W15 = SHA256_W2[i11 - 15];
          const W22 = SHA256_W2[i11 - 2];
          const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
          const s1 = rotr2(W22, 17) ^ rotr2(W22, 19) ^ W22 >>> 10;
          SHA256_W2[i11] = s1 + SHA256_W2[i11 - 7] + s0 + SHA256_W2[i11 - 16] | 0;
        }
        let { A: A6, B: B5, C: C7, D: D4, E: E8, F: F4, G: G5, H: H5 } = this;
        for (let i11 = 0; i11 < 64; i11++) {
          const sigma1 = rotr2(E8, 6) ^ rotr2(E8, 11) ^ rotr2(E8, 25);
          const T1 = H5 + sigma1 + Chi2(E8, F4, G5) + SHA256_K2[i11] + SHA256_W2[i11] | 0;
          const sigma0 = rotr2(A6, 2) ^ rotr2(A6, 13) ^ rotr2(A6, 22);
          const T22 = sigma0 + Maj2(A6, B5, C7) | 0;
          H5 = G5;
          G5 = F4;
          F4 = E8;
          E8 = D4 + T1 | 0;
          D4 = C7;
          C7 = B5;
          B5 = A6;
          A6 = T1 + T22 | 0;
        }
        A6 = A6 + this.A | 0;
        B5 = B5 + this.B | 0;
        C7 = C7 + this.C | 0;
        D4 = D4 + this.D | 0;
        E8 = E8 + this.E | 0;
        F4 = F4 + this.F | 0;
        G5 = G5 + this.G | 0;
        H5 = H5 + this.H | 0;
        this.set(A6, B5, C7, D4, E8, F4, G5, H5);
      }
      roundClean() {
        clean(SHA256_W2);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean(this.buffer);
      }
    };
    sha2562 = /* @__PURE__ */ createHasher(() => new SHA2562());
  }
});

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/hmac.js
var HMAC2, hmac2;
var init_hmac = __esm({
  "node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/hmac.js"() {
    init_utils();
    HMAC2 = class extends Hash2 {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash2);
        const key = toBytes3(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad3 = new Uint8Array(blockLen);
        pad3.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i11 = 0; i11 < pad3.length; i11++)
          pad3[i11] ^= 54;
        this.iHash.update(pad3);
        this.oHash = hash2.create();
        for (let i11 = 0; i11 < pad3.length; i11++)
          pad3[i11] ^= 54 ^ 92;
        this.oHash.update(pad3);
        clean(pad3);
      }
      update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        aexists(this);
        abytes2(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to4) {
        to4 || (to4 = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to4 = to4;
        to4.finished = finished;
        to4.destroyed = destroyed;
        to4.blockLen = blockLen;
        to4.outputLen = outputLen;
        to4.oHash = oHash._cloneInto(to4.oHash);
        to4.iHash = iHash._cloneInto(to4.iHash);
        return to4;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac2 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
    hmac2.create = (hash2, key) => new HMAC2(hash2, key);
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js
function isBytes3(a5) {
  return a5 instanceof Uint8Array || ArrayBuffer.isView(a5) && a5.constructor.name === "Uint8Array";
}
function abytes3(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded2(num2) {
  const hex = num2.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n3 : BigInt("0x" + hex);
}
function bytesToHex5(bytes2) {
  abytes3(bytes2);
  if (hasHexBuiltin)
    return bytes2.toHex();
  let hex = "";
  for (let i11 = 0; i11 < bytes2.length; i11++) {
    hex += hexes6[bytes2[i11]];
  }
  return hex;
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes5(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai4 = 0, hi4 = 0; ai4 < al; ai4++, hi4 += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi4));
    const n22 = asciiToBase16(hex.charCodeAt(hi4 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex[hi4] + hex[hi4 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi4);
    }
    array[ai4] = n1 * 16 + n22;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber3(bytesToHex5(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes3(bytes2);
  return hexToNumber3(bytesToHex5(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n12, len) {
  return hexToBytes5(n12.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n12, len) {
  return numberToBytesBE(n12, len).reverse();
}
function ensureBytes2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes5(hex);
    } catch (e10) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e10);
    }
  } else if (isBytes3(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes5(...arrays) {
  let sum = 0;
  for (let i11 = 0; i11 < arrays.length; i11++) {
    const a5 = arrays[i11];
    abytes3(a5);
    sum += a5.length;
  }
  const res = new Uint8Array(sum);
  for (let i11 = 0, pad3 = 0; i11 < arrays.length; i11++) {
    const a5 = arrays[i11];
    res.set(a5, pad3);
    pad3 += a5.length;
  }
  return res;
}
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function inRange(n12, min, max) {
  return isPosBig(n12) && isPosBig(min) && isPosBig(max) && min <= n12 && n12 < max;
}
function aInRange(title, n12, min, max) {
  if (!inRange(n12, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n12);
}
function bitLen(n12) {
  let len;
  for (len = 0; n12 > _0n3; n12 >>= _1n3, len += 1)
    ;
  return len;
}
function createHmacDrbg(hashLen2, qByteLen, hmacFn) {
  if (typeof hashLen2 !== "number" || hashLen2 < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v8 = u8n(hashLen2);
  let k7 = u8n(hashLen2);
  let i11 = 0;
  const reset = () => {
    v8.fill(1);
    k7.fill(0);
    i11 = 0;
  };
  const h12 = (...b7) => hmacFn(k7, v8, ...b7);
  const reseed = (seed = u8n(0)) => {
    k7 = h12(u8fr([0]), seed);
    v8 = h12();
    if (seed.length === 0)
      return;
    k7 = h12(u8fr([1]), seed);
    v8 = h12();
  };
  const gen2 = () => {
    if (i11++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v8 = h12();
      const sl = v8.slice();
      out.push(sl);
      len += v8.length;
    }
    return concatBytes5(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(fn3) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn3(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}
var _0n3, _1n3, hasHexBuiltin, hexes6, asciis, isPosBig, bitMask, u8n, u8fr, validatorFns;
var init_utils2 = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js"() {
    _0n3 = /* @__PURE__ */ BigInt(0);
    _1n3 = /* @__PURE__ */ BigInt(1);
    hasHexBuiltin = // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function";
    hexes6 = /* @__PURE__ */ Array.from({ length: 256 }, (_5, i11) => i11.toString(16).padStart(2, "0"));
    asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    isPosBig = (n12) => typeof n12 === "bigint" && _0n3 <= n12;
    bitMask = (n12) => (_1n3 << BigInt(n12)) - _1n3;
    u8n = (len) => new Uint8Array(len);
    u8fr = (arr) => Uint8Array.from(arr);
    validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js
function mod2(a5, b7) {
  const result = a5 % b7;
  return result >= _0n4 ? result : b7 + result;
}
function pow22(x7, power, modulo) {
  let res = x7;
  while (power-- > _0n4) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number2, modulo) {
  if (number2 === _0n4)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n4)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a5 = mod2(number2, modulo);
  let b7 = modulo;
  let x7 = _0n4, y9 = _1n4, u6 = _1n4, v8 = _0n4;
  while (a5 !== _0n4) {
    const q3 = b7 / a5;
    const r9 = b7 % a5;
    const m6 = x7 - u6 * q3;
    const n12 = y9 - v8 * q3;
    b7 = a5, a5 = r9, x7 = u6, y9 = v8, u6 = m6, v8 = n12;
  }
  const gcd2 = b7;
  if (gcd2 !== _1n4)
    throw new Error("invert: does not exist");
  return mod2(x7, modulo);
}
function sqrt3mod4(Fp, n12) {
  const p1div4 = (Fp.ORDER + _1n4) / _4n;
  const root = Fp.pow(n12, p1div4);
  if (!Fp.eql(Fp.sqr(root), n12))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod8(Fp, n12) {
  const p5div8 = (Fp.ORDER - _5n) / _8n2;
  const n22 = Fp.mul(n12, _2n3);
  const v8 = Fp.pow(n22, p5div8);
  const nv = Fp.mul(n12, v8);
  const i11 = Fp.mul(Fp.mul(nv, _2n3), v8);
  const root = Fp.mul(nv, Fp.sub(i11, Fp.ONE));
  if (!Fp.eql(Fp.sqr(root), n12))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks(P8) {
  if (P8 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q6 = P8 - _1n4;
  let S7 = 0;
  while (Q6 % _2n3 === _0n4) {
    Q6 /= _2n3;
    S7++;
  }
  let Z5 = _2n3;
  const _Fp = Field(P8);
  while (FpLegendre(_Fp, Z5) === 1) {
    if (Z5++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S7 === 1)
    return sqrt3mod4;
  let cc2 = _Fp.pow(Z5, Q6);
  const Q1div2 = (Q6 + _1n4) / _2n3;
  return function tonelliSlow(Fp, n12) {
    if (Fp.is0(n12))
      return n12;
    if (FpLegendre(Fp, n12) !== 1)
      throw new Error("Cannot find square root");
    let M6 = S7;
    let c12 = Fp.mul(Fp.ONE, cc2);
    let t5 = Fp.pow(n12, Q6);
    let R6 = Fp.pow(n12, Q1div2);
    while (!Fp.eql(t5, Fp.ONE)) {
      if (Fp.is0(t5))
        return Fp.ZERO;
      let i11 = 1;
      let t_tmp = Fp.sqr(t5);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i11++;
        t_tmp = Fp.sqr(t_tmp);
        if (i11 === M6)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n4 << BigInt(M6 - i11 - 1);
      const b7 = Fp.pow(c12, exponent);
      M6 = i11;
      c12 = Fp.sqr(b7);
      t5 = Fp.mul(t5, c12);
      R6 = Fp.mul(R6, b7);
    }
    return R6;
  };
}
function FpSqrt(P8) {
  if (P8 % _4n === _3n2)
    return sqrt3mod4;
  if (P8 % _8n2 === _5n)
    return sqrt5mod8;
  return tonelliShanks(P8);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(Fp, num2, power) {
  if (power < _0n4)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n4)
    return Fp.ONE;
  if (power === _1n4)
    return num2;
  let p8 = Fp.ONE;
  let d7 = num2;
  while (power > _0n4) {
    if (power & _1n4)
      p8 = Fp.mul(p8, d7);
    d7 = Fp.sqr(d7);
    power >>= _1n4;
  }
  return p8;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i11) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i11] = acc;
    return Fp.mul(acc, num2);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i11) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i11] = Fp.mul(acc, inverted[i11]);
    return Fp.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n12) {
  const p1mod2 = (Fp.ORDER - _1n4) / _2n3;
  const powered = Fp.pow(n12, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no4 = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no4)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n12, nBitLength) {
  if (nBitLength !== void 0)
    anumber2(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n12.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n4)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f13 = Object.freeze({
    ORDER,
    isLE: isLE3,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n4,
    ONE: _1n4,
    create: (num2) => mod2(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n4 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n4,
    isOdd: (num2) => (num2 & _1n4) === _1n4,
    neg: (num2) => mod2(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod2(num2 * num2, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f13, num2, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert2(num2, ORDER),
    sqrt: redef.sqrt || ((n12) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f13, n12);
    }),
    toBytes: (num2) => isLE3 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE3 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f13, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a5, b7, c12) => c12 ? b7 : a5
  });
  return Object.freeze(f13);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length2 = getFieldBytesLength(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen2 = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod2(num2, fieldOrder - _1n4) + _1n4;
  return isLE3 ? numberToBytesLE(reduced, fieldLen2) : numberToBytesBE(reduced, fieldLen2);
}
var _0n4, _1n4, _2n3, _3n2, _4n, _5n, _8n2, FIELD_FIELDS;
var init_modular = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_utils();
    init_utils2();
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
    _2n3 = /* @__PURE__ */ BigInt(2);
    _3n2 = /* @__PURE__ */ BigInt(3);
    _4n = /* @__PURE__ */ BigInt(4);
    _5n = /* @__PURE__ */ BigInt(5);
    _8n2 = /* @__PURE__ */ BigInt(8);
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js
function constTimeNegate2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W6, bits) {
  if (!Number.isSafeInteger(W6) || W6 <= 0 || W6 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W6);
}
function calcWOpts(W6, scalarBits) {
  validateW(W6, scalarBits);
  const windows = Math.ceil(scalarBits / W6) + 1;
  const windowSize = 2 ** (W6 - 1);
  const maxNumber = 2 ** W6;
  const mask = bitMask(W6);
  const shiftBy = BigInt(W6);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n12, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n12 & mask);
  let nextN = n12 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n5;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c12) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p8, i11) => {
    if (!(p8 instanceof c12))
      throw new Error("invalid point at index " + i11);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s8, i11) => {
    if (!field.isValid(s8))
      throw new Error("invalid scalar at index " + i11);
  });
}
function getW(P8) {
  return pointWindowSizes.get(P8) || 1;
}
function wNAF(c12, bits) {
  return {
    constTimeNegate: constTimeNegate2,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n12, p8 = c12.ZERO) {
      let d7 = elm;
      while (n12 > _0n5) {
        if (n12 & _1n5)
          p8 = p8.add(d7);
        d7 = d7.double();
        n12 >>= _1n5;
      }
      return p8;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W6) {
      const { windows, windowSize } = calcWOpts(W6, bits);
      const points = [];
      let p8 = elm;
      let base3 = p8;
      for (let window2 = 0; window2 < windows; window2++) {
        base3 = p8;
        points.push(base3);
        for (let i11 = 1; i11 < windowSize; i11++) {
          base3 = base3.add(p8);
          points.push(base3);
        }
        p8 = base3.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W6, precomputes, n12) {
      let p8 = c12.ZERO;
      let f13 = c12.BASE;
      const wo4 = calcWOpts(W6, bits);
      for (let window2 = 0; window2 < wo4.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n12, window2, wo4);
        n12 = nextN;
        if (isZero) {
          f13 = f13.add(constTimeNegate2(isNegF, precomputes[offsetF]));
        } else {
          p8 = p8.add(constTimeNegate2(isNeg, precomputes[offset]));
        }
      }
      return { p: p8, f: f13 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W6, precomputes, n12, acc = c12.ZERO) {
      const wo4 = calcWOpts(W6, bits);
      for (let window2 = 0; window2 < wo4.windows; window2++) {
        if (n12 === _0n5)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n12, window2, wo4);
        n12 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      return acc;
    },
    getPrecomputes(W6, P8, transform) {
      let comp = pointPrecomputes2.get(P8);
      if (!comp) {
        comp = this.precomputeWindow(P8, W6);
        if (W6 !== 1)
          pointPrecomputes2.set(P8, transform(comp));
      }
      return comp;
    },
    wNAFCached(P8, n12, transform) {
      const W6 = getW(P8);
      return this.wNAF(W6, this.getPrecomputes(W6, P8, transform), n12);
    },
    wNAFCachedUnsafe(P8, n12, transform, prev) {
      const W6 = getW(P8);
      if (W6 === 1)
        return this.unsafeLadder(P8, n12, prev);
      return this.wNAFUnsafe(W6, this.getPrecomputes(W6, P8, transform), n12, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P8, W6) {
      validateW(W6, bits);
      pointWindowSizes.set(P8, W6);
      pointPrecomputes2.delete(P8);
    }
  };
}
function pippenger(c12, fieldN, points, scalars) {
  validateMSMPoints(points, c12);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c12.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i11 = lastBits; i11 >= 0; i11 -= windowSize) {
    buckets.fill(zero);
    for (let j7 = 0; j7 < slength; j7++) {
      const scalar = scalars[j7];
      const wbits2 = Number(scalar >> BigInt(i11) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j7]);
    }
    let resI = zero;
    for (let j7 = buckets.length - 1, sumI = zero; j7 > 0; j7--) {
      sumI = sumI.add(buckets[j7]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i11 !== 0)
      for (let j7 = 0; j7 < windowSize; j7++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n5, _1n5, pointPrecomputes2, pointWindowSizes;
var init_curve = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_modular();
    init_utils2();
    _0n5 = BigInt(0);
    _1n5 = BigInt(1);
    pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
    pointWindowSizes = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowInfinityPoint: "boolean",
    allowedPrivateKeyLengths: "array",
    clearCofactor: "function",
    fromBytes: "function",
    isTorsionFree: "function",
    toBytes: "function",
    wrapPrivateKey: "boolean"
  });
  const { endo: endo2, Fp, a: a5 } = opts;
  if (endo2) {
    if (!Fp.eql(a5, Fp.ZERO)) {
      throw new Error("invalid endo: CURVE.a must be 0");
    }
    if (typeof endo2 !== "object" || typeof endo2.beta !== "bigint" || typeof endo2.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  return Object.freeze({ ...opts });
}
function numToSizedHex(num2, size4) {
  return bytesToHex5(numberToBytesBE(num2, size4));
}
function weierstrassPoints(opts) {
  const CURVE2 = validatePointOpts(opts);
  const { Fp } = CURVE2;
  const Fn4 = Field(CURVE2.n, CURVE2.nBitLength);
  const toBytes4 = CURVE2.toBytes || ((_c2, point, _isCompressed) => {
    const a5 = point.toAffine();
    return concatBytes5(Uint8Array.from([4]), Fp.toBytes(a5.x), Fp.toBytes(a5.y));
  });
  const fromBytes = CURVE2.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x7 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y9 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x: x7, y: y9 };
  });
  function weierstrassEquation(x7) {
    const { a: a5, b: b7 } = CURVE2;
    const x22 = Fp.sqr(x7);
    const x32 = Fp.mul(x22, x7);
    return Fp.add(Fp.add(x32, Fp.mul(x7, a5)), b7);
  }
  function isValidXY(x7, y9) {
    const left = Fp.sqr(y9);
    const right = weierstrassEquation(x7);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE2.Gx, CURVE2.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE2.a, _3n3), _4n2);
  const _27b2 = Fp.mul(Fp.sqr(CURVE2.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function isWithinCurveOrder2(num2) {
    return inRange(num2, _1n6, CURVE2.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N15 } = CURVE2;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex5(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num2;
    try {
      num2 = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes2("private key", key, nByteLength));
    } catch (error2) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num2 = mod2(num2, N15);
    aInRange("private key", num2, _1n6, N15);
    return num2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p8, iz) => {
    const { px: x7, py: y9, pz: z5 } = p8;
    if (Fp.eql(z5, Fp.ONE))
      return { x: x7, y: y9 };
    const is0 = p8.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z5);
    const ax = Fp.mul(x7, iz);
    const ay = Fp.mul(y9, iz);
    const zz = Fp.mul(z5, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p8) => {
    if (p8.is0()) {
      if (CURVE2.allowInfinityPoint && !Fp.is0(p8.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x7, y: y9 } = p8.toAffine();
    if (!Fp.isValid(x7) || !Fp.isValid(y9))
      throw new Error("bad point: x or y not FE");
    if (!isValidXY(x7, y9))
      throw new Error("bad point: equation left != right");
    if (!p8.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point3 {
    constructor(px, py, pz) {
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py) || Fp.is0(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
      this.px = px;
      this.py = py;
      this.pz = pz;
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p8) {
      const { x: x7, y: y9 } = p8 || {};
      if (!p8 || !Fp.isValid(x7) || !Fp.isValid(y9))
        throw new Error("invalid affine point");
      if (p8 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i11) => Fp.eql(i11, Fp.ZERO);
      if (is0(x7) && is0(y9))
        return Point3.ZERO;
      return new Point3(x7, y9, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp, points.map((p8) => p8.pz));
      return points.map((p8, i11) => p8.toAffine(toInv[i11])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P8 = Point3.fromAffine(fromBytes(ensureBytes2("pointHex", hex)));
      P8.assertValidity();
      return P8;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point3, Fn4, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y9 } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y9);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z22), Fp.mul(X22, Z1));
      const U22 = Fp.eql(Fp.mul(Y1, Z22), Fp.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a5, b: b7 } = CURVE2;
      const b32 = Fp.mul(b7, _3n3);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp.ZERO, Y32 = Fp.ZERO, Z32 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t22 = Fp.mul(Z1, Z1);
      let t32 = Fp.mul(X1, Y1);
      t32 = Fp.add(t32, t32);
      Z32 = Fp.mul(X1, Z1);
      Z32 = Fp.add(Z32, Z32);
      X32 = Fp.mul(a5, Z32);
      Y32 = Fp.mul(b32, t22);
      Y32 = Fp.add(X32, Y32);
      X32 = Fp.sub(t1, Y32);
      Y32 = Fp.add(t1, Y32);
      Y32 = Fp.mul(X32, Y32);
      X32 = Fp.mul(t32, X32);
      Z32 = Fp.mul(b32, Z32);
      t22 = Fp.mul(a5, t22);
      t32 = Fp.sub(t0, t22);
      t32 = Fp.mul(a5, t32);
      t32 = Fp.add(t32, Z32);
      Z32 = Fp.add(t0, t0);
      t0 = Fp.add(Z32, t0);
      t0 = Fp.add(t0, t22);
      t0 = Fp.mul(t0, t32);
      Y32 = Fp.add(Y32, t0);
      t22 = Fp.mul(Y1, Z1);
      t22 = Fp.add(t22, t22);
      t0 = Fp.mul(t22, t32);
      X32 = Fp.sub(X32, t0);
      Z32 = Fp.mul(t22, t1);
      Z32 = Fp.add(Z32, Z32);
      Z32 = Fp.add(Z32, Z32);
      return new Point3(X32, Y32, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp.ZERO, Y32 = Fp.ZERO, Z32 = Fp.ZERO;
      const a5 = CURVE2.a;
      const b32 = Fp.mul(CURVE2.b, _3n3);
      let t0 = Fp.mul(X1, X22);
      let t1 = Fp.mul(Y1, Y22);
      let t22 = Fp.mul(Z1, Z22);
      let t32 = Fp.add(X1, Y1);
      let t42 = Fp.add(X22, Y22);
      t32 = Fp.mul(t32, t42);
      t42 = Fp.add(t0, t1);
      t32 = Fp.sub(t32, t42);
      t42 = Fp.add(X1, Z1);
      let t5 = Fp.add(X22, Z22);
      t42 = Fp.mul(t42, t5);
      t5 = Fp.add(t0, t22);
      t42 = Fp.sub(t42, t5);
      t5 = Fp.add(Y1, Z1);
      X32 = Fp.add(Y22, Z22);
      t5 = Fp.mul(t5, X32);
      X32 = Fp.add(t1, t22);
      t5 = Fp.sub(t5, X32);
      Z32 = Fp.mul(a5, t42);
      X32 = Fp.mul(b32, t22);
      Z32 = Fp.add(X32, Z32);
      X32 = Fp.sub(t1, Z32);
      Z32 = Fp.add(t1, Z32);
      Y32 = Fp.mul(X32, Z32);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t22 = Fp.mul(a5, t22);
      t42 = Fp.mul(b32, t42);
      t1 = Fp.add(t1, t22);
      t22 = Fp.sub(t0, t22);
      t22 = Fp.mul(a5, t22);
      t42 = Fp.add(t42, t22);
      t0 = Fp.mul(t1, t42);
      Y32 = Fp.add(Y32, t0);
      t0 = Fp.mul(t5, t42);
      X32 = Fp.mul(t32, X32);
      X32 = Fp.sub(X32, t0);
      t0 = Fp.mul(t32, t1);
      Z32 = Fp.mul(t5, Z32);
      Z32 = Fp.add(Z32, t0);
      return new Point3(X32, Y32, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n12) {
      return wnaf.wNAFCached(this, n12, Point3.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc2) {
      const { endo: endo3, n: N15 } = CURVE2;
      aInRange("scalar", sc2, _0n6, N15);
      const I6 = Point3.ZERO;
      if (sc2 === _0n6)
        return I6;
      if (this.is0() || sc2 === _1n6)
        return this;
      if (!endo3 || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc2, Point3.normalizeZ);
      let { k1neg, k1, k2neg, k2: k22 } = endo3.splitScalar(sc2);
      let k1p = I6;
      let k2p = I6;
      let d7 = this;
      while (k1 > _0n6 || k22 > _0n6) {
        if (k1 & _1n6)
          k1p = k1p.add(d7);
        if (k22 & _1n6)
          k2p = k2p.add(d7);
        d7 = d7.double();
        k1 >>= _1n6;
        k22 >>= _1n6;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp.mul(k2p.px, endo3.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo3, n: N15 } = CURVE2;
      aInRange("scalar", scalar, _1n6, N15);
      let point, fake;
      if (endo3) {
        const { k1neg, k1, k2neg, k2: k22 } = endo3.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp.mul(k2p.px, endo3.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p8, f: f13 } = this.wNAF(scalar);
        point = p8;
        fake = f13;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q6, a5, b7) {
      const G5 = Point3.BASE;
      const mul = (P8, a6) => a6 === _0n6 || a6 === _1n6 || !P8.equals(G5) ? P8.multiplyUnsafe(a6) : P8.multiply(a6);
      const sum = mul(this, a5).add(mul(Q6, b7));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE2;
      if (cofactor === _1n6)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE2;
      if (cofactor === _1n6)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE2.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes4(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex5(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE2.Gx, CURVE2.Gy, Fp.ONE);
  Point3.ZERO = new Point3(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const { endo: endo2, nBitLength } = CURVE2;
  const wnaf = wNAF(Point3, endo2 ? Math.ceil(nBitLength / 2) : nBitLength);
  return {
    CURVE: CURVE2,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder: isWithinCurveOrder2
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass2(curveDef) {
  const CURVE2 = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE2;
  const compressedLen2 = Fp.BYTES + 1;
  const uncompressedLen2 = 2 * Fp.BYTES + 1;
  function modN2(a5) {
    return mod2(a5, CURVE_ORDER);
  }
  function invN(a5) {
    return invert2(a5, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder: isWithinCurveOrder2 } = weierstrassPoints({
    ...CURVE2,
    toBytes(_c2, point, isCompressed) {
      const a5 = point.toAffine();
      const x7 = Fp.toBytes(a5.x);
      const cat = concatBytes5;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x7);
      } else {
        return cat(Uint8Array.from([4]), x7, Fp.toBytes(a5.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen2 && (head === 2 || head === 3)) {
        const x7 = bytesToNumberBE(tail);
        if (!inRange(x7, _1n6, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x7);
        let y9;
        try {
          y9 = Fp.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y9 & _1n6) === _1n6;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y9 = Fp.neg(y9);
        return { x: x7, y: y9 };
      } else if (len === uncompressedLen2 && head === 4) {
        const x7 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y9 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x: x7, y: y9 };
      } else {
        const cl = compressedLen2;
        const ul = uncompressedLen2;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n6;
    return number2 > HALF;
  }
  function normalizeS(s8) {
    return isBiggerThanHalfOrder(s8) ? modN2(-s8) : s8;
  }
  const slcNum = (b7, from3, to4) => bytesToNumberBE(b7.slice(from3, to4));
  class Signature2 {
    constructor(r9, s8, recovery) {
      aInRange("r", r9, _1n6, CURVE_ORDER);
      aInRange("s", s8, _1n6, CURVE_ORDER);
      this.r = r9;
      this.s = s8;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l10 = nByteLength;
      hex = ensureBytes2("compactSignature", hex, l10 * 2);
      return new Signature2(slcNum(hex, 0, l10), slcNum(hex, l10, 2 * l10));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r: r9, s: s8 } = DER.toSig(ensureBytes2("DER", hex));
      return new Signature2(r9, s8);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r9, s: s8, recovery: rec } = this;
      const h12 = bits2int_modN(ensureBytes2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r9 + CURVE2.n : r9;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R6 = Point3.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));
      const ir4 = invN(radj);
      const u1 = modN2(-h12 * ir4);
      const u22 = modN2(s8 * ir4);
      const Q6 = Point3.BASE.multiplyAndAddUnsafe(R6, u1, u22);
      if (!Q6)
        throw new Error("point at infinify");
      Q6.assertValidity();
      return Q6;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes5(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig(this);
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes5(this.toCompactHex());
    }
    toCompactHex() {
      const l10 = nByteLength;
      return numToSizedHex(this.r, l10) + numToSizedHex(this.s, l10);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength(CURVE2.n);
      return mapHashToField(CURVE2.randomBytes(length2), CURVE2.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey2(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point3)
      return true;
    const arr = ensureBytes2("key", item);
    const len = arr.length;
    const fpl = Fp.BYTES;
    const compLen = fpl + 1;
    const uncompLen = 2 * fpl + 1;
    if (CURVE2.allowedPrivateKeyLengths || nByteLength === compLen) {
      return void 0;
    } else {
      return len === compLen || len === uncompLen;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b7 = Point3.fromHex(publicB);
    return b7.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int2 = CURVE2.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - nBitLength;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = CURVE2.bits2int_modN || function(bytes2) {
    return modN2(bits2int2(bytes2));
  };
  const ORDER_MASK = bitMask(nBitLength);
  function int2octets2(num2) {
    aInRange("num < 2^" + nBitLength, num2, _0n6, ORDER_MASK);
    return numberToBytesBE(num2, nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k7) => k7 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE2;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d7 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets2(d7), int2octets2(h1int)];
    if (ent != null && ent !== false) {
      const e10 = ent === true ? randomBytes2(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e10));
    }
    const seed = concatBytes5(...seedArgs);
    const m6 = h1int;
    function k2sig(kBytes) {
      const k7 = bits2int2(kBytes);
      if (!isWithinCurveOrder2(k7))
        return;
      const ik = invN(k7);
      const q3 = Point3.BASE.multiply(k7).toAffine();
      const r9 = modN2(q3.x);
      if (r9 === _0n6)
        return;
      const s8 = modN2(ik * modN2(m6 + r9 * d7));
      if (s8 === _0n6)
        return;
      let recovery = (q3.x === r9 ? 0 : 2) | Number(q3.y & _1n6);
      let normS = s8;
      if (lowS && isBiggerThanHalfOrder(s8)) {
        normS = normalizeS(s8);
        recovery ^= 1;
      }
      return new Signature2(r9, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE2.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE2.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C7 = CURVE2;
    const drbg = createHmacDrbg(C7.hash.outputLen, C7.nByteLength, C7.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify3(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex3 = typeof sg === "string" || isBytes3(sg);
    const isObj = !isHex3 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex3 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P8;
    try {
      if (isObj)
        _sig = new Signature2(sg.r, sg.s);
      if (isHex3) {
        try {
          if (format !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P8 = Point3.fromHex(publicKey);
    } catch (error2) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE2.hash(msgHash);
    const { r: r9, s: s8 } = _sig;
    const h12 = bits2int_modN(msgHash);
    const is3 = invN(s8);
    const u1 = modN2(h12 * is3);
    const u22 = modN2(r9 * is3);
    const R6 = Point3.BASE.multiplyAndAddUnsafe(P8, u1, u22)?.toAffine();
    if (!R6)
      return false;
    const v8 = modN2(R6.x);
    return v8 === r9;
  }
  return {
    CURVE: CURVE2,
    getPublicKey: getPublicKey2,
    getSharedSecret,
    sign,
    verify: verify3,
    ProjectivePoint: Point3,
    Signature: Signature2,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp, Z5) {
  const q3 = Fp.ORDER;
  let l10 = _0n6;
  for (let o13 = q3 - _1n6; o13 % _2n4 === _0n6; o13 /= _2n4)
    l10 += _1n6;
  const c1 = l10;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n6 - _1n6;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c22 = (q3 - _1n6) / _2n_pow_c1;
  const c32 = (c22 - _1n6) / _2n4;
  const c42 = _2n_pow_c1 - _1n6;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp.pow(Z5, c22);
  const c72 = Fp.pow(Z5, (c22 + _1n6) / _2n4);
  let sqrtRatio = (u6, v8) => {
    let tv1 = c62;
    let tv2 = Fp.pow(v8, c42);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v8);
    let tv5 = Fp.mul(u6, tv3);
    tv5 = Fp.pow(tv5, c32);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v8);
    tv3 = Fp.mul(tv5, u6);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c52);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c72);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i11 = c1; i11 > _1n6; i11--) {
      let tv52 = i11 - _2n4;
      tv52 = _2n4 << tv52 - _1n6;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n3) {
    const c12 = (Fp.ORDER - _3n3) / _4n2;
    const c23 = Fp.sqrt(Fp.neg(Z5));
    sqrtRatio = (u6, v8) => {
      let tv1 = Fp.sqr(v8);
      const tv2 = Fp.mul(u6, v8);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y22 = Fp.mul(y1, c23);
      const tv3 = Fp.mul(Fp.sqr(y1), v8);
      const isQR = Fp.eql(tv3, u6);
      let y9 = Fp.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y9 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
  if (!Fp.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u6) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x7, y9;
    tv1 = Fp.sqr(u6);
    tv1 = Fp.mul(tv1, opts.Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, opts.B);
    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, opts.A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, opts.A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, opts.B);
    tv2 = Fp.add(tv2, tv5);
    x7 = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y9 = Fp.mul(tv1, u6);
    y9 = Fp.mul(y9, value);
    x7 = Fp.cmov(x7, tv3, isValid);
    y9 = Fp.cmov(y9, value, isValid);
    const e1 = Fp.isOdd(u6) === Fp.isOdd(y9);
    y9 = Fp.cmov(Fp.neg(y9), y9, e1);
    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];
    x7 = Fp.mul(x7, tv4_inv);
    return { x: x7, y: y9 };
  };
}
var DERErr, DER, _0n6, _1n6, _2n4, _3n3, _4n2;
var init_weierstrass = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_curve();
    init_modular();
    init_utils2();
    DERErr = class extends Error {
      constructor(m6 = "") {
        super(m6);
      }
    };
    DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data) => {
          const { Err: E8 } = DER;
          if (tag < 0 || tag > 256)
            throw new E8("tlv.encode: wrong tag");
          if (data.length & 1)
            throw new E8("tlv.encode: unpadded data");
          const dataLen = data.length / 2;
          const len = numberToHexUnpadded2(dataLen);
          if (len.length / 2 & 128)
            throw new E8("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
          const t5 = numberToHexUnpadded2(tag);
          return t5 + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
          const { Err: E8 } = DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E8("tlv.encode: wrong tag");
          if (data.length < 2 || data[pos++] !== tag)
            throw new E8("tlv.decode: wrong tlv");
          const first = data[pos++];
          const isLong = !!(first & 128);
          let length2 = 0;
          if (!isLong)
            length2 = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E8("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E8("tlv.decode(long): byte length is too big");
            const lengthBytes = data.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E8("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E8("tlv.decode(long): zero leftmost byte");
            for (const b7 of lengthBytes)
              length2 = length2 << 8 | b7;
            pos += lenLen;
            if (length2 < 128)
              throw new E8("tlv.decode(long): not minimal encoding");
          }
          const v8 = data.subarray(pos, pos + length2);
          if (v8.length !== length2)
            throw new E8("tlv.decode: wrong value length");
          return { v: v8, l: data.subarray(pos + length2) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num2) {
          const { Err: E8 } = DER;
          if (num2 < _0n6)
            throw new E8("integer: negative integers are not allowed");
          let hex = numberToHexUnpadded2(num2);
          if (Number.parseInt(hex[0], 16) & 8)
            hex = "00" + hex;
          if (hex.length & 1)
            throw new E8("unexpected DER parsing assertion: unpadded hex");
          return hex;
        },
        decode(data) {
          const { Err: E8 } = DER;
          if (data[0] & 128)
            throw new E8("invalid signature integer: negative");
          if (data[0] === 0 && !(data[1] & 128))
            throw new E8("invalid signature integer: unnecessary leading zero");
          return bytesToNumberBE(data);
        }
      },
      toSig(hex) {
        const { Err: E8, _int: int2, _tlv: tlv } = DER;
        const data = ensureBytes2("signature", hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
        if (seqLeftBytes.length)
          throw new E8("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E8("invalid signature: left bytes after parsing");
        return { r: int2.decode(rBytes), s: int2.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int2 } = DER;
        const rs3 = tlv.encode(2, int2.encode(sig.r));
        const ss3 = tlv.encode(2, int2.encode(sig.s));
        const seq = rs3 + ss3;
        return tlv.encode(48, seq);
      }
    };
    _0n6 = BigInt(0);
    _1n6 = BigInt(1);
    _2n4 = BigInt(2);
    _3n3 = BigInt(3);
    _4n2 = BigInt(4);
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac2(hash2, key, concatBytes4(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create2 = (hash2) => weierstrass2({ ...curveDef, ...getHash(hash2) });
  return { ...create2(defHash), create: create2 };
}
var init_shortw_utils = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_hmac();
    init_utils();
    init_weierstrass();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function i2osp(value, length2) {
  anum(value);
  anum(length2);
  if (value < 0 || value >= 1 << 8 * length2)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length: length2 }).fill(0);
  for (let i11 = length2 - 1; i11 >= 0; i11--) {
    res[i11] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a5, b7) {
  const arr = new Uint8Array(a5.length);
  for (let i11 = 0; i11 < a5.length; i11++) {
    arr[i11] = a5[i11] ^ b7[i11];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H5) {
  abytes3(msg);
  abytes3(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H5(concatBytes5(utf8ToBytes5("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H5;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes5(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b7 = new Array(ell);
  const b_0 = H5(concatBytes5(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b7[0] = H5(concatBytes5(b_0, i2osp(1, 1), DST_prime));
  for (let i11 = 1; i11 <= ell; i11++) {
    const args = [strxor(b_0, b7[i11 - 1]), i2osp(i11 + 1, 1), DST_prime];
    b7[i11] = H5(concatBytes5(...args));
  }
  const pseudo_random_bytes = concatBytes5(...b7);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k7, H5) {
  abytes3(msg);
  abytes3(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k7 / 8);
    DST = H5.create({ dkLen }).update(utf8ToBytes5("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H5.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p8, k: k7, m: m6, hash: hash2, expand, DST: _DST } = options;
  abytes3(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes5(_DST) : _DST;
  const log2p = p8.toString(2).length;
  const L6 = Math.ceil((log2p + k7) / 8);
  const len_in_bytes = count * m6 * L6;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k7, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u6 = new Array(count);
  for (let i11 = 0; i11 < count; i11++) {
    const e10 = new Array(m6);
    for (let j7 = 0; j7 < m6; j7++) {
      const elm_offset = L6 * (j7 + i11 * m6);
      const tv = prb.subarray(elm_offset, elm_offset + L6);
      e10[j7] = mod2(os2ip(tv), p8);
    }
    u6[i11] = e10;
  }
  return u6;
}
function isogenyMap(field, map2) {
  const coeff = map2.map((i11) => Array.from(i11).reverse());
  return (x7, y9) => {
    const [xn4, xd, yn4, yd] = coeff.map((val) => val.reduce((acc, i11) => field.add(field.mul(acc, x7), i11)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x7 = field.mul(xn4, xd_inv);
    y9 = field.mul(y9, field.mul(yn4, yd_inv));
    return { x: x7, y: y9 };
  };
}
function createHasher2(Point3, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map2(num2) {
    return Point3.fromAffine(mapToCurve(num2));
  }
  function clear2(initial) {
    const P8 = initial.clearCofactor();
    if (P8.equals(Point3.ZERO))
      return Point3.ZERO;
    P8.assertValidity();
    return P8;
  }
  return {
    defaults,
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u6 = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options });
      const u0 = map2(u6[0]);
      const u1 = map2(u6[1]);
      return clear2(u0.add(u1));
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u6 = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options });
      return clear2(map2(u6[0]));
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i11 of scalars)
        if (typeof i11 !== "bigint")
          throw new Error("expected array of bigints");
      return clear2(map2(scalars));
    }
  };
}
var os2ip;
var init_hash_to_curve = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
    init_modular();
    init_utils2();
    os2ip = bytesToNumberBE;
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_exports = {};
__export(secp256k1_exports, {
  encodeToCurve: () => encodeToCurve,
  hashToCurve: () => hashToCurve,
  schnorr: () => schnorr,
  secp256k1: () => secp256k1,
  secp256k1_hasher: () => secp256k1_hasher
});
function sqrtMod2(y9) {
  const P8 = secp256k1P;
  const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y9 * y9 * y9 % P8;
  const b32 = b22 * b22 * y9 % P8;
  const b62 = pow22(b32, _3n4, P8) * b32 % P8;
  const b9 = pow22(b62, _3n4, P8) * b32 % P8;
  const b11 = pow22(b9, _2n5, P8) * b22 % P8;
  const b222 = pow22(b11, _11n, P8) * b11 % P8;
  const b44 = pow22(b222, _22n, P8) * b222 % P8;
  const b88 = pow22(b44, _44n, P8) * b44 % P8;
  const b176 = pow22(b88, _88n, P8) * b88 % P8;
  const b220 = pow22(b176, _44n, P8) * b44 % P8;
  const b223 = pow22(b220, _3n4, P8) * b32 % P8;
  const t1 = pow22(b223, _23n, P8) * b222 % P8;
  const t22 = pow22(t1, _6n, P8) * b22 % P8;
  const root = pow22(t22, _2n5, P8);
  if (!Fpk1.eql(Fpk1.sqr(root), y9))
    throw new Error("Cannot find square root");
  return root;
}
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES2[tag];
  if (tagP === void 0) {
    const tagH = sha2562(Uint8Array.from(tag, (c12) => c12.charCodeAt(0)));
    tagP = concatBytes5(tagH, tagH);
    TAGGED_HASH_PREFIXES2[tag] = tagP;
  }
  return sha2562(concatBytes5(tagP, ...messages));
}
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p8 = Point2.fromPrivateKey(d_);
  const scalar = p8.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p8) };
}
function lift_x(x7) {
  aInRange("x", x7, _1n7, secp256k1P);
  const xx = modP(x7 * x7);
  const c12 = modP(xx * x7 + BigInt(7));
  let y9 = sqrtMod2(c12);
  if (y9 % _2n5 !== _0n7)
    y9 = modP(-y9);
  const p8 = new Point2(x7, y9, _1n7);
  p8.assertValidity();
  return p8;
}
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m6 = ensureBytes2("message", message);
  const { bytes: px, scalar: d7 } = schnorrGetExtPubKey(privateKey);
  const a5 = ensureBytes2("auxRand", auxRand, 32);
  const t5 = numTo32b2(d7 ^ num(taggedHash("BIP0340/aux", a5)));
  const rand = taggedHash("BIP0340/nonce", t5, px, m6);
  const k_ = modN(num(rand));
  if (k_ === _0n7)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k7 } = schnorrGetExtPubKey(k_);
  const e10 = challenge(rx, px, m6);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b2(modN(k7 + e10 * d7)), 32);
  if (!schnorrVerify(sig, m6, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes2("signature", signature, 64);
  const m6 = ensureBytes2("message", message);
  const pub = ensureBytes2("publicKey", publicKey, 32);
  try {
    const P8 = lift_x(num(pub));
    const r9 = num(sig.subarray(0, 32));
    if (!inRange(r9, _1n7, secp256k1P))
      return false;
    const s8 = num(sig.subarray(32, 64));
    if (!inRange(s8, _1n7, secp256k1N))
      return false;
    const e10 = challenge(numTo32b2(r9), pointToBytes(P8), m6);
    const R6 = GmulAdd(P8, s8, modN(-e10));
    if (!R6 || !R6.hasEvenY() || R6.toAffine().x !== r9)
      return false;
    return true;
  } catch (error2) {
    return false;
  }
}
var secp256k1P, secp256k1N, _0n7, _1n7, _2n5, divNearest2, Fpk1, secp256k1, TAGGED_HASH_PREFIXES2, pointToBytes, numTo32b2, modP, modN, Point2, GmulAdd, num, schnorr, isoMap, mapSWU, secp256k1_hasher, hashToCurve, encodeToCurve;
var init_secp256k1 = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js"() {
    init_sha2();
    init_utils();
    init_shortw_utils();
    init_hash_to_curve();
    init_modular();
    init_utils2();
    init_weierstrass();
    secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    _0n7 = BigInt(0);
    _1n7 = BigInt(1);
    _2n5 = BigInt(2);
    divNearest2 = (a5, b7) => (a5 + b7 / _2n5) / b7;
    Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod2 });
    secp256k1 = createCurve({
      a: _0n7,
      b: BigInt(7),
      Fp: Fpk1,
      n: secp256k1N,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      endo: {
        // Endomorphism, see above
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k7) => {
          const n12 = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b22 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest2(b22 * k7, n12);
          const c22 = divNearest2(-b1 * k7, n12);
          let k1 = mod2(k7 - c1 * a1 - c22 * a22, n12);
          let k22 = mod2(-c1 * b1 - c22 * b22, n12);
          const k1neg = k1 > POW_2_128;
          const k2neg = k22 > POW_2_128;
          if (k1neg)
            k1 = n12 - k1;
          if (k2neg)
            k22 = n12 - k22;
          if (k1 > POW_2_128 || k22 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k7);
          }
          return { k1neg, k1, k2neg, k2: k22 };
        }
      }
    }, sha2562);
    TAGGED_HASH_PREFIXES2 = {};
    pointToBytes = (point) => point.toRawBytes(true).slice(1);
    numTo32b2 = (n12) => numberToBytesBE(n12, 32);
    modP = (x7) => mod2(x7, secp256k1P);
    modN = (x7) => mod2(x7, secp256k1N);
    Point2 = /* @__PURE__ */ (() => secp256k1.ProjectivePoint)();
    GmulAdd = (Q6, a5, b7) => Point2.BASE.multiplyAndAddUnsafe(Q6, a5, b7);
    num = bytesToNumberBE;
    schnorr = /* @__PURE__ */ (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE,
        bytesToNumberBE,
        taggedHash,
        mod: mod2
      }
    }))();
    isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i11) => i11.map((j7) => BigInt(j7)))))();
    mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    secp256k1_hasher = /* @__PURE__ */ (() => createHasher2(secp256k1.ProjectivePoint, (scalars) => {
      const { x: x7, y: y9 } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x7, y9);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2562
    }))();
    hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();
    encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash: hash2, signature }) {
  const hashHex = isHex(hash2) ? hash2 : toHex(hash2);
  const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), secp256k1_exports));
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r9, s: s8, v: v8, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v8);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt2(r9), hexToBigInt2(s8)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    if (size(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber2(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
var init_recoverPublicKey = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js"() {
    init_isHex();
    init_size();
    init_fromHex();
    init_toHex();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash2, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature }));
}
var init_recoverAddress = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js"() {
    init_publicKeyToAddress();
    init_recoverPublicKey();
  }
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/index.js
var init_esm4 = __esm({
  "node_modules/@walletconnect/utils/node_modules/viem/_esm/index.js"() {
    init_recoverAddress();
  }
});

// node_modules/base-x/src/esm/index.js
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j7 = 0; j7 < BASE_MAP.length; j7++) {
    BASE_MAP[j7] = 255;
  }
  for (let i11 = 0; i11 < ALPHABET2.length; i11++) {
    const x7 = ALPHABET2.charAt(i11);
    const xc2 = x7.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x7 + " is ambiguous");
    }
    BASE_MAP[xc2] = i11;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode6(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length2 = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size4);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i11 = 0;
      for (let it1 = size4 - 1; (carry !== 0 || i11 < length2) && it1 !== -1; it1--, i11++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i11;
      pbegin++;
    }
    let it22 = size4 - length2;
    while (it22 !== size4 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size4; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size4 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size4);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i11 = 0;
      for (let it32 = size4 - 1; (carry !== 0 || i11 < length2) && it32 !== -1; it32--, i11++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i11;
      psz++;
    }
    let it4 = size4 - length2;
    while (it4 !== size4 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size4 - it4));
    let j7 = zeroes;
    while (it4 !== size4) {
      vch[j7++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string2) {
    const buffer3 = decodeUnsafe(string2);
    if (buffer3) {
      return buffer3;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode6,
    decodeUnsafe,
    decode: decode7
  };
}
var esm_default;
var init_esm5 = __esm({
  "node_modules/base-x/src/esm/index.js"() {
    esm_default = base;
  }
});

// node_modules/bs58/src/esm/index.js
var ALPHABET, esm_default2;
var init_esm6 = __esm({
  "node_modules/bs58/src/esm/index.js"() {
    init_esm5();
    ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    esm_default2 = esm_default(ALPHABET);
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs
function utf8Count(str) {
  const strLength = str.length;
  let byteLength = 0;
  let pos = 0;
  while (pos < strLength) {
    let value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output2, outputOffset) {
  const strLength = str.length;
  let offset = outputOffset;
  let pos = 0;
  while (pos < strLength) {
    let value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output2[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output2[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output2[offset++] = value >> 12 & 15 | 224;
        output2[offset++] = value >> 6 & 63 | 128;
      } else {
        output2[offset++] = value >> 18 & 7 | 240;
        output2[offset++] = value >> 12 & 63 | 128;
        output2[offset++] = value >> 6 & 63 | 128;
      }
    }
    output2[offset++] = value & 63 | 128;
  }
}
function utf8EncodeTE(str, output2, outputOffset) {
  sharedTextEncoder.encodeInto(str, output2.subarray(outputOffset));
}
function utf8Encode(str, output2, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output2, outputOffset);
  } else {
    utf8EncodeJs(str, output2, outputOffset);
  }
}
function utf8DecodeJs(bytes2, inputOffset, byteLength) {
  let offset = inputOffset;
  const end = offset + byteLength;
  const units = [];
  let result = "";
  while (offset < end) {
    const byte1 = bytes2[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = bytes2[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = bytes2[offset++] & 63;
      const byte3 = bytes2[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = bytes2[offset++] & 63;
      const byte3 = bytes2[offset++] & 63;
      const byte4 = bytes2[offset++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode(...units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode(...units);
  }
  return result;
}
function utf8DecodeTD(bytes2, inputOffset, byteLength) {
  const stringBytes = bytes2.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes2, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes2, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes2, inputOffset, byteLength);
  }
}
var sharedTextEncoder, TEXT_ENCODER_THRESHOLD, CHUNK_SIZE, sharedTextDecoder, TEXT_DECODER_THRESHOLD;
var init_utf8 = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs"() {
    sharedTextEncoder = new TextEncoder();
    TEXT_ENCODER_THRESHOLD = 50;
    CHUNK_SIZE = 4096;
    sharedTextDecoder = new TextDecoder();
    TEXT_DECODER_THRESHOLD = 200;
  }
});

// node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs
var ExtData;
var init_ExtData = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs"() {
    ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs
var DecodeError;
var init_DecodeError = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs"() {
    DecodeError = class _DecodeError extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(_DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: _DecodeError.name
        });
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs
function setUint64(view, offset, value) {
  const high = value / 4294967296;
  const low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  const high = Math.floor(value / 4294967296);
  const low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  const high = view.getInt32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset) {
  const high = view.getUint32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
var UINT32_MAX;
var init_int = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs"() {
    UINT32_MAX = 4294967295;
  }
});

// node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs
function encodeTimeSpecToTimestamp({ sec, nsec }) {
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      const rv = new Uint8Array(4);
      const view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      const secHigh = sec / 4294967296;
      const secLow = sec & 4294967295;
      const rv = new Uint8Array(8);
      const view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    const rv = new Uint8Array(12);
    const view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  const msec = date.getTime();
  const sec = Math.floor(msec / 1e3);
  const nsec = (msec - sec * 1e3) * 1e6;
  const nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    const timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      const sec = view.getUint32(0);
      const nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      const nsec30AndSecHigh2 = view.getUint32(0);
      const secLow32 = view.getUint32(4);
      const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      const nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      const sec = getInt64(view, 4);
      const nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
  }
}
function decodeTimestampExtension(data) {
  const timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var EXT_TIMESTAMP, TIMESTAMP32_MAX_SEC, TIMESTAMP64_MAX_SEC, timestampExtension;
var init_timestamp = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs"() {
    init_DecodeError();
    init_int();
    EXT_TIMESTAMP = -1;
    TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    timestampExtension = {
      type: EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs
var ExtensionCodec;
var init_ExtensionCodec = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs"() {
    init_ExtData();
    init_timestamp();
    ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestampExtension);
      }
      register({ type, encode: encode6, decode: decode7 }) {
        if (type >= 0) {
          this.encoders[type] = encode6;
          this.decoders[type] = decode7;
        } else {
          const index2 = -1 - type;
          this.builtInEncoders[index2] = encode6;
          this.builtInDecoders[index2] = decode7;
        }
      }
      tryToEncode(object, context) {
        for (let i11 = 0; i11 < this.builtInEncoders.length; i11++) {
          const encodeExt = this.builtInEncoders[i11];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i11;
              return new ExtData(type, data);
            }
          }
        }
        for (let i11 = 0; i11 < this.encoders.length; i11++) {
          const encodeExt = this.encoders[i11];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i11;
              return new ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData(type, data);
        }
      }
    };
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs
function isArrayBufferLike(buffer3) {
  return buffer3 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && buffer3 instanceof SharedArrayBuffer;
}
function ensureUint8Array(buffer3) {
  if (buffer3 instanceof Uint8Array) {
    return buffer3;
  } else if (ArrayBuffer.isView(buffer3)) {
    return new Uint8Array(buffer3.buffer, buffer3.byteOffset, buffer3.byteLength);
  } else if (isArrayBufferLike(buffer3)) {
    return new Uint8Array(buffer3);
  } else {
    return Uint8Array.from(buffer3);
  }
}
var init_typedArrays = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs
var DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder;
var init_Encoder = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs"() {
    init_utf8();
    init_ExtensionCodec();
    init_int();
    init_typedArrays();
    DEFAULT_MAX_DEPTH = 100;
    DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    Encoder = class _Encoder {
      constructor(options) {
        this.entered = false;
        this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;
        this.context = options?.context;
        this.useBigInt64 = options?.useBigInt64 ?? false;
        this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;
        this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;
        this.sortKeys = options?.sortKeys ?? false;
        this.forceFloat32 = options?.forceFloat32 ?? false;
        this.ignoreUndefined = options?.ignoreUndefined ?? false;
        this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      clone() {
        return new _Encoder({
          extensionCodec: this.extensionCodec,
          context: this.context,
          useBigInt64: this.useBigInt64,
          maxDepth: this.maxDepth,
          initialBufferSize: this.initialBufferSize,
          sortKeys: this.sortKeys,
          forceFloat32: this.forceFloat32,
          ignoreUndefined: this.ignoreUndefined,
          forceIntegerToFloat: this.forceIntegerToFloat
        });
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        if (this.entered) {
          const instance = this.clone();
          return instance.encodeSharedRef(object);
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.bytes.subarray(0, this.pos);
        } finally {
          this.entered = false;
        }
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        if (this.entered) {
          const instance = this.clone();
          return instance.encode(object);
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.bytes.slice(0, this.pos);
        } finally {
          this.entered = false;
        }
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          if (!this.forceIntegerToFloat) {
            this.encodeNumber(object);
          } else {
            this.encodeNumberAsFloat(object);
          }
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else if (this.useBigInt64 && typeof object === "bigint") {
          this.encodeBigInt64(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else if (!this.useBigInt64) {
              this.writeU8(207);
              this.writeU64(object);
            } else {
              this.encodeNumberAsFloat(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else if (!this.useBigInt64) {
              this.writeU8(211);
              this.writeI64(object);
            } else {
              this.encodeNumberAsFloat(object);
            }
          }
        } else {
          this.encodeNumberAsFloat(object);
        }
      }
      encodeNumberAsFloat(object) {
        if (this.forceFloat32) {
          this.writeU8(202);
          this.writeF32(object);
        } else {
          this.writeU8(203);
          this.writeF64(object);
        }
      }
      encodeBigInt64(object) {
        if (object >= BigInt(0)) {
          this.writeU8(207);
          this.writeBigUint64(object);
        } else {
          this.writeU8(211);
          this.writeBigInt64(object);
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const byteLength = utf8Count(object);
        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
        this.writeStringHeader(byteLength);
        utf8Encode(object, this.bytes, this.pos);
        this.pos += byteLength;
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size4 = object.byteLength;
        if (size4 < 256) {
          this.writeU8(196);
          this.writeU8(size4);
        } else if (size4 < 65536) {
          this.writeU8(197);
          this.writeU16(size4);
        } else if (size4 < 4294967296) {
          this.writeU8(198);
          this.writeU32(size4);
        } else {
          throw new Error(`Too large binary: ${size4}`);
        }
        const bytes2 = ensureUint8Array(object);
        this.writeU8a(bytes2);
      }
      encodeArray(object, depth) {
        const size4 = object.length;
        if (size4 < 16) {
          this.writeU8(144 + size4);
        } else if (size4 < 65536) {
          this.writeU8(220);
          this.writeU16(size4);
        } else if (size4 < 4294967296) {
          this.writeU8(221);
          this.writeU32(size4);
        } else {
          throw new Error(`Too large array: ${size4}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys2) {
        let count = 0;
        for (const key of keys2) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys2 = Object.keys(object);
        if (this.sortKeys) {
          keys2.sort();
        }
        const size4 = this.ignoreUndefined ? this.countWithoutUndefined(object, keys2) : keys2.length;
        if (size4 < 16) {
          this.writeU8(128 + size4);
        } else if (size4 < 65536) {
          this.writeU8(222);
          this.writeU16(size4);
        } else if (size4 < 4294967296) {
          this.writeU8(223);
          this.writeU32(size4);
        } else {
          throw new Error(`Too large map object: ${size4}`);
        }
        for (const key of keys2) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        if (typeof ext.data === "function") {
          const data = ext.data(this.pos + 6);
          const size5 = data.length;
          if (size5 >= 4294967296) {
            throw new Error(`Too large extension object: ${size5}`);
          }
          this.writeU8(201);
          this.writeU32(size5);
          this.writeI8(ext.type);
          this.writeU8a(data);
          return;
        }
        const size4 = ext.data.length;
        if (size4 === 1) {
          this.writeU8(212);
        } else if (size4 === 2) {
          this.writeU8(213);
        } else if (size4 === 4) {
          this.writeU8(214);
        } else if (size4 === 8) {
          this.writeU8(215);
        } else if (size4 === 16) {
          this.writeU8(216);
        } else if (size4 < 256) {
          this.writeU8(199);
          this.writeU8(size4);
        } else if (size4 < 65536) {
          this.writeU8(200);
          this.writeU16(size4);
        } else if (size4 < 4294967296) {
          this.writeU8(201);
          this.writeU32(size4);
        } else {
          throw new Error(`Too large extension object: ${size4}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size4 = values.length;
        this.ensureBufferSizeToWrite(size4);
        this.bytes.set(values, this.pos);
        this.pos += size4;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        setUint64(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        setInt64(this.view, this.pos, value);
        this.pos += 8;
      }
      writeBigUint64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigUint64(this.pos, value);
        this.pos += 8;
      }
      writeBigInt64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setBigInt64(this.pos, value);
        this.pos += 8;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/encode.mjs
function encode(value, options) {
  const encoder4 = new Encoder(options);
  return encoder4.encodeSharedRef(value);
}
var init_encode = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/encode.mjs"() {
    init_Encoder();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}
var init_prettyByte = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs"() {
  }
});

// node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH, DEFAULT_MAX_LENGTH_PER_KEY, CachedKeyDecoder;
var init_CachedKeyDecoder = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs"() {
    init_utf8();
    DEFAULT_MAX_KEY_LENGTH = 16;
    DEFAULT_MAX_LENGTH_PER_KEY = 16;
    CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.hit = 0;
        this.miss = 0;
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.caches = [];
        for (let i11 = 0; i11 < this.maxKeyLength; i11++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes2, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK: for (const record of records) {
          const recordBytes = record.bytes;
          for (let j7 = 0; j7 < byteLength; j7++) {
            if (recordBytes[j7] !== bytes2[inputOffset + j7]) {
              continue FIND_CHUNK;
            }
          }
          return record.str;
        }
        return null;
      }
      store(bytes2, value) {
        const records = this.caches[bytes2.length - 1];
        const record = { bytes: bytes2, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes2, inputOffset, byteLength) {
        const cachedValue = this.find(bytes2, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = utf8DecodeJs(bytes2, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes2, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs
var STATE_ARRAY, STATE_MAP_KEY, STATE_MAP_VALUE, mapKeyConverter, StackPool, HEAD_BYTE_REQUIRED, EMPTY_VIEW, EMPTY_BYTES, MORE_DATA, sharedCachedKeyDecoder, Decoder;
var init_Decoder = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs"() {
    init_prettyByte();
    init_ExtensionCodec();
    init_int();
    init_utf8();
    init_typedArrays();
    init_CachedKeyDecoder();
    init_DecodeError();
    STATE_ARRAY = "array";
    STATE_MAP_KEY = "map_key";
    STATE_MAP_VALUE = "map_value";
    mapKeyConverter = (key) => {
      if (typeof key === "string" || typeof key === "number") {
        return key;
      }
      throw new DecodeError("The type of key must be string or number but " + typeof key);
    };
    StackPool = class {
      constructor() {
        this.stack = [];
        this.stackHeadPosition = -1;
      }
      get length() {
        return this.stackHeadPosition + 1;
      }
      top() {
        return this.stack[this.stackHeadPosition];
      }
      pushArrayState(size4) {
        const state24 = this.getUninitializedStateFromPool();
        state24.type = STATE_ARRAY;
        state24.position = 0;
        state24.size = size4;
        state24.array = new Array(size4);
      }
      pushMapState(size4) {
        const state24 = this.getUninitializedStateFromPool();
        state24.type = STATE_MAP_KEY;
        state24.readCount = 0;
        state24.size = size4;
        state24.map = {};
      }
      getUninitializedStateFromPool() {
        this.stackHeadPosition++;
        if (this.stackHeadPosition === this.stack.length) {
          const partialState = {
            type: void 0,
            size: 0,
            array: void 0,
            position: 0,
            readCount: 0,
            map: void 0,
            key: null
          };
          this.stack.push(partialState);
        }
        return this.stack[this.stackHeadPosition];
      }
      release(state24) {
        const topStackState = this.stack[this.stackHeadPosition];
        if (topStackState !== state24) {
          throw new Error("Invalid stack state. Released state is not on top of the stack.");
        }
        if (state24.type === STATE_ARRAY) {
          const partialState = state24;
          partialState.size = 0;
          partialState.array = void 0;
          partialState.position = 0;
          partialState.type = void 0;
        }
        if (state24.type === STATE_MAP_KEY || state24.type === STATE_MAP_VALUE) {
          const partialState = state24;
          partialState.size = 0;
          partialState.map = void 0;
          partialState.readCount = 0;
          partialState.type = void 0;
        }
        this.stackHeadPosition--;
      }
      reset() {
        this.stack.length = 0;
        this.stackHeadPosition = -1;
      }
    };
    HEAD_BYTE_REQUIRED = -1;
    EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    try {
      EMPTY_VIEW.getInt8(0);
    } catch (e10) {
      if (!(e10 instanceof RangeError)) {
        throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
      }
    }
    MORE_DATA = new RangeError("Insufficient data");
    sharedCachedKeyDecoder = new CachedKeyDecoder();
    Decoder = class _Decoder {
      constructor(options) {
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = new StackPool();
        this.entered = false;
        this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec;
        this.context = options?.context;
        this.useBigInt64 = options?.useBigInt64 ?? false;
        this.rawStrings = options?.rawStrings ?? false;
        this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;
        this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;
        this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;
        this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;
        this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;
        this.keyDecoder = options?.keyDecoder !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
        this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;
      }
      clone() {
        return new _Decoder({
          extensionCodec: this.extensionCodec,
          context: this.context,
          useBigInt64: this.useBigInt64,
          rawStrings: this.rawStrings,
          maxStrLength: this.maxStrLength,
          maxBinLength: this.maxBinLength,
          maxArrayLength: this.maxArrayLength,
          maxMapLength: this.maxMapLength,
          maxExtLength: this.maxExtLength,
          keyDecoder: this.keyDecoder
        });
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.reset();
      }
      setBuffer(buffer3) {
        const bytes2 = ensureUint8Array(buffer3);
        this.bytes = bytes2;
        this.view = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
        this.pos = 0;
      }
      appendBuffer(buffer3) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer3);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = ensureUint8Array(buffer3);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size4) {
        return this.view.byteLength - this.pos >= size4;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer3) {
        if (this.entered) {
          const instance = this.clone();
          return instance.decode(buffer3);
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.setBuffer(buffer3);
          const object = this.doDecodeSync();
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.pos);
          }
          return object;
        } finally {
          this.entered = false;
        }
      }
      *decodeMulti(buffer3) {
        if (this.entered) {
          const instance = this.clone();
          yield* instance.decodeMulti(buffer3);
          return;
        }
        try {
          this.entered = true;
          this.reinitializeState();
          this.setBuffer(buffer3);
          while (this.hasRemaining(1)) {
            yield this.doDecodeSync();
          }
        } finally {
          this.entered = false;
        }
      }
      async decodeAsync(stream) {
        if (this.entered) {
          const instance = this.clone();
          return instance.decodeAsync(stream);
        }
        try {
          this.entered = true;
          let decoded = false;
          let object;
          for await (const buffer3 of stream) {
            if (decoded) {
              this.entered = false;
              throw this.createExtraByteError(this.totalPos);
            }
            this.appendBuffer(buffer3);
            try {
              object = this.doDecodeSync();
              decoded = true;
            } catch (e10) {
              if (!(e10 instanceof RangeError)) {
                throw e10;
              }
            }
            this.totalPos += this.pos;
          }
          if (decoded) {
            if (this.hasRemaining(1)) {
              throw this.createExtraByteError(this.totalPos);
            }
            return object;
          }
          const { headByte, pos, totalPos } = this;
          throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
        } finally {
          this.entered = false;
        }
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        if (this.entered) {
          const instance = this.clone();
          yield* instance.decodeMultiAsync(stream, isArray);
          return;
        }
        try {
          this.entered = true;
          let isArrayHeaderRequired = isArray;
          let arrayItemsLeft = -1;
          for await (const buffer3 of stream) {
            if (isArray && arrayItemsLeft === 0) {
              throw this.createExtraByteError(this.totalPos);
            }
            this.appendBuffer(buffer3);
            if (isArrayHeaderRequired) {
              arrayItemsLeft = this.readArraySize();
              isArrayHeaderRequired = false;
              this.complete();
            }
            try {
              while (true) {
                yield this.doDecodeSync();
                if (--arrayItemsLeft === 0) {
                  break;
                }
              }
            } catch (e10) {
              if (!(e10 instanceof RangeError)) {
                throw e10;
              }
            }
            this.totalPos += this.pos;
          }
        } finally {
          this.entered = false;
        }
      }
      doDecodeSync() {
        DECODE: while (true) {
          const headByte = this.readHeadByte();
          let object;
          if (headByte >= 224) {
            object = headByte - 256;
          } else if (headByte < 192) {
            if (headByte < 128) {
              object = headByte;
            } else if (headByte < 144) {
              const size4 = headByte - 128;
              if (size4 !== 0) {
                this.pushMapState(size4);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte < 160) {
              const size4 = headByte - 144;
              if (size4 !== 0) {
                this.pushArrayState(size4);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else {
              const byteLength = headByte - 160;
              object = this.decodeString(byteLength, 0);
            }
          } else if (headByte === 192) {
            object = null;
          } else if (headByte === 194) {
            object = false;
          } else if (headByte === 195) {
            object = true;
          } else if (headByte === 202) {
            object = this.readF32();
          } else if (headByte === 203) {
            object = this.readF64();
          } else if (headByte === 204) {
            object = this.readU8();
          } else if (headByte === 205) {
            object = this.readU16();
          } else if (headByte === 206) {
            object = this.readU32();
          } else if (headByte === 207) {
            if (this.useBigInt64) {
              object = this.readU64AsBigInt();
            } else {
              object = this.readU64();
            }
          } else if (headByte === 208) {
            object = this.readI8();
          } else if (headByte === 209) {
            object = this.readI16();
          } else if (headByte === 210) {
            object = this.readI32();
          } else if (headByte === 211) {
            if (this.useBigInt64) {
              object = this.readI64AsBigInt();
            } else {
              object = this.readI64();
            }
          } else if (headByte === 217) {
            const byteLength = this.lookU8();
            object = this.decodeString(byteLength, 1);
          } else if (headByte === 218) {
            const byteLength = this.lookU16();
            object = this.decodeString(byteLength, 2);
          } else if (headByte === 219) {
            const byteLength = this.lookU32();
            object = this.decodeString(byteLength, 4);
          } else if (headByte === 220) {
            const size4 = this.readU16();
            if (size4 !== 0) {
              this.pushArrayState(size4);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 221) {
            const size4 = this.readU32();
            if (size4 !== 0) {
              this.pushArrayState(size4);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else if (headByte === 222) {
            const size4 = this.readU16();
            if (size4 !== 0) {
              this.pushMapState(size4);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 223) {
            const size4 = this.readU32();
            if (size4 !== 0) {
              this.pushMapState(size4);
              this.complete();
              continue DECODE;
            } else {
              object = {};
            }
          } else if (headByte === 196) {
            const size4 = this.lookU8();
            object = this.decodeBinary(size4, 1);
          } else if (headByte === 197) {
            const size4 = this.lookU16();
            object = this.decodeBinary(size4, 2);
          } else if (headByte === 198) {
            const size4 = this.lookU32();
            object = this.decodeBinary(size4, 4);
          } else if (headByte === 212) {
            object = this.decodeExtension(1, 0);
          } else if (headByte === 213) {
            object = this.decodeExtension(2, 0);
          } else if (headByte === 214) {
            object = this.decodeExtension(4, 0);
          } else if (headByte === 215) {
            object = this.decodeExtension(8, 0);
          } else if (headByte === 216) {
            object = this.decodeExtension(16, 0);
          } else if (headByte === 199) {
            const size4 = this.lookU8();
            object = this.decodeExtension(size4, 1);
          } else if (headByte === 200) {
            const size4 = this.lookU16();
            object = this.decodeExtension(size4, 2);
          } else if (headByte === 201) {
            const size4 = this.lookU32();
            object = this.decodeExtension(size4, 4);
          } else {
            throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
          }
          this.complete();
          const stack = this.stack;
          while (stack.length > 0) {
            const state24 = stack.top();
            if (state24.type === STATE_ARRAY) {
              state24.array[state24.position] = object;
              state24.position++;
              if (state24.position === state24.size) {
                object = state24.array;
                stack.release(state24);
              } else {
                continue DECODE;
              }
            } else if (state24.type === STATE_MAP_KEY) {
              if (object === "__proto__") {
                throw new DecodeError("The key __proto__ is not allowed");
              }
              state24.key = this.mapKeyConverter(object);
              state24.type = STATE_MAP_VALUE;
              continue DECODE;
            } else {
              state24.map[state24.key] = object;
              state24.readCount++;
              if (state24.readCount === state24.size) {
                object = state24.map;
                stack.release(state24);
              } else {
                state24.key = null;
                state24.type = STATE_MAP_KEY;
                continue DECODE;
              }
            }
          }
          return object;
        }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
            }
          }
        }
      }
      pushMapState(size4) {
        if (size4 > this.maxMapLength) {
          throw new DecodeError(`Max length exceeded: map length (${size4}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.pushMapState(size4);
      }
      pushArrayState(size4) {
        if (size4 > this.maxArrayLength) {
          throw new DecodeError(`Max length exceeded: array length (${size4}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.pushArrayState(size4);
      }
      decodeString(byteLength, headerOffset) {
        if (!this.rawStrings || this.stateIsMapKey()) {
          return this.decodeUtf8String(byteLength, headerOffset);
        }
        return this.decodeBinary(byteLength, headerOffset);
      }
      /**
       * @throws {@link RangeError}
       */
      decodeUtf8String(byteLength, headerOffset) {
        if (byteLength > this.maxStrLength) {
          throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else {
          object = utf8Decode(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state24 = this.stack.top();
          return state24.type === STATE_MAP_KEY;
        }
        return false;
      }
      /**
       * @throws {@link RangeError}
       */
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size4, headOffset) {
        if (size4 > this.maxExtLength) {
          throw new DecodeError(`Max length exceeded: ext length (${size4}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size4,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = getUint64(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = getInt64(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readU64AsBigInt() {
        const value = this.view.getBigUint64(this.pos);
        this.pos += 8;
        return value;
      }
      readI64AsBigInt() {
        const value = this.view.getBigInt64(this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
  }
});

// node_modules/@msgpack/msgpack/dist.esm/decode.mjs
function decode(buffer3, options) {
  const decoder = new Decoder(options);
  return decoder.decode(buffer3);
}
var init_decode = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/decode.mjs"() {
    init_Decoder();
  }
});

// node_modules/@msgpack/msgpack/dist.esm/index.mjs
var init_dist4 = __esm({
  "node_modules/@msgpack/msgpack/dist.esm/index.mjs"() {
    init_encode();
    init_decode();
  }
});

// node_modules/uint8arrays/esm/src/compare.js
var init_compare = __esm({
  "node_modules/uint8arrays/esm/src/compare.js"() {
  }
});

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
var init_as_uint8array = __esm({
  "node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
  }
});

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size4 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size4));
  }
  return new Uint8Array(size4);
}
var init_alloc = __esm({
  "node_modules/uint8arrays/esm/src/alloc.js"() {
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/equals.js
var init_equals = __esm({
  "node_modules/uint8arrays/esm/src/equals.js"() {
  }
});

// node_modules/multiformats/esm/vendor/base-x.js
function base2(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j7 = 0; j7 < BASE_MAP.length; j7++) {
    BASE_MAP[j7] = 255;
  }
  for (var i11 = 0; i11 < ALPHABET2.length; i11++) {
    var x7 = ALPHABET2.charAt(i11);
    var xc2 = x7.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x7 + " is ambiguous");
    }
    BASE_MAP[xc2] = i11;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode6(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size4 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size4);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i12 = 0;
      for (var it1 = size4 - 1; (carry !== 0 || i12 < length2) && it1 !== -1; it1--, i12++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i12;
      pbegin++;
    }
    var it22 = size4 - length2;
    while (it22 !== size4 && b58[it22] === 0) {
      it22++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it22 < size4; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size4 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size4);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i12 = 0;
      for (var it32 = size4 - 1; (carry !== 0 || i12 < length2) && it32 !== -1; it32--, i12++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i12;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size4 - length2;
    while (it4 !== size4 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size4 - it4));
    var j8 = zeroes;
    while (it4 !== size4) {
      vch[j8++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string2) {
    var buffer3 = decodeUnsafe(string2);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode6,
    decodeUnsafe,
    decode: decode7
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/multiformats/esm/vendor/base-x.js"() {
    src = base2;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/multiformats/esm/src/bytes.js
var empty, equals, coerce, fromString, toString;
var init_bytes = __esm({
  "node_modules/multiformats/esm/src/bytes.js"() {
    empty = new Uint8Array(0);
    equals = (aa2, bb) => {
      if (aa2 === bb)
        return true;
      if (aa2.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii4 = 0; ii4 < aa2.byteLength; ii4++) {
        if (aa2[ii4] !== bb[ii4]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o13) => {
      if (o13 instanceof Uint8Array && o13.constructor.name === "Uint8Array")
        return o13;
      if (o13 instanceof ArrayBuffer)
        return new Uint8Array(o13);
      if (ArrayBuffer.isView(o13)) {
        return new Uint8Array(o13.buffer, o13.byteOffset, o13.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b7) => new TextDecoder().decode(b7);
  }
});

// node_modules/multiformats/esm/src/bases/base.js
var Encoder2, Decoder2, ComposedDecoder, or2, Codec, from, baseX, decode2, encode2, rfc4648;
var init_base2 = __esm({
  "node_modules/multiformats/esm/src/bases/base.js"() {
    init_base_x();
    init_bytes();
    Encoder2 = class {
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder2 = class {
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or2(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or2(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or2 = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name2, prefix, baseEncode);
        this.decoder = new Decoder2(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name2, prefix, encode: encode6, decode: decode7 }) => new Codec(name2, prefix, encode6, decode7);
    baseX = ({ prefix, name: name2, alphabet: alphabet3 }) => {
      const { encode: encode6, decode: decode7 } = base_x_default(alphabet3, name2);
      return from({
        prefix,
        name: name2,
        encode: encode6,
        decode: (text) => coerce(decode7(text))
      });
    };
    decode2 = (string2, alphabet3, bitsPerChar, name2) => {
      const codes = {};
      for (let i11 = 0; i11 < alphabet3.length; ++i11) {
        codes[alphabet3[i11]] = i11;
      }
      let end = string2.length;
      while (string2[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i11 = 0; i11 < end; ++i11) {
        const value = codes[string2[i11]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name2} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode2 = (data, alphabet3, bitsPerChar) => {
      const pad3 = alphabet3[alphabet3.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i11 = 0; i11 < data.length; ++i11) {
        buffer3 = buffer3 << 8 | data[i11];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet3[mask & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet3[mask & buffer3 << bitsPerChar - bits];
      }
      if (pad3) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet3 }) => {
      return from({
        prefix,
        name: name2,
        encode(input) {
          return encode2(input, alphabet3, bitsPerChar);
        },
        decode(input) {
          return decode2(input, alphabet3, bitsPerChar, name2);
        }
      });
    };
  }
});

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "node_modules/multiformats/esm/src/bases/identity.js"() {
    init_base2();
    init_bytes();
    identity = from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => toString(buf),
      decode: (str) => fromString(str)
    });
  }
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base22
});
var base22;
var init_base22 = __esm({
  "node_modules/multiformats/esm/src/bases/base2.js"() {
    init_base2();
    base22 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "node_modules/multiformats/esm/src/bases/base8.js"() {
    init_base2();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "node_modules/multiformats/esm/src/bases/base10.js"() {
    init_base2();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "node_modules/multiformats/esm/src/bases/base16.js"() {
    init_base2();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base322,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base322, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/multiformats/esm/src/bases/base32.js"() {
    init_base2();
    base322 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/multiformats/esm/src/bases/base36.js"() {
    init_base2();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/multiformats/esm/src/bases/base58.js"() {
    init_base2();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base642,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base642, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "node_modules/multiformats/esm/src/bases/base64.js"() {
    init_base2();
    base642 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
function encode3(data) {
  return data.reduce((p8, c12) => {
    p8 += alphabetBytesToChars[c12];
    return p8;
  }, "");
}
function decode3(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var alphabet2, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
var init_base256emoji = __esm({
  "node_modules/multiformats/esm/src/bases/base256emoji.js"() {
    init_base2();
    alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    alphabetBytesToChars = alphabet2.reduce((p8, c12, i11) => {
      p8[i11] = c12;
      return p8;
    }, []);
    alphabetCharsToBytes = alphabet2.reduce((p8, c12, i11) => {
      p8[c12.codePointAt(0)] = i11;
      return p8;
    }, []);
    base256emoji = from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode3,
      decode: decode3
    });
  }
});

// node_modules/multiformats/esm/vendor/varint.js
function encode4(num2, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num2 >= INT) {
    out[offset++] = num2 & 255 | MSB;
    num2 /= 128;
  }
  while (num2 & MSBALL) {
    out[offset++] = num2 & 255 | MSB;
    num2 >>>= 7;
  }
  out[offset] = num2 | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b7, l10 = buf.length;
  do {
    if (counter >= l10) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b7 = buf[counter++];
    res += shift < 28 ? (b7 & REST$1) << shift : (b7 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b7 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode4, MSB$1, REST$1, N1, N22, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/multiformats/esm/vendor/varint.js"() {
    encode_1 = encode4;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode4 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N22 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N22 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode4,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/multiformats/esm/src/varint.js
var decode5, encodeTo, encodingLength;
var init_varint2 = __esm({
  "node_modules/multiformats/esm/src/varint.js"() {
    init_varint();
    decode5 = (data, offset = 0) => {
      const code2 = varint_default.decode(data, offset);
      return [
        code2,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int2, target, offset = 0) => {
      varint_default.encode(int2, target, offset);
      return target;
    };
    encodingLength = (int2) => {
      return varint_default.encodingLength(int2);
    };
  }
});

// node_modules/multiformats/esm/src/hashes/digest.js
var create, decode6, equals2, Digest;
var init_digest = __esm({
  "node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    create = (code2, digest2) => {
      const size4 = digest2.byteLength;
      const sizeOffset = encodingLength(code2);
      const digestOffset = sizeOffset + encodingLength(size4);
      const bytes2 = new Uint8Array(digestOffset + size4);
      encodeTo(code2, bytes2, 0);
      encodeTo(size4, bytes2, sizeOffset);
      bytes2.set(digest2, digestOffset);
      return new Digest(code2, size4, digest2, bytes2);
    };
    decode6 = (multihash) => {
      const bytes2 = coerce(multihash);
      const [code2, sizeOffset] = decode5(bytes2);
      const [size4, digestOffset] = decode5(bytes2.subarray(sizeOffset));
      const digest2 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest2.byteLength !== size4) {
        throw new Error("Incorrect length");
      }
      return new Digest(code2, size4, digest2, bytes2);
    };
    equals2 = (a5, b7) => {
      if (a5 === b7) {
        return true;
      } else {
        return a5.code === b7.code && a5.size === b7.size && equals(a5.bytes, b7.bytes);
      }
    };
    Digest = class {
      constructor(code2, size4, digest2, bytes2) {
        this.code = code2;
        this.size = size4;
        this.digest = digest2;
        this.bytes = bytes2;
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_digest();
    from2 = ({ name: name2, code: code2, encode: encode6 }) => new Hasher(name2, code2, encode6);
    Hasher = class {
      constructor(name2, code2, encode6) {
        this.name = name2;
        this.code = code2;
        this.encode = encode6;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha2563,
  sha512: () => sha5122
});
var sha, sha2563, sha5122;
var init_sha2_browser = __esm({
  "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
    sha2563 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha5122 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code, name, encode5, digest, identity2;
var init_identity2 = __esm({
  "node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_bytes();
    init_digest();
    code = 0;
    name = "identity";
    encode5 = coerce;
    digest = (input) => create(code, encode5(input));
    identity2 = {
      code,
      name,
      encode: encode5,
      digest
    };
  }
});

// node_modules/multiformats/esm/src/codecs/raw.js
var init_raw = __esm({
  "node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_bytes();
  }
});

// node_modules/multiformats/esm/src/codecs/json.js
var textEncoder, textDecoder;
var init_json = __esm({
  "node_modules/multiformats/esm/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
  }
});

// node_modules/multiformats/esm/src/cid.js
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version2, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multiformats/esm/src/cid.js"() {
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class _CID {
      constructor(version4, code2, multihash, bytes2) {
        this.code = code2;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code2, multihash } = this;
            if (code2 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code2, digest: digest2 } = this.multihash;
            const multihash = create(code2, digest2);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes: bytes2, version: version4, _baseCache } = this;
        switch (version4) {
          case 0:
            return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes2, _baseCache, base3 || base322.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version4, code: code2, multihash, bytes: bytes2 } = value;
          return new _CID(version4, code2, multihash, bytes2 || encodeCID(version4, code2, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version4, multihash, code: code2 } = value;
          const digest2 = decode6(multihash);
          return _CID.create(version4, code2, digest2);
        } else {
          return null;
        }
      }
      static create(version4, code2, digest2) {
        if (typeof code2 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version4) {
          case 0: {
            if (code2 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version4, code2, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID(version4, code2, digest2.bytes);
            return new _CID(version4, code2, digest2, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return _CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code2, digest2) {
        return _CID.create(1, code2, digest2);
      }
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes2) {
        const specs = _CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
        return [
          cid,
          bytes2.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i11, length2] = decode5(initialBytes.subarray(offset));
          offset += length2;
          return i11;
        };
        let version4 = next();
        let codec = DAG_PB_CODE;
        if (version4 === 18) {
          version4 = 0;
          offset = 0;
        } else if (version4 === 1) {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size4 = offset + digestSize;
        const multihashSize = size4 - prefixSize;
        return {
          version: version4,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size: size4
        };
      }
      static parse(source, base3) {
        const [prefix, bytes2] = parseCIDtoBytes(source, base3);
        const cid = _CID.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base322.prefix: {
          const decoder = base3 || base322;
          return [
            base322.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes2).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes2, cache, base3) => {
      const { prefix } = base3;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes2);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version4, code2, multihash) => {
      const codeOffset = encodingLength(version4);
      const hashOffset = codeOffset + encodingLength(code2);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version4, bytes2, 0);
      encodeTo(code2, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version2 = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "node_modules/multiformats/esm/src/index.js"() {
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multiformats/esm/src/basics.js
var bases, hashes;
var init_basics = __esm({
  "node_modules/multiformats/esm/src/basics.js"() {
    init_identity();
    init_base22();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_base256emoji();
    init_sha2_browser();
    init_identity2();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports,
      ...base256emoji_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports2
    };
  }
});

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode6, decode7) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode6
    },
    decoder: { decode: decode7 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_basics();
    init_alloc();
    string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str) => {
      const encoder4 = new TextEncoder();
      return encoder4.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i11 = 0; i11 < buf.length; i11++) {
        string2 += String.fromCharCode(buf[i11]);
      }
      return string2;
    }, (str) => {
      str = str.substring(1);
      const buf = allocUnsafe(str.length);
      for (let i11 = 0; i11 < str.length; i11++) {
        buf[i11] = str.charCodeAt(i11);
      }
      return buf;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
var init_from_string = __esm({
  "node_modules/uint8arrays/esm/src/from-string.js"() {
    init_bases();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "node_modules/uint8arrays/esm/src/to-string.js"() {
    init_bases();
  }
});

// node_modules/uint8arrays/esm/src/xor.js
var init_xor = __esm({
  "node_modules/uint8arrays/esm/src/xor.js"() {
    init_alloc();
    init_as_uint8array();
  }
});

// node_modules/uint8arrays/esm/src/index.js
var init_src2 = __esm({
  "node_modules/uint8arrays/esm/src/index.js"() {
    init_compare();
    init_concat();
    init_equals();
    init_from_string();
    init_to_string();
    init_xor();
  }
});

// node_modules/@walletconnect/relay-api/dist/index.es.js
var C2;
var init_index_es6 = __esm({
  "node_modules/@walletconnect/relay-api/dist/index.es.js"() {
    C2 = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };
  }
});

// node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder4 = new TextEncoder();
        ret = encoder4.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex3(bytes2) {
      return Array.prototype.map.call(bytes2, function(n12) {
        return (n12 < 16 ? "0" : "") + n12.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size4) {
      let msg = "\n" + label + " = ";
      for (let i11 = 0; i11 < arr.length; i11 += 2) {
        if (size4 === 32) {
          msg += uint32ToHex(arr[i11]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i11 + 1]).toUpperCase();
        } else if (size4 === 64) {
          msg += uint32ToHex(arr[i11 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i11]).toUpperCase();
        } else throw new Error("Invalid size " + size4);
        if (i11 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i11 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N15, M6) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N15);
      for (let i11 = 0; i11 < N15; i11++) {
        input[i11] = i11 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i11 = 0; i11 < M6; i11++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms2 = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms2 + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N15 / (1 << 20) / (ms2 / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex: toHex3,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v9, a5, b7) {
      const o0 = v9[a5] + v9[b7];
      let o1 = v9[a5 + 1] + v9[b7 + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v9[a5] = o0;
      v9[a5 + 1] = o1;
    }
    function ADD64AC(v9, a5, b0, b1) {
      let o0 = v9[a5] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v9[a5 + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v9[a5] = o0;
      v9[a5 + 1] = o1;
    }
    function B2B_GET32(arr, i11) {
      return arr[i11] ^ arr[i11 + 1] << 8 ^ arr[i11 + 2] << 16 ^ arr[i11 + 3] << 24;
    }
    function B2B_G(a5, b7, c12, d7, ix, iy) {
      const x0 = m6[ix];
      const x1 = m6[ix + 1];
      const y0 = m6[iy];
      const y1 = m6[iy + 1];
      ADD64AA(v8, a5, b7);
      ADD64AC(v8, a5, x0, x1);
      let xor0 = v8[d7] ^ v8[a5];
      let xor1 = v8[d7 + 1] ^ v8[a5 + 1];
      v8[d7] = xor1;
      v8[d7 + 1] = xor0;
      ADD64AA(v8, c12, d7);
      xor0 = v8[b7] ^ v8[c12];
      xor1 = v8[b7 + 1] ^ v8[c12 + 1];
      v8[b7] = xor0 >>> 24 ^ xor1 << 8;
      v8[b7 + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v8, a5, b7);
      ADD64AC(v8, a5, y0, y1);
      xor0 = v8[d7] ^ v8[a5];
      xor1 = v8[d7 + 1] ^ v8[a5 + 1];
      v8[d7] = xor0 >>> 16 ^ xor1 << 16;
      v8[d7 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v8, c12, d7);
      xor0 = v8[b7] ^ v8[c12];
      xor1 = v8[b7 + 1] ^ v8[c12 + 1];
      v8[b7] = xor1 >>> 31 ^ xor0 << 1;
      v8[b7 + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x7) {
        return x7 * 2;
      })
    );
    var v8 = new Uint32Array(32);
    var m6 = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i11 = 0;
      for (i11 = 0; i11 < 16; i11++) {
        v8[i11] = ctx.h[i11];
        v8[i11 + 16] = BLAKE2B_IV32[i11];
      }
      v8[24] = v8[24] ^ ctx.t;
      v8[25] = v8[25] ^ ctx.t / 4294967296;
      if (last) {
        v8[28] = ~v8[28];
        v8[29] = ~v8[29];
      }
      for (i11 = 0; i11 < 32; i11++) {
        m6[i11] = B2B_GET32(ctx.b, 4 * i11);
      }
      for (i11 = 0; i11 < 12; i11++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i11 * 16 + 0], SIGMA82[i11 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i11 * 16 + 2], SIGMA82[i11 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i11 * 16 + 4], SIGMA82[i11 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i11 * 16 + 6], SIGMA82[i11 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i11 * 16 + 8], SIGMA82[i11 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i11 * 16 + 10], SIGMA82[i11 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i11 * 16 + 12], SIGMA82[i11 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i11 * 16 + 14], SIGMA82[i11 * 16 + 15]);
      }
      for (i11 = 0; i11 < 16; i11++) {
        ctx.h[i11] = ctx.h[i11] ^ v8[i11] ^ v8[i11 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i11 = 0; i11 < 16; i11++) {
        ctx.h[i11] = BLAKE2B_IV32[i11] ^ B2B_GET32(parameterBlock, i11 * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i11 = 0; i11 < input.length; i11++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i11];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i11 = 0; i11 < ctx.outlen; i11++) {
        out[i11] = ctx.h[i11 >> 2] >> 8 * (i11 & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output2 = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output2);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v9, i11) {
      return v9[i11] ^ v9[i11 + 1] << 8 ^ v9[i11 + 2] << 16 ^ v9[i11 + 3] << 24;
    }
    function B2S_G(a5, b7, c12, d7, x7, y9) {
      v8[a5] = v8[a5] + v8[b7] + x7;
      v8[d7] = ROTR32(v8[d7] ^ v8[a5], 16);
      v8[c12] = v8[c12] + v8[d7];
      v8[b7] = ROTR32(v8[b7] ^ v8[c12], 12);
      v8[a5] = v8[a5] + v8[b7] + y9;
      v8[d7] = ROTR32(v8[d7] ^ v8[a5], 8);
      v8[c12] = v8[c12] + v8[d7];
      v8[b7] = ROTR32(v8[b7] ^ v8[c12], 7);
    }
    function ROTR32(x7, y9) {
      return x7 >>> y9 ^ x7 << 32 - y9;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v8 = new Uint32Array(16);
    var m6 = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i11 = 0;
      for (i11 = 0; i11 < 8; i11++) {
        v8[i11] = ctx.h[i11];
        v8[i11 + 8] = BLAKE2S_IV[i11];
      }
      v8[12] ^= ctx.t;
      v8[13] ^= ctx.t / 4294967296;
      if (last) {
        v8[14] = ~v8[14];
      }
      for (i11 = 0; i11 < 16; i11++) {
        m6[i11] = B2S_GET32(ctx.b, 4 * i11);
      }
      for (i11 = 0; i11 < 10; i11++) {
        B2S_G(0, 4, 8, 12, m6[SIGMA[i11 * 16 + 0]], m6[SIGMA[i11 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m6[SIGMA[i11 * 16 + 2]], m6[SIGMA[i11 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m6[SIGMA[i11 * 16 + 4]], m6[SIGMA[i11 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m6[SIGMA[i11 * 16 + 6]], m6[SIGMA[i11 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m6[SIGMA[i11 * 16 + 8]], m6[SIGMA[i11 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m6[SIGMA[i11 * 16 + 10]], m6[SIGMA[i11 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m6[SIGMA[i11 * 16 + 12]], m6[SIGMA[i11 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m6[SIGMA[i11 * 16 + 14]], m6[SIGMA[i11 * 16 + 15]]);
      }
      for (i11 = 0; i11 < 8; i11++) {
        ctx.h[i11] ^= v8[i11] ^ v8[i11 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i11 = 0; i11 < input.length; i11++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i11];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i11 = 0; i11 < ctx.outlen; i11++) {
        out[i11] = ctx.h[i11 >> 2] >> 8 * (i11 & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output2 = blake2s(input, key, outlen);
      return util.toHex(output2);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/@walletconnect/utils/dist/index.es.js
function Fe(t5) {
  const [e10, n12] = t5.split(xe2);
  return { namespace: e10, reference: n12 };
}
function ve2(t5, e10) {
  return t5.includes(":") ? [t5] : e10.chains || [];
}
function Ye2() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Bt2() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === er2;
}
function Ms() {
  return Bt2() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Vs() {
  return Bt2() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function zt2() {
  return !Ye2() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function Pt2() {
  return Bt2() ? J3.reactNative : Ye2() ? J3.node : zt2() ? J3.browser : J3.unknown;
}
function qs() {
  var t5;
  try {
    return Bt2() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t5 = global.Application) == null ? void 0 : t5.applicationId : void 0;
  } catch {
    return;
  }
}
function or3(t5, e10) {
  const n12 = new URLSearchParams(t5);
  for (const r9 of Object.keys(e10).sort()) if (e10.hasOwnProperty(r9)) {
    const o13 = e10[r9];
    o13 !== void 0 && n12.set(r9, o13);
  }
  return n12.toString();
}
function Ks(t5) {
  var e10, n12;
  const r9 = sr2();
  try {
    return t5 != null && t5.url && r9.url && new URL(t5.url).host !== new URL(r9.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t5.url} differs from the actual page url:${r9.url}. This is probably unintended and can lead to issues.`), t5.url = r9.url), (e10 = t5?.icons) != null && e10.length && t5.icons.length > 0 && (t5.icons = t5.icons.filter((o13) => o13 !== "")), Ps(Qn2(Qn2({}, r9), t5), { url: t5?.url || r9.url, name: t5?.name || r9.name, description: t5?.description || r9.description, icons: (n12 = t5?.icons) != null && n12.length && t5.icons.length > 0 ? t5.icons : r9.icons });
  } catch (o13) {
    return console.warn("Error populating app metadata", o13), t5 || r9;
  }
}
function sr2() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ir2() {
  if (Pt2() === J3.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n12, Version: r9 } = global.Platform;
    return [n12, r9].join("-");
  }
  const t5 = detect();
  if (t5 === null) return "unknown";
  const e10 = t5.os ? t5.os.replace(" ", "").toLowerCase() : "unknown";
  return t5.type === "browser" ? [e10, t5.name, t5.version].join("-") : [e10, t5.version].join("-");
}
function fr2() {
  var t5;
  const e10 = Pt2();
  return e10 === J3.browser ? [e10, ((t5 = (0, import_window_getters.getLocation)()) == null ? void 0 : t5.host) || "unknown"].join(":") : e10;
}
function cr2(t5, e10, n12) {
  const r9 = ir2(), o13 = fr2();
  return [[t5, e10].join("-"), [rr2, n12].join("-"), r9, o13].join("/");
}
function zs({ protocol: t5, version: e10, relayUrl: n12, sdkVersion: r9, auth: o13, projectId: s8, useOnCloseEvent: i11, bundleId: f13, packageName: a5 }) {
  const l10 = n12.split("?"), c12 = cr2(t5, e10, r9), u6 = { auth: o13, ua: c12, projectId: s8, useOnCloseEvent: i11 || void 0, packageName: a5 || void 0, bundleId: f13 || void 0 }, h12 = or3(l10[1] || "", u6);
  return l10[0] + "?" + h12;
}
function It2(t5, e10) {
  return t5.filter((n12) => e10.includes(n12)).length === t5.length;
}
function Ys(t5) {
  return Object.fromEntries(t5.entries());
}
function Xs(t5) {
  return new Map(Object.entries(t5));
}
function ei(t5 = import_time3.FIVE_MINUTES, e10) {
  const n12 = (0, import_time3.toMiliseconds)(t5 || import_time3.FIVE_MINUTES);
  let r9, o13, s8, i11;
  return { resolve: (f13) => {
    s8 && r9 && (clearTimeout(s8), r9(f13), i11 = Promise.resolve(f13));
  }, reject: (f13) => {
    s8 && o13 && (clearTimeout(s8), o13(f13));
  }, done: () => new Promise((f13, a5) => {
    if (i11) return f13(i11);
    s8 = setTimeout(() => {
      const l10 = new Error(e10);
      i11 = Promise.reject(l10), a5(l10);
    }, n12), r9 = f13, o13 = a5;
  }) };
}
function ni(t5, e10, n12) {
  return new Promise(async (r9, o13) => {
    const s8 = setTimeout(() => o13(new Error(n12)), e10);
    try {
      const i11 = await t5;
      r9(i11);
    } catch (i11) {
      o13(i11);
    }
    clearTimeout(s8);
  });
}
function Xe2(t5, e10) {
  if (typeof e10 == "string" && e10.startsWith(`${t5}:`)) return e10;
  if (t5.toLowerCase() === "topic") {
    if (typeof e10 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e10}`;
  } else if (t5.toLowerCase() === "id") {
    if (typeof e10 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e10}`;
  }
  throw new Error(`Unknown expirer target type: ${t5}`);
}
function ri(t5) {
  return Xe2("topic", t5);
}
function oi(t5) {
  return Xe2("id", t5);
}
function si(t5) {
  const [e10, n12] = t5.split(":"), r9 = { id: void 0, topic: void 0 };
  if (e10 === "topic" && typeof n12 == "string") r9.topic = n12;
  else if (e10 === "id" && Number.isInteger(Number(n12))) r9.id = Number(n12);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e10}:${n12}`);
  return r9;
}
function ii(t5, e10) {
  return (0, import_time3.fromMiliseconds)((e10 || Date.now()) + (0, import_time3.toMiliseconds)(t5));
}
function fi(t5) {
  return Date.now() >= (0, import_time3.toMiliseconds)(t5);
}
function ci(t5, e10) {
  return `${t5}${e10 ? `:${e10}` : ""}`;
}
function ct2(t5 = [], e10 = []) {
  return [.../* @__PURE__ */ new Set([...t5, ...e10])];
}
async function ai({ id: t5, topic: e10, wcDeepLink: n12 }) {
  var r9;
  try {
    if (!n12) return;
    const o13 = typeof n12 == "string" ? JSON.parse(n12) : n12, s8 = o13?.href;
    if (typeof s8 != "string") return;
    const i11 = dr2(s8, t5, e10), f13 = Pt2();
    if (f13 === J3.browser) {
      if (!((r9 = (0, import_window_getters.getDocument)()) != null && r9.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      hr2(i11);
    } else f13 === J3.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i11);
  } catch (o13) {
    console.error(o13);
  }
}
function dr2(t5, e10, n12) {
  const r9 = `requestId=${e10}&sessionTopic=${n12}`;
  t5.endsWith("/") && (t5 = t5.slice(0, -1));
  let o13 = `${t5}`;
  if (t5.startsWith("https://t.me")) {
    const s8 = t5.includes("?") ? "&startapp=" : "?startapp=";
    o13 = `${o13}${s8}${br2(r9, true)}`;
  } else o13 = `${o13}/wc?${r9}`;
  return o13;
}
function hr2(t5) {
  let e10 = "_self";
  gr2() ? e10 = "_top" : (pr2() || t5.startsWith("https://") || t5.startsWith("http://")) && (e10 = "_blank"), window.open(t5, e10, "noreferrer noopener");
}
async function ui(t5, e10) {
  let n12 = "";
  try {
    if (zt2() && (n12 = localStorage.getItem(e10), n12)) return n12;
    n12 = await t5.getItem(e10);
  } catch (r9) {
    console.error(r9);
  }
  return n12;
}
function li(t5, e10) {
  if (!t5.includes(e10)) return null;
  const n12 = t5.split(/([&,?,=])/), r9 = n12.indexOf(e10);
  return n12[r9 + 2];
}
function di() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t5) => {
    const e10 = Math.random() * 16 | 0;
    return (t5 === "x" ? e10 : e10 & 3 | 8).toString(16);
  });
}
function hi() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function pr2() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function gr2() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function br2(t5, e10 = false) {
  const n12 = Buffer.from(t5).toString("base64");
  return e10 ? n12.replace(/[=]/g, "") : n12;
}
function Qe2(t5) {
  return Buffer.from(t5, "base64").toString("utf-8");
}
function pi(t5) {
  return new Promise((e10) => setTimeout(e10, t5));
}
function mr2(t5, e10 = false) {
  return e10 ? { h: Number(t5 & Be2), l: Number(t5 >> yr2 & Be2) } : { h: Number(t5 >> yr2 & Be2) | 0, l: Number(t5 & Be2) | 0 };
}
function wr2(t5, e10 = false) {
  const n12 = t5.length;
  let r9 = new Uint32Array(n12), o13 = new Uint32Array(n12);
  for (let s8 = 0; s8 < n12; s8++) {
    const { h: i11, l: f13 } = mr2(t5[s8], e10);
    [r9[s8], o13[s8]] = [i11, f13];
  }
  return [r9, o13];
}
function dt2(t5, e10, n12, r9) {
  const o13 = (e10 >>> 0) + (r9 >>> 0);
  return { h: t5 + n12 + (o13 / 2 ** 32 | 0) | 0, l: o13 | 0 };
}
function nn2(t5) {
  return t5 instanceof Uint8Array || ArrayBuffer.isView(t5) && t5.constructor.name === "Uint8Array";
}
function mt(t5) {
  if (!Number.isSafeInteger(t5) || t5 < 0) throw new Error("positive integer expected, got " + t5);
}
function at(t5, ...e10) {
  if (!nn2(t5)) throw new Error("Uint8Array expected");
  if (e10.length > 0 && !e10.includes(t5.length)) throw new Error("Uint8Array expected of length " + e10 + ", got length=" + t5.length);
}
function rn2(t5) {
  if (typeof t5 != "function" || typeof t5.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t5.outputLen), mt(t5.blockLen);
}
function Nt2(t5, e10 = true) {
  if (t5.destroyed) throw new Error("Hash instance has been destroyed");
  if (e10 && t5.finished) throw new Error("Hash#digest() has already been called");
}
function on2(t5, e10) {
  at(t5);
  const n12 = e10.outputLen;
  if (t5.length < n12) throw new Error("digestInto() expects output buffer of length at least " + n12);
}
function fe2(t5) {
  return new Uint32Array(t5.buffer, t5.byteOffset, Math.floor(t5.byteLength / 4));
}
function ut2(...t5) {
  for (let e10 = 0; e10 < t5.length; e10++) t5[e10].fill(0);
}
function sn2(t5) {
  return new DataView(t5.buffer, t5.byteOffset, t5.byteLength);
}
function gt2(t5, e10) {
  return t5 << 32 - e10 | t5 >>> e10;
}
function Br2(t5) {
  return t5 << 24 & 4278190080 | t5 << 8 & 16711680 | t5 >>> 8 & 65280 | t5 >>> 24 & 255;
}
function Si(t5) {
  for (let e10 = 0; e10 < t5.length; e10++) t5[e10] = Br2(t5[e10]);
  return t5;
}
function ce(t5) {
  if (at(t5), Ir2) return t5.toHex();
  let e10 = "";
  for (let n12 = 0; n12 < t5.length; n12++) e10 += Ni[t5[n12]];
  return e10;
}
function Ar2(t5) {
  if (t5 >= xt2._0 && t5 <= xt2._9) return t5 - xt2._0;
  if (t5 >= xt2.A && t5 <= xt2.F) return t5 - (xt2.A - 10);
  if (t5 >= xt2.a && t5 <= xt2.f) return t5 - (xt2.a - 10);
}
function fn(t5) {
  if (typeof t5 != "string") throw new Error("hex string expected, got " + typeof t5);
  if (Ir2) return Uint8Array.fromHex(t5);
  const e10 = t5.length, n12 = e10 / 2;
  if (e10 % 2) throw new Error("hex string expected, got unpadded hex of length " + e10);
  const r9 = new Uint8Array(n12);
  for (let o13 = 0, s8 = 0; o13 < n12; o13++, s8 += 2) {
    const i11 = Ar2(t5.charCodeAt(s8)), f13 = Ar2(t5.charCodeAt(s8 + 1));
    if (i11 === void 0 || f13 === void 0) {
      const a5 = t5[s8] + t5[s8 + 1];
      throw new Error('hex string expected, got non-hex character "' + a5 + '" at index ' + s8);
    }
    r9[o13] = i11 * 16 + f13;
  }
  return r9;
}
function Oi(t5) {
  if (typeof t5 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t5));
}
function ht2(t5) {
  return typeof t5 == "string" && (t5 = Oi(t5)), at(t5), t5;
}
function Ht2(...t5) {
  let e10 = 0;
  for (let r9 = 0; r9 < t5.length; r9++) {
    const o13 = t5[r9];
    at(o13), e10 += o13.length;
  }
  const n12 = new Uint8Array(e10);
  for (let r9 = 0, o13 = 0; r9 < t5.length; r9++) {
    const s8 = t5[r9];
    n12.set(s8, o13), o13 += s8.length;
  }
  return n12;
}
function ae(t5) {
  const e10 = (r9) => t5().update(ht2(r9)).digest(), n12 = t5();
  return e10.outputLen = n12.outputLen, e10.blockLen = n12.blockLen, e10.create = () => t5(), e10;
}
function Ui(t5) {
  const e10 = (r9, o13) => t5(o13).update(ht2(r9)).digest(), n12 = t5({});
  return e10.outputLen = n12.outputLen, e10.blockLen = n12.blockLen, e10.create = (r9) => t5(r9), e10;
}
function Zt2(t5 = 32) {
  if (Gt2 && typeof Gt2.getRandomValues == "function") return Gt2.getRandomValues(new Uint8Array(t5));
  if (Gt2 && typeof Gt2.randomBytes == "function") return Uint8Array.from(Gt2.randomBytes(t5));
  throw new Error("crypto.getRandomValues must be defined");
}
function ki(t5, e10 = 24) {
  const n12 = new Uint32Array(10);
  for (let r9 = 24 - e10; r9 < 24; r9++) {
    for (let i11 = 0; i11 < 10; i11++) n12[i11] = t5[i11] ^ t5[i11 + 10] ^ t5[i11 + 20] ^ t5[i11 + 30] ^ t5[i11 + 40];
    for (let i11 = 0; i11 < 10; i11 += 2) {
      const f13 = (i11 + 8) % 10, a5 = (i11 + 2) % 10, l10 = n12[a5], c12 = n12[a5 + 1], u6 = _r2(l10, c12, 1) ^ n12[f13], h12 = Tr2(l10, c12, 1) ^ n12[f13 + 1];
      for (let g5 = 0; g5 < 50; g5 += 10) t5[i11 + g5] ^= u6, t5[i11 + g5 + 1] ^= h12;
    }
    let o13 = t5[2], s8 = t5[3];
    for (let i11 = 0; i11 < 24; i11++) {
      const f13 = Nr2[i11], a5 = _r2(o13, s8, f13), l10 = Tr2(o13, s8, f13), c12 = Sr2[i11];
      o13 = t5[c12], s8 = t5[c12 + 1], t5[c12] = a5, t5[c12 + 1] = l10;
    }
    for (let i11 = 0; i11 < 50; i11 += 10) {
      for (let f13 = 0; f13 < 10; f13++) n12[f13] = t5[i11 + f13];
      for (let f13 = 0; f13 < 10; f13++) t5[i11 + f13] ^= ~n12[(f13 + 2) % 10] & n12[(f13 + 4) % 10];
    }
    t5[0] ^= Li[r9], t5[1] ^= ji[r9];
  }
  ut2(n12);
}
function Di(t5, e10, n12, r9) {
  if (typeof t5.setBigUint64 == "function") return t5.setBigUint64(e10, n12, r9);
  const o13 = BigInt(32), s8 = BigInt(4294967295), i11 = Number(n12 >> o13 & s8), f13 = Number(n12 & s8), a5 = r9 ? 4 : 0, l10 = r9 ? 0 : 4;
  t5.setUint32(e10 + a5, i11, r9), t5.setUint32(e10 + l10, f13, r9);
}
function Mi(t5, e10, n12) {
  return t5 & e10 ^ ~t5 & n12;
}
function Vi(t5, e10, n12) {
  return t5 & e10 ^ t5 & n12 ^ e10 & n12;
}
function $t2(t5, e10, n12, r9, o13, s8) {
  const i11 = o13[s8], f13 = o13[s8 + 1];
  let a5 = N10[2 * t5], l10 = N10[2 * t5 + 1], c12 = N10[2 * e10], u6 = N10[2 * e10 + 1], h12 = N10[2 * n12], g5 = N10[2 * n12 + 1], w6 = N10[2 * r9], y9 = N10[2 * r9 + 1], x7 = tn(a5, c12, i11);
  l10 = en2(x7, l10, u6, f13), a5 = x7 | 0, { Dh: y9, Dl: w6 } = { Dh: y9 ^ l10, Dl: w6 ^ a5 }, { Dh: y9, Dl: w6 } = { Dh: bi(y9, w6), Dl: yi(y9) }, { h: g5, l: h12 } = dt2(g5, h12, y9, w6), { Bh: u6, Bl: c12 } = { Bh: u6 ^ g5, Bl: c12 ^ h12 }, { Bh: u6, Bl: c12 } = { Bh: At(u6, c12, 24), Bl: St2(u6, c12, 24) }, N10[2 * t5] = a5, N10[2 * t5 + 1] = l10, N10[2 * e10] = c12, N10[2 * e10 + 1] = u6, N10[2 * n12] = h12, N10[2 * n12 + 1] = g5, N10[2 * r9] = w6, N10[2 * r9 + 1] = y9;
}
function Ct(t5, e10, n12, r9, o13, s8) {
  const i11 = o13[s8], f13 = o13[s8 + 1];
  let a5 = N10[2 * t5], l10 = N10[2 * t5 + 1], c12 = N10[2 * e10], u6 = N10[2 * e10 + 1], h12 = N10[2 * n12], g5 = N10[2 * n12 + 1], w6 = N10[2 * r9], y9 = N10[2 * r9 + 1], x7 = tn(a5, c12, i11);
  l10 = en2(x7, l10, u6, f13), a5 = x7 | 0, { Dh: y9, Dl: w6 } = { Dh: y9 ^ l10, Dl: w6 ^ a5 }, { Dh: y9, Dl: w6 } = { Dh: At(y9, w6, 16), Dl: St2(y9, w6, 16) }, { h: g5, l: h12 } = dt2(g5, h12, y9, w6), { Bh: u6, Bl: c12 } = { Bh: u6 ^ g5, Bl: c12 ^ h12 }, { Bh: u6, Bl: c12 } = { Bh: se(u6, c12, 63), Bl: ie(u6, c12, 63) }, N10[2 * t5] = a5, N10[2 * t5 + 1] = l10, N10[2 * e10] = c12, N10[2 * e10 + 1] = u6, N10[2 * n12] = h12, N10[2 * n12 + 1] = g5, N10[2 * r9] = w6, N10[2 * r9 + 1] = y9;
}
function Qi(t5, e10 = {}, n12, r9, o13) {
  if (mt(n12), t5 < 0 || t5 > n12) throw new Error("outputLen bigger than keyLen");
  const { key: s8, salt: i11, personalization: f13 } = e10;
  if (s8 !== void 0 && (s8.length < 1 || s8.length > n12)) throw new Error("key length must be undefined or 1.." + n12);
  if (i11 !== void 0 && i11.length !== r9) throw new Error("salt must be undefined or " + r9);
  if (f13 !== void 0 && f13.length !== o13) throw new Error("personalization must be undefined or " + o13);
}
function an(t5) {
  const e10 = `Ethereum Signed Message:
${t5.length}`, n12 = new TextEncoder().encode(e10 + t5);
  return "0x" + Buffer.from(Hi(n12)).toString("hex");
}
async function Cr2(t5, e10, n12, r9, o13, s8) {
  switch (n12.t) {
    case "eip191":
      return await Lr2(t5, e10, n12.s);
    case "eip1271":
      return await jr2(t5, e10, n12.s, r9, o13, s8);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n12.t}`);
  }
}
async function Lr2(t5, e10, n12) {
  return (await recoverAddress({ hash: an(e10), signature: n12 })).toLowerCase() === t5.toLowerCase();
}
async function jr2(t5, e10, n12, r9, o13, s8) {
  const i11 = Fe(r9);
  if (!i11.namespace || !i11.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r9}`);
  try {
    const f13 = "0x1626ba7e", a5 = "0000000000000000000000000000000000000000000000000000000000000040", l10 = n12.substring(2), c12 = (l10.length / 2).toString(16).padStart(64, "0"), u6 = (e10.startsWith("0x") ? e10 : an(e10)).substring(2), h12 = f13 + u6 + a5 + c12 + l10, g5 = await fetch(`${s8 || rf}/?chainId=${r9}&projectId=${o13}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: of(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t5, data: h12 }, "latest"] }) }), { result: w6 } = await g5.json();
    return w6 ? w6.slice(0, f13.length).toLowerCase() === f13.toLowerCase() : false;
  } catch (f13) {
    return console.error("isValidEip1271Signature: ", f13), false;
  }
}
function of() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function sf(t5) {
  const e10 = atob(t5), n12 = new Uint8Array(e10.length);
  for (let i11 = 0; i11 < e10.length; i11++) n12[i11] = e10.charCodeAt(i11);
  const r9 = n12[0];
  if (r9 === 0) throw new Error("No signatures found");
  const o13 = 1 + r9 * 64;
  if (n12.length < o13) throw new Error("Transaction data too short for claimed signature count");
  if (n12.length < 100) throw new Error("Transaction too short");
  const s8 = Buffer.from(t5, "base64").slice(1, 65);
  return esm_default2.encode(s8);
}
function ff(t5) {
  const e10 = new Uint8Array(Buffer.from(t5, "base64")), n12 = Array.from("TransactionData::").map((s8) => s8.charCodeAt(0)), r9 = new Uint8Array(n12.length + e10.length);
  r9.set(n12), r9.set(e10, n12.length);
  const o13 = nf(r9, { dkLen: 32 });
  return esm_default2.encode(o13);
}
function cf(t5) {
  const e10 = new Uint8Array(Ae2(kr2(t5)));
  return esm_default2.encode(e10);
}
function kr2(t5) {
  if (t5 instanceof Uint8Array) return t5;
  if (Array.isArray(t5)) return new Uint8Array(t5);
  if (typeof t5 == "object" && t5 != null && t5.data) return new Uint8Array(Object.values(t5.data));
  if (typeof t5 == "object" && t5) return new Uint8Array(Object.values(t5));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function af(t5) {
  const e10 = Buffer.from(t5, "base64"), n12 = decode(e10).txn;
  if (!n12) throw new Error("Invalid signed transaction: missing 'txn' field");
  const r9 = encode(n12), o13 = Buffer.from("TX"), s8 = Buffer.concat([o13, Buffer.from(r9)]), i11 = Xi(s8);
  return base32.encode(i11).replace(/=+$/, "");
}
function un(t5) {
  const e10 = [];
  let n12 = BigInt(t5);
  for (; n12 >= BigInt(128); ) e10.push(Number(n12 & BigInt(127) | BigInt(128))), n12 >>= BigInt(7);
  return e10.push(Number(n12)), Buffer.from(e10);
}
function uf(t5) {
  const e10 = Buffer.from(t5.signed.bodyBytes, "base64"), n12 = Buffer.from(t5.signed.authInfoBytes, "base64"), r9 = Buffer.from(t5.signature.signature, "base64"), o13 = [];
  o13.push(Buffer.from([10])), o13.push(un(e10.length)), o13.push(e10), o13.push(Buffer.from([18])), o13.push(un(n12.length)), o13.push(n12), o13.push(Buffer.from([26])), o13.push(un(r9.length)), o13.push(r9);
  const s8 = Buffer.concat(o13), i11 = Ae2(s8);
  return Buffer.from(i11).toString("hex").toUpperCase();
}
async function yf(t5) {
  const { cacao: e10, projectId: n12 } = t5, { s: r9, p: o13 } = e10, s8 = qr2(o13, o13.iss), i11 = dn(o13.iss);
  return await Cr2(i11, s8, r9, Vr2(o13.iss), n12);
}
function Gr2(t5) {
  return Buffer.from(JSON.stringify(t5)).toString("base64");
}
function Zr2(t5) {
  return JSON.parse(Buffer.from(t5, "base64").toString("utf-8"));
}
function bt2(t5) {
  if (!t5) throw new Error("No recap provided, value is undefined");
  if (!t5.att) throw new Error("No `att` property found");
  const e10 = Object.keys(t5.att);
  if (!(e10 != null && e10.length)) throw new Error("No resources found in `att` property");
  e10.forEach((n12) => {
    const r9 = t5.att[n12];
    if (Array.isArray(r9)) throw new Error(`Resource must be an object: ${n12}`);
    if (typeof r9 != "object") throw new Error(`Resource must be an object: ${n12}`);
    if (!Object.keys(r9).length) throw new Error(`Resource object is empty: ${n12}`);
    Object.keys(r9).forEach((o13) => {
      const s8 = r9[o13];
      if (!Array.isArray(s8)) throw new Error(`Ability limits ${o13} must be an array of objects, found: ${s8}`);
      if (!s8.length) throw new Error(`Value of ${o13} is empty array, must be an array with objects`);
      s8.forEach((i11) => {
        if (typeof i11 != "object") throw new Error(`Ability limits (${o13}) must be an array of objects, found: ${i11}`);
      });
    });
  });
}
function Wr2(t5, e10, n12, r9 = {}) {
  return n12?.sort((o13, s8) => o13.localeCompare(s8)), { att: { [t5]: hn(e10, n12, r9) } };
}
function hn(t5, e10, n12 = {}) {
  e10 = e10?.sort((o13, s8) => o13.localeCompare(s8));
  const r9 = e10.map((o13) => ({ [`${t5}/${o13}`]: [n12] }));
  return Object.assign({}, ...r9);
}
function Ne2(t5) {
  return bt2(t5), `urn:recap:${Gr2(t5).replace(/=/g, "")}`;
}
function Lt2(t5) {
  const e10 = Zr2(t5.replace("urn:recap:", ""));
  return bt2(e10), e10;
}
function Ef(t5, e10, n12) {
  const r9 = Wr2(t5, e10, n12);
  return Ne2(r9);
}
function pn(t5) {
  return t5 && t5.includes("urn:recap:");
}
function Bf(t5, e10) {
  const n12 = Lt2(t5), r9 = Lt2(e10), o13 = Xr2(n12, r9);
  return Ne2(o13);
}
function Xr2(t5, e10) {
  bt2(t5), bt2(e10);
  const n12 = Object.keys(t5.att).concat(Object.keys(e10.att)).sort((o13, s8) => o13.localeCompare(s8)), r9 = { att: {} };
  return n12.forEach((o13) => {
    var s8, i11;
    Object.keys(((s8 = t5.att) == null ? void 0 : s8[o13]) || {}).concat(Object.keys(((i11 = e10.att) == null ? void 0 : i11[o13]) || {})).sort((f13, a5) => f13.localeCompare(a5)).forEach((f13) => {
      var a5, l10;
      r9.att[o13] = Dr2(ln({}, r9.att[o13]), { [f13]: ((a5 = t5.att[o13]) == null ? void 0 : a5[f13]) || ((l10 = e10.att[o13]) == null ? void 0 : l10[f13]) });
    });
  }), r9;
}
function gn2(t5 = "", e10) {
  bt2(e10);
  const n12 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t5.includes(n12)) return t5;
  const r9 = [];
  let o13 = 0;
  Object.keys(e10.att).forEach((f13) => {
    const a5 = Object.keys(e10.att[f13]).map((u6) => ({ ability: u6.split("/")[0], action: u6.split("/")[1] }));
    a5.sort((u6, h12) => u6.action.localeCompare(h12.action));
    const l10 = {};
    a5.forEach((u6) => {
      l10[u6.ability] || (l10[u6.ability] = []), l10[u6.ability].push(u6.action);
    });
    const c12 = Object.keys(l10).map((u6) => (o13++, `(${o13}) '${u6}': '${l10[u6].join("', '")}' for '${f13}'.`));
    r9.push(c12.join(", ").replace(".,", "."));
  });
  const s8 = r9.join(" "), i11 = `${n12}${s8}`;
  return `${t5 ? t5 + " " : ""}${i11}`;
}
function If(t5) {
  var e10;
  const n12 = Lt2(t5);
  bt2(n12);
  const r9 = (e10 = n12.att) == null ? void 0 : e10.eip155;
  return r9 ? Object.keys(r9).map((o13) => o13.split("/")[1]) : [];
}
function Af(t5) {
  const e10 = Lt2(t5);
  bt2(e10);
  const n12 = [];
  return Object.values(e10.att).forEach((r9) => {
    Object.values(r9).forEach((o13) => {
      var s8;
      (s8 = o13?.[0]) != null && s8.chains && n12.push(o13[0].chains);
    });
  }), [...new Set(n12.flat())];
}
function Oe2(t5) {
  if (!t5) return;
  const e10 = t5?.[t5.length - 1];
  return pn(e10) ? e10 : void 0;
}
function Qr2(t5) {
  return t5 instanceof Uint8Array || ArrayBuffer.isView(t5) && t5.constructor.name === "Uint8Array";
}
function bn2(t5) {
  if (typeof t5 != "boolean") throw new Error(`boolean expected, not ${t5}`);
}
function yn2(t5) {
  if (!Number.isSafeInteger(t5) || t5 < 0) throw new Error("positive integer expected, got " + t5);
}
function nt2(t5, ...e10) {
  if (!Qr2(t5)) throw new Error("Uint8Array expected");
  if (e10.length > 0 && !e10.includes(t5.length)) throw new Error("Uint8Array expected of length " + e10 + ", got length=" + t5.length);
}
function to2(t5, e10 = true) {
  if (t5.destroyed) throw new Error("Hash instance has been destroyed");
  if (e10 && t5.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t5, e10) {
  nt2(t5);
  const n12 = e10.outputLen;
  if (t5.length < n12) throw new Error("digestInto() expects output buffer of length at least " + n12);
}
function jt2(t5) {
  return new Uint32Array(t5.buffer, t5.byteOffset, Math.floor(t5.byteLength / 4));
}
function Wt2(...t5) {
  for (let e10 = 0; e10 < t5.length; e10++) t5[e10].fill(0);
}
function Nf(t5) {
  return new DataView(t5.buffer, t5.byteOffset, t5.byteLength);
}
function Uf(t5) {
  if (typeof t5 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t5));
}
function mn2(t5) {
  if (typeof t5 == "string") t5 = Uf(t5);
  else if (Qr2(t5)) t5 = wn(t5);
  else throw new Error("Uint8Array expected, got " + typeof t5);
  return t5;
}
function _f(t5, e10) {
  if (e10 == null || typeof e10 != "object") throw new Error("options must be defined");
  return Object.assign(t5, e10);
}
function Tf(t5, e10) {
  if (t5.length !== e10.length) return false;
  let n12 = 0;
  for (let r9 = 0; r9 < t5.length; r9++) n12 |= t5[r9] ^ e10[r9];
  return n12 === 0;
}
function eo2(t5, e10, n12 = true) {
  if (e10 === void 0) return new Uint8Array(t5);
  if (e10.length !== t5) throw new Error("invalid output length, expected " + t5 + ", got: " + e10.length);
  if (n12 && !Cf(e10)) throw new Error("invalid output, must be aligned");
  return e10;
}
function no2(t5, e10, n12, r9) {
  if (typeof t5.setBigUint64 == "function") return t5.setBigUint64(e10, n12, r9);
  const o13 = BigInt(32), s8 = BigInt(4294967295), i11 = Number(n12 >> o13 & s8), f13 = Number(n12 & s8), a5 = r9 ? 4 : 0, l10 = r9 ? 0 : 4;
  t5.setUint32(e10 + a5, i11, r9), t5.setUint32(e10 + l10, f13, r9);
}
function $f(t5, e10, n12) {
  bn2(n12);
  const r9 = new Uint8Array(16), o13 = Nf(r9);
  return no2(o13, 0, BigInt(e10), n12), no2(o13, 8, BigInt(t5), n12), r9;
}
function Cf(t5) {
  return t5.byteOffset % 4 === 0;
}
function wn(t5) {
  return Uint8Array.from(t5);
}
function D2(t5, e10) {
  return t5 << e10 | t5 >>> 32 - e10;
}
function xn2(t5) {
  return t5.byteOffset % 4 === 0;
}
function Df(t5, e10, n12, r9, o13, s8, i11, f13) {
  const a5 = o13.length, l10 = new Uint8Array(Ue2), c12 = jt2(l10), u6 = xn2(o13) && xn2(s8), h12 = u6 ? jt2(o13) : so2, g5 = u6 ? jt2(s8) : so2;
  for (let w6 = 0; w6 < a5; i11++) {
    if (t5(e10, n12, r9, c12, i11, f13), i11 >= oo2) throw new Error("arx: counter overflow");
    const y9 = Math.min(Ue2, a5 - w6);
    if (u6 && y9 === Ue2) {
      const x7 = w6 / 4;
      if (w6 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R6 = 0, M6; R6 < Hf; R6++) M6 = x7 + R6, g5[M6] = h12[M6] ^ c12[R6];
      w6 += Ue2;
      continue;
    }
    for (let x7 = 0, R6; x7 < y9; x7++) R6 = w6 + x7, s8[R6] = o13[R6] ^ l10[x7];
    w6 += y9;
  }
}
function Mf(t5, e10) {
  const { allowShortKeys: n12, extendNonceFn: r9, counterLength: o13, counterRight: s8, rounds: i11 } = _f({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e10);
  if (typeof t5 != "function") throw new Error("core must be a function");
  return yn2(o13), yn2(i11), bn2(s8), bn2(n12), (f13, a5, l10, c12, u6 = 0) => {
    nt2(f13), nt2(a5), nt2(l10);
    const h12 = l10.length;
    if (c12 === void 0 && (c12 = new Uint8Array(h12)), nt2(c12), yn2(u6), u6 < 0 || u6 >= oo2) throw new Error("arx: counter overflow");
    if (c12.length < h12) throw new Error(`arx: output (${c12.length}) is shorter than data (${h12})`);
    const g5 = [];
    let w6 = f13.length, y9, x7;
    if (w6 === 32) g5.push(y9 = wn(f13)), x7 = Pf;
    else if (w6 === 16 && n12) y9 = new Uint8Array(32), y9.set(f13), y9.set(f13, 16), x7 = kf, g5.push(y9);
    else throw new Error(`arx: invalid 32-byte key, got length=${w6}`);
    xn2(a5) || g5.push(a5 = wn(a5));
    const R6 = jt2(y9);
    if (r9) {
      if (a5.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r9(x7, R6, jt2(a5.subarray(0, 16)), R6), a5 = a5.subarray(16);
    }
    const M6 = 16 - o13;
    if (M6 !== a5.length) throw new Error(`arx: nonce must be ${M6} or 16 bytes`);
    if (M6 !== 12) {
      const V6 = new Uint8Array(12);
      V6.set(a5, s8 ? 0 : 12 - a5.length), a5 = V6, g5.push(a5);
    }
    const L6 = jt2(a5);
    return Df(t5, x7, R6, L6, l10, c12, u6, i11), Wt2(...g5), c12;
  };
}
function qf(t5) {
  const e10 = (r9, o13) => t5(o13).update(mn2(r9)).digest(), n12 = t5(new Uint8Array(32));
  return e10.outputLen = n12.outputLen, e10.blockLen = n12.blockLen, e10.create = (r9) => t5(r9), e10;
}
function Ff(t5, e10, n12, r9, o13, s8 = 20) {
  let i11 = t5[0], f13 = t5[1], a5 = t5[2], l10 = t5[3], c12 = e10[0], u6 = e10[1], h12 = e10[2], g5 = e10[3], w6 = e10[4], y9 = e10[5], x7 = e10[6], R6 = e10[7], M6 = o13, L6 = n12[0], V6 = n12[1], _5 = n12[2], k7 = i11, j7 = f13, $6 = a5, d7 = l10, m6 = c12, p8 = u6, b7 = h12, v8 = g5, B5 = w6, E8 = y9, I6 = x7, S7 = R6, O8 = M6, A6 = L6, T6 = V6, U4 = _5;
  for (let H5 = 0; H5 < s8; H5 += 2) k7 = k7 + m6 | 0, O8 = D2(O8 ^ k7, 16), B5 = B5 + O8 | 0, m6 = D2(m6 ^ B5, 12), k7 = k7 + m6 | 0, O8 = D2(O8 ^ k7, 8), B5 = B5 + O8 | 0, m6 = D2(m6 ^ B5, 7), j7 = j7 + p8 | 0, A6 = D2(A6 ^ j7, 16), E8 = E8 + A6 | 0, p8 = D2(p8 ^ E8, 12), j7 = j7 + p8 | 0, A6 = D2(A6 ^ j7, 8), E8 = E8 + A6 | 0, p8 = D2(p8 ^ E8, 7), $6 = $6 + b7 | 0, T6 = D2(T6 ^ $6, 16), I6 = I6 + T6 | 0, b7 = D2(b7 ^ I6, 12), $6 = $6 + b7 | 0, T6 = D2(T6 ^ $6, 8), I6 = I6 + T6 | 0, b7 = D2(b7 ^ I6, 7), d7 = d7 + v8 | 0, U4 = D2(U4 ^ d7, 16), S7 = S7 + U4 | 0, v8 = D2(v8 ^ S7, 12), d7 = d7 + v8 | 0, U4 = D2(U4 ^ d7, 8), S7 = S7 + U4 | 0, v8 = D2(v8 ^ S7, 7), k7 = k7 + p8 | 0, U4 = D2(U4 ^ k7, 16), I6 = I6 + U4 | 0, p8 = D2(p8 ^ I6, 12), k7 = k7 + p8 | 0, U4 = D2(U4 ^ k7, 8), I6 = I6 + U4 | 0, p8 = D2(p8 ^ I6, 7), j7 = j7 + b7 | 0, O8 = D2(O8 ^ j7, 16), S7 = S7 + O8 | 0, b7 = D2(b7 ^ S7, 12), j7 = j7 + b7 | 0, O8 = D2(O8 ^ j7, 8), S7 = S7 + O8 | 0, b7 = D2(b7 ^ S7, 7), $6 = $6 + v8 | 0, A6 = D2(A6 ^ $6, 16), B5 = B5 + A6 | 0, v8 = D2(v8 ^ B5, 12), $6 = $6 + v8 | 0, A6 = D2(A6 ^ $6, 8), B5 = B5 + A6 | 0, v8 = D2(v8 ^ B5, 7), d7 = d7 + m6 | 0, T6 = D2(T6 ^ d7, 16), E8 = E8 + T6 | 0, m6 = D2(m6 ^ E8, 12), d7 = d7 + m6 | 0, T6 = D2(T6 ^ d7, 8), E8 = E8 + T6 | 0, m6 = D2(m6 ^ E8, 7);
  let C7 = 0;
  r9[C7++] = i11 + k7 | 0, r9[C7++] = f13 + j7 | 0, r9[C7++] = a5 + $6 | 0, r9[C7++] = l10 + d7 | 0, r9[C7++] = c12 + m6 | 0, r9[C7++] = u6 + p8 | 0, r9[C7++] = h12 + b7 | 0, r9[C7++] = g5 + v8 | 0, r9[C7++] = w6 + B5 | 0, r9[C7++] = y9 + E8 | 0, r9[C7++] = x7 + I6 | 0, r9[C7++] = R6 + S7 | 0, r9[C7++] = M6 + O8 | 0, r9[C7++] = L6 + A6 | 0, r9[C7++] = V6 + T6 | 0, r9[C7++] = _5 + U4 | 0;
}
function fo2(t5, e10, n12, r9, o13) {
  const s8 = t5(e10, n12, Zf), i11 = Kf.create(s8);
  o13 && io2(i11, o13), io2(i11, r9);
  const f13 = $f(r9.length, o13 ? o13.length : 0, true);
  i11.update(f13);
  const a5 = i11.digest();
  return Wt2(s8, f13), a5;
}
function Yf(t5, e10, n12) {
  return rn2(t5), n12 === void 0 && (n12 = new Uint8Array(t5.outputLen)), _e2(t5, ht2(n12), ht2(e10));
}
function Xf(t5, e10, n12, r9 = 32) {
  rn2(t5), mt(r9);
  const o13 = t5.outputLen;
  if (r9 > 255 * o13) throw new Error("Length should be <= 255*HashLen");
  const s8 = Math.ceil(r9 / o13);
  n12 === void 0 && (n12 = uo2);
  const i11 = new Uint8Array(s8 * o13), f13 = _e2.create(t5, e10), a5 = f13._cloneInto(), l10 = new Uint8Array(f13.outputLen);
  for (let c12 = 0; c12 < s8; c12++) vn2[0] = c12 + 1, a5.update(c12 === 0 ? uo2 : l10).update(n12).update(vn2).digestInto(l10), i11.set(l10, o13 * c12), f13._cloneInto(a5);
  return f13.destroy(), a5.destroy(), ut2(l10, vn2), i11.slice(0, r9);
}
function Re2(t5, e10) {
  if (typeof e10 != "boolean") throw new Error(t5 + " boolean expected, got " + e10);
}
function $e2(t5) {
  const e10 = t5.toString(16);
  return e10.length & 1 ? "0" + e10 : e10;
}
function lo2(t5) {
  if (typeof t5 != "string") throw new Error("hex string expected, got " + typeof t5);
  return t5 === "" ? En2 : BigInt("0x" + t5);
}
function Ce2(t5) {
  return lo2(ce(t5));
}
function Le2(t5) {
  return at(t5), lo2(ce(Uint8Array.from(t5).reverse()));
}
function In2(t5, e10) {
  return fn(t5.toString(16).padStart(e10 * 2, "0"));
}
function An2(t5, e10) {
  return In2(t5, e10).reverse();
}
function rt2(t5, e10, n12) {
  let r9;
  if (typeof e10 == "string") try {
    r9 = fn(e10);
  } catch (s8) {
    throw new Error(t5 + " must be hex string or Uint8Array, cause: " + s8);
  }
  else if (nn2(e10)) r9 = Uint8Array.from(e10);
  else throw new Error(t5 + " must be hex string or Uint8Array");
  const o13 = r9.length;
  if (typeof n12 == "number" && o13 !== n12) throw new Error(t5 + " of length " + n12 + " expected, got " + o13);
  return r9;
}
function Qf(t5, e10, n12) {
  return Sn2(t5) && Sn2(e10) && Sn2(n12) && e10 <= t5 && t5 < n12;
}
function Nn2(t5, e10, n12, r9) {
  if (!Qf(e10, n12, r9)) throw new Error("expected valid " + t5 + ": " + n12 + " <= n < " + r9 + ", got " + e10);
}
function tc(t5) {
  let e10;
  for (e10 = 0; t5 > En2; t5 >>= Bn2, e10 += 1) ;
  return e10;
}
function ec(t5, e10, n12) {
  if (typeof t5 != "number" || t5 < 2) throw new Error("hashLen must be a number");
  if (typeof e10 != "number" || e10 < 2) throw new Error("qByteLen must be a number");
  if (typeof n12 != "function") throw new Error("hmacFn must be a function");
  const r9 = (g5) => new Uint8Array(g5), o13 = (g5) => Uint8Array.of(g5);
  let s8 = r9(t5), i11 = r9(t5), f13 = 0;
  const a5 = () => {
    s8.fill(1), i11.fill(0), f13 = 0;
  }, l10 = (...g5) => n12(i11, s8, ...g5), c12 = (g5 = r9(0)) => {
    i11 = l10(o13(0), g5), s8 = l10(), g5.length !== 0 && (i11 = l10(o13(1), g5), s8 = l10());
  }, u6 = () => {
    if (f13++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g5 = 0;
    const w6 = [];
    for (; g5 < e10; ) {
      s8 = l10();
      const y9 = s8.slice();
      w6.push(y9), g5 += s8.length;
    }
    return Ht2(...w6);
  };
  return (g5, w6) => {
    a5(), c12(g5);
    let y9;
    for (; !(y9 = w6(u6())); ) c12();
    return a5(), y9;
  };
}
function ke2(t5, e10, n12 = {}) {
  if (!t5 || typeof t5 != "object") throw new Error("expected valid options object");
  function r9(o13, s8, i11) {
    const f13 = t5[o13];
    if (i11 && f13 === void 0) return;
    const a5 = typeof f13;
    if (a5 !== s8 || f13 === null) throw new Error(`param "${o13}" is invalid: expected ${s8}, got ${a5}`);
  }
  Object.entries(e10).forEach(([o13, s8]) => r9(o13, s8, false)), Object.entries(n12).forEach(([o13, s8]) => r9(o13, s8, true));
}
function ho2(t5) {
  const e10 = /* @__PURE__ */ new WeakMap();
  return (n12, ...r9) => {
    const o13 = e10.get(n12);
    if (o13 !== void 0) return o13;
    const s8 = t5(n12, ...r9);
    return e10.set(n12, s8), s8;
  };
}
function lt2(t5, e10) {
  const n12 = t5 % e10;
  return n12 >= ot ? n12 : e10 + n12;
}
function pt(t5, e10, n12) {
  let r9 = t5;
  for (; e10-- > ot; ) r9 *= r9, r9 %= n12;
  return r9;
}
function yo2(t5, e10) {
  if (t5 === ot) throw new Error("invert: expected non-zero number");
  if (e10 <= ot) throw new Error("invert: expected positive modulus, got " + e10);
  let n12 = lt2(t5, e10), r9 = e10, o13 = ot, s8 = Q2;
  for (; n12 !== ot; ) {
    const f13 = r9 / n12, a5 = r9 % n12, l10 = o13 - s8 * f13;
    r9 = n12, n12 = a5, o13 = s8, s8 = l10;
  }
  if (r9 !== Q2) throw new Error("invert: does not exist");
  return lt2(o13, e10);
}
function mo2(t5, e10) {
  const n12 = (t5.ORDER + Q2) / po2, r9 = t5.pow(e10, n12);
  if (!t5.eql(t5.sqr(r9), e10)) throw new Error("Cannot find square root");
  return r9;
}
function rc(t5, e10) {
  const n12 = (t5.ORDER - go2) / bo2, r9 = t5.mul(e10, Dt2), o13 = t5.pow(r9, n12), s8 = t5.mul(e10, o13), i11 = t5.mul(t5.mul(s8, Dt2), o13), f13 = t5.mul(s8, t5.sub(i11, t5.ONE));
  if (!t5.eql(t5.sqr(f13), e10)) throw new Error("Cannot find square root");
  return f13;
}
function oc(t5) {
  if (t5 < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e10 = t5 - Q2, n12 = 0;
  for (; e10 % Dt2 === ot; ) e10 /= Dt2, n12++;
  let r9 = Dt2;
  const o13 = Yt2(t5);
  for (; xo2(o13, r9) === 1; ) if (r9++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n12 === 1) return mo2;
  let s8 = o13.pow(r9, e10);
  const i11 = (e10 + Q2) / Dt2;
  return function(a5, l10) {
    if (a5.is0(l10)) return l10;
    if (xo2(a5, l10) !== 1) throw new Error("Cannot find square root");
    let c12 = n12, u6 = a5.mul(a5.ONE, s8), h12 = a5.pow(l10, e10), g5 = a5.pow(l10, i11);
    for (; !a5.eql(h12, a5.ONE); ) {
      if (a5.is0(h12)) return a5.ZERO;
      let w6 = 1, y9 = a5.sqr(h12);
      for (; !a5.eql(y9, a5.ONE); ) if (w6++, y9 = a5.sqr(y9), w6 === c12) throw new Error("Cannot find square root");
      const x7 = Q2 << BigInt(c12 - w6 - 1), R6 = a5.pow(u6, x7);
      c12 = w6, u6 = a5.sqr(R6), h12 = a5.mul(h12, u6), g5 = a5.mul(g5, R6);
    }
    return g5;
  };
}
function sc(t5) {
  return t5 % po2 === nc ? mo2 : t5 % bo2 === go2 ? rc : oc(t5);
}
function fc(t5) {
  const e10 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n12 = ic.reduce((r9, o13) => (r9[o13] = "function", r9), e10);
  return ke2(t5, n12), t5;
}
function cc(t5, e10, n12) {
  if (n12 < ot) throw new Error("invalid exponent, negatives unsupported");
  if (n12 === ot) return t5.ONE;
  if (n12 === Q2) return e10;
  let r9 = t5.ONE, o13 = e10;
  for (; n12 > ot; ) n12 & Q2 && (r9 = t5.mul(r9, o13)), o13 = t5.sqr(o13), n12 >>= Q2;
  return r9;
}
function wo2(t5, e10, n12 = false) {
  const r9 = new Array(e10.length).fill(n12 ? t5.ZERO : void 0), o13 = e10.reduce((i11, f13, a5) => t5.is0(f13) ? i11 : (r9[a5] = i11, t5.mul(i11, f13)), t5.ONE), s8 = t5.inv(o13);
  return e10.reduceRight((i11, f13, a5) => t5.is0(f13) ? i11 : (r9[a5] = t5.mul(i11, r9[a5]), t5.mul(i11, f13)), s8), r9;
}
function xo2(t5, e10) {
  const n12 = (t5.ORDER - Q2) / Dt2, r9 = t5.pow(e10, n12), o13 = t5.eql(r9, t5.ONE), s8 = t5.eql(r9, t5.ZERO), i11 = t5.eql(r9, t5.neg(t5.ONE));
  if (!o13 && !s8 && !i11) throw new Error("invalid Legendre symbol result");
  return o13 ? 1 : s8 ? 0 : -1;
}
function ac(t5, e10) {
  e10 !== void 0 && mt(e10);
  const n12 = e10 !== void 0 ? e10 : t5.toString(2).length, r9 = Math.ceil(n12 / 8);
  return { nBitLength: n12, nByteLength: r9 };
}
function Yt2(t5, e10, n12 = false, r9 = {}) {
  if (t5 <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t5);
  let o13, s8;
  if (typeof e10 == "object" && e10 != null) {
    if (r9.sqrt || n12) throw new Error("cannot specify opts in two arguments");
    const c12 = e10;
    c12.BITS && (o13 = c12.BITS), c12.sqrt && (s8 = c12.sqrt), typeof c12.isLE == "boolean" && (n12 = c12.isLE);
  } else typeof e10 == "number" && (o13 = e10), r9.sqrt && (s8 = r9.sqrt);
  const { nBitLength: i11, nByteLength: f13 } = ac(t5, o13);
  if (f13 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a5;
  const l10 = Object.freeze({ ORDER: t5, isLE: n12, BITS: i11, BYTES: f13, MASK: je2(i11), ZERO: ot, ONE: Q2, create: (c12) => lt2(c12, t5), isValid: (c12) => {
    if (typeof c12 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c12);
    return ot <= c12 && c12 < t5;
  }, is0: (c12) => c12 === ot, isValidNot0: (c12) => !l10.is0(c12) && l10.isValid(c12), isOdd: (c12) => (c12 & Q2) === Q2, neg: (c12) => lt2(-c12, t5), eql: (c12, u6) => c12 === u6, sqr: (c12) => lt2(c12 * c12, t5), add: (c12, u6) => lt2(c12 + u6, t5), sub: (c12, u6) => lt2(c12 - u6, t5), mul: (c12, u6) => lt2(c12 * u6, t5), pow: (c12, u6) => cc(l10, c12, u6), div: (c12, u6) => lt2(c12 * yo2(u6, t5), t5), sqrN: (c12) => c12 * c12, addN: (c12, u6) => c12 + u6, subN: (c12, u6) => c12 - u6, mulN: (c12, u6) => c12 * u6, inv: (c12) => yo2(c12, t5), sqrt: s8 || ((c12) => (a5 || (a5 = sc(t5)), a5(l10, c12))), toBytes: (c12) => n12 ? An2(c12, f13) : In2(c12, f13), fromBytes: (c12) => {
    if (c12.length !== f13) throw new Error("Field.fromBytes: expected " + f13 + " bytes, got " + c12.length);
    return n12 ? Le2(c12) : Ce2(c12);
  }, invertBatch: (c12) => wo2(l10, c12), cmov: (c12, u6, h12) => h12 ? u6 : c12 });
  return Object.freeze(l10);
}
function vo2(t5) {
  if (typeof t5 != "bigint") throw new Error("field order must be bigint");
  const e10 = t5.toString(2).length;
  return Math.ceil(e10 / 8);
}
function Eo2(t5) {
  const e10 = vo2(t5);
  return e10 + Math.ceil(e10 / 2);
}
function uc(t5, e10, n12 = false) {
  const r9 = t5.length, o13 = vo2(e10), s8 = Eo2(e10);
  if (r9 < 16 || r9 < s8 || r9 > 1024) throw new Error("expected " + s8 + "-1024 bytes of input, got " + r9);
  const i11 = n12 ? Le2(t5) : Ce2(t5), f13 = lt2(i11, e10 - Q2) + Q2;
  return n12 ? An2(f13, o13) : In2(f13, o13);
}
function le2(t5, e10) {
  const n12 = e10.negate();
  return t5 ? n12 : e10;
}
function lc(t5, e10, n12) {
  const r9 = e10 === "pz" ? (i11) => i11.pz : (i11) => i11.ez, o13 = wo2(t5.Fp, n12.map(r9));
  return n12.map((i11, f13) => i11.toAffine(o13[f13])).map(t5.fromAffine);
}
function Bo2(t5, e10) {
  if (!Number.isSafeInteger(t5) || t5 <= 0 || t5 > e10) throw new Error("invalid window size, expected [1.." + e10 + "], got W=" + t5);
}
function On2(t5, e10) {
  Bo2(t5, e10);
  const n12 = Math.ceil(e10 / t5) + 1, r9 = 2 ** (t5 - 1), o13 = 2 ** t5, s8 = je2(t5), i11 = BigInt(t5);
  return { windows: n12, windowSize: r9, mask: s8, maxNumber: o13, shiftBy: i11 };
}
function Io2(t5, e10, n12) {
  const { windowSize: r9, mask: o13, maxNumber: s8, shiftBy: i11 } = n12;
  let f13 = Number(t5 & o13), a5 = t5 >> i11;
  f13 > r9 && (f13 -= s8, a5 += Mt2);
  const l10 = e10 * r9, c12 = l10 + Math.abs(f13) - 1, u6 = f13 === 0, h12 = f13 < 0, g5 = e10 % 2 !== 0;
  return { nextN: a5, offset: c12, isZero: u6, isNeg: h12, isNegF: g5, offsetF: l10 };
}
function dc(t5, e10) {
  if (!Array.isArray(t5)) throw new Error("array expected");
  t5.forEach((n12, r9) => {
    if (!(n12 instanceof e10)) throw new Error("invalid point at index " + r9);
  });
}
function hc(t5, e10) {
  if (!Array.isArray(t5)) throw new Error("array of scalars expected");
  t5.forEach((n12, r9) => {
    if (!e10.isValid(n12)) throw new Error("invalid scalar at index " + r9);
  });
}
function _n2(t5) {
  return Ao2.get(t5) || 1;
}
function So2(t5) {
  if (t5 !== Xt2) throw new Error("invalid wNAF");
}
function pc(t5, e10) {
  return { constTimeNegate: le2, hasPrecomputes(n12) {
    return _n2(n12) !== 1;
  }, unsafeLadder(n12, r9, o13 = t5.ZERO) {
    let s8 = n12;
    for (; r9 > Xt2; ) r9 & Mt2 && (o13 = o13.add(s8)), s8 = s8.double(), r9 >>= Mt2;
    return o13;
  }, precomputeWindow(n12, r9) {
    const { windows: o13, windowSize: s8 } = On2(r9, e10), i11 = [];
    let f13 = n12, a5 = f13;
    for (let l10 = 0; l10 < o13; l10++) {
      a5 = f13, i11.push(a5);
      for (let c12 = 1; c12 < s8; c12++) a5 = a5.add(f13), i11.push(a5);
      f13 = a5.double();
    }
    return i11;
  }, wNAF(n12, r9, o13) {
    let s8 = t5.ZERO, i11 = t5.BASE;
    const f13 = On2(n12, e10);
    for (let a5 = 0; a5 < f13.windows; a5++) {
      const { nextN: l10, offset: c12, isZero: u6, isNeg: h12, isNegF: g5, offsetF: w6 } = Io2(o13, a5, f13);
      o13 = l10, u6 ? i11 = i11.add(le2(g5, r9[w6])) : s8 = s8.add(le2(h12, r9[c12]));
    }
    return So2(o13), { p: s8, f: i11 };
  }, wNAFUnsafe(n12, r9, o13, s8 = t5.ZERO) {
    const i11 = On2(n12, e10);
    for (let f13 = 0; f13 < i11.windows && o13 !== Xt2; f13++) {
      const { nextN: a5, offset: l10, isZero: c12, isNeg: u6 } = Io2(o13, f13, i11);
      if (o13 = a5, !c12) {
        const h12 = r9[l10];
        s8 = s8.add(u6 ? h12.negate() : h12);
      }
    }
    return So2(o13), s8;
  }, getPrecomputes(n12, r9, o13) {
    let s8 = Un2.get(r9);
    return s8 || (s8 = this.precomputeWindow(r9, n12), n12 !== 1 && (typeof o13 == "function" && (s8 = o13(s8)), Un2.set(r9, s8))), s8;
  }, wNAFCached(n12, r9, o13) {
    const s8 = _n2(n12);
    return this.wNAF(s8, this.getPrecomputes(s8, n12, o13), r9);
  }, wNAFCachedUnsafe(n12, r9, o13, s8) {
    const i11 = _n2(n12);
    return i11 === 1 ? this.unsafeLadder(n12, r9, s8) : this.wNAFUnsafe(i11, this.getPrecomputes(i11, n12, o13), r9, s8);
  }, setWindowSize(n12, r9) {
    Bo2(r9, e10), Ao2.set(n12, r9), Un2.delete(n12);
  } };
}
function gc(t5, e10, n12, r9) {
  let o13 = e10, s8 = t5.ZERO, i11 = t5.ZERO;
  for (; n12 > Xt2 || r9 > Xt2; ) n12 & Mt2 && (s8 = s8.add(o13)), r9 & Mt2 && (i11 = i11.add(o13)), o13 = o13.double(), n12 >>= Mt2, r9 >>= Mt2;
  return { p1: s8, p2: i11 };
}
function bc(t5, e10, n12, r9) {
  dc(n12, t5), hc(r9, e10);
  const o13 = n12.length, s8 = r9.length;
  if (o13 !== s8) throw new Error("arrays of points and scalars must have equal length");
  const i11 = t5.ZERO, f13 = tc(BigInt(o13));
  let a5 = 1;
  f13 > 12 ? a5 = f13 - 3 : f13 > 4 ? a5 = f13 - 2 : f13 > 0 && (a5 = 2);
  const l10 = je2(a5), c12 = new Array(Number(l10) + 1).fill(i11), u6 = Math.floor((e10.BITS - 1) / a5) * a5;
  let h12 = i11;
  for (let g5 = u6; g5 >= 0; g5 -= a5) {
    c12.fill(i11);
    for (let y9 = 0; y9 < s8; y9++) {
      const x7 = r9[y9], R6 = Number(x7 >> BigInt(g5) & l10);
      c12[R6] = c12[R6].add(n12[y9]);
    }
    let w6 = i11;
    for (let y9 = c12.length - 1, x7 = i11; y9 > 0; y9--) x7 = x7.add(c12[y9]), w6 = w6.add(x7);
    if (h12 = h12.add(w6), g5 !== 0) for (let y9 = 0; y9 < a5; y9++) h12 = h12.double();
  }
  return h12;
}
function No2(t5, e10) {
  if (e10) {
    if (e10.ORDER !== t5) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc(e10), e10;
  } else return Yt2(t5);
}
function yc(t5, e10, n12 = {}) {
  if (!e10 || typeof e10 != "object") throw new Error(`expected valid ${t5} CURVE object`);
  for (const f13 of ["p", "n", "h"]) {
    const a5 = e10[f13];
    if (!(typeof a5 == "bigint" && a5 > Xt2)) throw new Error(`CURVE.${f13} must be positive bigint`);
  }
  const r9 = No2(e10.p, n12.Fp), o13 = No2(e10.n, n12.Fn), i11 = ["Gx", "Gy", "a", t5 === "weierstrass" ? "b" : "d"];
  for (const f13 of i11) if (!r9.isValid(e10[f13])) throw new Error(`CURVE.${f13} must be valid field element of CURVE.Fp`);
  return { Fp: r9, Fn: o13 };
}
function mc(t5) {
  return ke2(t5, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t5 });
}
function wc(t5) {
  const e10 = mc(t5), { P: n12, type: r9, adjustScalarBytes: o13, powPminus2: s8, randomBytes: i11 } = e10, f13 = r9 === "x25519";
  if (!f13 && r9 !== "x448") throw new Error("invalid type");
  const a5 = i11 || Zt2, l10 = f13 ? 255 : 448, c12 = f13 ? 32 : 56, u6 = BigInt(f13 ? 9 : 5), h12 = BigInt(f13 ? 121665 : 39081), g5 = f13 ? Pe2 ** BigInt(254) : Pe2 ** BigInt(447), w6 = f13 ? BigInt(8) * Pe2 ** BigInt(251) - Jt2 : BigInt(4) * Pe2 ** BigInt(445) - Jt2, y9 = g5 + w6 + Jt2, x7 = (d7) => lt2(d7, n12), R6 = M6(u6);
  function M6(d7) {
    return An2(x7(d7), c12);
  }
  function L6(d7) {
    const m6 = rt2("u coordinate", d7, c12);
    return f13 && (m6[31] &= 127), x7(Le2(m6));
  }
  function V6(d7) {
    return Le2(o13(rt2("scalar", d7, c12)));
  }
  function _5(d7, m6) {
    const p8 = $6(L6(m6), V6(d7));
    if (p8 === de2) throw new Error("invalid private or public key received");
    return M6(p8);
  }
  function k7(d7) {
    return _5(d7, R6);
  }
  function j7(d7, m6, p8) {
    const b7 = x7(d7 * (m6 - p8));
    return m6 = x7(m6 - b7), p8 = x7(p8 + b7), { x_2: m6, x_3: p8 };
  }
  function $6(d7, m6) {
    Nn2("u", d7, de2, n12), Nn2("scalar", m6, g5, y9);
    const p8 = m6, b7 = d7;
    let v8 = Jt2, B5 = de2, E8 = d7, I6 = Jt2, S7 = de2;
    for (let A6 = BigInt(l10 - 1); A6 >= de2; A6--) {
      const T6 = p8 >> A6 & Jt2;
      S7 ^= T6, { x_2: v8, x_3: E8 } = j7(S7, v8, E8), { x_2: B5, x_3: I6 } = j7(S7, B5, I6), S7 = T6;
      const U4 = v8 + B5, C7 = x7(U4 * U4), H5 = v8 - B5, q3 = x7(H5 * H5), P8 = C7 - q3, K5 = E8 + I6, et2 = E8 - I6, Z5 = x7(et2 * U4), z5 = x7(K5 * H5), Ft3 = Z5 + z5, yt4 = Z5 - z5;
      E8 = x7(Ft3 * Ft3), I6 = x7(b7 * x7(yt4 * yt4)), v8 = x7(C7 * q3), B5 = x7(P8 * (C7 + x7(h12 * P8)));
    }
    ({ x_2: v8, x_3: E8 } = j7(S7, v8, E8)), { x_2: B5, x_3: I6 } = j7(S7, B5, I6);
    const O8 = s8(B5);
    return x7(v8 * O8);
  }
  return { scalarMult: _5, scalarMultBase: k7, getSharedSecret: (d7, m6) => _5(d7, m6), getPublicKey: (d7) => k7(d7), utils: { randomPrivateKey: () => a5(c12) }, GuBytes: R6.slice() };
}
function Ic(t5) {
  const e10 = BigInt(10), n12 = BigInt(20), r9 = BigInt(40), o13 = BigInt(80), s8 = Uo2.p, f13 = t5 * t5 % s8 * t5 % s8, a5 = pt(f13, Oo2, s8) * f13 % s8, l10 = pt(a5, xc, s8) * t5 % s8, c12 = pt(l10, Ec, s8) * l10 % s8, u6 = pt(c12, e10, s8) * c12 % s8, h12 = pt(u6, n12, s8) * u6 % s8, g5 = pt(h12, r9, s8) * h12 % s8, w6 = pt(g5, o13, s8) * g5 % s8, y9 = pt(w6, o13, s8) * g5 % s8, x7 = pt(y9, e10, s8) * c12 % s8;
  return { pow_p_5_8: pt(x7, Oo2, s8) * t5 % s8, b2: f13 };
}
function Ac(t5) {
  return t5[0] &= 248, t5[31] &= 127, t5[31] |= 64, t5;
}
function _o2(t5) {
  t5.lowS !== void 0 && Re2("lowS", t5.lowS), t5.prehash !== void 0 && Re2("prehash", t5.prehash);
}
function Uc(t5, e10, n12) {
  function r9(o13) {
    const s8 = t5.sqr(o13), i11 = t5.mul(s8, o13);
    return t5.add(t5.add(i11, t5.mul(o13, e10)), n12);
  }
  return r9;
}
function To2(t5, e10, n12) {
  const { BYTES: r9 } = t5;
  function o13(s8) {
    let i11;
    if (typeof s8 == "bigint") i11 = s8;
    else {
      let f13 = rt2("private key", s8);
      if (e10) {
        if (!e10.includes(f13.length * 2)) throw new Error("invalid private key");
        const a5 = new Uint8Array(r9);
        a5.set(f13, a5.length - f13.length), f13 = a5;
      }
      try {
        i11 = t5.fromBytes(f13);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r9}, got ${typeof s8}`);
      }
    }
    if (n12 && (i11 = t5.create(i11)), !t5.isValidNot0(i11)) throw new Error("invalid private key: out of range [1..N-1]");
    return i11;
  }
  return o13;
}
function _c(t5, e10 = {}) {
  const { Fp: n12, Fn: r9 } = yc("weierstrass", t5, e10), { h: o13, n: s8 } = t5;
  ke2(e10, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i11 } = e10;
  if (i11 && (!n12.is0(t5.a) || typeof i11.beta != "bigint" || typeof i11.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f13() {
    if (!n12.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a5($6, d7, m6) {
    const { x: p8, y: b7 } = d7.toAffine(), v8 = n12.toBytes(p8);
    if (Re2("isCompressed", m6), m6) {
      f13();
      const B5 = !n12.isOdd(b7);
      return Ht2(Ro2(B5), v8);
    } else return Ht2(Uint8Array.of(4), v8, n12.toBytes(b7));
  }
  function l10($6) {
    at($6);
    const d7 = n12.BYTES, m6 = d7 + 1, p8 = 2 * d7 + 1, b7 = $6.length, v8 = $6[0], B5 = $6.subarray(1);
    if (b7 === m6 && (v8 === 2 || v8 === 3)) {
      const E8 = n12.fromBytes(B5);
      if (!n12.isValid(E8)) throw new Error("bad point: is not on curve, wrong x");
      const I6 = h12(E8);
      let S7;
      try {
        S7 = n12.sqrt(I6);
      } catch (T6) {
        const U4 = T6 instanceof Error ? ": " + T6.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U4);
      }
      f13();
      const O8 = n12.isOdd(S7);
      return (v8 & 1) === 1 !== O8 && (S7 = n12.neg(S7)), { x: E8, y: S7 };
    } else if (b7 === p8 && v8 === 4) {
      const E8 = n12.fromBytes(B5.subarray(d7 * 0, d7 * 1)), I6 = n12.fromBytes(B5.subarray(d7 * 1, d7 * 2));
      if (!g5(E8, I6)) throw new Error("bad point: is not on curve");
      return { x: E8, y: I6 };
    } else throw new Error(`bad point: got length ${b7}, expected compressed=${m6} or uncompressed=${p8}`);
  }
  const c12 = e10.toBytes || a5, u6 = e10.fromBytes || l10, h12 = Uc(n12, t5.a, t5.b);
  function g5($6, d7) {
    const m6 = n12.sqr(d7), p8 = h12($6);
    return n12.eql(m6, p8);
  }
  if (!g5(t5.Gx, t5.Gy)) throw new Error("bad curve params: generator point");
  const w6 = n12.mul(n12.pow(t5.a, He2), Oc), y9 = n12.mul(n12.sqr(t5.b), BigInt(27));
  if (n12.is0(n12.add(w6, y9))) throw new Error("bad curve params: a or b");
  function x7($6, d7, m6 = false) {
    if (!n12.isValid(d7) || m6 && n12.is0(d7)) throw new Error(`bad point coordinate ${$6}`);
    return d7;
  }
  function R6($6) {
    if (!($6 instanceof _5)) throw new Error("ProjectivePoint expected");
  }
  const M6 = ho2(($6, d7) => {
    const { px: m6, py: p8, pz: b7 } = $6;
    if (n12.eql(b7, n12.ONE)) return { x: m6, y: p8 };
    const v8 = $6.is0();
    d7 == null && (d7 = v8 ? n12.ONE : n12.inv(b7));
    const B5 = n12.mul(m6, d7), E8 = n12.mul(p8, d7), I6 = n12.mul(b7, d7);
    if (v8) return { x: n12.ZERO, y: n12.ZERO };
    if (!n12.eql(I6, n12.ONE)) throw new Error("invZ was invalid");
    return { x: B5, y: E8 };
  }), L6 = ho2(($6) => {
    if ($6.is0()) {
      if (e10.allowInfinityPoint && !n12.is0($6.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d7, y: m6 } = $6.toAffine();
    if (!n12.isValid(d7) || !n12.isValid(m6)) throw new Error("bad point: x or y not field elements");
    if (!g5(d7, m6)) throw new Error("bad point: equation left != right");
    if (!$6.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V6($6, d7, m6, p8, b7) {
    return m6 = new _5(n12.mul(m6.px, $6), m6.py, m6.pz), d7 = le2(p8, d7), m6 = le2(b7, m6), d7.add(m6);
  }
  class _5 {
    constructor(d7, m6, p8) {
      this.px = x7("x", d7), this.py = x7("y", m6, true), this.pz = x7("z", p8), Object.freeze(this);
    }
    static fromAffine(d7) {
      const { x: m6, y: p8 } = d7 || {};
      if (!d7 || !n12.isValid(m6) || !n12.isValid(p8)) throw new Error("invalid affine point");
      if (d7 instanceof _5) throw new Error("projective point not allowed");
      return n12.is0(m6) && n12.is0(p8) ? _5.ZERO : new _5(m6, p8, n12.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d7) {
      return lc(_5, "pz", d7);
    }
    static fromBytes(d7) {
      return at(d7), _5.fromHex(d7);
    }
    static fromHex(d7) {
      const m6 = _5.fromAffine(u6(rt2("pointHex", d7)));
      return m6.assertValidity(), m6;
    }
    static fromPrivateKey(d7) {
      const m6 = To2(r9, e10.allowedPrivateKeyLengths, e10.wrapPrivateKey);
      return _5.BASE.multiply(m6(d7));
    }
    static msm(d7, m6) {
      return bc(_5, r9, d7, m6);
    }
    precompute(d7 = 8, m6 = true) {
      return j7.setWindowSize(this, d7), m6 || this.multiply(He2), this;
    }
    _setWindowSize(d7) {
      this.precompute(d7);
    }
    assertValidity() {
      L6(this);
    }
    hasEvenY() {
      const { y: d7 } = this.toAffine();
      if (!n12.isOdd) throw new Error("Field doesn't support isOdd");
      return !n12.isOdd(d7);
    }
    equals(d7) {
      R6(d7);
      const { px: m6, py: p8, pz: b7 } = this, { px: v8, py: B5, pz: E8 } = d7, I6 = n12.eql(n12.mul(m6, E8), n12.mul(v8, b7)), S7 = n12.eql(n12.mul(p8, E8), n12.mul(B5, b7));
      return I6 && S7;
    }
    negate() {
      return new _5(this.px, n12.neg(this.py), this.pz);
    }
    double() {
      const { a: d7, b: m6 } = t5, p8 = n12.mul(m6, He2), { px: b7, py: v8, pz: B5 } = this;
      let E8 = n12.ZERO, I6 = n12.ZERO, S7 = n12.ZERO, O8 = n12.mul(b7, b7), A6 = n12.mul(v8, v8), T6 = n12.mul(B5, B5), U4 = n12.mul(b7, v8);
      return U4 = n12.add(U4, U4), S7 = n12.mul(b7, B5), S7 = n12.add(S7, S7), E8 = n12.mul(d7, S7), I6 = n12.mul(p8, T6), I6 = n12.add(E8, I6), E8 = n12.sub(A6, I6), I6 = n12.add(A6, I6), I6 = n12.mul(E8, I6), E8 = n12.mul(U4, E8), S7 = n12.mul(p8, S7), T6 = n12.mul(d7, T6), U4 = n12.sub(O8, T6), U4 = n12.mul(d7, U4), U4 = n12.add(U4, S7), S7 = n12.add(O8, O8), O8 = n12.add(S7, O8), O8 = n12.add(O8, T6), O8 = n12.mul(O8, U4), I6 = n12.add(I6, O8), T6 = n12.mul(v8, B5), T6 = n12.add(T6, T6), O8 = n12.mul(T6, U4), E8 = n12.sub(E8, O8), S7 = n12.mul(T6, A6), S7 = n12.add(S7, S7), S7 = n12.add(S7, S7), new _5(E8, I6, S7);
    }
    add(d7) {
      R6(d7);
      const { px: m6, py: p8, pz: b7 } = this, { px: v8, py: B5, pz: E8 } = d7;
      let I6 = n12.ZERO, S7 = n12.ZERO, O8 = n12.ZERO;
      const A6 = t5.a, T6 = n12.mul(t5.b, He2);
      let U4 = n12.mul(m6, v8), C7 = n12.mul(p8, B5), H5 = n12.mul(b7, E8), q3 = n12.add(m6, p8), P8 = n12.add(v8, B5);
      q3 = n12.mul(q3, P8), P8 = n12.add(U4, C7), q3 = n12.sub(q3, P8), P8 = n12.add(m6, b7);
      let K5 = n12.add(v8, E8);
      return P8 = n12.mul(P8, K5), K5 = n12.add(U4, H5), P8 = n12.sub(P8, K5), K5 = n12.add(p8, b7), I6 = n12.add(B5, E8), K5 = n12.mul(K5, I6), I6 = n12.add(C7, H5), K5 = n12.sub(K5, I6), O8 = n12.mul(A6, P8), I6 = n12.mul(T6, H5), O8 = n12.add(I6, O8), I6 = n12.sub(C7, O8), O8 = n12.add(C7, O8), S7 = n12.mul(I6, O8), C7 = n12.add(U4, U4), C7 = n12.add(C7, U4), H5 = n12.mul(A6, H5), P8 = n12.mul(T6, P8), C7 = n12.add(C7, H5), H5 = n12.sub(U4, H5), H5 = n12.mul(A6, H5), P8 = n12.add(P8, H5), U4 = n12.mul(C7, P8), S7 = n12.add(S7, U4), U4 = n12.mul(K5, P8), I6 = n12.mul(q3, I6), I6 = n12.sub(I6, U4), U4 = n12.mul(q3, C7), O8 = n12.mul(K5, O8), O8 = n12.add(O8, U4), new _5(I6, S7, O8);
    }
    subtract(d7) {
      return this.add(d7.negate());
    }
    is0() {
      return this.equals(_5.ZERO);
    }
    multiply(d7) {
      const { endo: m6 } = e10;
      if (!r9.isValidNot0(d7)) throw new Error("invalid scalar: out of range");
      let p8, b7;
      const v8 = (B5) => j7.wNAFCached(this, B5, _5.normalizeZ);
      if (m6) {
        const { k1neg: B5, k1: E8, k2neg: I6, k2: S7 } = m6.splitScalar(d7), { p: O8, f: A6 } = v8(E8), { p: T6, f: U4 } = v8(S7);
        b7 = A6.add(U4), p8 = V6(m6.beta, O8, T6, B5, I6);
      } else {
        const { p: B5, f: E8 } = v8(d7);
        p8 = B5, b7 = E8;
      }
      return _5.normalizeZ([p8, b7])[0];
    }
    multiplyUnsafe(d7) {
      const { endo: m6 } = e10, p8 = this;
      if (!r9.isValid(d7)) throw new Error("invalid scalar: out of range");
      if (d7 === he2 || p8.is0()) return _5.ZERO;
      if (d7 === pe2) return p8;
      if (j7.hasPrecomputes(this)) return this.multiply(d7);
      if (m6) {
        const { k1neg: b7, k1: v8, k2neg: B5, k2: E8 } = m6.splitScalar(d7), { p1: I6, p2: S7 } = gc(_5, p8, v8, E8);
        return V6(m6.beta, I6, S7, b7, B5);
      } else return j7.wNAFCachedUnsafe(p8, d7);
    }
    multiplyAndAddUnsafe(d7, m6, p8) {
      const b7 = this.multiplyUnsafe(m6).add(d7.multiplyUnsafe(p8));
      return b7.is0() ? void 0 : b7;
    }
    toAffine(d7) {
      return M6(this, d7);
    }
    isTorsionFree() {
      const { isTorsionFree: d7 } = e10;
      return o13 === pe2 ? true : d7 ? d7(_5, this) : j7.wNAFCachedUnsafe(this, s8).is0();
    }
    clearCofactor() {
      const { clearCofactor: d7 } = e10;
      return o13 === pe2 ? this : d7 ? d7(_5, this) : this.multiplyUnsafe(o13);
    }
    toBytes(d7 = true) {
      return Re2("isCompressed", d7), this.assertValidity(), c12(_5, this, d7);
    }
    toRawBytes(d7 = true) {
      return this.toBytes(d7);
    }
    toHex(d7 = true) {
      return ce(this.toBytes(d7));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _5.BASE = new _5(t5.Gx, t5.Gy, n12.ONE), _5.ZERO = new _5(n12.ZERO, n12.ONE, n12.ZERO), _5.Fp = n12, _5.Fn = r9;
  const k7 = r9.BITS, j7 = pc(_5, e10.endo ? Math.ceil(k7 / 2) : k7);
  return _5;
}
function Ro2(t5) {
  return Uint8Array.of(t5 ? 2 : 3);
}
function Tc(t5, e10, n12 = {}) {
  ke2(e10, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r9 = e10.randomBytes || Zt2, o13 = e10.hmac || ((p8, ...b7) => _e2(e10.hash, p8, Ht2(...b7))), { Fp: s8, Fn: i11 } = t5, { ORDER: f13, BITS: a5 } = i11;
  function l10(p8) {
    const b7 = f13 >> pe2;
    return p8 > b7;
  }
  function c12(p8) {
    return l10(p8) ? i11.neg(p8) : p8;
  }
  function u6(p8, b7) {
    if (!i11.isValidNot0(b7)) throw new Error(`invalid signature ${p8}: out of range 1..CURVE.n`);
  }
  class h12 {
    constructor(b7, v8, B5) {
      u6("r", b7), u6("s", v8), this.r = b7, this.s = v8, B5 != null && (this.recovery = B5), Object.freeze(this);
    }
    static fromCompact(b7) {
      const v8 = i11.BYTES, B5 = rt2("compactSignature", b7, v8 * 2);
      return new h12(i11.fromBytes(B5.subarray(0, v8)), i11.fromBytes(B5.subarray(v8, v8 * 2)));
    }
    static fromDER(b7) {
      const { r: v8, s: B5 } = vt2.toSig(rt2("DER", b7));
      return new h12(v8, B5);
    }
    assertValidity() {
    }
    addRecoveryBit(b7) {
      return new h12(this.r, this.s, b7);
    }
    recoverPublicKey(b7) {
      const v8 = s8.ORDER, { r: B5, s: E8, recovery: I6 } = this;
      if (I6 == null || ![0, 1, 2, 3].includes(I6)) throw new Error("recovery id invalid");
      if (f13 * Nc < v8 && I6 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O8 = I6 === 2 || I6 === 3 ? B5 + f13 : B5;
      if (!s8.isValid(O8)) throw new Error("recovery id 2 or 3 invalid");
      const A6 = s8.toBytes(O8), T6 = t5.fromHex(Ht2(Ro2((I6 & 1) === 0), A6)), U4 = i11.inv(O8), C7 = L6(rt2("msgHash", b7)), H5 = i11.create(-C7 * U4), q3 = i11.create(E8 * U4), P8 = t5.BASE.multiplyUnsafe(H5).add(T6.multiplyUnsafe(q3));
      if (P8.is0()) throw new Error("point at infinify");
      return P8.assertValidity(), P8;
    }
    hasHighS() {
      return l10(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h12(this.r, i11.neg(this.s), this.recovery) : this;
    }
    toBytes(b7) {
      if (b7 === "compact") return Ht2(i11.toBytes(this.r), i11.toBytes(this.s));
      if (b7 === "der") return fn(vt2.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce(this.toBytes("compact"));
    }
  }
  const g5 = To2(i11, n12.allowedPrivateKeyLengths, n12.wrapPrivateKey), w6 = { isValidPrivateKey(p8) {
    try {
      return g5(p8), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g5, randomPrivateKey: () => {
    const p8 = f13;
    return uc(r9(Eo2(p8)), p8);
  }, precompute(p8 = 8, b7 = t5.BASE) {
    return b7.precompute(p8, false);
  } };
  function y9(p8, b7 = true) {
    return t5.fromPrivateKey(p8).toBytes(b7);
  }
  function x7(p8) {
    if (typeof p8 == "bigint") return false;
    if (p8 instanceof t5) return true;
    const v8 = rt2("key", p8).length, B5 = s8.BYTES, E8 = B5 + 1, I6 = 2 * B5 + 1;
    if (!(n12.allowedPrivateKeyLengths || i11.BYTES === E8)) return v8 === E8 || v8 === I6;
  }
  function R6(p8, b7, v8 = true) {
    if (x7(p8) === true) throw new Error("first arg must be private key");
    if (x7(b7) === false) throw new Error("second arg must be public key");
    return t5.fromHex(b7).multiply(g5(p8)).toBytes(v8);
  }
  const M6 = e10.bits2int || function(p8) {
    if (p8.length > 8192) throw new Error("input is too large");
    const b7 = Ce2(p8), v8 = p8.length * 8 - a5;
    return v8 > 0 ? b7 >> BigInt(v8) : b7;
  }, L6 = e10.bits2int_modN || function(p8) {
    return i11.create(M6(p8));
  }, V6 = je2(a5);
  function _5(p8) {
    return Nn2("num < 2^" + a5, p8, he2, V6), i11.toBytes(p8);
  }
  function k7(p8, b7, v8 = j7) {
    if (["recovered", "canonical"].some((q3) => q3 in v8)) throw new Error("sign() legacy options not supported");
    const { hash: B5 } = e10;
    let { lowS: E8, prehash: I6, extraEntropy: S7 } = v8;
    E8 == null && (E8 = true), p8 = rt2("msgHash", p8), _o2(v8), I6 && (p8 = rt2("prehashed msgHash", B5(p8)));
    const O8 = L6(p8), A6 = g5(b7), T6 = [_5(A6), _5(O8)];
    if (S7 != null && S7 !== false) {
      const q3 = S7 === true ? r9(s8.BYTES) : S7;
      T6.push(rt2("extraEntropy", q3));
    }
    const U4 = Ht2(...T6), C7 = O8;
    function H5(q3) {
      const P8 = M6(q3);
      if (!i11.isValidNot0(P8)) return;
      const K5 = i11.inv(P8), et2 = t5.BASE.multiply(P8).toAffine(), Z5 = i11.create(et2.x);
      if (Z5 === he2) return;
      const z5 = i11.create(K5 * i11.create(C7 + Z5 * A6));
      if (z5 === he2) return;
      let Ft3 = (et2.x === Z5 ? 0 : 2) | Number(et2.y & pe2), yt4 = z5;
      return E8 && l10(z5) && (yt4 = c12(z5), Ft3 ^= 1), new h12(Z5, yt4, Ft3);
    }
    return { seed: U4, k2sig: H5 };
  }
  const j7 = { lowS: e10.lowS, prehash: false }, $6 = { lowS: e10.lowS, prehash: false };
  function d7(p8, b7, v8 = j7) {
    const { seed: B5, k2sig: E8 } = k7(p8, b7, v8);
    return ec(e10.hash.outputLen, i11.BYTES, o13)(B5, E8);
  }
  t5.BASE.precompute(8);
  function m6(p8, b7, v8, B5 = $6) {
    const E8 = p8;
    b7 = rt2("msgHash", b7), v8 = rt2("publicKey", v8), _o2(B5);
    const { lowS: I6, prehash: S7, format: O8 } = B5;
    if ("strict" in B5) throw new Error("options.strict was renamed to lowS");
    if (O8 !== void 0 && !["compact", "der", "js"].includes(O8)) throw new Error('format must be "compact", "der" or "js"');
    const A6 = typeof E8 == "string" || nn2(E8), T6 = !A6 && !O8 && typeof E8 == "object" && E8 !== null && typeof E8.r == "bigint" && typeof E8.s == "bigint";
    if (!A6 && !T6) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U4, C7;
    try {
      if (T6) if (O8 === void 0 || O8 === "js") U4 = new h12(E8.r, E8.s);
      else throw new Error("invalid format");
      if (A6) {
        try {
          O8 !== "compact" && (U4 = h12.fromDER(E8));
        } catch (yt4) {
          if (!(yt4 instanceof vt2.Err)) throw yt4;
        }
        !U4 && O8 !== "der" && (U4 = h12.fromCompact(E8));
      }
      C7 = t5.fromHex(v8);
    } catch {
      return false;
    }
    if (!U4 || I6 && U4.hasHighS()) return false;
    S7 && (b7 = e10.hash(b7));
    const { r: H5, s: q3 } = U4, P8 = L6(b7), K5 = i11.inv(q3), et2 = i11.create(P8 * K5), Z5 = i11.create(H5 * K5), z5 = t5.BASE.multiplyUnsafe(et2).add(C7.multiplyUnsafe(Z5));
    return z5.is0() ? false : i11.create(z5.x) === H5;
  }
  return Object.freeze({ getPublicKey: y9, getSharedSecret: R6, sign: d7, verify: m6, utils: w6, Point: t5, Signature: h12 });
}
function Rc(t5) {
  const e10 = { a: t5.a, b: t5.b, p: t5.Fp.ORDER, n: t5.n, h: t5.h, Gx: t5.Gx, Gy: t5.Gy }, n12 = t5.Fp, r9 = Yt2(e10.n, t5.nBitLength), o13 = { Fp: n12, Fn: r9, allowedPrivateKeyLengths: t5.allowedPrivateKeyLengths, allowInfinityPoint: t5.allowInfinityPoint, endo: t5.endo, wrapPrivateKey: t5.wrapPrivateKey, isTorsionFree: t5.isTorsionFree, clearCofactor: t5.clearCofactor, fromBytes: t5.fromBytes, toBytes: t5.toBytes };
  return { CURVE: e10, curveOpts: o13 };
}
function $c(t5) {
  const { CURVE: e10, curveOpts: n12 } = Rc(t5), r9 = { hash: t5.hash, hmac: t5.hmac, randomBytes: t5.randomBytes, lowS: t5.lowS, bits2int: t5.bits2int, bits2int_modN: t5.bits2int_modN };
  return { CURVE: e10, curveOpts: n12, ecdsaOpts: r9 };
}
function Cc(t5, e10) {
  return Object.assign({}, e10, { ProjectivePoint: e10.Point, CURVE: t5 });
}
function Lc(t5) {
  const { CURVE: e10, curveOpts: n12, ecdsaOpts: r9 } = $c(t5), o13 = _c(e10, n12), s8 = Tc(o13, r9, n12);
  return Cc(t5, s8);
}
function Rn2(t5, e10) {
  const n12 = (r9) => Lc({ ...t5, hash: r9 });
  return { ...n12(e10), create: n12 };
}
function Vc() {
  const t5 = Tn2.utils.randomPrivateKey(), e10 = Tn2.getPublicKey(t5);
  return { privateKey: toString2(t5, tt), publicKey: toString2(e10, tt) };
}
function qc() {
  const t5 = Zt2(Ln2);
  return toString2(t5, tt);
}
function Kc(t5, e10) {
  const n12 = Tn2.getSharedSecret(fromString2(t5, tt), fromString2(e10, tt)), r9 = Jf(Te2, n12, void 0, void 0, Ln2);
  return toString2(r9, tt);
}
function Fc(t5) {
  const e10 = Te2(fromString2(t5, tt));
  return toString2(e10, tt);
}
function zc(t5) {
  const e10 = Te2(fromString2(t5, te2));
  return toString2(e10, tt);
}
function jn2(t5) {
  return fromString2(`${t5}`, $n2);
}
function Vt2(t5) {
  return Number(toString2(t5, $n2));
}
function ko2(t5) {
  return t5.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Po2(t5) {
  const e10 = t5.replace(/-/g, "+").replace(/_/g, "/"), n12 = (4 - e10.length % 4) % 4;
  return e10 + "=".repeat(n12);
}
function Gc(t5) {
  const e10 = jn2(typeof t5.type < "u" ? t5.type : Cn2);
  if (Vt2(e10) === ee && typeof t5.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n12 = typeof t5.senderPublicKey < "u" ? fromString2(t5.senderPublicKey, tt) : void 0, r9 = typeof t5.iv < "u" ? fromString2(t5.iv, tt) : Zt2(be2), o13 = fromString2(t5.symKey, tt), s8 = co2(o13, r9).encrypt(fromString2(t5.message, te2)), i11 = kn2({ type: e10, sealed: s8, iv: r9, senderPublicKey: n12 });
  return t5.encoding === De2 ? ko2(i11) : i11;
}
function Zc(t5) {
  const e10 = fromString2(t5.symKey, tt), { sealed: n12, iv: r9 } = Me2({ encoded: t5.encoded, encoding: t5.encoding }), o13 = co2(e10, r9).decrypt(n12);
  if (o13 === null) throw new Error("Failed to decrypt");
  return toString2(o13, te2);
}
function Wc(t5, e10) {
  const n12 = jn2(ge2), r9 = Zt2(be2), o13 = fromString2(t5, te2), s8 = kn2({ type: n12, sealed: o13, iv: r9 });
  return e10 === De2 ? ko2(s8) : s8;
}
function Yc(t5, e10) {
  const { sealed: n12 } = Me2({ encoded: t5, encoding: e10 });
  return toString2(n12, te2);
}
function kn2(t5) {
  if (Vt2(t5.type) === ge2) return toString2(concat([t5.type, t5.sealed]), Qt2);
  if (Vt2(t5.type) === ee) {
    if (typeof t5.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString2(concat([t5.type, t5.senderPublicKey, t5.iv, t5.sealed]), Qt2);
  }
  return toString2(concat([t5.type, t5.iv, t5.sealed]), Qt2);
}
function Me2(t5) {
  const e10 = (t5.encoding || Qt2) === De2 ? Po2(t5.encoded) : t5.encoded, n12 = fromString2(e10, Qt2), r9 = n12.slice(Mc, jo2), o13 = jo2;
  if (Vt2(r9) === ee) {
    const a5 = o13 + Ln2, l10 = a5 + be2, c12 = n12.slice(o13, a5), u6 = n12.slice(a5, l10), h12 = n12.slice(l10);
    return { type: r9, sealed: h12, iv: u6, senderPublicKey: c12 };
  }
  if (Vt2(r9) === ge2) {
    const a5 = n12.slice(o13), l10 = Zt2(be2);
    return { type: r9, sealed: a5, iv: l10 };
  }
  const s8 = o13 + be2, i11 = n12.slice(o13, s8), f13 = n12.slice(s8);
  return { type: r9, sealed: f13, iv: i11 };
}
function Xc(t5, e10) {
  const n12 = Me2({ encoded: t5, encoding: e10?.encoding });
  return Ho2({ type: Vt2(n12.type), senderPublicKey: typeof n12.senderPublicKey < "u" ? toString2(n12.senderPublicKey, tt) : void 0, receiverPublicKey: e10?.receiverPublicKey });
}
function Ho2(t5) {
  const e10 = t5?.type || Cn2;
  if (e10 === ee) {
    if (typeof t5?.senderPublicKey > "u") throw new Error("missing sender public key");
    if (typeof t5?.receiverPublicKey > "u") throw new Error("missing receiver public key");
  }
  return { type: e10, senderPublicKey: t5?.senderPublicKey, receiverPublicKey: t5?.receiverPublicKey };
}
function Jc(t5) {
  return t5.type === ee && typeof t5.senderPublicKey == "string" && typeof t5.receiverPublicKey == "string";
}
function Qc(t5) {
  return t5.type === ge2;
}
function Do2(t5) {
  const e10 = Buffer.from(t5.x, "base64"), n12 = Buffer.from(t5.y, "base64");
  return concat([new Uint8Array([4]), e10, n12]);
}
function ta(t5, e10) {
  const [n12, r9, o13] = t5.split("."), s8 = Buffer.from(Po2(o13), "base64");
  if (s8.length !== 64) throw new Error("Invalid signature length");
  const i11 = s8.slice(0, 32), f13 = s8.slice(32, 64), a5 = `${n12}.${r9}`, l10 = Te2(a5), c12 = Do2(e10);
  if (!Dc.verify(concat([i11, f13]), l10, c12)) throw new Error("Invalid signature");
  return sn(t5).payload;
}
function ea(t5) {
  return t5?.relay || { protocol: Mo2 };
}
function na(t5) {
  const e10 = C2[t5];
  if (typeof e10 > "u") throw new Error(`Relay Protocol not supported: ${t5}`);
  return e10;
}
function Vo2(t5, e10 = "-") {
  const n12 = {}, r9 = "relay" + e10;
  return Object.keys(t5).forEach((o13) => {
    if (o13.startsWith(r9)) {
      const s8 = o13.replace(r9, ""), i11 = t5[o13];
      n12[s8] = i11;
    }
  }), n12;
}
function ra(t5) {
  if (!t5.includes("wc:")) {
    const l10 = Qe2(t5);
    l10 != null && l10.includes("wc:") && (t5 = l10);
  }
  t5 = t5.includes("wc://") ? t5.replace("wc://", "") : t5, t5 = t5.includes("wc:") ? t5.replace("wc:", "") : t5;
  const e10 = t5.indexOf(":"), n12 = t5.indexOf("?") !== -1 ? t5.indexOf("?") : void 0, r9 = t5.substring(0, e10), o13 = t5.substring(e10 + 1, n12).split("@"), s8 = typeof n12 < "u" ? t5.substring(n12) : "", i11 = new URLSearchParams(s8), f13 = {};
  i11.forEach((l10, c12) => {
    f13[c12] = l10;
  });
  const a5 = typeof f13.methods == "string" ? f13.methods.split(",") : void 0;
  return { protocol: r9, topic: qo2(o13[0]), version: parseInt(o13[1], 10), symKey: f13.symKey, relay: Vo2(f13), methods: a5, expiryTimestamp: f13.expiryTimestamp ? parseInt(f13.expiryTimestamp, 10) : void 0 };
}
function qo2(t5) {
  return t5.startsWith("//") ? t5.substring(2) : t5;
}
function Ko2(t5, e10 = "-") {
  const n12 = "relay", r9 = {};
  return Object.keys(t5).forEach((o13) => {
    const s8 = o13, i11 = n12 + e10 + s8;
    t5[s8] && (r9[i11] = t5[s8]);
  }), r9;
}
function oa(t5) {
  const e10 = new URLSearchParams(), n12 = Ko2(t5.relay);
  Object.keys(n12).sort().forEach((o13) => {
    e10.set(o13, n12[o13]);
  }), e10.set("symKey", t5.symKey), t5.expiryTimestamp && e10.set("expiryTimestamp", t5.expiryTimestamp.toString()), t5.methods && e10.set("methods", t5.methods.join(","));
  const r9 = e10.toString();
  return `${t5.protocol}:${t5.topic}@${t5.version}?${r9}`;
}
function sa(t5, e10, n12) {
  return `${t5}?wc_ev=${n12}&topic=${e10}`;
}
function qt2(t5) {
  const e10 = [];
  return t5.forEach((n12) => {
    const [r9, o13] = n12.split(":");
    e10.push(`${r9}:${o13}`);
  }), e10;
}
function Go2(t5) {
  const e10 = [];
  return Object.values(t5).forEach((n12) => {
    e10.push(...qt2(n12.accounts));
  }), e10;
}
function Zo2(t5, e10) {
  const n12 = [];
  return Object.values(t5).forEach((r9) => {
    qt2(r9.accounts).includes(e10) && n12.push(...r9.methods);
  }), n12;
}
function Wo2(t5, e10) {
  const n12 = [];
  return Object.values(t5).forEach((r9) => {
    qt2(r9.accounts).includes(e10) && n12.push(...r9.events);
  }), n12;
}
function Pn2(t5) {
  return t5.includes(":");
}
function Yo2(t5) {
  return Pn2(t5) ? t5.split(":")[0] : t5;
}
function ye2(t5) {
  var e10, n12, r9;
  const o13 = {};
  if (!Ve2(t5)) return o13;
  for (const [s8, i11] of Object.entries(t5)) {
    const f13 = Pn2(s8) ? [s8] : i11.chains, a5 = i11.methods || [], l10 = i11.events || [], c12 = Yo2(s8);
    o13[c12] = da(la({}, o13[c12]), { chains: ct2(f13, (e10 = o13[c12]) == null ? void 0 : e10.chains), methods: ct2(a5, (n12 = o13[c12]) == null ? void 0 : n12.methods), events: ct2(l10, (r9 = o13[c12]) == null ? void 0 : r9.events) });
  }
  return o13;
}
function Xo(t5) {
  const e10 = {};
  return t5?.forEach((n12) => {
    var r9;
    const [o13, s8] = n12.split(":");
    e10[o13] || (e10[o13] = { accounts: [], chains: [], events: [], methods: [] }), e10[o13].accounts.push(n12), (r9 = e10[o13].chains) == null || r9.push(`${o13}:${s8}`);
  }), e10;
}
function ga(t5, e10) {
  e10 = e10.map((r9) => r9.replace("did:pkh:", ""));
  const n12 = Xo(e10);
  for (const [r9, o13] of Object.entries(n12)) o13.methods ? o13.methods = ct2(o13.methods, t5) : o13.methods = t5, o13.events = ["chainChanged", "accountsChanged"];
  return n12;
}
function ba(t5, e10) {
  var n12, r9, o13, s8, i11, f13;
  const a5 = ye2(t5), l10 = ye2(e10), c12 = {}, u6 = Object.keys(a5).concat(Object.keys(l10));
  for (const h12 of u6) c12[h12] = { chains: ct2((n12 = a5[h12]) == null ? void 0 : n12.chains, (r9 = l10[h12]) == null ? void 0 : r9.chains), methods: ct2((o13 = a5[h12]) == null ? void 0 : o13.methods, (s8 = l10[h12]) == null ? void 0 : s8.methods), events: ct2((i11 = a5[h12]) == null ? void 0 : i11.events, (f13 = l10[h12]) == null ? void 0 : f13.events) };
  return c12;
}
function Et2(t5, e10) {
  const { message: n12, code: r9 } = Qo2[t5];
  return { message: e10 ? `${n12} ${e10}` : n12, code: r9 };
}
function Kt2(t5, e10) {
  const { message: n12, code: r9 } = Jo2[t5];
  return { message: e10 ? `${n12} ${e10}` : n12, code: r9 };
}
function me2(t5, e10) {
  return Array.isArray(t5) ? typeof e10 < "u" && t5.length ? t5.every(e10) : true : false;
}
function Ve2(t5) {
  return Object.getPrototypeOf(t5) === Object.prototype && Object.keys(t5).length;
}
function kt2(t5) {
  return typeof t5 > "u";
}
function it2(t5, e10) {
  return e10 && kt2(t5) ? true : typeof t5 == "string" && !!t5.trim().length;
}
function qe2(t5, e10) {
  return e10 && kt2(t5) ? true : typeof t5 == "number" && !isNaN(t5);
}
function ya(t5, e10) {
  const { requiredNamespaces: n12 } = e10, r9 = Object.keys(t5.namespaces), o13 = Object.keys(n12);
  let s8 = true;
  return It2(o13, r9) ? (r9.forEach((i11) => {
    const { accounts: f13, methods: a5, events: l10 } = t5.namespaces[i11], c12 = qt2(f13), u6 = n12[i11];
    (!It2(ve2(i11, u6), c12) || !It2(u6.methods, a5) || !It2(u6.events, l10)) && (s8 = false);
  }), s8) : false;
}
function we2(t5) {
  return it2(t5, false) && t5.includes(":") ? t5.split(":").length === 2 : false;
}
function ts(t5) {
  if (it2(t5, false) && t5.includes(":")) {
    const e10 = t5.split(":");
    if (e10.length === 3) {
      const n12 = e10[0] + ":" + e10[1];
      return !!e10[2] && we2(n12);
    }
  }
  return false;
}
function ma(t5) {
  function e10(n12) {
    try {
      return typeof new URL(n12) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (it2(t5, false)) {
      if (e10(t5)) return true;
      const n12 = Qe2(t5);
      return e10(n12);
    }
  } catch {
  }
  return false;
}
function wa(t5) {
  var e10;
  return (e10 = t5?.proposer) == null ? void 0 : e10.publicKey;
}
function xa(t5) {
  return t5?.topic;
}
function va(t5, e10) {
  let n12 = null;
  return it2(t5?.publicKey, false) || (n12 = Et2("MISSING_OR_INVALID", `${e10} controller public key should be a string`)), n12;
}
function Hn2(t5) {
  let e10 = true;
  return me2(t5) ? t5.length && (e10 = t5.every((n12) => it2(n12, false))) : e10 = false, e10;
}
function es(t5, e10, n12) {
  let r9 = null;
  return me2(e10) && e10.length ? e10.forEach((o13) => {
    r9 || we2(o13) || (r9 = Kt2("UNSUPPORTED_CHAINS", `${n12}, chain ${o13} should be a string and conform to "namespace:chainId" format`));
  }) : we2(t5) || (r9 = Kt2("UNSUPPORTED_CHAINS", `${n12}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r9;
}
function ns(t5, e10, n12) {
  let r9 = null;
  return Object.entries(t5).forEach(([o13, s8]) => {
    if (r9) return;
    const i11 = es(o13, ve2(o13, s8), `${e10} ${n12}`);
    i11 && (r9 = i11);
  }), r9;
}
function rs(t5, e10) {
  let n12 = null;
  return me2(t5) ? t5.forEach((r9) => {
    n12 || ts(r9) || (n12 = Kt2("UNSUPPORTED_ACCOUNTS", `${e10}, account ${r9} should be a string and conform to "namespace:chainId:address" format`));
  }) : n12 = Kt2("UNSUPPORTED_ACCOUNTS", `${e10}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n12;
}
function os(t5, e10) {
  let n12 = null;
  return Object.values(t5).forEach((r9) => {
    if (n12) return;
    const o13 = rs(r9?.accounts, `${e10} namespace`);
    o13 && (n12 = o13);
  }), n12;
}
function ss(t5, e10) {
  let n12 = null;
  return Hn2(t5?.methods) ? Hn2(t5?.events) || (n12 = Kt2("UNSUPPORTED_EVENTS", `${e10}, events should be an array of strings or empty array for no events`)) : n12 = Kt2("UNSUPPORTED_METHODS", `${e10}, methods should be an array of strings or empty array for no methods`), n12;
}
function Dn(t5, e10) {
  let n12 = null;
  return Object.values(t5).forEach((r9) => {
    if (n12) return;
    const o13 = ss(r9, `${e10}, namespace`);
    o13 && (n12 = o13);
  }), n12;
}
function Ea(t5, e10, n12) {
  let r9 = null;
  if (t5 && Ve2(t5)) {
    const o13 = Dn(t5, e10);
    o13 && (r9 = o13);
    const s8 = ns(t5, e10, n12);
    s8 && (r9 = s8);
  } else r9 = Et2("MISSING_OR_INVALID", `${e10}, ${n12} should be an object with data`);
  return r9;
}
function is(t5, e10) {
  let n12 = null;
  if (t5 && Ve2(t5)) {
    const r9 = Dn(t5, e10);
    r9 && (n12 = r9);
    const o13 = os(t5, e10);
    o13 && (n12 = o13);
  } else n12 = Et2("MISSING_OR_INVALID", `${e10}, namespaces should be an object with data`);
  return n12;
}
function fs(t5) {
  return it2(t5.protocol, true);
}
function Ba(t5, e10) {
  let n12 = false;
  return e10 && !t5 ? n12 = true : t5 && me2(t5) && t5.length && t5.forEach((r9) => {
    n12 = fs(r9);
  }), n12;
}
function Ia(t5) {
  return typeof t5 == "number";
}
function Aa(t5) {
  return typeof t5 < "u" && typeof t5 !== null;
}
function Sa(t5) {
  return !(!t5 || typeof t5 != "object" || !t5.code || !qe2(t5.code, false) || !t5.message || !it2(t5.message, false));
}
function Na(t5) {
  return !(kt2(t5) || !it2(t5.method, false));
}
function Oa(t5) {
  return !(kt2(t5) || kt2(t5.result) && kt2(t5.error) || !qe2(t5.id, false) || !it2(t5.jsonrpc, false));
}
function Ua(t5) {
  return !(kt2(t5) || !it2(t5.name, false));
}
function _a(t5, e10) {
  return !(!we2(e10) || !Go2(t5).includes(e10));
}
function Ta(t5, e10, n12) {
  return it2(n12, false) ? Zo2(t5, e10).includes(n12) : false;
}
function Ra(t5, e10, n12) {
  return it2(n12, false) ? Wo2(t5, e10).includes(n12) : false;
}
function cs(t5, e10, n12) {
  let r9 = null;
  const o13 = $a(t5), s8 = Ca(e10), i11 = Object.keys(o13), f13 = Object.keys(s8), a5 = as(Object.keys(t5)), l10 = as(Object.keys(e10)), c12 = a5.filter((u6) => !l10.includes(u6));
  return c12.length && (r9 = Et2("NON_CONFORMING_NAMESPACES", `${n12} namespaces keys don't satisfy requiredNamespaces.
      Required: ${c12.toString()}
      Received: ${Object.keys(e10).toString()}`)), It2(i11, f13) || (r9 = Et2("NON_CONFORMING_NAMESPACES", `${n12} namespaces chains don't satisfy required namespaces.
      Required: ${i11.toString()}
      Approved: ${f13.toString()}`)), Object.keys(e10).forEach((u6) => {
    if (!u6.includes(":") || r9) return;
    const h12 = qt2(e10[u6].accounts);
    h12.includes(u6) || (r9 = Et2("NON_CONFORMING_NAMESPACES", `${n12} namespaces accounts don't satisfy namespace accounts for ${u6}
        Required: ${u6}
        Approved: ${h12.toString()}`));
  }), i11.forEach((u6) => {
    r9 || (It2(o13[u6].methods, s8[u6].methods) ? It2(o13[u6].events, s8[u6].events) || (r9 = Et2("NON_CONFORMING_NAMESPACES", `${n12} namespaces events don't satisfy namespace events for ${u6}`)) : r9 = Et2("NON_CONFORMING_NAMESPACES", `${n12} namespaces methods don't satisfy namespace methods for ${u6}`));
  }), r9;
}
function $a(t5) {
  const e10 = {};
  return Object.keys(t5).forEach((n12) => {
    var r9;
    n12.includes(":") ? e10[n12] = t5[n12] : (r9 = t5[n12].chains) == null || r9.forEach((o13) => {
      e10[o13] = { methods: t5[n12].methods, events: t5[n12].events };
    });
  }), e10;
}
function as(t5) {
  return [...new Set(t5.map((e10) => e10.includes(":") ? e10.split(":")[0] : e10))];
}
function Ca(t5) {
  const e10 = {};
  return Object.keys(t5).forEach((n12) => {
    if (n12.includes(":")) e10[n12] = t5[n12];
    else {
      const r9 = qt2(t5[n12].accounts);
      r9?.forEach((o13) => {
        e10[o13] = { accounts: t5[n12].accounts.filter((s8) => s8.includes(`${o13}:`)), methods: t5[n12].methods, events: t5[n12].events };
      });
    }
  }), e10;
}
function La(t5, e10) {
  return qe2(t5, false) && t5 <= e10.max && t5 >= e10.min;
}
function ja() {
  const t5 = Pt2();
  return new Promise((e10) => {
    switch (t5) {
      case J3.browser:
        e10(us());
        break;
      case J3.reactNative:
        e10(ls());
        break;
      case J3.node:
        e10(ds());
        break;
      default:
        e10(true);
    }
  });
}
function us() {
  return zt2() && navigator?.onLine;
}
async function ls() {
  if (Bt2() && typeof global < "u" && global != null && global.NetInfo) {
    const t5 = await (global == null ? void 0 : global.NetInfo.fetch());
    return t5?.isConnected;
  }
  return true;
}
function ds() {
  return true;
}
function ka(t5) {
  switch (Pt2()) {
    case J3.browser:
      hs(t5);
      break;
    case J3.reactNative:
      ps(t5);
      break;
    case J3.node:
      break;
  }
}
function hs(t5) {
  !Bt2() && zt2() && (window.addEventListener("online", () => t5(true)), window.addEventListener("offline", () => t5(false)));
}
function ps(t5) {
  Bt2() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e10) => t5(e10?.isConnected));
}
function Pa() {
  var t5;
  return zt2() && (0, import_window_getters.getDocument)() ? ((t5 = (0, import_window_getters.getDocument)()) == null ? void 0 : t5.visibilityState) === "visible" : true;
}
function gs(t5) {
  const e10 = esm_default2.decode(t5);
  if (e10.length < 33) throw new Error("Too short to contain a public key");
  return e10.slice(1, 33);
}
function bs({ publicKey: t5, signature: e10, payload: n12 }) {
  var r9;
  const o13 = Vn2(n12.method), s8 = 128 | parseInt(((r9 = n12.version) == null ? void 0 : r9.toString()) || "4"), i11 = Ma(n12.address), f13 = n12.era === "00" ? new Uint8Array([0]) : Vn2(n12.era);
  if (f13.length !== 1 && f13.length !== 2) throw new Error("Invalid era length");
  const a5 = parseInt(n12.nonce, 16), l10 = new Uint8Array([a5 & 255, a5 >> 8 & 255]), c12 = BigInt(`0x${Da(n12.tip)}`), u6 = qa(c12), h12 = new Uint8Array([0, ...t5, i11, ...e10, ...f13, ...l10, ...u6, ...o13]), g5 = Va(h12.length + 1);
  return new Uint8Array([...g5, s8, ...h12]);
}
function ys(t5) {
  const e10 = Vn2(t5), n12 = (0, import_blakejs.blake2b)(e10, void 0, 32);
  return "0x" + Buffer.from(n12).toString("hex");
}
function Vn2(t5) {
  return new Uint8Array(t5.replace(/^0x/, "").match(/.{1,2}/g).map((e10) => parseInt(e10, 16)));
}
function Da(t5) {
  return t5.startsWith("0x") ? t5.slice(2) : t5;
}
function Ma(t5) {
  const e10 = esm_default2.decode(t5)[0];
  return e10 === 42 ? 0 : e10 === 60 ? 2 : 1;
}
function Va(t5) {
  if (t5 < 64) return new Uint8Array([t5 << 2]);
  if (t5 < 16384) {
    const e10 = t5 << 2 | 1;
    return new Uint8Array([e10 & 255, e10 >> 8 & 255]);
  } else if (t5 < 1 << 30) {
    const e10 = t5 << 2 | 2;
    return new Uint8Array([e10 & 255, e10 >> 8 & 255, e10 >> 16 & 255, e10 >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function qa(t5) {
  if (t5 < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t5 << BigInt(2))]);
  if (t5 < BigInt(1) << BigInt(14)) {
    const e10 = t5 << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e10 & BigInt(255)), Number(e10 >> BigInt(8) & BigInt(255))]);
  } else if (t5 < BigInt(1) << BigInt(30)) {
    const e10 = t5 << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e10 & BigInt(255)), Number(e10 >> BigInt(8) & BigInt(255)), Number(e10 >> BigInt(16) & BigInt(255)), Number(e10 >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function Ka(t5) {
  const e10 = Uint8Array.from(Buffer.from(t5.signature, "hex")), n12 = gs(t5.transaction.address), r9 = bs({ publicKey: n12, signature: e10, payload: t5.transaction }), o13 = Buffer.from(r9).toString("hex");
  return ys(o13);
}
var import_time3, import_window_getters, import_window_metadata, import_blakejs, xe2, $s, Cs, Ls, Jn2, js, ks, Ze2, Qn2, Ps, tr2, er2, J3, rr2, gi, Be2, yr2, xr2, vr2, At, St2, se, ie, bi, yi, mi, wi, xi, vi, tn, en2, Ei, Bi, Ii, Ai, Gt2, Er2, wt2, Ot2, Ir2, Ni, xt2, Ie2, _i, ue, Ti, Ri, $i, Ci, Sr2, Nr2, Or2, Ur2, Li, ji, _r2, Tr2, qn2, Pi2, Hi, Rr2, Ut2, W2, Y, qi, _t2, Ki, $r2, Fi, zi, Tt2, Rt2, cn, Gi, X, Zi, Ae2, Wi, Yi, Xi, Ji, F, N10, tf, ef, nf, rf, lf, df, hf, Pr2, pf, gf, Hr2, ln, Dr2, bf, Se2, Mr2, Vr2, dn, qr2, Of, Rf, ro2, Lf, jf, kf, Pf, Ue2, Hf, oo2, so2, G2, Vf, Kf, zf, Gf, io2, Zf, Wf, co2, ao2, _e2, vn2, uo2, Jf, Te2, En2, Bn2, Sn2, je2, ot, Q2, Dt2, nc, po2, go2, bo2, ic, Xt2, Mt2, Un2, Ao2, de2, Jt2, Pe2, xc, Oo2, vc, Ec, Bc, Uo2, Tn2, Sc, vt2, he2, pe2, Nc, He2, Oc, $o2, Co2, Lo2, jc, kc, Pc, Hc, Dc, $n2, tt, Qt2, De2, te2, Cn2, ee, ge2, Mc, jo2, be2, Ln2, Mo2, ia, fa, ca, Fo2, aa, ua, zo2, la, da, Jo2, Qo2, Mn2, Ha;
var init_index_es7 = __esm({
  "node_modules/@walletconnect/utils/dist/index.es.js"() {
    init_es();
    import_time3 = __toESM(require_cjs());
    import_window_getters = __toESM(require_cjs2());
    import_window_metadata = __toESM(require_cjs3());
    init_esm4();
    init_esm6();
    init_dist4();
    init_esm();
    init_index_es5();
    init_src2();
    init_index_es6();
    import_blakejs = __toESM(require_blakejs());
    xe2 = ":";
    $s = Object.defineProperty;
    Cs = Object.defineProperties;
    Ls = Object.getOwnPropertyDescriptors;
    Jn2 = Object.getOwnPropertySymbols;
    js = Object.prototype.hasOwnProperty;
    ks = Object.prototype.propertyIsEnumerable;
    Ze2 = (t5, e10, n12) => e10 in t5 ? $s(t5, e10, { enumerable: true, configurable: true, writable: true, value: n12 }) : t5[e10] = n12;
    Qn2 = (t5, e10) => {
      for (var n12 in e10 || (e10 = {})) js.call(e10, n12) && Ze2(t5, n12, e10[n12]);
      if (Jn2) for (var n12 of Jn2(e10)) ks.call(e10, n12) && Ze2(t5, n12, e10[n12]);
      return t5;
    };
    Ps = (t5, e10) => Cs(t5, Ls(e10));
    tr2 = (t5, e10, n12) => Ze2(t5, typeof e10 != "symbol" ? e10 + "" : e10, n12);
    er2 = "ReactNative";
    J3 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
    rr2 = "js";
    gi = class {
      constructor({ limit: e10 }) {
        tr2(this, "limit"), tr2(this, "set"), this.limit = e10, this.set = /* @__PURE__ */ new Set();
      }
      add(e10) {
        if (!this.set.has(e10)) {
          if (this.set.size >= this.limit) {
            const n12 = this.set.values().next().value;
            n12 && this.set.delete(n12);
          }
          this.set.add(e10);
        }
      }
      has(e10) {
        return this.set.has(e10);
      }
    };
    Be2 = BigInt(2 ** 32 - 1);
    yr2 = BigInt(32);
    xr2 = (t5, e10, n12) => t5 >>> n12;
    vr2 = (t5, e10, n12) => t5 << 32 - n12 | e10 >>> n12;
    At = (t5, e10, n12) => t5 >>> n12 | e10 << 32 - n12;
    St2 = (t5, e10, n12) => t5 << 32 - n12 | e10 >>> n12;
    se = (t5, e10, n12) => t5 << 64 - n12 | e10 >>> n12 - 32;
    ie = (t5, e10, n12) => t5 >>> n12 - 32 | e10 << 64 - n12;
    bi = (t5, e10) => e10;
    yi = (t5, e10) => t5;
    mi = (t5, e10, n12) => t5 << n12 | e10 >>> 32 - n12;
    wi = (t5, e10, n12) => e10 << n12 | t5 >>> 32 - n12;
    xi = (t5, e10, n12) => e10 << n12 - 32 | t5 >>> 64 - n12;
    vi = (t5, e10, n12) => t5 << n12 - 32 | e10 >>> 64 - n12;
    tn = (t5, e10, n12) => (t5 >>> 0) + (e10 >>> 0) + (n12 >>> 0);
    en2 = (t5, e10, n12, r9) => e10 + n12 + r9 + (t5 / 2 ** 32 | 0) | 0;
    Ei = (t5, e10, n12, r9) => (t5 >>> 0) + (e10 >>> 0) + (n12 >>> 0) + (r9 >>> 0);
    Bi = (t5, e10, n12, r9, o13) => e10 + n12 + r9 + o13 + (t5 / 2 ** 32 | 0) | 0;
    Ii = (t5, e10, n12, r9, o13) => (t5 >>> 0) + (e10 >>> 0) + (n12 >>> 0) + (r9 >>> 0) + (o13 >>> 0);
    Ai = (t5, e10, n12, r9, o13, s8) => e10 + n12 + r9 + o13 + s8 + (t5 / 2 ** 32 | 0) | 0;
    Gt2 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    Er2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    wt2 = Er2 ? (t5) => t5 : (t5) => Br2(t5);
    Ot2 = Er2 ? (t5) => t5 : Si;
    Ir2 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
    Ni = Array.from({ length: 256 }, (t5, e10) => e10.toString(16).padStart(2, "0"));
    xt2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    Ie2 = class {
    };
    _i = BigInt(0);
    ue = BigInt(1);
    Ti = BigInt(2);
    Ri = BigInt(7);
    $i = BigInt(256);
    Ci = BigInt(113);
    Sr2 = [];
    Nr2 = [];
    Or2 = [];
    for (let t5 = 0, e10 = ue, n12 = 1, r9 = 0; t5 < 24; t5++) {
      [n12, r9] = [r9, (2 * n12 + 3 * r9) % 5], Sr2.push(2 * (5 * r9 + n12)), Nr2.push((t5 + 1) * (t5 + 2) / 2 % 64);
      let o13 = _i;
      for (let s8 = 0; s8 < 7; s8++) e10 = (e10 << ue ^ (e10 >> Ri) * Ci) % $i, e10 & Ti && (o13 ^= ue << (ue << BigInt(s8)) - ue);
      Or2.push(o13);
    }
    Ur2 = wr2(Or2, true);
    Li = Ur2[0];
    ji = Ur2[1];
    _r2 = (t5, e10, n12) => n12 > 32 ? xi(t5, e10, n12) : mi(t5, e10, n12);
    Tr2 = (t5, e10, n12) => n12 > 32 ? vi(t5, e10, n12) : wi(t5, e10, n12);
    qn2 = class _qn extends Ie2 {
      constructor(e10, n12, r9, o13 = false, s8 = 24) {
        if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e10, this.suffix = n12, this.outputLen = r9, this.enableXOF = o13, this.rounds = s8, mt(r9), !(0 < e10 && e10 < 200)) throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200), this.state32 = fe2(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        Ot2(this.state32), ki(this.state32, this.rounds), Ot2(this.state32), this.posOut = 0, this.pos = 0;
      }
      update(e10) {
        Nt2(this), e10 = ht2(e10), at(e10);
        const { blockLen: n12, state: r9 } = this, o13 = e10.length;
        for (let s8 = 0; s8 < o13; ) {
          const i11 = Math.min(n12 - this.pos, o13 - s8);
          for (let f13 = 0; f13 < i11; f13++) r9[this.pos++] ^= e10[s8++];
          this.pos === n12 && this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished) return;
        this.finished = true;
        const { state: e10, suffix: n12, pos: r9, blockLen: o13 } = this;
        e10[r9] ^= n12, (n12 & 128) !== 0 && r9 === o13 - 1 && this.keccak(), e10[o13 - 1] ^= 128, this.keccak();
      }
      writeInto(e10) {
        Nt2(this, false), at(e10), this.finish();
        const n12 = this.state, { blockLen: r9 } = this;
        for (let o13 = 0, s8 = e10.length; o13 < s8; ) {
          this.posOut >= r9 && this.keccak();
          const i11 = Math.min(r9 - this.posOut, s8 - o13);
          e10.set(n12.subarray(this.posOut, this.posOut + i11), o13), this.posOut += i11, o13 += i11;
        }
        return e10;
      }
      xofInto(e10) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e10);
      }
      xof(e10) {
        return mt(e10), this.xofInto(new Uint8Array(e10));
      }
      digestInto(e10) {
        if (on2(e10, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e10), this.destroy(), e10;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true, ut2(this.state);
      }
      _cloneInto(e10) {
        const { blockLen: n12, suffix: r9, outputLen: o13, rounds: s8, enableXOF: i11 } = this;
        return e10 || (e10 = new _qn(n12, r9, o13, i11, s8)), e10.state32.set(this.state32), e10.pos = this.pos, e10.posOut = this.posOut, e10.finished = this.finished, e10.rounds = s8, e10.suffix = r9, e10.outputLen = o13, e10.enableXOF = i11, e10.destroyed = this.destroyed, e10;
      }
    };
    Pi2 = (t5, e10, n12) => ae(() => new qn2(e10, t5, n12));
    Hi = Pi2(1, 136, 256 / 8);
    Rr2 = class extends Ie2 {
      constructor(e10, n12, r9, o13) {
        super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e10, this.outputLen = n12, this.padOffset = r9, this.isLE = o13, this.buffer = new Uint8Array(e10), this.view = sn2(this.buffer);
      }
      update(e10) {
        Nt2(this), e10 = ht2(e10), at(e10);
        const { view: n12, buffer: r9, blockLen: o13 } = this, s8 = e10.length;
        for (let i11 = 0; i11 < s8; ) {
          const f13 = Math.min(o13 - this.pos, s8 - i11);
          if (f13 === o13) {
            const a5 = sn2(e10);
            for (; o13 <= s8 - i11; i11 += o13) this.process(a5, i11);
            continue;
          }
          r9.set(e10.subarray(i11, i11 + f13), this.pos), this.pos += f13, i11 += f13, this.pos === o13 && (this.process(n12, 0), this.pos = 0);
        }
        return this.length += e10.length, this.roundClean(), this;
      }
      digestInto(e10) {
        Nt2(this), on2(e10, this), this.finished = true;
        const { buffer: n12, view: r9, blockLen: o13, isLE: s8 } = this;
        let { pos: i11 } = this;
        n12[i11++] = 128, ut2(this.buffer.subarray(i11)), this.padOffset > o13 - i11 && (this.process(r9, 0), i11 = 0);
        for (let u6 = i11; u6 < o13; u6++) n12[u6] = 0;
        Di(r9, o13 - 8, BigInt(this.length * 8), s8), this.process(r9, 0);
        const f13 = sn2(e10), a5 = this.outputLen;
        if (a5 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l10 = a5 / 4, c12 = this.get();
        if (l10 > c12.length) throw new Error("_sha2: outputLen bigger than state");
        for (let u6 = 0; u6 < l10; u6++) f13.setUint32(4 * u6, c12[u6], s8);
      }
      digest() {
        const { buffer: e10, outputLen: n12 } = this;
        this.digestInto(e10);
        const r9 = e10.slice(0, n12);
        return this.destroy(), r9;
      }
      _cloneInto(e10) {
        e10 || (e10 = new this.constructor()), e10.set(...this.get());
        const { blockLen: n12, buffer: r9, length: o13, finished: s8, destroyed: i11, pos: f13 } = this;
        return e10.destroyed = i11, e10.finished = s8, e10.length = o13, e10.pos = f13, o13 % n12 && e10.buffer.set(r9), e10;
      }
      clone() {
        return this._cloneInto();
      }
    };
    Ut2 = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
    W2 = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
    Y = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
    qi = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
    _t2 = new Uint32Array(64);
    Ki = class extends Rr2 {
      constructor(e10 = 32) {
        super(64, e10, 8, false), this.A = Ut2[0] | 0, this.B = Ut2[1] | 0, this.C = Ut2[2] | 0, this.D = Ut2[3] | 0, this.E = Ut2[4] | 0, this.F = Ut2[5] | 0, this.G = Ut2[6] | 0, this.H = Ut2[7] | 0;
      }
      get() {
        const { A: e10, B: n12, C: r9, D: o13, E: s8, F: i11, G: f13, H: a5 } = this;
        return [e10, n12, r9, o13, s8, i11, f13, a5];
      }
      set(e10, n12, r9, o13, s8, i11, f13, a5) {
        this.A = e10 | 0, this.B = n12 | 0, this.C = r9 | 0, this.D = o13 | 0, this.E = s8 | 0, this.F = i11 | 0, this.G = f13 | 0, this.H = a5 | 0;
      }
      process(e10, n12) {
        for (let u6 = 0; u6 < 16; u6++, n12 += 4) _t2[u6] = e10.getUint32(n12, false);
        for (let u6 = 16; u6 < 64; u6++) {
          const h12 = _t2[u6 - 15], g5 = _t2[u6 - 2], w6 = gt2(h12, 7) ^ gt2(h12, 18) ^ h12 >>> 3, y9 = gt2(g5, 17) ^ gt2(g5, 19) ^ g5 >>> 10;
          _t2[u6] = y9 + _t2[u6 - 7] + w6 + _t2[u6 - 16] | 0;
        }
        let { A: r9, B: o13, C: s8, D: i11, E: f13, F: a5, G: l10, H: c12 } = this;
        for (let u6 = 0; u6 < 64; u6++) {
          const h12 = gt2(f13, 6) ^ gt2(f13, 11) ^ gt2(f13, 25), g5 = c12 + h12 + Mi(f13, a5, l10) + qi[u6] + _t2[u6] | 0, y9 = (gt2(r9, 2) ^ gt2(r9, 13) ^ gt2(r9, 22)) + Vi(r9, o13, s8) | 0;
          c12 = l10, l10 = a5, a5 = f13, f13 = i11 + g5 | 0, i11 = s8, s8 = o13, o13 = r9, r9 = g5 + y9 | 0;
        }
        r9 = r9 + this.A | 0, o13 = o13 + this.B | 0, s8 = s8 + this.C | 0, i11 = i11 + this.D | 0, f13 = f13 + this.E | 0, a5 = a5 + this.F | 0, l10 = l10 + this.G | 0, c12 = c12 + this.H | 0, this.set(r9, o13, s8, i11, f13, a5, l10, c12);
      }
      roundClean() {
        ut2(_t2);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), ut2(this.buffer);
      }
    };
    $r2 = wr2(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t5) => BigInt(t5)));
    Fi = $r2[0];
    zi = $r2[1];
    Tt2 = new Uint32Array(80);
    Rt2 = new Uint32Array(80);
    cn = class extends Rr2 {
      constructor(e10 = 64) {
        super(128, e10, 16, false), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
      }
      get() {
        const { Ah: e10, Al: n12, Bh: r9, Bl: o13, Ch: s8, Cl: i11, Dh: f13, Dl: a5, Eh: l10, El: c12, Fh: u6, Fl: h12, Gh: g5, Gl: w6, Hh: y9, Hl: x7 } = this;
        return [e10, n12, r9, o13, s8, i11, f13, a5, l10, c12, u6, h12, g5, w6, y9, x7];
      }
      set(e10, n12, r9, o13, s8, i11, f13, a5, l10, c12, u6, h12, g5, w6, y9, x7) {
        this.Ah = e10 | 0, this.Al = n12 | 0, this.Bh = r9 | 0, this.Bl = o13 | 0, this.Ch = s8 | 0, this.Cl = i11 | 0, this.Dh = f13 | 0, this.Dl = a5 | 0, this.Eh = l10 | 0, this.El = c12 | 0, this.Fh = u6 | 0, this.Fl = h12 | 0, this.Gh = g5 | 0, this.Gl = w6 | 0, this.Hh = y9 | 0, this.Hl = x7 | 0;
      }
      process(e10, n12) {
        for (let L6 = 0; L6 < 16; L6++, n12 += 4) Tt2[L6] = e10.getUint32(n12), Rt2[L6] = e10.getUint32(n12 += 4);
        for (let L6 = 16; L6 < 80; L6++) {
          const V6 = Tt2[L6 - 15] | 0, _5 = Rt2[L6 - 15] | 0, k7 = At(V6, _5, 1) ^ At(V6, _5, 8) ^ xr2(V6, _5, 7), j7 = St2(V6, _5, 1) ^ St2(V6, _5, 8) ^ vr2(V6, _5, 7), $6 = Tt2[L6 - 2] | 0, d7 = Rt2[L6 - 2] | 0, m6 = At($6, d7, 19) ^ se($6, d7, 61) ^ xr2($6, d7, 6), p8 = St2($6, d7, 19) ^ ie($6, d7, 61) ^ vr2($6, d7, 6), b7 = Ei(j7, p8, Rt2[L6 - 7], Rt2[L6 - 16]), v8 = Bi(b7, k7, m6, Tt2[L6 - 7], Tt2[L6 - 16]);
          Tt2[L6] = v8 | 0, Rt2[L6] = b7 | 0;
        }
        let { Ah: r9, Al: o13, Bh: s8, Bl: i11, Ch: f13, Cl: a5, Dh: l10, Dl: c12, Eh: u6, El: h12, Fh: g5, Fl: w6, Gh: y9, Gl: x7, Hh: R6, Hl: M6 } = this;
        for (let L6 = 0; L6 < 80; L6++) {
          const V6 = At(u6, h12, 14) ^ At(u6, h12, 18) ^ se(u6, h12, 41), _5 = St2(u6, h12, 14) ^ St2(u6, h12, 18) ^ ie(u6, h12, 41), k7 = u6 & g5 ^ ~u6 & y9, j7 = h12 & w6 ^ ~h12 & x7, $6 = Ii(M6, _5, j7, zi[L6], Rt2[L6]), d7 = Ai($6, R6, V6, k7, Fi[L6], Tt2[L6]), m6 = $6 | 0, p8 = At(r9, o13, 28) ^ se(r9, o13, 34) ^ se(r9, o13, 39), b7 = St2(r9, o13, 28) ^ ie(r9, o13, 34) ^ ie(r9, o13, 39), v8 = r9 & s8 ^ r9 & f13 ^ s8 & f13, B5 = o13 & i11 ^ o13 & a5 ^ i11 & a5;
          R6 = y9 | 0, M6 = x7 | 0, y9 = g5 | 0, x7 = w6 | 0, g5 = u6 | 0, w6 = h12 | 0, { h: u6, l: h12 } = dt2(l10 | 0, c12 | 0, d7 | 0, m6 | 0), l10 = f13 | 0, c12 = a5 | 0, f13 = s8 | 0, a5 = i11 | 0, s8 = r9 | 0, i11 = o13 | 0;
          const E8 = tn(m6, b7, B5);
          r9 = en2(E8, d7, p8, v8), o13 = E8 | 0;
        }
        ({ h: r9, l: o13 } = dt2(this.Ah | 0, this.Al | 0, r9 | 0, o13 | 0)), { h: s8, l: i11 } = dt2(this.Bh | 0, this.Bl | 0, s8 | 0, i11 | 0), { h: f13, l: a5 } = dt2(this.Ch | 0, this.Cl | 0, f13 | 0, a5 | 0), { h: l10, l: c12 } = dt2(this.Dh | 0, this.Dl | 0, l10 | 0, c12 | 0), { h: u6, l: h12 } = dt2(this.Eh | 0, this.El | 0, u6 | 0, h12 | 0), { h: g5, l: w6 } = dt2(this.Fh | 0, this.Fl | 0, g5 | 0, w6 | 0), { h: y9, l: x7 } = dt2(this.Gh | 0, this.Gl | 0, y9 | 0, x7 | 0), { h: R6, l: M6 } = dt2(this.Hh | 0, this.Hl | 0, R6 | 0, M6 | 0), this.set(r9, o13, s8, i11, f13, a5, l10, c12, u6, h12, g5, w6, y9, x7, R6, M6);
      }
      roundClean() {
        ut2(Tt2, Rt2);
      }
      destroy() {
        ut2(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    Gi = class extends cn {
      constructor() {
        super(48), this.Ah = W2[0] | 0, this.Al = W2[1] | 0, this.Bh = W2[2] | 0, this.Bl = W2[3] | 0, this.Ch = W2[4] | 0, this.Cl = W2[5] | 0, this.Dh = W2[6] | 0, this.Dl = W2[7] | 0, this.Eh = W2[8] | 0, this.El = W2[9] | 0, this.Fh = W2[10] | 0, this.Fl = W2[11] | 0, this.Gh = W2[12] | 0, this.Gl = W2[13] | 0, this.Hh = W2[14] | 0, this.Hl = W2[15] | 0;
      }
    };
    X = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
    Zi = class extends cn {
      constructor() {
        super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
      }
    };
    Ae2 = ae(() => new Ki());
    Wi = ae(() => new cn());
    Yi = ae(() => new Gi());
    Xi = ae(() => new Zi());
    Ji = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
    F = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
    N10 = new Uint32Array(32);
    tf = class extends Ie2 {
      constructor(e10, n12) {
        super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e10), mt(n12), this.blockLen = e10, this.outputLen = n12, this.buffer = new Uint8Array(e10), this.buffer32 = fe2(this.buffer);
      }
      update(e10) {
        Nt2(this), e10 = ht2(e10), at(e10);
        const { blockLen: n12, buffer: r9, buffer32: o13 } = this, s8 = e10.length, i11 = e10.byteOffset, f13 = e10.buffer;
        for (let a5 = 0; a5 < s8; ) {
          this.pos === n12 && (Ot2(o13), this.compress(o13, 0, false), Ot2(o13), this.pos = 0);
          const l10 = Math.min(n12 - this.pos, s8 - a5), c12 = i11 + a5;
          if (l10 === n12 && !(c12 % 4) && a5 + l10 < s8) {
            const u6 = new Uint32Array(f13, c12, Math.floor((s8 - a5) / 4));
            Ot2(u6);
            for (let h12 = 0; a5 + n12 < s8; h12 += o13.length, a5 += n12) this.length += n12, this.compress(u6, h12, false);
            Ot2(u6);
            continue;
          }
          r9.set(e10.subarray(a5, a5 + l10), this.pos), this.pos += l10, this.length += l10, a5 += l10;
        }
        return this;
      }
      digestInto(e10) {
        Nt2(this), on2(e10, this);
        const { pos: n12, buffer32: r9 } = this;
        this.finished = true, ut2(this.buffer.subarray(n12)), Ot2(r9), this.compress(r9, 0, true), Ot2(r9);
        const o13 = fe2(e10);
        this.get().forEach((s8, i11) => o13[i11] = wt2(s8));
      }
      digest() {
        const { buffer: e10, outputLen: n12 } = this;
        this.digestInto(e10);
        const r9 = e10.slice(0, n12);
        return this.destroy(), r9;
      }
      _cloneInto(e10) {
        const { buffer: n12, length: r9, finished: o13, destroyed: s8, outputLen: i11, pos: f13 } = this;
        return e10 || (e10 = new this.constructor({ dkLen: i11 })), e10.set(...this.get()), e10.buffer.set(n12), e10.destroyed = s8, e10.finished = o13, e10.length = r9, e10.pos = f13, e10.outputLen = i11, e10;
      }
      clone() {
        return this._cloneInto();
      }
    };
    ef = class extends tf {
      constructor(e10 = {}) {
        const n12 = e10.dkLen === void 0 ? 64 : e10.dkLen;
        super(128, n12), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n12, e10, 64, 16, 16);
        let { key: r9, personalization: o13, salt: s8 } = e10, i11 = 0;
        if (r9 !== void 0 && (r9 = ht2(r9), i11 = r9.length), this.v0l ^= this.outputLen | i11 << 8 | 65536 | 1 << 24, s8 !== void 0) {
          s8 = ht2(s8);
          const f13 = fe2(s8);
          this.v4l ^= wt2(f13[0]), this.v4h ^= wt2(f13[1]), this.v5l ^= wt2(f13[2]), this.v5h ^= wt2(f13[3]);
        }
        if (o13 !== void 0) {
          o13 = ht2(o13);
          const f13 = fe2(o13);
          this.v6l ^= wt2(f13[0]), this.v6h ^= wt2(f13[1]), this.v7l ^= wt2(f13[2]), this.v7h ^= wt2(f13[3]);
        }
        if (r9 !== void 0) {
          const f13 = new Uint8Array(this.blockLen);
          f13.set(r9), this.update(f13);
        }
      }
      get() {
        let { v0l: e10, v0h: n12, v1l: r9, v1h: o13, v2l: s8, v2h: i11, v3l: f13, v3h: a5, v4l: l10, v4h: c12, v5l: u6, v5h: h12, v6l: g5, v6h: w6, v7l: y9, v7h: x7 } = this;
        return [e10, n12, r9, o13, s8, i11, f13, a5, l10, c12, u6, h12, g5, w6, y9, x7];
      }
      set(e10, n12, r9, o13, s8, i11, f13, a5, l10, c12, u6, h12, g5, w6, y9, x7) {
        this.v0l = e10 | 0, this.v0h = n12 | 0, this.v1l = r9 | 0, this.v1h = o13 | 0, this.v2l = s8 | 0, this.v2h = i11 | 0, this.v3l = f13 | 0, this.v3h = a5 | 0, this.v4l = l10 | 0, this.v4h = c12 | 0, this.v5l = u6 | 0, this.v5h = h12 | 0, this.v6l = g5 | 0, this.v6h = w6 | 0, this.v7l = y9 | 0, this.v7h = x7 | 0;
      }
      compress(e10, n12, r9) {
        this.get().forEach((a5, l10) => N10[l10] = a5), N10.set(F, 16);
        let { h: o13, l: s8 } = mr2(BigInt(this.length));
        N10[24] = F[8] ^ s8, N10[25] = F[9] ^ o13, r9 && (N10[28] = ~N10[28], N10[29] = ~N10[29]);
        let i11 = 0;
        const f13 = Ji;
        for (let a5 = 0; a5 < 12; a5++) $t2(0, 4, 8, 12, e10, n12 + 2 * f13[i11++]), Ct(0, 4, 8, 12, e10, n12 + 2 * f13[i11++]), $t2(1, 5, 9, 13, e10, n12 + 2 * f13[i11++]), Ct(1, 5, 9, 13, e10, n12 + 2 * f13[i11++]), $t2(2, 6, 10, 14, e10, n12 + 2 * f13[i11++]), Ct(2, 6, 10, 14, e10, n12 + 2 * f13[i11++]), $t2(3, 7, 11, 15, e10, n12 + 2 * f13[i11++]), Ct(3, 7, 11, 15, e10, n12 + 2 * f13[i11++]), $t2(0, 5, 10, 15, e10, n12 + 2 * f13[i11++]), Ct(0, 5, 10, 15, e10, n12 + 2 * f13[i11++]), $t2(1, 6, 11, 12, e10, n12 + 2 * f13[i11++]), Ct(1, 6, 11, 12, e10, n12 + 2 * f13[i11++]), $t2(2, 7, 8, 13, e10, n12 + 2 * f13[i11++]), Ct(2, 7, 8, 13, e10, n12 + 2 * f13[i11++]), $t2(3, 4, 9, 14, e10, n12 + 2 * f13[i11++]), Ct(3, 4, 9, 14, e10, n12 + 2 * f13[i11++]);
        this.v0l ^= N10[0] ^ N10[16], this.v0h ^= N10[1] ^ N10[17], this.v1l ^= N10[2] ^ N10[18], this.v1h ^= N10[3] ^ N10[19], this.v2l ^= N10[4] ^ N10[20], this.v2h ^= N10[5] ^ N10[21], this.v3l ^= N10[6] ^ N10[22], this.v3h ^= N10[7] ^ N10[23], this.v4l ^= N10[8] ^ N10[24], this.v4h ^= N10[9] ^ N10[25], this.v5l ^= N10[10] ^ N10[26], this.v5h ^= N10[11] ^ N10[27], this.v6l ^= N10[12] ^ N10[28], this.v6h ^= N10[13] ^ N10[29], this.v7l ^= N10[14] ^ N10[30], this.v7h ^= N10[15] ^ N10[31], ut2(N10);
      }
      destroy() {
        this.destroyed = true, ut2(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    nf = Ui((t5) => new ef(t5));
    rf = "https://rpc.walletconnect.org/v1";
    lf = Object.defineProperty;
    df = Object.defineProperties;
    hf = Object.getOwnPropertyDescriptors;
    Pr2 = Object.getOwnPropertySymbols;
    pf = Object.prototype.hasOwnProperty;
    gf = Object.prototype.propertyIsEnumerable;
    Hr2 = (t5, e10, n12) => e10 in t5 ? lf(t5, e10, { enumerable: true, configurable: true, writable: true, value: n12 }) : t5[e10] = n12;
    ln = (t5, e10) => {
      for (var n12 in e10 || (e10 = {})) pf.call(e10, n12) && Hr2(t5, n12, e10[n12]);
      if (Pr2) for (var n12 of Pr2(e10)) gf.call(e10, n12) && Hr2(t5, n12, e10[n12]);
      return t5;
    };
    Dr2 = (t5, e10) => df(t5, hf(e10));
    bf = "did:pkh:";
    Se2 = (t5) => t5?.split(":");
    Mr2 = (t5) => {
      const e10 = t5 && Se2(t5);
      if (e10) return t5.includes(bf) ? e10[3] : e10[1];
    };
    Vr2 = (t5) => {
      const e10 = t5 && Se2(t5);
      if (e10) return e10[2] + ":" + e10[3];
    };
    dn = (t5) => {
      const e10 = t5 && Se2(t5);
      if (e10) return e10.pop();
    };
    qr2 = (t5, e10) => {
      const n12 = `${t5.domain} wants you to sign in with your Ethereum account:`, r9 = dn(e10);
      if (!t5.aud && !t5.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
      let o13 = t5.statement || void 0;
      const s8 = `URI: ${t5.aud || t5.uri}`, i11 = `Version: ${t5.version}`, f13 = `Chain ID: ${Mr2(e10)}`, a5 = `Nonce: ${t5.nonce}`, l10 = `Issued At: ${t5.iat}`, c12 = t5.exp ? `Expiration Time: ${t5.exp}` : void 0, u6 = t5.nbf ? `Not Before: ${t5.nbf}` : void 0, h12 = t5.requestId ? `Request ID: ${t5.requestId}` : void 0, g5 = t5.resources ? `Resources:${t5.resources.map((y9) => `
- ${y9}`).join("")}` : void 0, w6 = Oe2(t5.resources);
      if (w6) {
        const y9 = Lt2(w6);
        o13 = gn2(o13, y9);
      }
      return [n12, r9, "", o13, "", s8, i11, f13, a5, l10, c12, u6, h12, g5].filter((y9) => y9 != null).join(`
`);
    };
    Of = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    Rf = (t5, e10) => {
      function n12(r9, ...o13) {
        if (nt2(r9), !Of) throw new Error("Non little-endian hardware is not yet supported");
        if (t5.nonceLength !== void 0) {
          const c12 = o13[0];
          if (!c12) throw new Error("nonce / iv required");
          t5.varSizeNonce ? nt2(c12) : nt2(c12, t5.nonceLength);
        }
        const s8 = t5.tagLength;
        s8 && o13[1] !== void 0 && nt2(o13[1]);
        const i11 = e10(r9, ...o13), f13 = (c12, u6) => {
          if (u6 !== void 0) {
            if (c12 !== 2) throw new Error("cipher output not supported");
            nt2(u6);
          }
        };
        let a5 = false;
        return { encrypt(c12, u6) {
          if (a5) throw new Error("cannot encrypt() twice with same key + nonce");
          return a5 = true, nt2(c12), f13(i11.encrypt.length, u6), i11.encrypt(c12, u6);
        }, decrypt(c12, u6) {
          if (nt2(c12), s8 && c12.length < s8) throw new Error("invalid ciphertext length: smaller than tagLength=" + s8);
          return f13(i11.decrypt.length, u6), i11.decrypt(c12, u6);
        } };
      }
      return Object.assign(n12, t5), n12;
    };
    ro2 = (t5) => Uint8Array.from(t5.split("").map((e10) => e10.charCodeAt(0)));
    Lf = ro2("expand 16-byte k");
    jf = ro2("expand 32-byte k");
    kf = jt2(Lf);
    Pf = jt2(jf);
    Ue2 = 64;
    Hf = 16;
    oo2 = 2 ** 32 - 1;
    so2 = new Uint32Array();
    G2 = (t5, e10) => t5[e10++] & 255 | (t5[e10++] & 255) << 8;
    Vf = class {
      constructor(e10) {
        this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e10 = mn2(e10), nt2(e10, 32);
        const n12 = G2(e10, 0), r9 = G2(e10, 2), o13 = G2(e10, 4), s8 = G2(e10, 6), i11 = G2(e10, 8), f13 = G2(e10, 10), a5 = G2(e10, 12), l10 = G2(e10, 14);
        this.r[0] = n12 & 8191, this.r[1] = (n12 >>> 13 | r9 << 3) & 8191, this.r[2] = (r9 >>> 10 | o13 << 6) & 7939, this.r[3] = (o13 >>> 7 | s8 << 9) & 8191, this.r[4] = (s8 >>> 4 | i11 << 12) & 255, this.r[5] = i11 >>> 1 & 8190, this.r[6] = (i11 >>> 14 | f13 << 2) & 8191, this.r[7] = (f13 >>> 11 | a5 << 5) & 8065, this.r[8] = (a5 >>> 8 | l10 << 8) & 8191, this.r[9] = l10 >>> 5 & 127;
        for (let c12 = 0; c12 < 8; c12++) this.pad[c12] = G2(e10, 16 + 2 * c12);
      }
      process(e10, n12, r9 = false) {
        const o13 = r9 ? 0 : 2048, { h: s8, r: i11 } = this, f13 = i11[0], a5 = i11[1], l10 = i11[2], c12 = i11[3], u6 = i11[4], h12 = i11[5], g5 = i11[6], w6 = i11[7], y9 = i11[8], x7 = i11[9], R6 = G2(e10, n12 + 0), M6 = G2(e10, n12 + 2), L6 = G2(e10, n12 + 4), V6 = G2(e10, n12 + 6), _5 = G2(e10, n12 + 8), k7 = G2(e10, n12 + 10), j7 = G2(e10, n12 + 12), $6 = G2(e10, n12 + 14);
        let d7 = s8[0] + (R6 & 8191), m6 = s8[1] + ((R6 >>> 13 | M6 << 3) & 8191), p8 = s8[2] + ((M6 >>> 10 | L6 << 6) & 8191), b7 = s8[3] + ((L6 >>> 7 | V6 << 9) & 8191), v8 = s8[4] + ((V6 >>> 4 | _5 << 12) & 8191), B5 = s8[5] + (_5 >>> 1 & 8191), E8 = s8[6] + ((_5 >>> 14 | k7 << 2) & 8191), I6 = s8[7] + ((k7 >>> 11 | j7 << 5) & 8191), S7 = s8[8] + ((j7 >>> 8 | $6 << 8) & 8191), O8 = s8[9] + ($6 >>> 5 | o13), A6 = 0, T6 = A6 + d7 * f13 + m6 * (5 * x7) + p8 * (5 * y9) + b7 * (5 * w6) + v8 * (5 * g5);
        A6 = T6 >>> 13, T6 &= 8191, T6 += B5 * (5 * h12) + E8 * (5 * u6) + I6 * (5 * c12) + S7 * (5 * l10) + O8 * (5 * a5), A6 += T6 >>> 13, T6 &= 8191;
        let U4 = A6 + d7 * a5 + m6 * f13 + p8 * (5 * x7) + b7 * (5 * y9) + v8 * (5 * w6);
        A6 = U4 >>> 13, U4 &= 8191, U4 += B5 * (5 * g5) + E8 * (5 * h12) + I6 * (5 * u6) + S7 * (5 * c12) + O8 * (5 * l10), A6 += U4 >>> 13, U4 &= 8191;
        let C7 = A6 + d7 * l10 + m6 * a5 + p8 * f13 + b7 * (5 * x7) + v8 * (5 * y9);
        A6 = C7 >>> 13, C7 &= 8191, C7 += B5 * (5 * w6) + E8 * (5 * g5) + I6 * (5 * h12) + S7 * (5 * u6) + O8 * (5 * c12), A6 += C7 >>> 13, C7 &= 8191;
        let H5 = A6 + d7 * c12 + m6 * l10 + p8 * a5 + b7 * f13 + v8 * (5 * x7);
        A6 = H5 >>> 13, H5 &= 8191, H5 += B5 * (5 * y9) + E8 * (5 * w6) + I6 * (5 * g5) + S7 * (5 * h12) + O8 * (5 * u6), A6 += H5 >>> 13, H5 &= 8191;
        let q3 = A6 + d7 * u6 + m6 * c12 + p8 * l10 + b7 * a5 + v8 * f13;
        A6 = q3 >>> 13, q3 &= 8191, q3 += B5 * (5 * x7) + E8 * (5 * y9) + I6 * (5 * w6) + S7 * (5 * g5) + O8 * (5 * h12), A6 += q3 >>> 13, q3 &= 8191;
        let P8 = A6 + d7 * h12 + m6 * u6 + p8 * c12 + b7 * l10 + v8 * a5;
        A6 = P8 >>> 13, P8 &= 8191, P8 += B5 * f13 + E8 * (5 * x7) + I6 * (5 * y9) + S7 * (5 * w6) + O8 * (5 * g5), A6 += P8 >>> 13, P8 &= 8191;
        let K5 = A6 + d7 * g5 + m6 * h12 + p8 * u6 + b7 * c12 + v8 * l10;
        A6 = K5 >>> 13, K5 &= 8191, K5 += B5 * a5 + E8 * f13 + I6 * (5 * x7) + S7 * (5 * y9) + O8 * (5 * w6), A6 += K5 >>> 13, K5 &= 8191;
        let et2 = A6 + d7 * w6 + m6 * g5 + p8 * h12 + b7 * u6 + v8 * c12;
        A6 = et2 >>> 13, et2 &= 8191, et2 += B5 * l10 + E8 * a5 + I6 * f13 + S7 * (5 * x7) + O8 * (5 * y9), A6 += et2 >>> 13, et2 &= 8191;
        let Z5 = A6 + d7 * y9 + m6 * w6 + p8 * g5 + b7 * h12 + v8 * u6;
        A6 = Z5 >>> 13, Z5 &= 8191, Z5 += B5 * c12 + E8 * l10 + I6 * a5 + S7 * f13 + O8 * (5 * x7), A6 += Z5 >>> 13, Z5 &= 8191;
        let z5 = A6 + d7 * x7 + m6 * y9 + p8 * w6 + b7 * g5 + v8 * h12;
        A6 = z5 >>> 13, z5 &= 8191, z5 += B5 * u6 + E8 * c12 + I6 * l10 + S7 * a5 + O8 * f13, A6 += z5 >>> 13, z5 &= 8191, A6 = (A6 << 2) + A6 | 0, A6 = A6 + T6 | 0, T6 = A6 & 8191, A6 = A6 >>> 13, U4 += A6, s8[0] = T6, s8[1] = U4, s8[2] = C7, s8[3] = H5, s8[4] = q3, s8[5] = P8, s8[6] = K5, s8[7] = et2, s8[8] = Z5, s8[9] = z5;
      }
      finalize() {
        const { h: e10, pad: n12 } = this, r9 = new Uint16Array(10);
        let o13 = e10[1] >>> 13;
        e10[1] &= 8191;
        for (let f13 = 2; f13 < 10; f13++) e10[f13] += o13, o13 = e10[f13] >>> 13, e10[f13] &= 8191;
        e10[0] += o13 * 5, o13 = e10[0] >>> 13, e10[0] &= 8191, e10[1] += o13, o13 = e10[1] >>> 13, e10[1] &= 8191, e10[2] += o13, r9[0] = e10[0] + 5, o13 = r9[0] >>> 13, r9[0] &= 8191;
        for (let f13 = 1; f13 < 10; f13++) r9[f13] = e10[f13] + o13, o13 = r9[f13] >>> 13, r9[f13] &= 8191;
        r9[9] -= 8192;
        let s8 = (o13 ^ 1) - 1;
        for (let f13 = 0; f13 < 10; f13++) r9[f13] &= s8;
        s8 = ~s8;
        for (let f13 = 0; f13 < 10; f13++) e10[f13] = e10[f13] & s8 | r9[f13];
        e10[0] = (e10[0] | e10[1] << 13) & 65535, e10[1] = (e10[1] >>> 3 | e10[2] << 10) & 65535, e10[2] = (e10[2] >>> 6 | e10[3] << 7) & 65535, e10[3] = (e10[3] >>> 9 | e10[4] << 4) & 65535, e10[4] = (e10[4] >>> 12 | e10[5] << 1 | e10[6] << 14) & 65535, e10[5] = (e10[6] >>> 2 | e10[7] << 11) & 65535, e10[6] = (e10[7] >>> 5 | e10[8] << 8) & 65535, e10[7] = (e10[8] >>> 8 | e10[9] << 5) & 65535;
        let i11 = e10[0] + n12[0];
        e10[0] = i11 & 65535;
        for (let f13 = 1; f13 < 8; f13++) i11 = (e10[f13] + n12[f13] | 0) + (i11 >>> 16) | 0, e10[f13] = i11 & 65535;
        Wt2(r9);
      }
      update(e10) {
        to2(this), e10 = mn2(e10), nt2(e10);
        const { buffer: n12, blockLen: r9 } = this, o13 = e10.length;
        for (let s8 = 0; s8 < o13; ) {
          const i11 = Math.min(r9 - this.pos, o13 - s8);
          if (i11 === r9) {
            for (; r9 <= o13 - s8; s8 += r9) this.process(e10, s8);
            continue;
          }
          n12.set(e10.subarray(s8, s8 + i11), this.pos), this.pos += i11, s8 += i11, this.pos === r9 && (this.process(n12, 0, false), this.pos = 0);
        }
        return this;
      }
      destroy() {
        Wt2(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(e10) {
        to2(this), Sf(e10, this), this.finished = true;
        const { buffer: n12, h: r9 } = this;
        let { pos: o13 } = this;
        if (o13) {
          for (n12[o13++] = 1; o13 < 16; o13++) n12[o13] = 0;
          this.process(n12, 0, true);
        }
        this.finalize();
        let s8 = 0;
        for (let i11 = 0; i11 < 8; i11++) e10[s8++] = r9[i11] >>> 0, e10[s8++] = r9[i11] >>> 8;
        return e10;
      }
      digest() {
        const { buffer: e10, outputLen: n12 } = this;
        this.digestInto(e10);
        const r9 = e10.slice(0, n12);
        return this.destroy(), r9;
      }
    };
    Kf = qf((t5) => new Vf(t5));
    zf = Mf(Ff, { counterRight: false, counterLength: 4, allowShortKeys: false });
    Gf = new Uint8Array(16);
    io2 = (t5, e10) => {
      t5.update(e10);
      const n12 = e10.length % 16;
      n12 && t5.update(Gf.subarray(n12));
    };
    Zf = new Uint8Array(32);
    Wf = (t5) => (e10, n12, r9) => ({ encrypt(s8, i11) {
      const f13 = s8.length;
      i11 = eo2(f13 + 16, i11, false), i11.set(s8);
      const a5 = i11.subarray(0, -16);
      t5(e10, n12, a5, a5, 1);
      const l10 = fo2(t5, e10, n12, a5, r9);
      return i11.set(l10, f13), Wt2(l10), i11;
    }, decrypt(s8, i11) {
      i11 = eo2(s8.length - 16, i11, false);
      const f13 = s8.subarray(0, -16), a5 = s8.subarray(-16), l10 = fo2(t5, e10, n12, f13, r9);
      if (!Tf(a5, l10)) throw new Error("invalid tag");
      return i11.set(s8.subarray(0, -16)), t5(e10, n12, i11, i11, 1), Wt2(l10), i11;
    } });
    co2 = Rf({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf(zf));
    ao2 = class extends Ie2 {
      constructor(e10, n12) {
        super(), this.finished = false, this.destroyed = false, rn2(e10);
        const r9 = ht2(n12);
        if (this.iHash = e10.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const o13 = this.blockLen, s8 = new Uint8Array(o13);
        s8.set(r9.length > o13 ? e10.create().update(r9).digest() : r9);
        for (let i11 = 0; i11 < s8.length; i11++) s8[i11] ^= 54;
        this.iHash.update(s8), this.oHash = e10.create();
        for (let i11 = 0; i11 < s8.length; i11++) s8[i11] ^= 106;
        this.oHash.update(s8), ut2(s8);
      }
      update(e10) {
        return Nt2(this), this.iHash.update(e10), this;
      }
      digestInto(e10) {
        Nt2(this), at(e10, this.outputLen), this.finished = true, this.iHash.digestInto(e10), this.oHash.update(e10), this.oHash.digestInto(e10), this.destroy();
      }
      digest() {
        const e10 = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e10), e10;
      }
      _cloneInto(e10) {
        e10 || (e10 = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: n12, iHash: r9, finished: o13, destroyed: s8, blockLen: i11, outputLen: f13 } = this;
        return e10 = e10, e10.finished = o13, e10.destroyed = s8, e10.blockLen = i11, e10.outputLen = f13, e10.oHash = n12._cloneInto(e10.oHash), e10.iHash = r9._cloneInto(e10.iHash), e10;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
      }
    };
    _e2 = (t5, e10, n12) => new ao2(t5, e10).update(n12).digest();
    _e2.create = (t5, e10) => new ao2(t5, e10);
    vn2 = Uint8Array.from([0]);
    uo2 = Uint8Array.of();
    Jf = (t5, e10, n12, r9, o13) => Xf(t5, Yf(t5, e10, n12), r9, o13);
    Te2 = Ae2;
    En2 = BigInt(0);
    Bn2 = BigInt(1);
    Sn2 = (t5) => typeof t5 == "bigint" && En2 <= t5;
    je2 = (t5) => (Bn2 << BigInt(t5)) - Bn2;
    ot = BigInt(0);
    Q2 = BigInt(1);
    Dt2 = BigInt(2);
    nc = BigInt(3);
    po2 = BigInt(4);
    go2 = BigInt(5);
    bo2 = BigInt(8);
    ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
    Xt2 = BigInt(0);
    Mt2 = BigInt(1);
    Un2 = /* @__PURE__ */ new WeakMap();
    Ao2 = /* @__PURE__ */ new WeakMap();
    BigInt(0), BigInt(1), BigInt(2), BigInt(8);
    de2 = BigInt(0);
    Jt2 = BigInt(1);
    Pe2 = BigInt(2);
    BigInt(0);
    xc = BigInt(1);
    Oo2 = BigInt(2);
    vc = BigInt(3);
    Ec = BigInt(5);
    Bc = BigInt(8);
    Uo2 = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
    Tn2 = (() => {
      const t5 = Uo2.p;
      return wc({ P: t5, type: "x25519", powPminus2: (e10) => {
        const { pow_p_5_8: n12, b2: r9 } = Ic(e10);
        return lt2(pt(n12, vc, t5) * r9, t5);
      }, adjustScalarBytes: Ac });
    })();
    Sc = class extends Error {
      constructor(e10 = "") {
        super(e10);
      }
    };
    vt2 = { Err: Sc, _tlv: { encode: (t5, e10) => {
      const { Err: n12 } = vt2;
      if (t5 < 0 || t5 > 256) throw new n12("tlv.encode: wrong tag");
      if (e10.length & 1) throw new n12("tlv.encode: unpadded data");
      const r9 = e10.length / 2, o13 = $e2(r9);
      if (o13.length / 2 & 128) throw new n12("tlv.encode: long form length too big");
      const s8 = r9 > 127 ? $e2(o13.length / 2 | 128) : "";
      return $e2(t5) + s8 + o13 + e10;
    }, decode(t5, e10) {
      const { Err: n12 } = vt2;
      let r9 = 0;
      if (t5 < 0 || t5 > 256) throw new n12("tlv.encode: wrong tag");
      if (e10.length < 2 || e10[r9++] !== t5) throw new n12("tlv.decode: wrong tlv");
      const o13 = e10[r9++], s8 = !!(o13 & 128);
      let i11 = 0;
      if (!s8) i11 = o13;
      else {
        const a5 = o13 & 127;
        if (!a5) throw new n12("tlv.decode(long): indefinite length not supported");
        if (a5 > 4) throw new n12("tlv.decode(long): byte length is too big");
        const l10 = e10.subarray(r9, r9 + a5);
        if (l10.length !== a5) throw new n12("tlv.decode: length bytes not complete");
        if (l10[0] === 0) throw new n12("tlv.decode(long): zero leftmost byte");
        for (const c12 of l10) i11 = i11 << 8 | c12;
        if (r9 += a5, i11 < 128) throw new n12("tlv.decode(long): not minimal encoding");
      }
      const f13 = e10.subarray(r9, r9 + i11);
      if (f13.length !== i11) throw new n12("tlv.decode: wrong value length");
      return { v: f13, l: e10.subarray(r9 + i11) };
    } }, _int: { encode(t5) {
      const { Err: e10 } = vt2;
      if (t5 < he2) throw new e10("integer: negative integers are not allowed");
      let n12 = $e2(t5);
      if (Number.parseInt(n12[0], 16) & 8 && (n12 = "00" + n12), n12.length & 1) throw new e10("unexpected DER parsing assertion: unpadded hex");
      return n12;
    }, decode(t5) {
      const { Err: e10 } = vt2;
      if (t5[0] & 128) throw new e10("invalid signature integer: negative");
      if (t5[0] === 0 && !(t5[1] & 128)) throw new e10("invalid signature integer: unnecessary leading zero");
      return Ce2(t5);
    } }, toSig(t5) {
      const { Err: e10, _int: n12, _tlv: r9 } = vt2, o13 = rt2("signature", t5), { v: s8, l: i11 } = r9.decode(48, o13);
      if (i11.length) throw new e10("invalid signature: left bytes after parsing");
      const { v: f13, l: a5 } = r9.decode(2, s8), { v: l10, l: c12 } = r9.decode(2, a5);
      if (c12.length) throw new e10("invalid signature: left bytes after parsing");
      return { r: n12.decode(f13), s: n12.decode(l10) };
    }, hexFromSig(t5) {
      const { _tlv: e10, _int: n12 } = vt2, r9 = e10.encode(2, n12.encode(t5.r)), o13 = e10.encode(2, n12.encode(t5.s)), s8 = r9 + o13;
      return e10.encode(48, s8);
    } };
    he2 = BigInt(0);
    pe2 = BigInt(1);
    Nc = BigInt(2);
    He2 = BigInt(3);
    Oc = BigInt(4);
    $o2 = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
    Co2 = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
    Lo2 = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
    jc = Yt2($o2.p);
    kc = Yt2(Co2.p);
    Pc = Yt2(Lo2.p);
    Hc = Rn2({ ...$o2, Fp: jc, lowS: false }, Ae2);
    Rn2({ ...Co2, Fp: kc, lowS: false }, Yi), Rn2({ ...Lo2, Fp: Pc, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi);
    Dc = Hc;
    $n2 = "base10";
    tt = "base16";
    Qt2 = "base64pad";
    De2 = "base64url";
    te2 = "utf8";
    Cn2 = 0;
    ee = 1;
    ge2 = 2;
    Mc = 0;
    jo2 = 1;
    be2 = 12;
    Ln2 = 32;
    Mo2 = "irn";
    ia = Object.defineProperty;
    fa = Object.defineProperties;
    ca = Object.getOwnPropertyDescriptors;
    Fo2 = Object.getOwnPropertySymbols;
    aa = Object.prototype.hasOwnProperty;
    ua = Object.prototype.propertyIsEnumerable;
    zo2 = (t5, e10, n12) => e10 in t5 ? ia(t5, e10, { enumerable: true, configurable: true, writable: true, value: n12 }) : t5[e10] = n12;
    la = (t5, e10) => {
      for (var n12 in e10 || (e10 = {})) aa.call(e10, n12) && zo2(t5, n12, e10[n12]);
      if (Fo2) for (var n12 of Fo2(e10)) ua.call(e10, n12) && zo2(t5, n12, e10[n12]);
      return t5;
    };
    da = (t5, e10) => fa(t5, ca(e10));
    Jo2 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
    Qo2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
    Mn2 = {};
    Ha = class {
      static get(e10) {
        return Mn2[e10];
      }
      static set(e10, n12) {
        Mn2[e10] = n12;
      }
      static delete(e10) {
        delete Mn2[e10];
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
var init_constants = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
    PARSE_ERROR = "PARSE_ERROR";
    INVALID_REQUEST = "INVALID_REQUEST";
    METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    INVALID_PARAMS = "INVALID_PARAMS";
    INTERNAL_ERROR = "INTERNAL_ERROR";
    SERVER_ERROR = "SERVER_ERROR";
    RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    STANDARD_ERROR_MAP = {
      [PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
    DEFAULT_ERROR = SERVER_ERROR;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code2) {
  return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function isValidErrorCode(code2) {
  return typeof code2 === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e10) => e10.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error2 = getErrorByCode(response.error.code);
    if (error2.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error2.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e10, url, type) {
  return e10.message.includes("getaddrinfo ENOTFOUND") || e10.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e10;
}
var init_error = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
    init_constants();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto2(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment, isNodeJs;
var init_env = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
    import_environment = __toESM(require_cjs4());
    __reExport(env_exports, __toESM(require_cjs4()));
    isNodeJs = import_environment.isNode;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error2, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error2, data)
  };
}
function formatErrorMessage(error2, data) {
  if (typeof error2 === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error2 === "string") {
    error2 = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error2 });
  }
  if (typeof data !== "undefined") {
    error2.data = data;
  }
  if (isReservedErrorCode(error2.code)) {
    error2 = getErrorByCode(error2.code);
  }
  return error2;
}
var init_format = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
    init_error();
    init_constants();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x7) => x7.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}
var init_routing = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e, o2, n4, r2;
var init_index_es8 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/index.es.js"() {
    e = class {
    };
    o2 = class extends e {
      constructor(c12) {
        super();
      }
    };
    n4 = class extends e {
      constructor() {
        super();
      }
    };
    r2 = class extends n4 {
      constructor(c12) {
        super();
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
var init_types = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
    init_index_es8();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex2) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex2).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
var HTTP_REGEX, WS_REGEX;
var init_url = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
    HTTP_REGEX = "^https?:";
    WS_REGEX = "^wss?:";
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}
var init_validators = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n4,
  IEvents: () => e,
  IJsonRpcConnection: () => o2,
  IJsonRpcProvider: () => r2,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
var init_esm7 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
    init_constants();
    init_error();
    init_env();
    __reExport(esm_exports, env_exports);
    init_format();
    init_routing();
    init_types();
    init_url();
    init_validators();
  }
});

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5, o3;
var init_index_es9 = __esm({
  "node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js"() {
    import_events5 = __toESM(require_events());
    init_esm7();
    o3 = class extends r2 {
      constructor(t5) {
        super(t5), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t5), this.connection.connected && this.registerEventListeners();
      }
      async connect(t5 = this.connection) {
        await this.open(t5);
      }
      async disconnect() {
        await this.close();
      }
      on(t5, e10) {
        this.events.on(t5, e10);
      }
      once(t5, e10) {
        this.events.once(t5, e10);
      }
      off(t5, e10) {
        this.events.off(t5, e10);
      }
      removeListener(t5, e10) {
        this.events.removeListener(t5, e10);
      }
      async request(t5, e10) {
        return this.requestStrict(formatJsonRpcRequest(t5.method, t5.params || [], t5.id || getBigIntRpcId().toString()), e10);
      }
      async requestStrict(t5, e10) {
        return new Promise(async (i11, s8) => {
          if (!this.connection.connected) try {
            await this.open();
          } catch (n12) {
            s8(n12);
          }
          this.events.on(`${t5.id}`, (n12) => {
            isJsonRpcError(n12) ? s8(n12.error) : i11(n12.result);
          });
          try {
            await this.connection.send(t5, e10);
          } catch (n12) {
            s8(n12);
          }
        });
      }
      setConnection(t5 = this.connection) {
        return t5;
      }
      onPayload(t5) {
        this.events.emit("payload", t5), isJsonRpcResponse(t5) ? this.events.emit(`${t5.id}`, t5) : this.events.emit("message", { type: t5.method, data: t5.params });
      }
      onClose(t5) {
        t5 && t5.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t5.code} ${t5.reason ? `(${t5.reason})` : ""}`)), this.events.emit("disconnect");
      }
      async open(t5 = this.connection) {
        this.connection === t5 && this.connection.connected || (this.connection.connected && this.close(), typeof t5 == "string" && (await this.connection.open(t5), t5 = this.connection), this.connection = this.setConnection(t5), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
      }
      async close() {
        await this.connection.close();
      }
      registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", (t5) => this.onPayload(t5)), this.connection.on("close", (t5) => this.onClose(t5)), this.connection.on("error", (t5) => this.events.emit("error", t5)), this.connection.on("register_error", (t5) => this.onClose()), this.hasRegisteredEventListeners = true);
      }
    };
  }
});

// node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6, v3, w2, d3, h5, b3, f4;
var init_index_es10 = __esm({
  "node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js"() {
    import_events6 = __toESM(require_events());
    init_esm3();
    init_esm7();
    v3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser2();
    w2 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
    d3 = (r9) => r9.split("?")[0];
    h5 = 10;
    b3 = v3();
    f4 = class {
      constructor(e10) {
        if (this.url = e10, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e10)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e10}`);
        this.url = e10;
      }
      get connected() {
        return typeof this.socket < "u";
      }
      get connecting() {
        return this.registering;
      }
      on(e10, t5) {
        this.events.on(e10, t5);
      }
      once(e10, t5) {
        this.events.once(e10, t5);
      }
      off(e10, t5) {
        this.events.off(e10, t5);
      }
      removeListener(e10, t5) {
        this.events.removeListener(e10, t5);
      }
      async open(e10 = this.url) {
        await this.register(e10);
      }
      async close() {
        return new Promise((e10, t5) => {
          if (typeof this.socket > "u") {
            t5(new Error("Connection already closed"));
            return;
          }
          this.socket.onclose = (n12) => {
            this.onClose(n12), e10();
          }, this.socket.close();
        });
      }
      async send(e10) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
          this.socket.send(safeJsonStringify(e10));
        } catch (t5) {
          this.onError(e10.id, t5);
        }
      }
      register(e10 = this.url) {
        if (!isWsUrl(e10)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e10}`);
        if (this.registering) {
          const t5 = this.events.getMaxListeners();
          return (this.events.listenerCount("register_error") >= t5 || this.events.listenerCount("open") >= t5) && this.events.setMaxListeners(t5 + 1), new Promise((n12, s8) => {
            this.events.once("register_error", (o13) => {
              this.resetMaxListeners(), s8(o13);
            }), this.events.once("open", () => {
              if (this.resetMaxListeners(), typeof this.socket > "u") return s8(new Error("WebSocket connection is missing or invalid"));
              n12(this.socket);
            });
          });
        }
        return this.url = e10, this.registering = true, new Promise((t5, n12) => {
          const s8 = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e10) }, o13 = new b3(e10, [], s8);
          w2() ? o13.onerror = (i11) => {
            const a5 = i11;
            n12(this.emitError(a5.error));
          } : o13.on("error", (i11) => {
            n12(this.emitError(i11));
          }), o13.onopen = () => {
            this.onOpen(o13), t5(o13);
          };
        });
      }
      onOpen(e10) {
        e10.onmessage = (t5) => this.onPayload(t5), e10.onclose = (t5) => this.onClose(t5), this.socket = e10, this.registering = false, this.events.emit("open");
      }
      onClose(e10) {
        this.socket = void 0, this.registering = false, this.events.emit("close", e10);
      }
      onPayload(e10) {
        if (typeof e10.data > "u") return;
        const t5 = typeof e10.data == "string" ? safeJsonParse(e10.data) : e10.data;
        this.events.emit("payload", t5);
      }
      onError(e10, t5) {
        const n12 = this.parseError(t5), s8 = n12.message || n12.toString(), o13 = formatJsonRpcError(e10, s8);
        this.events.emit("payload", o13);
      }
      parseError(e10, t5 = this.url) {
        return parseConnectionError(e10, d3(t5), "WS");
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > h5 && this.events.setMaxListeners(h5);
      }
      emitError(e10) {
        const t5 = this.parseError(new Error(e10?.message || `WebSocket connection failed for host: ${d3(this.url)}`));
        return this.events.emit("register_error", t5), t5;
      }
    };
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
function nr2(r9, e10) {
  if (r9.length >= 255) throw new TypeError("Alphabet too long");
  for (var t5 = new Uint8Array(256), i11 = 0; i11 < t5.length; i11++) t5[i11] = 255;
  for (var s8 = 0; s8 < r9.length; s8++) {
    var n12 = r9.charAt(s8), o13 = n12.charCodeAt(0);
    if (t5[o13] !== 255) throw new TypeError(n12 + " is ambiguous");
    t5[o13] = s8;
  }
  var a5 = r9.length, c12 = r9.charAt(0), h12 = Math.log(a5) / Math.log(256), l10 = Math.log(256) / Math.log(a5);
  function d7(u6) {
    if (u6 instanceof Uint8Array || (ArrayBuffer.isView(u6) ? u6 = new Uint8Array(u6.buffer, u6.byteOffset, u6.byteLength) : Array.isArray(u6) && (u6 = Uint8Array.from(u6))), !(u6 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u6.length === 0) return "";
    for (var b7 = 0, x7 = 0, I6 = 0, D4 = u6.length; I6 !== D4 && u6[I6] === 0; ) I6++, b7++;
    for (var j7 = (D4 - I6) * l10 + 1 >>> 0, T6 = new Uint8Array(j7); I6 !== D4; ) {
      for (var q3 = u6[I6], J5 = 0, K5 = j7 - 1; (q3 !== 0 || J5 < x7) && K5 !== -1; K5--, J5++) q3 += 256 * T6[K5] >>> 0, T6[K5] = q3 % a5 >>> 0, q3 = q3 / a5 >>> 0;
      if (q3 !== 0) throw new Error("Non-zero carry");
      x7 = J5, I6++;
    }
    for (var H5 = j7 - x7; H5 !== j7 && T6[H5] === 0; ) H5++;
    for (var me6 = c12.repeat(b7); H5 < j7; ++H5) me6 += r9.charAt(T6[H5]);
    return me6;
  }
  function g5(u6) {
    if (typeof u6 != "string") throw new TypeError("Expected String");
    if (u6.length === 0) return new Uint8Array();
    var b7 = 0;
    if (u6[b7] !== " ") {
      for (var x7 = 0, I6 = 0; u6[b7] === c12; ) x7++, b7++;
      for (var D4 = (u6.length - b7) * h12 + 1 >>> 0, j7 = new Uint8Array(D4); u6[b7]; ) {
        var T6 = t5[u6.charCodeAt(b7)];
        if (T6 === 255) return;
        for (var q3 = 0, J5 = D4 - 1; (T6 !== 0 || q3 < I6) && J5 !== -1; J5--, q3++) T6 += a5 * j7[J5] >>> 0, j7[J5] = T6 % 256 >>> 0, T6 = T6 / 256 >>> 0;
        if (T6 !== 0) throw new Error("Non-zero carry");
        I6 = q3, b7++;
      }
      if (u6[b7] !== " ") {
        for (var K5 = D4 - I6; K5 !== D4 && j7[K5] === 0; ) K5++;
        for (var H5 = new Uint8Array(x7 + (D4 - K5)), me6 = x7; K5 !== D4; ) H5[me6++] = j7[K5++];
        return H5;
      }
    }
  }
  function _5(u6) {
    var b7 = g5(u6);
    if (b7) return b7;
    throw new Error(`Non-${e10} character`);
  }
  return { encode: d7, decodeUnsafe: g5, decode: _5 };
}
function Jr2(r9) {
  return r9.reduce((e10, t5) => (e10 += Hr3[t5], e10), "");
}
function Xr3(r9) {
  const e10 = [];
  for (const t5 of r9) {
    const i11 = Yr2[t5.codePointAt(0)];
    if (i11 === void 0) throw new Error(`Non-base256emoji character: ${t5}`);
    e10.push(i11);
  }
  return new Uint8Array(e10);
}
function ai2(r9, e10, t5) {
  e10 = e10 || [], t5 = t5 || 0;
  for (var i11 = t5; r9 >= rn3; ) e10[t5++] = r9 & 255 | oi2, r9 /= 128;
  for (; r9 & sn3; ) e10[t5++] = r9 & 255 | oi2, r9 >>>= 7;
  return e10[t5] = r9 | 0, ai2.bytes = t5 - i11 + 1, e10;
}
function Me3(r9, i11) {
  var t5 = 0, i11 = i11 || 0, s8 = 0, n12 = i11, o13, a5 = r9.length;
  do {
    if (n12 >= a5) throw Me3.bytes = 0, new RangeError("Could not decode varint");
    o13 = r9[n12++], t5 += s8 < 28 ? (o13 & ci2) << s8 : (o13 & ci2) * Math.pow(2, s8), s8 += 7;
  } while (o13 >= on3);
  return Me3.bytes = n12 - i11, t5;
}
function mi2(r9) {
  return globalThis.Buffer != null ? new Uint8Array(r9.buffer, r9.byteOffset, r9.byteLength) : r9;
}
function Pn3(r9 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? mi2(globalThis.Buffer.allocUnsafe(r9)) : new Uint8Array(r9);
}
function fi2(r9, e10, t5, i11) {
  return { name: r9, prefix: e10, encoder: { name: r9, prefix: e10, encode: t5 }, decoder: { decode: i11 } };
}
function On3(r9, e10 = "utf8") {
  const t5 = Sn3[e10];
  if (!t5) throw new Error(`Unsupported encoding "${e10}"`);
  return (e10 === "utf8" || e10 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? mi2(globalThis.Buffer.from(r9, "utf-8")) : t5.decoder.decode(`${t5.prefix}${r9}`);
}
function ro3(r9, e10) {
  return r9 === e10 || Number.isNaN(r9) && Number.isNaN(e10);
}
function Ri2(r9) {
  return Object.getOwnPropertySymbols(r9).filter((e10) => Object.prototype.propertyIsEnumerable.call(r9, e10));
}
function Ai2(r9) {
  return r9 == null ? r9 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r9);
}
function Ro3() {
}
function Ni2(r9) {
  if (!r9 || typeof r9 != "object") return false;
  const e10 = Object.getPrototypeOf(r9);
  return e10 === null || e10 === Object.prototype || Object.getPrototypeOf(e10) === null ? Object.prototype.toString.call(r9) === "[object Object]" : false;
}
function Ao3(r9, e10, t5) {
  return pe3(r9, e10, void 0, void 0, void 0, void 0, t5);
}
function pe3(r9, e10, t5, i11, s8, n12, o13) {
  const a5 = o13(r9, e10, t5, i11, s8, n12);
  if (a5 !== void 0) return a5;
  if (typeof r9 == typeof e10) switch (typeof r9) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r9 === e10;
    case "number":
      return r9 === e10 || Object.is(r9, e10);
    case "function":
      return r9 === e10;
    case "object":
      return ye3(r9, e10, n12, o13);
  }
  return ye3(r9, e10, n12, o13);
}
function ye3(r9, e10, t5, i11) {
  if (Object.is(r9, e10)) return true;
  let s8 = Ai2(r9), n12 = Ai2(e10);
  if (s8 === xi2 && (s8 = Je2), n12 === xi2 && (n12 = Je2), s8 !== n12) return false;
  switch (s8) {
    case oo3:
      return r9.toString() === e10.toString();
    case ao3: {
      const c12 = r9.valueOf(), h12 = e10.valueOf();
      return ro3(c12, h12);
    }
    case co3:
    case lo3:
    case ho3:
      return Object.is(r9.valueOf(), e10.valueOf());
    case no3:
      return r9.source === e10.source && r9.flags === e10.flags;
    case yo3:
      return r9 === e10;
  }
  t5 = t5 ?? /* @__PURE__ */ new Map();
  const o13 = t5.get(r9), a5 = t5.get(e10);
  if (o13 != null && a5 != null) return o13 === e10;
  t5.set(r9, e10), t5.set(e10, r9);
  try {
    switch (s8) {
      case uo3: {
        if (r9.size !== e10.size) return false;
        for (const [c12, h12] of r9.entries()) if (!e10.has(c12) || !pe3(h12, e10.get(c12), c12, r9, e10, t5, i11)) return false;
        return true;
      }
      case go3: {
        if (r9.size !== e10.size) return false;
        const c12 = Array.from(r9.values()), h12 = Array.from(e10.values());
        for (let l10 = 0; l10 < c12.length; l10++) {
          const d7 = c12[l10], g5 = h12.findIndex((_5) => pe3(d7, _5, void 0, r9, e10, t5, i11));
          if (g5 === -1) return false;
          h12.splice(g5, 1);
        }
        return true;
      }
      case po3:
      case Do3:
      case vo3:
      case wo3:
      case _o3:
      case Eo3:
      case Io3:
      case To3:
      case Co3:
      case Po3:
      case So3:
      case Oo3: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r9) !== Buffer.isBuffer(e10) || r9.length !== e10.length) return false;
        for (let c12 = 0; c12 < r9.length; c12++) if (!pe3(r9[c12], e10[c12], c12, r9, e10, t5, i11)) return false;
        return true;
      }
      case bo3:
        return r9.byteLength !== e10.byteLength ? false : ye3(new Uint8Array(r9), new Uint8Array(e10), t5, i11);
      case fo3:
        return r9.byteLength !== e10.byteLength || r9.byteOffset !== e10.byteOffset ? false : ye3(new Uint8Array(r9), new Uint8Array(e10), t5, i11);
      case mo3:
        return r9.name === e10.name && r9.message === e10.message;
      case Je2: {
        if (!(ye3(r9.constructor, e10.constructor, t5, i11) || Ni2(r9) && Ni2(e10))) return false;
        const h12 = [...Object.keys(r9), ...Ri2(r9)], l10 = [...Object.keys(e10), ...Ri2(e10)];
        if (h12.length !== l10.length) return false;
        for (let d7 = 0; d7 < h12.length; d7++) {
          const g5 = h12[d7], _5 = r9[g5];
          if (!Object.hasOwn(e10, g5)) return false;
          const u6 = e10[g5];
          if (!pe3(_5, u6, g5, r9, e10, t5, i11)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t5.delete(r9), t5.delete(e10);
  }
}
function xo3(r9, e10) {
  return Ao3(r9, e10, Ro3);
}
var import_events7, import_time4, import_window_getters2, ze2, Le3, he3, B2, Et3, It3, Tt3, ke3, Ct2, Pt3, St3, Ot3, Rt3, je3, At2, xt3, Nt3, Ue3, $t3, C3, zt3, L2, Lt3, _e3, Q3, le3, kt3, jt3, Fe2, $, Ut3, Ft2, Js, Mt3, Kt3, se2, re, F2, Bt3, Vt3, qt3, M3, Gt3, Wt3, Qs, Ht3, ue2, Yt3, Jt3, Xt3, Zt3, G3, Y2, tr3, ir3, sr3, rr3, Qt3, ei2, ti, ii2, or4, ar2, si2, cr3, hr3, lr2, ur2, dr3, ri2, gr3, Ee2, de3, pr3, yr3, P3, br3, mr3, fr3, Dr3, vr3, wr3, _r3, Er3, Ir3, Tr3, Cr3, Pr3, Sr3, Or3, Rr3, Ar3, xr3, Nr3, $r3, zr2, Lr3, kr3, jr3, Ur3, Fr2, Mr3, Kr3, Br3, Vr3, qr3, Gr3, Wr3, ni2, Hr3, Yr2, Zr3, Qr3, en3, oi2, tn2, sn3, rn3, nn3, on3, ci2, an2, cn2, hn2, ln2, un2, dn2, gn3, pn2, yn3, bn3, mn3, hi2, li2, ui2, Ke3, fn2, di2, Dn2, gi2, vn3, wn2, _n3, pi2, En3, yi2, In3, Tn3, Cn3, bi2, Di2, Be3, Sn3, Rn3, An3, W3, vi2, xn3, Nn3, S3, wi2, $n3, zn3, Ln3, _i2, kn3, jn3, Ve3, Un3, Fn3, k5, Ei2, Mn3, Kn3, Bn3, Ii2, Vn3, qn3, qe3, Ie3, Ge2, V2, Gn2, Wn2, Hn3, ne2, Yn2, Jn3, Xn2, Zn2, Ti2, Qn3, eo3, We2, ge3, He3, f5, Ci2, to3, Pi3, io3, so3, Ye3, Si2, y4, Oi2, no3, oo3, ao3, co3, xi2, ho3, lo3, uo3, go3, po3, yo3, bo3, Je2, mo3, fo3, Do3, vo3, wo3, _o3, Eo3, Io3, To3, Co3, Po3, So3, Oo3, No3, $i2, $o3, zo3, Xe3, zi2, z3, Li2, Lo3, ko3, p3, ki2, jo3, Uo3, O4, ji2, Fo3, Mo3, A2, Ui2, Ko3, Bo3, w3, Fi2, Vo3, qo3, Mi2, Ki2, Go3, Bi2, Wo3, Ho3, Ze3, be3, E3, Vi2, Yo3, qi2, Jo3, Xo2, Qe3, Gi2, v4, Te3, Zo3;
var init_index_es11 = __esm({
  "node_modules/@walletconnect/core/dist/index.es.js"() {
    import_events7 = __toESM(require_events());
    init_index_es();
    init_index_es2();
    init_index_es3();
    init_index_es4();
    import_time4 = __toESM(require_cjs());
    init_esm3();
    init_index_es5();
    init_index_es5();
    init_index_es7();
    init_src2();
    init_index_es9();
    init_esm7();
    init_index_es10();
    import_window_getters2 = __toESM(require_cjs2());
    ze2 = "wc";
    Le3 = 2;
    he3 = "core";
    B2 = `${ze2}@2:${he3}:`;
    Et3 = { name: he3, logger: "error" };
    It3 = { database: ":memory:" };
    Tt3 = "crypto";
    ke3 = "client_ed25519_seed";
    Ct2 = import_time4.ONE_DAY;
    Pt3 = "keychain";
    St3 = "0.3";
    Ot3 = "messages";
    Rt3 = "0.3";
    je3 = import_time4.SIX_HOURS;
    At2 = "publisher";
    xt3 = "irn";
    Nt3 = "error";
    Ue3 = "wss://relay.walletconnect.org";
    $t3 = "relayer";
    C3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
    zt3 = "_subscription";
    L2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
    Lt3 = 0.1;
    _e3 = "2.21.5";
    Q3 = { link_mode: "link_mode", relay: "relay" };
    le3 = { inbound: "inbound", outbound: "outbound" };
    kt3 = "0.3";
    jt3 = "WALLETCONNECT_CLIENT_ID";
    Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
    $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
    Ut3 = "subscription";
    Ft2 = "0.3";
    Js = import_time4.FIVE_SECONDS * 1e3;
    Mt3 = "pairing";
    Kt3 = "0.3";
    se2 = { wc_pairingDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 0 } } };
    re = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
    F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
    Bt3 = "history";
    Vt3 = "0.3";
    qt3 = "expirer";
    M3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
    Gt3 = "0.3";
    Wt3 = "verify-api";
    Qs = "https://verify.walletconnect.com";
    Ht3 = "https://verify.walletconnect.org";
    ue2 = Ht3;
    Yt3 = `${ue2}/v3`;
    Jt3 = [Qs, Ht3];
    Xt3 = "echo";
    Zt3 = "https://echo.walletconnect.com";
    G3 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
    Y2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
    tr3 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
    ir3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
    sr3 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
    rr3 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
    Qt3 = 0.1;
    ei2 = "event-client";
    ti = 86400;
    ii2 = "https://pulse.walletconnect.org/batch";
    or4 = nr2;
    ar2 = or4;
    si2 = (r9) => {
      if (r9 instanceof Uint8Array && r9.constructor.name === "Uint8Array") return r9;
      if (r9 instanceof ArrayBuffer) return new Uint8Array(r9);
      if (ArrayBuffer.isView(r9)) return new Uint8Array(r9.buffer, r9.byteOffset, r9.byteLength);
      throw new Error("Unknown type, must be binary type");
    };
    cr3 = (r9) => new TextEncoder().encode(r9);
    hr3 = (r9) => new TextDecoder().decode(r9);
    lr2 = class {
      constructor(e10, t5, i11) {
        this.name = e10, this.prefix = t5, this.baseEncode = i11;
      }
      encode(e10) {
        if (e10 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e10)}`;
        throw Error("Unknown type, must be binary type");
      }
    };
    ur2 = class {
      constructor(e10, t5, i11) {
        if (this.name = e10, this.prefix = t5, t5.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
        this.prefixCodePoint = t5.codePointAt(0), this.baseDecode = i11;
      }
      decode(e10) {
        if (typeof e10 == "string") {
          if (e10.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e10)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(e10.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
      or(e10) {
        return ri2(this, e10);
      }
    };
    dr3 = class {
      constructor(e10) {
        this.decoders = e10;
      }
      or(e10) {
        return ri2(this, e10);
      }
      decode(e10) {
        const t5 = e10[0], i11 = this.decoders[t5];
        if (i11) return i11.decode(e10);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(e10)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    };
    ri2 = (r9, e10) => new dr3({ ...r9.decoders || { [r9.prefix]: r9 }, ...e10.decoders || { [e10.prefix]: e10 } });
    gr3 = class {
      constructor(e10, t5, i11, s8) {
        this.name = e10, this.prefix = t5, this.baseEncode = i11, this.baseDecode = s8, this.encoder = new lr2(e10, t5, i11), this.decoder = new ur2(e10, t5, s8);
      }
      encode(e10) {
        return this.encoder.encode(e10);
      }
      decode(e10) {
        return this.decoder.decode(e10);
      }
    };
    Ee2 = ({ name: r9, prefix: e10, encode: t5, decode: i11 }) => new gr3(r9, e10, t5, i11);
    de3 = ({ prefix: r9, name: e10, alphabet: t5 }) => {
      const { encode: i11, decode: s8 } = ar2(t5, e10);
      return Ee2({ prefix: r9, name: e10, encode: i11, decode: (n12) => si2(s8(n12)) });
    };
    pr3 = (r9, e10, t5, i11) => {
      const s8 = {};
      for (let l10 = 0; l10 < e10.length; ++l10) s8[e10[l10]] = l10;
      let n12 = r9.length;
      for (; r9[n12 - 1] === "="; ) --n12;
      const o13 = new Uint8Array(n12 * t5 / 8 | 0);
      let a5 = 0, c12 = 0, h12 = 0;
      for (let l10 = 0; l10 < n12; ++l10) {
        const d7 = s8[r9[l10]];
        if (d7 === void 0) throw new SyntaxError(`Non-${i11} character`);
        c12 = c12 << t5 | d7, a5 += t5, a5 >= 8 && (a5 -= 8, o13[h12++] = 255 & c12 >> a5);
      }
      if (a5 >= t5 || 255 & c12 << 8 - a5) throw new SyntaxError("Unexpected end of data");
      return o13;
    };
    yr3 = (r9, e10, t5) => {
      const i11 = e10[e10.length - 1] === "=", s8 = (1 << t5) - 1;
      let n12 = "", o13 = 0, a5 = 0;
      for (let c12 = 0; c12 < r9.length; ++c12) for (a5 = a5 << 8 | r9[c12], o13 += 8; o13 > t5; ) o13 -= t5, n12 += e10[s8 & a5 >> o13];
      if (o13 && (n12 += e10[s8 & a5 << t5 - o13]), i11) for (; n12.length * t5 & 7; ) n12 += "=";
      return n12;
    };
    P3 = ({ name: r9, prefix: e10, bitsPerChar: t5, alphabet: i11 }) => Ee2({ prefix: e10, name: r9, encode(s8) {
      return yr3(s8, i11, t5);
    }, decode(s8) {
      return pr3(s8, i11, t5, r9);
    } });
    br3 = Ee2({ prefix: "\0", name: "identity", encode: (r9) => hr3(r9), decode: (r9) => cr3(r9) });
    mr3 = Object.freeze({ __proto__: null, identity: br3 });
    fr3 = P3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
    Dr3 = Object.freeze({ __proto__: null, base2: fr3 });
    vr3 = P3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
    wr3 = Object.freeze({ __proto__: null, base8: vr3 });
    _r3 = de3({ prefix: "9", name: "base10", alphabet: "0123456789" });
    Er3 = Object.freeze({ __proto__: null, base10: _r3 });
    Ir3 = P3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
    Tr3 = P3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
    Cr3 = Object.freeze({ __proto__: null, base16: Ir3, base16upper: Tr3 });
    Pr3 = P3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
    Sr3 = P3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
    Or3 = P3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
    Rr3 = P3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
    Ar3 = P3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
    xr3 = P3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
    Nr3 = P3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
    $r3 = P3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
    zr2 = P3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
    Lr3 = Object.freeze({ __proto__: null, base32: Pr3, base32upper: Sr3, base32pad: Or3, base32padupper: Rr3, base32hex: Ar3, base32hexupper: xr3, base32hexpad: Nr3, base32hexpadupper: $r3, base32z: zr2 });
    kr3 = de3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
    jr3 = de3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
    Ur3 = Object.freeze({ __proto__: null, base36: kr3, base36upper: jr3 });
    Fr2 = de3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
    Mr3 = de3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
    Kr3 = Object.freeze({ __proto__: null, base58btc: Fr2, base58flickr: Mr3 });
    Br3 = P3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
    Vr3 = P3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
    qr3 = P3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
    Gr3 = P3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
    Wr3 = Object.freeze({ __proto__: null, base64: Br3, base64pad: Vr3, base64url: qr3, base64urlpad: Gr3 });
    ni2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    Hr3 = ni2.reduce((r9, e10, t5) => (r9[t5] = e10, r9), []);
    Yr2 = ni2.reduce((r9, e10, t5) => (r9[e10.codePointAt(0)] = t5, r9), []);
    Zr3 = Ee2({ prefix: "\u{1F680}", name: "base256emoji", encode: Jr2, decode: Xr3 });
    Qr3 = Object.freeze({ __proto__: null, base256emoji: Zr3 });
    en3 = ai2;
    oi2 = 128;
    tn2 = 127;
    sn3 = ~tn2;
    rn3 = Math.pow(2, 31);
    nn3 = Me3;
    on3 = 128;
    ci2 = 127;
    an2 = Math.pow(2, 7);
    cn2 = Math.pow(2, 14);
    hn2 = Math.pow(2, 21);
    ln2 = Math.pow(2, 28);
    un2 = Math.pow(2, 35);
    dn2 = Math.pow(2, 42);
    gn3 = Math.pow(2, 49);
    pn2 = Math.pow(2, 56);
    yn3 = Math.pow(2, 63);
    bn3 = function(r9) {
      return r9 < an2 ? 1 : r9 < cn2 ? 2 : r9 < hn2 ? 3 : r9 < ln2 ? 4 : r9 < un2 ? 5 : r9 < dn2 ? 6 : r9 < gn3 ? 7 : r9 < pn2 ? 8 : r9 < yn3 ? 9 : 10;
    };
    mn3 = { encode: en3, decode: nn3, encodingLength: bn3 };
    hi2 = mn3;
    li2 = (r9, e10, t5 = 0) => (hi2.encode(r9, e10, t5), e10);
    ui2 = (r9) => hi2.encodingLength(r9);
    Ke3 = (r9, e10) => {
      const t5 = e10.byteLength, i11 = ui2(r9), s8 = i11 + ui2(t5), n12 = new Uint8Array(s8 + t5);
      return li2(r9, n12, 0), li2(t5, n12, i11), n12.set(e10, s8), new fn2(r9, t5, e10, n12);
    };
    fn2 = class {
      constructor(e10, t5, i11, s8) {
        this.code = e10, this.size = t5, this.digest = i11, this.bytes = s8;
      }
    };
    di2 = ({ name: r9, code: e10, encode: t5 }) => new Dn2(r9, e10, t5);
    Dn2 = class {
      constructor(e10, t5, i11) {
        this.name = e10, this.code = t5, this.encode = i11;
      }
      digest(e10) {
        if (e10 instanceof Uint8Array) {
          const t5 = this.encode(e10);
          return t5 instanceof Uint8Array ? Ke3(this.code, t5) : t5.then((i11) => Ke3(this.code, i11));
        } else throw Error("Unknown type, must be binary type");
      }
    };
    gi2 = (r9) => async (e10) => new Uint8Array(await crypto.subtle.digest(r9, e10));
    vn3 = di2({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
    wn2 = di2({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
    _n3 = Object.freeze({ __proto__: null, sha256: vn3, sha512: wn2 });
    pi2 = 0;
    En3 = "identity";
    yi2 = si2;
    In3 = (r9) => Ke3(pi2, yi2(r9));
    Tn3 = { code: pi2, name: En3, encode: yi2, digest: In3 };
    Cn3 = Object.freeze({ __proto__: null, identity: Tn3 });
    new TextEncoder(), new TextDecoder();
    bi2 = { ...mr3, ...Dr3, ...wr3, ...Er3, ...Cr3, ...Lr3, ...Ur3, ...Kr3, ...Wr3, ...Qr3 };
    ({ ..._n3, ...Cn3 });
    Di2 = fi2("utf8", "u", (r9) => "u" + new TextDecoder("utf8").decode(r9), (r9) => new TextEncoder().encode(r9.substring(1)));
    Be3 = fi2("ascii", "a", (r9) => {
      let e10 = "a";
      for (let t5 = 0; t5 < r9.length; t5++) e10 += String.fromCharCode(r9[t5]);
      return e10;
    }, (r9) => {
      r9 = r9.substring(1);
      const e10 = Pn3(r9.length);
      for (let t5 = 0; t5 < r9.length; t5++) e10[t5] = r9.charCodeAt(t5);
      return e10;
    });
    Sn3 = { utf8: Di2, "utf-8": Di2, hex: bi2.base16, latin1: Be3, ascii: Be3, binary: Be3, ...bi2 };
    Rn3 = Object.defineProperty;
    An3 = (r9, e10, t5) => e10 in r9 ? Rn3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    W3 = (r9, e10, t5) => An3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    vi2 = class {
      constructor(e10, t5) {
        this.core = e10, this.logger = t5, W3(this, "keychain", /* @__PURE__ */ new Map()), W3(this, "name", Pt3), W3(this, "version", St3), W3(this, "initialized", false), W3(this, "storagePrefix", B2), W3(this, "init", async () => {
          if (!this.initialized) {
            const i11 = await this.getKeyChain();
            typeof i11 < "u" && (this.keychain = i11), this.initialized = true;
          }
        }), W3(this, "has", (i11) => (this.isInitialized(), this.keychain.has(i11))), W3(this, "set", async (i11, s8) => {
          this.isInitialized(), this.keychain.set(i11, s8), await this.persist();
        }), W3(this, "get", (i11) => {
          this.isInitialized();
          const s8 = this.keychain.get(i11);
          if (typeof s8 > "u") {
            const { message: n12 } = Et2("NO_MATCHING_KEY", `${this.name}: ${i11}`);
            throw new Error(n12);
          }
          return s8;
        }), W3(this, "del", async (i11) => {
          this.isInitialized(), this.keychain.delete(i11), await this.persist();
        }), this.core = e10, this.logger = E2(t5, this.name);
      }
      get context() {
        return y2(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      async setKeyChain(e10) {
        await this.core.storage.setItem(this.storageKey, Ys(e10));
      }
      async getKeyChain() {
        const e10 = await this.core.storage.getItem(this.storageKey);
        return typeof e10 < "u" ? Xs(e10) : void 0;
      }
      async persist() {
        await this.setKeyChain(this.keychain);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
    };
    xn3 = Object.defineProperty;
    Nn3 = (r9, e10, t5) => e10 in r9 ? xn3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    S3 = (r9, e10, t5) => Nn3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    wi2 = class {
      constructor(e10, t5, i11) {
        this.core = e10, this.logger = t5, S3(this, "name", Tt3), S3(this, "keychain"), S3(this, "randomSessionIdentifier", qc()), S3(this, "initialized", false), S3(this, "init", async () => {
          this.initialized || (await this.keychain.init(), this.initialized = true);
        }), S3(this, "hasKeys", (s8) => (this.isInitialized(), this.keychain.has(s8))), S3(this, "getClientId", async () => {
          this.isInitialized();
          const s8 = await this.getClientSeed(), n12 = Po(s8);
          return Qe(n12.publicKey);
        }), S3(this, "generateKeyPair", () => {
          this.isInitialized();
          const s8 = Vc();
          return this.setPrivateKey(s8.publicKey, s8.privateKey);
        }), S3(this, "signJWT", async (s8) => {
          this.isInitialized();
          const n12 = await this.getClientSeed(), o13 = Po(n12), a5 = this.randomSessionIdentifier, c12 = Ct2;
          return await Qo(a5, s8, c12, o13);
        }), S3(this, "generateSharedKey", (s8, n12, o13) => {
          this.isInitialized();
          const a5 = this.getPrivateKey(s8), c12 = Kc(a5, n12);
          return this.setSymKey(c12, o13);
        }), S3(this, "setSymKey", async (s8, n12) => {
          this.isInitialized();
          const o13 = n12 || Fc(s8);
          return await this.keychain.set(o13, s8), o13;
        }), S3(this, "deleteKeyPair", async (s8) => {
          this.isInitialized(), await this.keychain.del(s8);
        }), S3(this, "deleteSymKey", async (s8) => {
          this.isInitialized(), await this.keychain.del(s8);
        }), S3(this, "encode", async (s8, n12, o13) => {
          this.isInitialized();
          const a5 = Ho2(o13), c12 = safeJsonStringify(n12);
          if (Qc(a5)) return Wc(c12, o13?.encoding);
          if (Jc(a5)) {
            const g5 = a5.senderPublicKey, _5 = a5.receiverPublicKey;
            s8 = await this.generateSharedKey(g5, _5);
          }
          const h12 = this.getSymKey(s8), { type: l10, senderPublicKey: d7 } = a5;
          return Gc({ type: l10, symKey: h12, message: c12, senderPublicKey: d7, encoding: o13?.encoding });
        }), S3(this, "decode", async (s8, n12, o13) => {
          this.isInitialized();
          const a5 = Xc(n12, o13);
          if (Qc(a5)) {
            const c12 = Yc(n12, o13?.encoding);
            return safeJsonParse(c12);
          }
          if (Jc(a5)) {
            const c12 = a5.receiverPublicKey, h12 = a5.senderPublicKey;
            s8 = await this.generateSharedKey(c12, h12);
          }
          try {
            const c12 = this.getSymKey(s8), h12 = Zc({ symKey: c12, encoded: n12, encoding: o13?.encoding });
            return safeJsonParse(h12);
          } catch (c12) {
            this.logger.error(`Failed to decode message from topic: '${s8}', clientId: '${await this.getClientId()}'`), this.logger.error(c12);
          }
        }), S3(this, "getPayloadType", (s8, n12 = Qt2) => {
          const o13 = Me2({ encoded: s8, encoding: n12 });
          return Vt2(o13.type);
        }), S3(this, "getPayloadSenderPublicKey", (s8, n12 = Qt2) => {
          const o13 = Me2({ encoded: s8, encoding: n12 });
          return o13.senderPublicKey ? toString2(o13.senderPublicKey, tt) : void 0;
        }), this.core = e10, this.logger = E2(t5, this.name), this.keychain = i11 || new vi2(this.core, this.logger);
      }
      get context() {
        return y2(this.logger);
      }
      async setPrivateKey(e10, t5) {
        return await this.keychain.set(e10, t5), e10;
      }
      getPrivateKey(e10) {
        return this.keychain.get(e10);
      }
      async getClientSeed() {
        let e10 = "";
        try {
          e10 = this.keychain.get(ke3);
        } catch {
          e10 = qc(), await this.keychain.set(ke3, e10);
        }
        return On3(e10, "base16");
      }
      getSymKey(e10) {
        return this.keychain.get(e10);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
    };
    $n3 = Object.defineProperty;
    zn3 = Object.defineProperties;
    Ln3 = Object.getOwnPropertyDescriptors;
    _i2 = Object.getOwnPropertySymbols;
    kn3 = Object.prototype.hasOwnProperty;
    jn3 = Object.prototype.propertyIsEnumerable;
    Ve3 = (r9, e10, t5) => e10 in r9 ? $n3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    Un3 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) kn3.call(e10, t5) && Ve3(r9, t5, e10[t5]);
      if (_i2) for (var t5 of _i2(e10)) jn3.call(e10, t5) && Ve3(r9, t5, e10[t5]);
      return r9;
    };
    Fn3 = (r9, e10) => zn3(r9, Ln3(e10));
    k5 = (r9, e10, t5) => Ve3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Ei2 = class extends y3 {
      constructor(e10, t5) {
        super(e10, t5), this.logger = e10, this.core = t5, k5(this, "messages", /* @__PURE__ */ new Map()), k5(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k5(this, "name", Ot3), k5(this, "version", Rt3), k5(this, "initialized", false), k5(this, "storagePrefix", B2), k5(this, "init", async () => {
          if (!this.initialized) {
            this.logger.trace("Initialized");
            try {
              const i11 = await this.getRelayerMessages();
              typeof i11 < "u" && (this.messages = i11);
              const s8 = await this.getRelayerMessagesWithoutClientAck();
              typeof s8 < "u" && (this.messagesWithoutClientAck = s8), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
            } catch (i11) {
              this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i11);
            } finally {
              this.initialized = true;
            }
          }
        }), k5(this, "set", async (i11, s8, n12) => {
          this.isInitialized();
          const o13 = zc(s8);
          let a5 = this.messages.get(i11);
          if (typeof a5 > "u" && (a5 = {}), typeof a5[o13] < "u") return o13;
          if (a5[o13] = s8, this.messages.set(i11, a5), n12 === le3.inbound) {
            const c12 = this.messagesWithoutClientAck.get(i11) || {};
            this.messagesWithoutClientAck.set(i11, Fn3(Un3({}, c12), { [o13]: s8 }));
          }
          return await this.persist(), o13;
        }), k5(this, "get", (i11) => {
          this.isInitialized();
          let s8 = this.messages.get(i11);
          return typeof s8 > "u" && (s8 = {}), s8;
        }), k5(this, "getWithoutAck", (i11) => {
          this.isInitialized();
          const s8 = {};
          for (const n12 of i11) {
            const o13 = this.messagesWithoutClientAck.get(n12) || {};
            s8[n12] = Object.values(o13);
          }
          return s8;
        }), k5(this, "has", (i11, s8) => {
          this.isInitialized();
          const n12 = this.get(i11), o13 = zc(s8);
          return typeof n12[o13] < "u";
        }), k5(this, "ack", async (i11, s8) => {
          this.isInitialized();
          const n12 = this.messagesWithoutClientAck.get(i11);
          if (typeof n12 > "u") return;
          const o13 = zc(s8);
          delete n12[o13], Object.keys(n12).length === 0 ? this.messagesWithoutClientAck.delete(i11) : this.messagesWithoutClientAck.set(i11, n12), await this.persist();
        }), k5(this, "del", async (i11) => {
          this.isInitialized(), this.messages.delete(i11), this.messagesWithoutClientAck.delete(i11), await this.persist();
        }), this.logger = E2(e10, this.name), this.core = t5;
      }
      get context() {
        return y2(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get storageKeyWithoutClientAck() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
      }
      async setRelayerMessages(e10) {
        await this.core.storage.setItem(this.storageKey, Ys(e10));
      }
      async setRelayerMessagesWithoutClientAck(e10) {
        await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ys(e10));
      }
      async getRelayerMessages() {
        const e10 = await this.core.storage.getItem(this.storageKey);
        return typeof e10 < "u" ? Xs(e10) : void 0;
      }
      async getRelayerMessagesWithoutClientAck() {
        const e10 = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
        return typeof e10 < "u" ? Xs(e10) : void 0;
      }
      async persist() {
        await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
    };
    Mn3 = Object.defineProperty;
    Kn3 = Object.defineProperties;
    Bn3 = Object.getOwnPropertyDescriptors;
    Ii2 = Object.getOwnPropertySymbols;
    Vn3 = Object.prototype.hasOwnProperty;
    qn3 = Object.prototype.propertyIsEnumerable;
    qe3 = (r9, e10, t5) => e10 in r9 ? Mn3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    Ie3 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) Vn3.call(e10, t5) && qe3(r9, t5, e10[t5]);
      if (Ii2) for (var t5 of Ii2(e10)) qn3.call(e10, t5) && qe3(r9, t5, e10[t5]);
      return r9;
    };
    Ge2 = (r9, e10) => Kn3(r9, Bn3(e10));
    V2 = (r9, e10, t5) => qe3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Gn2 = class extends m2 {
      constructor(e10, t5) {
        super(e10, t5), this.relayer = e10, this.logger = t5, V2(this, "events", new import_events7.EventEmitter()), V2(this, "name", At2), V2(this, "queue", /* @__PURE__ */ new Map()), V2(this, "publishTimeout", (0, import_time4.toMiliseconds)(import_time4.ONE_MINUTE)), V2(this, "initialPublishTimeout", (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND * 15)), V2(this, "needsTransportRestart", false), V2(this, "publish", async (i11, s8, n12) => {
          var o13;
          this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i11, message: s8, opts: n12 } });
          const a5 = n12?.ttl || je3, c12 = ea(n12), h12 = n12?.prompt || false, l10 = n12?.tag || 0, d7 = n12?.id || getBigIntRpcId().toString(), g5 = { topic: i11, message: s8, opts: { ttl: a5, relay: c12, prompt: h12, tag: l10, id: d7, attestation: n12?.attestation, tvf: n12?.tvf } }, _5 = `Failed to publish payload, please try again. id:${d7} tag:${l10}`;
          try {
            const u6 = new Promise(async (b7) => {
              const x7 = ({ id: D4 }) => {
                g5.opts.id === D4 && (this.removeRequestFromQueue(D4), this.relayer.events.removeListener(C3.publish, x7), b7(g5));
              };
              this.relayer.events.on(C3.publish, x7);
              const I6 = ni(new Promise((D4, j7) => {
                this.rpcPublish({ topic: i11, message: s8, ttl: a5, prompt: h12, tag: l10, id: d7, attestation: n12?.attestation, tvf: n12?.tvf }).then(D4).catch((T6) => {
                  this.logger.warn(T6, T6?.message), j7(T6);
                });
              }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d7} tag:${l10}`);
              try {
                await I6, this.events.removeListener(C3.publish, x7);
              } catch (D4) {
                this.queue.set(d7, Ge2(Ie3({}, g5), { attempt: 1 })), this.logger.warn(D4, D4?.message);
              }
            });
            this.logger.trace({ type: "method", method: "publish", params: { id: d7, topic: i11, message: s8, opts: n12 } }), await ni(u6, this.publishTimeout, _5);
          } catch (u6) {
            if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u6), (o13 = n12?.internal) != null && o13.throwOnFailedPublish) throw u6;
          } finally {
            this.queue.delete(d7);
          }
        }), V2(this, "on", (i11, s8) => {
          this.events.on(i11, s8);
        }), V2(this, "once", (i11, s8) => {
          this.events.once(i11, s8);
        }), V2(this, "off", (i11, s8) => {
          this.events.off(i11, s8);
        }), V2(this, "removeListener", (i11, s8) => {
          this.events.removeListener(i11, s8);
        }), this.relayer = e10, this.logger = E2(t5, this.name), this.registerEventListeners();
      }
      get context() {
        return y2(this.logger);
      }
      async rpcPublish(e10) {
        var t5, i11, s8, n12;
        const { topic: o13, message: a5, ttl: c12 = je3, prompt: h12, tag: l10, id: d7, attestation: g5, tvf: _5 } = e10, u6 = { method: na(ea().protocol).publish, params: Ie3({ topic: o13, message: a5, ttl: c12, prompt: h12, tag: l10, attestation: g5 }, _5), id: d7 };
        kt2((t5 = u6.params) == null ? void 0 : t5.prompt) && ((i11 = u6.params) == null || delete i11.prompt), kt2((s8 = u6.params) == null ? void 0 : s8.tag) && ((n12 = u6.params) == null || delete n12.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u6 });
        const b7 = await this.relayer.request(u6);
        return this.relayer.events.emit(C3.publish, e10), this.logger.debug("Successfully Published Payload"), b7;
      }
      removeRequestFromQueue(e10) {
        this.queue.delete(e10);
      }
      checkQueue() {
        this.queue.forEach(async (e10, t5) => {
          const i11 = e10.attempt + 1;
          this.queue.set(t5, Ge2(Ie3({}, e10), { attempt: i11 }));
          const { topic: s8, message: n12, opts: o13, attestation: a5 } = e10;
          this.logger.warn({}, `Publisher: queue->publishing: ${e10.opts.id}, tag: ${e10.opts.tag}, attempt: ${i11}`), await this.rpcPublish(Ge2(Ie3({}, e10), { topic: s8, message: n12, ttl: o13.ttl, prompt: o13.prompt, tag: o13.tag, id: o13.id, attestation: a5, tvf: o13.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e10.opts.id}`);
        });
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(r.pulse, () => {
          if (this.needsTransportRestart) {
            this.needsTransportRestart = false, this.relayer.events.emit(C3.connection_stalled);
            return;
          }
          this.checkQueue();
        }), this.relayer.on(C3.message_ack, (e10) => {
          this.removeRequestFromQueue(e10.id.toString());
        });
      }
    };
    Wn2 = Object.defineProperty;
    Hn3 = (r9, e10, t5) => e10 in r9 ? Wn2(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    ne2 = (r9, e10, t5) => Hn3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Yn2 = class {
      constructor() {
        ne2(this, "map", /* @__PURE__ */ new Map()), ne2(this, "set", (e10, t5) => {
          const i11 = this.get(e10);
          this.exists(e10, t5) || this.map.set(e10, [...i11, t5]);
        }), ne2(this, "get", (e10) => this.map.get(e10) || []), ne2(this, "exists", (e10, t5) => this.get(e10).includes(t5)), ne2(this, "delete", (e10, t5) => {
          if (typeof t5 > "u") {
            this.map.delete(e10);
            return;
          }
          if (!this.map.has(e10)) return;
          const i11 = this.get(e10);
          if (!this.exists(e10, t5)) return;
          const s8 = i11.filter((n12) => n12 !== t5);
          if (!s8.length) {
            this.map.delete(e10);
            return;
          }
          this.map.set(e10, s8);
        }), ne2(this, "clear", () => {
          this.map.clear();
        });
      }
      get topics() {
        return Array.from(this.map.keys());
      }
    };
    Jn3 = Object.defineProperty;
    Xn2 = Object.defineProperties;
    Zn2 = Object.getOwnPropertyDescriptors;
    Ti2 = Object.getOwnPropertySymbols;
    Qn3 = Object.prototype.hasOwnProperty;
    eo3 = Object.prototype.propertyIsEnumerable;
    We2 = (r9, e10, t5) => e10 in r9 ? Jn3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    ge3 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) Qn3.call(e10, t5) && We2(r9, t5, e10[t5]);
      if (Ti2) for (var t5 of Ti2(e10)) eo3.call(e10, t5) && We2(r9, t5, e10[t5]);
      return r9;
    };
    He3 = (r9, e10) => Xn2(r9, Zn2(e10));
    f5 = (r9, e10, t5) => We2(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Ci2 = class extends P {
      constructor(e10, t5) {
        super(e10, t5), this.relayer = e10, this.logger = t5, f5(this, "subscriptions", /* @__PURE__ */ new Map()), f5(this, "topicMap", new Yn2()), f5(this, "events", new import_events7.EventEmitter()), f5(this, "name", Ut3), f5(this, "version", Ft2), f5(this, "pending", /* @__PURE__ */ new Map()), f5(this, "cached", []), f5(this, "initialized", false), f5(this, "storagePrefix", B2), f5(this, "subscribeTimeout", (0, import_time4.toMiliseconds)(import_time4.ONE_MINUTE)), f5(this, "initialSubscribeTimeout", (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND * 15)), f5(this, "clientId"), f5(this, "batchSubscribeTopicsLimit", 500), f5(this, "init", async () => {
          this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
        }), f5(this, "subscribe", async (i11, s8) => {
          this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i11, opts: s8 } });
          try {
            const n12 = ea(s8), o13 = { topic: i11, relay: n12, transportType: s8?.transportType };
            this.pending.set(i11, o13);
            const a5 = await this.rpcSubscribe(i11, n12, s8);
            return typeof a5 == "string" && (this.onSubscribe(a5, o13), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i11, opts: s8 } })), a5;
          } catch (n12) {
            throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n12), n12;
          }
        }), f5(this, "unsubscribe", async (i11, s8) => {
          this.isInitialized(), typeof s8?.id < "u" ? await this.unsubscribeById(i11, s8.id, s8) : await this.unsubscribeByTopic(i11, s8);
        }), f5(this, "isSubscribed", (i11) => new Promise((s8) => {
          s8(this.topicMap.topics.includes(i11));
        })), f5(this, "isKnownTopic", (i11) => new Promise((s8) => {
          s8(this.topicMap.topics.includes(i11) || this.pending.has(i11) || this.cached.some((n12) => n12.topic === i11));
        })), f5(this, "on", (i11, s8) => {
          this.events.on(i11, s8);
        }), f5(this, "once", (i11, s8) => {
          this.events.once(i11, s8);
        }), f5(this, "off", (i11, s8) => {
          this.events.off(i11, s8);
        }), f5(this, "removeListener", (i11, s8) => {
          this.events.removeListener(i11, s8);
        }), f5(this, "start", async () => {
          await this.onConnect();
        }), f5(this, "stop", async () => {
          await this.onDisconnect();
        }), f5(this, "restart", async () => {
          await this.restore(), await this.onRestart();
        }), f5(this, "checkPending", async () => {
          if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
          const i11 = [];
          this.pending.forEach((s8) => {
            i11.push(s8);
          }), await this.batchSubscribe(i11);
        }), f5(this, "registerEventListeners", () => {
          this.relayer.core.heartbeat.on(r.pulse, async () => {
            await this.checkPending();
          }), this.events.on($.created, async (i11) => {
            const s8 = $.created;
            this.logger.info(`Emitting ${s8}`), this.logger.debug({ type: "event", event: s8, data: i11 }), await this.persist();
          }), this.events.on($.deleted, async (i11) => {
            const s8 = $.deleted;
            this.logger.info(`Emitting ${s8}`), this.logger.debug({ type: "event", event: s8, data: i11 }), await this.persist();
          });
        }), this.relayer = e10, this.logger = E2(t5, this.name), this.clientId = "";
      }
      get context() {
        return y2(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
      }
      get length() {
        return this.subscriptions.size;
      }
      get ids() {
        return Array.from(this.subscriptions.keys());
      }
      get values() {
        return Array.from(this.subscriptions.values());
      }
      get topics() {
        return this.topicMap.topics;
      }
      get hasAnyTopics() {
        return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
      }
      hasSubscription(e10, t5) {
        let i11 = false;
        try {
          i11 = this.getSubscription(e10).topic === t5;
        } catch {
        }
        return i11;
      }
      reset() {
        this.cached = [], this.initialized = true;
      }
      onDisable() {
        this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
      }
      async unsubscribeByTopic(e10, t5) {
        const i11 = this.topicMap.get(e10);
        await Promise.all(i11.map(async (s8) => await this.unsubscribeById(e10, s8, t5)));
      }
      async unsubscribeById(e10, t5, i11) {
        this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e10, id: t5, opts: i11 } });
        try {
          const s8 = ea(i11);
          await this.restartToComplete({ topic: e10, id: t5, relay: s8 }), await this.rpcUnsubscribe(e10, t5, s8);
          const n12 = Kt2("USER_DISCONNECTED", `${this.name}, ${e10}`);
          await this.onUnsubscribe(e10, t5, n12), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e10, id: t5, opts: i11 } });
        } catch (s8) {
          throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s8), s8;
        }
      }
      async rpcSubscribe(e10, t5, i11) {
        var s8;
        (!i11 || i11?.transportType === Q3.relay) && await this.restartToComplete({ topic: e10, id: e10, relay: t5 });
        const n12 = { method: na(t5.protocol).subscribe, params: { topic: e10 } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n12 });
        const o13 = (s8 = i11?.internal) == null ? void 0 : s8.throwOnFailedPublish;
        try {
          const a5 = await this.getSubscriptionId(e10);
          if (i11?.transportType === Q3.link_mode) return setTimeout(() => {
            (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n12).catch((l10) => this.logger.warn(l10));
          }, (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND)), a5;
          const c12 = new Promise(async (l10) => {
            const d7 = (g5) => {
              g5.topic === e10 && (this.events.removeListener($.created, d7), l10(g5.id));
            };
            this.events.on($.created, d7);
            try {
              const g5 = await ni(new Promise((_5, u6) => {
                this.relayer.request(n12).catch((b7) => {
                  this.logger.warn(b7, b7?.message), u6(b7);
                }).then(_5);
              }), this.initialSubscribeTimeout, `Subscribing to ${e10} failed, please try again`);
              this.events.removeListener($.created, d7), l10(g5);
            } catch {
            }
          }), h12 = await ni(c12, this.subscribeTimeout, `Subscribing to ${e10} failed, please try again`);
          if (!h12 && o13) throw new Error(`Subscribing to ${e10} failed, please try again`);
          return h12 ? a5 : null;
        } catch (a5) {
          if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C3.connection_stalled), o13) throw a5;
        }
        return null;
      }
      async rpcBatchSubscribe(e10) {
        if (!e10.length) return;
        const t5 = e10[0].relay, i11 = { method: na(t5.protocol).batchSubscribe, params: { topics: e10.map((s8) => s8.topic) } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i11 });
        try {
          await await ni(new Promise((s8) => {
            this.relayer.request(i11).catch((n12) => this.logger.warn(n12)).then(s8);
          }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
        } catch {
          this.relayer.events.emit(C3.connection_stalled);
        }
      }
      async rpcBatchFetchMessages(e10) {
        if (!e10.length) return;
        const t5 = e10[0].relay, i11 = { method: na(t5.protocol).batchFetchMessages, params: { topics: e10.map((n12) => n12.topic) } };
        this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i11 });
        let s8;
        try {
          s8 = await await ni(new Promise((n12, o13) => {
            this.relayer.request(i11).catch((a5) => {
              this.logger.warn(a5), o13(a5);
            }).then(n12);
          }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
        } catch {
          this.relayer.events.emit(C3.connection_stalled);
        }
        return s8;
      }
      rpcUnsubscribe(e10, t5, i11) {
        const s8 = { method: na(i11.protocol).unsubscribe, params: { topic: e10, id: t5 } };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s8 }), this.relayer.request(s8);
      }
      onSubscribe(e10, t5) {
        this.setSubscription(e10, He3(ge3({}, t5), { id: e10 })), this.pending.delete(t5.topic);
      }
      onBatchSubscribe(e10) {
        e10.length && e10.forEach((t5) => {
          this.setSubscription(t5.id, ge3({}, t5)), this.pending.delete(t5.topic);
        });
      }
      async onUnsubscribe(e10, t5, i11) {
        this.events.removeAllListeners(t5), this.hasSubscription(t5, e10) && this.deleteSubscription(t5, i11), await this.relayer.messages.del(e10);
      }
      async setRelayerSubscriptions(e10) {
        await this.relayer.core.storage.setItem(this.storageKey, e10);
      }
      async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey);
      }
      setSubscription(e10, t5) {
        this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e10, subscription: t5 }), this.addSubscription(e10, t5);
      }
      addSubscription(e10, t5) {
        this.subscriptions.set(e10, ge3({}, t5)), this.topicMap.set(t5.topic, e10), this.events.emit($.created, t5);
      }
      getSubscription(e10) {
        this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e10 });
        const t5 = this.subscriptions.get(e10);
        if (!t5) {
          const { message: i11 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e10}`);
          throw new Error(i11);
        }
        return t5;
      }
      deleteSubscription(e10, t5) {
        this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e10, reason: t5 });
        const i11 = this.getSubscription(e10);
        this.subscriptions.delete(e10), this.topicMap.delete(i11.topic, e10), this.events.emit($.deleted, He3(ge3({}, i11), { reason: t5 }));
      }
      async persist() {
        await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
      }
      async onRestart() {
        if (this.cached.length) {
          const e10 = [...this.cached], t5 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
          for (let i11 = 0; i11 < t5; i11++) {
            const s8 = e10.splice(0, this.batchSubscribeTopicsLimit);
            await this.batchSubscribe(s8);
          }
        }
        this.events.emit($.resubscribed);
      }
      async restore() {
        try {
          const e10 = await this.getRelayerSubscriptions();
          if (typeof e10 > "u" || !e10.length) return;
          if (this.subscriptions.size) {
            const { message: t5 } = Et2("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t5), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t5);
          }
          this.cached = e10, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
        } catch (e10) {
          this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e10);
        }
      }
      async batchSubscribe(e10) {
        e10.length && (await this.rpcBatchSubscribe(e10), this.onBatchSubscribe(await Promise.all(e10.map(async (t5) => He3(ge3({}, t5), { id: await this.getSubscriptionId(t5.topic) })))));
      }
      async batchFetchMessages(e10) {
        if (!e10.length) return;
        this.logger.trace(`Fetching batch messages for ${e10.length} subscriptions`);
        const t5 = await this.rpcBatchFetchMessages(e10);
        t5 && t5.messages && (await pi((0, import_time4.toMiliseconds)(import_time4.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t5.messages));
      }
      async onConnect() {
        await this.restart(), this.reset();
      }
      onDisconnect() {
        this.onDisable();
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
      async restartToComplete(e10) {
        !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e10), await this.relayer.transportOpen());
      }
      async getClientId() {
        return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
      }
      async getSubscriptionId(e10) {
        return zc(e10 + await this.getClientId());
      }
    };
    to3 = Object.defineProperty;
    Pi3 = Object.getOwnPropertySymbols;
    io3 = Object.prototype.hasOwnProperty;
    so3 = Object.prototype.propertyIsEnumerable;
    Ye3 = (r9, e10, t5) => e10 in r9 ? to3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    Si2 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) io3.call(e10, t5) && Ye3(r9, t5, e10[t5]);
      if (Pi3) for (var t5 of Pi3(e10)) so3.call(e10, t5) && Ye3(r9, t5, e10[t5]);
      return r9;
    };
    y4 = (r9, e10, t5) => Ye3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Oi2 = class extends d2 {
      constructor(e10) {
        super(e10), y4(this, "protocol", "wc"), y4(this, "version", 2), y4(this, "core"), y4(this, "logger"), y4(this, "events", new import_events7.EventEmitter()), y4(this, "provider"), y4(this, "messages"), y4(this, "subscriber"), y4(this, "publisher"), y4(this, "name", $t3), y4(this, "transportExplicitlyClosed", false), y4(this, "initialized", false), y4(this, "connectionAttemptInProgress", false), y4(this, "relayUrl"), y4(this, "projectId"), y4(this, "packageName"), y4(this, "bundleId"), y4(this, "hasExperiencedNetworkDisruption", false), y4(this, "pingTimeout"), y4(this, "heartBeatTimeout", (0, import_time4.toMiliseconds)(import_time4.THIRTY_SECONDS + import_time4.FIVE_SECONDS)), y4(this, "reconnectTimeout"), y4(this, "connectPromise"), y4(this, "reconnectInProgress", false), y4(this, "requestsInFlight", []), y4(this, "connectTimeout", (0, import_time4.toMiliseconds)(import_time4.ONE_SECOND * 15)), y4(this, "request", async (t5) => {
          var i11, s8;
          this.logger.debug("Publishing Request Payload");
          const n12 = t5.id || getBigIntRpcId().toString();
          await this.toEstablishConnection();
          try {
            this.logger.trace({ id: n12, method: t5.method, topic: (i11 = t5.params) == null ? void 0 : i11.topic }, "relayer.request - publishing...");
            const o13 = `${n12}:${((s8 = t5.params) == null ? void 0 : s8.tag) || ""}`;
            this.requestsInFlight.push(o13);
            const a5 = await this.provider.request(t5);
            return this.requestsInFlight = this.requestsInFlight.filter((c12) => c12 !== o13), a5;
          } catch (o13) {
            throw this.logger.debug(`Failed to Publish Request: ${n12}`), o13;
          }
        }), y4(this, "resetPingTimeout", () => {
          Ye2() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
            var t5, i11, s8, n12;
            try {
              this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n12 = (s8 = (i11 = (t5 = this.provider) == null ? void 0 : t5.connection) == null ? void 0 : i11.socket) == null ? void 0 : s8.terminate) == null || n12.call(s8);
            } catch (o13) {
              this.logger.warn(o13, o13?.message);
            }
          }, this.heartBeatTimeout));
        }), y4(this, "onPayloadHandler", (t5) => {
          this.onProviderPayload(t5), this.resetPingTimeout();
        }), y4(this, "onConnectHandler", () => {
          this.logger.warn({}, "Relayer connected \u{1F6DC}"), this.startPingTimeout(), this.events.emit(C3.connect);
        }), y4(this, "onDisconnectHandler", () => {
          this.logger.warn({}, "Relayer disconnected \u{1F6D1}"), this.requestsInFlight = [], this.onProviderDisconnect();
        }), y4(this, "onProviderErrorHandler", (t5) => {
          this.logger.fatal(`Fatal socket error: ${t5.message}`), this.events.emit(C3.error, t5), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
        }), y4(this, "registerProviderListeners", () => {
          this.provider.on(L2.payload, this.onPayloadHandler), this.provider.on(L2.connect, this.onConnectHandler), this.provider.on(L2.disconnect, this.onDisconnectHandler), this.provider.on(L2.error, this.onProviderErrorHandler);
        }), this.core = e10.core, this.logger = typeof e10.logger < "u" && typeof e10.logger != "string" ? E2(e10.logger, this.name) : (0, import_pino2.default)(k2({ level: e10.logger || Nt3 })), this.messages = new Ei2(this.logger, e10.core), this.subscriber = new Ci2(this, this.logger), this.publisher = new Gn2(this, this.logger), this.relayUrl = e10?.relayUrl || Ue3, this.projectId = e10.projectId, Ms() ? this.packageName = qs() : Vs() && (this.bundleId = qs()), this.provider = {};
      }
      async init() {
        this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e10) => this.logger.warn(e10, e10?.message));
      }
      get context() {
        return y2(this.logger);
      }
      get connected() {
        var e10, t5, i11;
        return ((i11 = (t5 = (e10 = this.provider) == null ? void 0 : e10.connection) == null ? void 0 : t5.socket) == null ? void 0 : i11.readyState) === 1 || false;
      }
      get connecting() {
        var e10, t5, i11;
        return ((i11 = (t5 = (e10 = this.provider) == null ? void 0 : e10.connection) == null ? void 0 : t5.socket) == null ? void 0 : i11.readyState) === 0 || this.connectPromise !== void 0 || false;
      }
      async publish(e10, t5, i11) {
        this.isInitialized(), await this.publisher.publish(e10, t5, i11), await this.recordMessageEvent({ topic: e10, message: t5, publishedAt: Date.now(), transportType: Q3.relay }, le3.outbound);
      }
      async subscribe(e10, t5) {
        var i11, s8, n12;
        this.isInitialized(), (!(t5 != null && t5.transportType) || t5?.transportType === "relay") && await this.toEstablishConnection();
        const o13 = typeof ((i11 = t5?.internal) == null ? void 0 : i11.throwOnFailedPublish) > "u" ? true : (s8 = t5?.internal) == null ? void 0 : s8.throwOnFailedPublish;
        let a5 = ((n12 = this.subscriber.topicMap.get(e10)) == null ? void 0 : n12[0]) || "", c12;
        const h12 = (l10) => {
          l10.topic === e10 && (this.subscriber.off($.created, h12), c12());
        };
        return await Promise.all([new Promise((l10) => {
          c12 = l10, this.subscriber.on($.created, h12);
        }), new Promise(async (l10, d7) => {
          a5 = await this.subscriber.subscribe(e10, Si2({ internal: { throwOnFailedPublish: o13 } }, t5)).catch((g5) => {
            o13 && d7(g5);
          }) || a5, l10();
        })]), a5;
      }
      async unsubscribe(e10, t5) {
        this.isInitialized(), await this.subscriber.unsubscribe(e10, t5);
      }
      on(e10, t5) {
        this.events.on(e10, t5);
      }
      once(e10, t5) {
        this.events.once(e10, t5);
      }
      off(e10, t5) {
        this.events.off(e10, t5);
      }
      removeListener(e10, t5) {
        this.events.removeListener(e10, t5);
      }
      async transportDisconnect() {
        this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ni(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
      }
      async transportClose() {
        this.transportExplicitlyClosed = true, await this.transportDisconnect();
      }
      async transportOpen(e10) {
        if (!this.subscriber.hasAnyTopics) {
          this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
          return;
        }
        if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t5, i11) => {
          await this.connect(e10).then(t5).catch(i11).finally(() => {
            this.connectPromise = void 0;
          });
        }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
      }
      async restartTransport(e10) {
        this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e10 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
      }
      async confirmOnlineStateOrThrow() {
        if (!await ja()) throw new Error("No internet connection detected. Please restart your network and try again.");
      }
      async handleBatchMessageEvents(e10) {
        if (e10?.length === 0) {
          this.logger.trace("Batch message events is empty. Ignoring...");
          return;
        }
        const t5 = e10.sort((i11, s8) => i11.publishedAt - s8.publishedAt);
        this.logger.debug(`Batch of ${t5.length} message events sorted`);
        for (const i11 of t5) try {
          await this.onMessageEvent(i11);
        } catch (s8) {
          this.logger.warn(s8, "Error while processing batch message event: " + s8?.message);
        }
        this.logger.trace(`Batch of ${t5.length} message events processed`);
      }
      async onLinkMessageEvent(e10, t5) {
        const { topic: i11 } = e10;
        if (!t5.sessionExists) {
          const s8 = ii(import_time4.FIVE_MINUTES), n12 = { topic: i11, expiry: s8, relay: { protocol: "irn" }, active: false };
          await this.core.pairing.pairings.set(i11, n12);
        }
        this.events.emit(C3.message, e10), await this.recordMessageEvent(e10, le3.inbound);
      }
      async connect(e10) {
        await this.confirmOnlineStateOrThrow(), e10 && e10 !== this.relayUrl && (this.relayUrl = e10, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
        let t5 = 1;
        for (; t5 < 6; ) {
          try {
            if (this.transportExplicitlyClosed) break;
            this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t5}...`), await this.createProvider(), await new Promise(async (i11, s8) => {
              const n12 = () => {
                s8(new Error("Connection interrupted while trying to connect"));
              };
              this.provider.once(L2.disconnect, n12), await ni(new Promise((o13, a5) => {
                this.provider.connect().then(o13).catch(a5);
              }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o13) => {
                s8(o13);
              }).finally(() => {
                this.provider.off(L2.disconnect, n12), clearTimeout(this.reconnectTimeout);
              }), await new Promise(async (o13, a5) => {
                const c12 = () => {
                  s8(new Error("Connection interrupted while trying to subscribe"));
                };
                this.provider.once(L2.disconnect, c12), await this.subscriber.start().then(o13).catch(a5).finally(() => {
                  this.provider.off(L2.disconnect, c12);
                });
              }), this.hasExperiencedNetworkDisruption = false, i11();
            });
          } catch (i11) {
            await this.subscriber.stop();
            const s8 = i11;
            this.logger.warn({}, s8.message), this.hasExperiencedNetworkDisruption = true;
          } finally {
            this.connectionAttemptInProgress = false;
          }
          if (this.connected) {
            this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t5}`);
            break;
          }
          await new Promise((i11) => setTimeout(i11, (0, import_time4.toMiliseconds)(t5 * 1))), t5++;
        }
      }
      startPingTimeout() {
        var e10, t5, i11, s8, n12;
        if (Ye2()) try {
          (t5 = (e10 = this.provider) == null ? void 0 : e10.connection) != null && t5.socket && ((n12 = (s8 = (i11 = this.provider) == null ? void 0 : i11.connection) == null ? void 0 : s8.socket) == null || n12.on("ping", () => {
            this.resetPingTimeout();
          })), this.resetPingTimeout();
        } catch (o13) {
          this.logger.warn(o13, o13?.message);
        }
      }
      async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        const e10 = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new o3(new f4(zs({ sdkVersion: _e3, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e10, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
      }
      async recordMessageEvent(e10, t5) {
        const { topic: i11, message: s8 } = e10;
        await this.messages.set(i11, s8, t5);
      }
      async shouldIgnoreMessageEvent(e10) {
        const { topic: t5, message: i11 } = e10;
        if (!i11 || i11.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i11}`), true;
        if (!await this.subscriber.isKnownTopic(t5)) return this.logger.warn(`Ignoring message for unknown topic ${t5}`), true;
        const s8 = this.messages.has(t5, i11);
        return s8 && this.logger.warn(`Ignoring duplicate message: ${i11}`), s8;
      }
      async onProviderPayload(e10) {
        if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e10 }), isJsonRpcRequest(e10)) {
          if (!e10.method.endsWith(zt3)) return;
          const t5 = e10.params, { topic: i11, message: s8, publishedAt: n12, attestation: o13 } = t5.data, a5 = { topic: i11, message: s8, publishedAt: n12, transportType: Q3.relay, attestation: o13 };
          this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Si2({ type: "event", event: t5.id }, a5)), this.events.emit(t5.id, a5), await this.acknowledgePayload(e10), await this.onMessageEvent(a5);
        } else isJsonRpcResponse(e10) && this.events.emit(C3.message_ack, e10);
      }
      async onMessageEvent(e10) {
        await this.shouldIgnoreMessageEvent(e10) || (await this.recordMessageEvent(e10, le3.inbound), this.events.emit(C3.message, e10));
      }
      async acknowledgePayload(e10) {
        const t5 = formatJsonRpcResult(e10.id, true);
        await this.provider.connection.send(t5);
      }
      unregisterProviderListeners() {
        this.provider.off(L2.payload, this.onPayloadHandler), this.provider.off(L2.connect, this.onConnectHandler), this.provider.off(L2.disconnect, this.onDisconnectHandler), this.provider.off(L2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
      }
      async registerEventListeners() {
        let e10 = await ja();
        ka(async (t5) => {
          e10 !== t5 && (e10 = t5, t5 ? await this.transportOpen().catch((i11) => this.logger.error(i11, i11?.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
        }), this.core.heartbeat.on(r.pulse, async () => {
          if (!this.transportExplicitlyClosed && !this.connected && Pa()) try {
            await this.confirmOnlineStateOrThrow(), await this.transportOpen();
          } catch (t5) {
            this.logger.warn(t5, t5?.message);
          }
        });
      }
      async onProviderDisconnect() {
        clearTimeout(this.pingTimeout), this.events.emit(C3.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
          await this.transportOpen().catch((e10) => this.logger.error(e10, e10?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
        }, (0, import_time4.toMiliseconds)(Lt3)))));
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
      async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(), !this.connected) {
          if (this.connectPromise) {
            await this.connectPromise;
            return;
          }
          await this.connect();
        }
      }
    };
    no3 = "[object RegExp]";
    oo3 = "[object String]";
    ao3 = "[object Number]";
    co3 = "[object Boolean]";
    xi2 = "[object Arguments]";
    ho3 = "[object Symbol]";
    lo3 = "[object Date]";
    uo3 = "[object Map]";
    go3 = "[object Set]";
    po3 = "[object Array]";
    yo3 = "[object Function]";
    bo3 = "[object ArrayBuffer]";
    Je2 = "[object Object]";
    mo3 = "[object Error]";
    fo3 = "[object DataView]";
    Do3 = "[object Uint8Array]";
    vo3 = "[object Uint8ClampedArray]";
    wo3 = "[object Uint16Array]";
    _o3 = "[object Uint32Array]";
    Eo3 = "[object BigUint64Array]";
    Io3 = "[object Int8Array]";
    To3 = "[object Int16Array]";
    Co3 = "[object Int32Array]";
    Po3 = "[object BigInt64Array]";
    So3 = "[object Float32Array]";
    Oo3 = "[object Float64Array]";
    No3 = Object.defineProperty;
    $i2 = Object.getOwnPropertySymbols;
    $o3 = Object.prototype.hasOwnProperty;
    zo3 = Object.prototype.propertyIsEnumerable;
    Xe3 = (r9, e10, t5) => e10 in r9 ? No3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    zi2 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) $o3.call(e10, t5) && Xe3(r9, t5, e10[t5]);
      if ($i2) for (var t5 of $i2(e10)) zo3.call(e10, t5) && Xe3(r9, t5, e10[t5]);
      return r9;
    };
    z3 = (r9, e10, t5) => Xe3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Li2 = class extends f3 {
      constructor(e10, t5, i11, s8 = B2, n12 = void 0) {
        super(e10, t5, i11, s8), this.core = e10, this.logger = t5, this.name = i11, z3(this, "map", /* @__PURE__ */ new Map()), z3(this, "version", kt3), z3(this, "cached", []), z3(this, "initialized", false), z3(this, "getKey"), z3(this, "storagePrefix", B2), z3(this, "recentlyDeleted", []), z3(this, "recentlyDeletedLimit", 200), z3(this, "init", async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o13) => {
            this.getKey && o13 !== null && !kt2(o13) ? this.map.set(this.getKey(o13), o13) : wa(o13) ? this.map.set(o13.id, o13) : xa(o13) && this.map.set(o13.topic, o13);
          }), this.cached = [], this.initialized = true);
        }), z3(this, "set", async (o13, a5) => {
          this.isInitialized(), this.map.has(o13) ? await this.update(o13, a5) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o13, value: a5 }), this.map.set(o13, a5), await this.persist());
        }), z3(this, "get", (o13) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o13 }), this.getData(o13))), z3(this, "getAll", (o13) => (this.isInitialized(), o13 ? this.values.filter((a5) => Object.keys(o13).every((c12) => xo3(a5[c12], o13[c12]))) : this.values)), z3(this, "update", async (o13, a5) => {
          this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o13, update: a5 });
          const c12 = zi2(zi2({}, this.getData(o13)), a5);
          this.map.set(o13, c12), await this.persist();
        }), z3(this, "delete", async (o13, a5) => {
          this.isInitialized(), this.map.has(o13) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o13, reason: a5 }), this.map.delete(o13), this.addToRecentlyDeleted(o13), await this.persist());
        }), this.logger = E2(t5, this.name), this.storagePrefix = s8, this.getKey = n12;
      }
      get context() {
        return y2(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get length() {
        return this.map.size;
      }
      get keys() {
        return Array.from(this.map.keys());
      }
      get values() {
        return Array.from(this.map.values());
      }
      addToRecentlyDeleted(e10) {
        this.recentlyDeleted.push(e10), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
      }
      async setDataStore(e10) {
        await this.core.storage.setItem(this.storageKey, e10);
      }
      async getDataStore() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getData(e10) {
        const t5 = this.map.get(e10);
        if (!t5) {
          if (this.recentlyDeleted.includes(e10)) {
            const { message: s8 } = Et2("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e10}`);
            throw this.logger.error(s8), new Error(s8);
          }
          const { message: i11 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e10}`);
          throw this.logger.error(i11), new Error(i11);
        }
        return t5;
      }
      async persist() {
        await this.setDataStore(this.values);
      }
      async restore() {
        try {
          const e10 = await this.getDataStore();
          if (typeof e10 > "u" || !e10.length) return;
          if (this.map.size) {
            const { message: t5 } = Et2("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t5), new Error(t5);
          }
          this.cached = e10, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
        } catch (e10) {
          this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e10);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
    };
    Lo3 = Object.defineProperty;
    ko3 = (r9, e10, t5) => e10 in r9 ? Lo3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    p3 = (r9, e10, t5) => ko3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    ki2 = class {
      constructor(e10, t5) {
        this.core = e10, this.logger = t5, p3(this, "name", Mt3), p3(this, "version", Kt3), p3(this, "events", new import_events7.default()), p3(this, "pairings"), p3(this, "initialized", false), p3(this, "storagePrefix", B2), p3(this, "ignoredPayloadTypes", [ee]), p3(this, "registeredMethods", []), p3(this, "init", async () => {
          this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
        }), p3(this, "register", ({ methods: i11 }) => {
          this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i11])];
        }), p3(this, "create", async (i11) => {
          this.isInitialized();
          const s8 = qc(), n12 = await this.core.crypto.setSymKey(s8), o13 = ii(import_time4.FIVE_MINUTES), a5 = { protocol: xt3 }, c12 = { topic: n12, expiry: o13, relay: a5, active: false, methods: i11?.methods }, h12 = oa({ protocol: this.core.protocol, version: this.core.version, topic: n12, symKey: s8, relay: a5, expiryTimestamp: o13, methods: i11?.methods });
          return this.events.emit(re.create, c12), this.core.expirer.set(n12, o13), await this.pairings.set(n12, c12), await this.core.relayer.subscribe(n12, { transportType: i11?.transportType }), { topic: n12, uri: h12 };
        }), p3(this, "pair", async (i11) => {
          this.isInitialized();
          const s8 = this.core.eventClient.createEvent({ properties: { topic: i11?.uri, trace: [G3.pairing_started] } });
          this.isValidPair(i11, s8);
          const { topic: n12, symKey: o13, relay: a5, expiryTimestamp: c12, methods: h12 } = ra(i11.uri);
          s8.props.properties.topic = n12, s8.addTrace(G3.pairing_uri_validation_success), s8.addTrace(G3.pairing_uri_not_expired);
          let l10;
          if (this.pairings.keys.includes(n12)) {
            if (l10 = this.pairings.get(n12), s8.addTrace(G3.existing_pairing), l10.active) throw s8.setError(Y2.active_pairing_already_exists), new Error(`Pairing already exists: ${n12}. Please try again with a new connection URI.`);
            s8.addTrace(G3.pairing_not_expired);
          }
          const d7 = c12 || ii(import_time4.FIVE_MINUTES), g5 = { topic: n12, relay: a5, expiry: d7, active: false, methods: h12 };
          this.core.expirer.set(n12, d7), await this.pairings.set(n12, g5), s8.addTrace(G3.store_new_pairing), i11.activatePairing && await this.activate({ topic: n12 }), this.events.emit(re.create, g5), s8.addTrace(G3.emit_inactive_pairing), this.core.crypto.keychain.has(n12) || await this.core.crypto.setSymKey(o13, n12), s8.addTrace(G3.subscribing_pairing_topic);
          try {
            await this.core.relayer.confirmOnlineStateOrThrow();
          } catch {
            s8.setError(Y2.no_internet_connection);
          }
          try {
            await this.core.relayer.subscribe(n12, { relay: a5 });
          } catch (_5) {
            throw s8.setError(Y2.subscribe_pairing_topic_failure), _5;
          }
          return s8.addTrace(G3.subscribe_pairing_topic_success), g5;
        }), p3(this, "activate", async ({ topic: i11 }) => {
          this.isInitialized();
          const s8 = ii(import_time4.FIVE_MINUTES);
          this.core.expirer.set(i11, s8), await this.pairings.update(i11, { active: true, expiry: s8 });
        }), p3(this, "ping", async (i11) => {
          this.isInitialized(), await this.isValidPing(i11), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
          const { topic: s8 } = i11;
          if (this.pairings.keys.includes(s8)) {
            const n12 = await this.sendRequest(s8, "wc_pairingPing", {}), { done: o13, resolve: a5, reject: c12 } = ei();
            this.events.once(ci("pairing_ping", n12), ({ error: h12 }) => {
              h12 ? c12(h12) : a5();
            }), await o13();
          }
        }), p3(this, "updateExpiry", async ({ topic: i11, expiry: s8 }) => {
          this.isInitialized(), await this.pairings.update(i11, { expiry: s8 });
        }), p3(this, "updateMetadata", async ({ topic: i11, metadata: s8 }) => {
          this.isInitialized(), await this.pairings.update(i11, { peerMetadata: s8 });
        }), p3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p3(this, "disconnect", async (i11) => {
          this.isInitialized(), await this.isValidDisconnect(i11);
          const { topic: s8 } = i11;
          this.pairings.keys.includes(s8) && (await this.sendRequest(s8, "wc_pairingDelete", Kt2("USER_DISCONNECTED")), await this.deletePairing(s8));
        }), p3(this, "formatUriFromPairing", (i11) => {
          this.isInitialized();
          const { topic: s8, relay: n12, expiry: o13, methods: a5 } = i11, c12 = this.core.crypto.keychain.get(s8);
          return oa({ protocol: this.core.protocol, version: this.core.version, topic: s8, symKey: c12, relay: n12, expiryTimestamp: o13, methods: a5 });
        }), p3(this, "sendRequest", async (i11, s8, n12) => {
          const o13 = formatJsonRpcRequest(s8, n12), a5 = await this.core.crypto.encode(i11, o13), c12 = se2[s8].req;
          return this.core.history.set(i11, o13), this.core.relayer.publish(i11, a5, c12), o13.id;
        }), p3(this, "sendResult", async (i11, s8, n12) => {
          const o13 = formatJsonRpcResult(i11, n12), a5 = await this.core.crypto.encode(s8, o13), c12 = (await this.core.history.get(s8, i11)).request.method, h12 = se2[c12].res;
          await this.core.relayer.publish(s8, a5, h12), await this.core.history.resolve(o13);
        }), p3(this, "sendError", async (i11, s8, n12) => {
          const o13 = formatJsonRpcError(i11, n12), a5 = await this.core.crypto.encode(s8, o13), c12 = (await this.core.history.get(s8, i11)).request.method, h12 = se2[c12] ? se2[c12].res : se2.unregistered_method.res;
          await this.core.relayer.publish(s8, a5, h12), await this.core.history.resolve(o13);
        }), p3(this, "deletePairing", async (i11, s8) => {
          await this.core.relayer.unsubscribe(i11), await Promise.all([this.pairings.delete(i11, Kt2("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i11), s8 ? Promise.resolve() : this.core.expirer.del(i11)]);
        }), p3(this, "cleanup", async () => {
          const i11 = this.pairings.getAll().filter((s8) => fi(s8.expiry));
          await Promise.all(i11.map((s8) => this.deletePairing(s8.topic)));
        }), p3(this, "onRelayEventRequest", async (i11) => {
          const { topic: s8, payload: n12 } = i11;
          switch (n12.method) {
            case "wc_pairingPing":
              return await this.onPairingPingRequest(s8, n12);
            case "wc_pairingDelete":
              return await this.onPairingDeleteRequest(s8, n12);
            default:
              return await this.onUnknownRpcMethodRequest(s8, n12);
          }
        }), p3(this, "onRelayEventResponse", async (i11) => {
          const { topic: s8, payload: n12 } = i11, o13 = (await this.core.history.get(s8, n12.id)).request.method;
          switch (o13) {
            case "wc_pairingPing":
              return this.onPairingPingResponse(s8, n12);
            default:
              return this.onUnknownRpcMethodResponse(o13);
          }
        }), p3(this, "onPairingPingRequest", async (i11, s8) => {
          const { id: n12 } = s8;
          try {
            this.isValidPing({ topic: i11 }), await this.sendResult(n12, i11, true), this.events.emit(re.ping, { id: n12, topic: i11 });
          } catch (o13) {
            await this.sendError(n12, i11, o13), this.logger.error(o13);
          }
        }), p3(this, "onPairingPingResponse", (i11, s8) => {
          const { id: n12 } = s8;
          setTimeout(() => {
            isJsonRpcResult(s8) ? this.events.emit(ci("pairing_ping", n12), {}) : isJsonRpcError(s8) && this.events.emit(ci("pairing_ping", n12), { error: s8.error });
          }, 500);
        }), p3(this, "onPairingDeleteRequest", async (i11, s8) => {
          const { id: n12 } = s8;
          try {
            this.isValidDisconnect({ topic: i11 }), await this.deletePairing(i11), this.events.emit(re.delete, { id: n12, topic: i11 });
          } catch (o13) {
            await this.sendError(n12, i11, o13), this.logger.error(o13);
          }
        }), p3(this, "onUnknownRpcMethodRequest", async (i11, s8) => {
          const { id: n12, method: o13 } = s8;
          try {
            if (this.registeredMethods.includes(o13)) return;
            const a5 = Kt2("WC_METHOD_UNSUPPORTED", o13);
            await this.sendError(n12, i11, a5), this.logger.error(a5);
          } catch (a5) {
            await this.sendError(n12, i11, a5), this.logger.error(a5);
          }
        }), p3(this, "onUnknownRpcMethodResponse", (i11) => {
          this.registeredMethods.includes(i11) || this.logger.error(Kt2("WC_METHOD_UNSUPPORTED", i11));
        }), p3(this, "isValidPair", (i11, s8) => {
          var n12;
          if (!Aa(i11)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `pair() params: ${i11}`);
            throw s8.setError(Y2.malformed_pairing_uri), new Error(a5);
          }
          if (!ma(i11.uri)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `pair() uri: ${i11.uri}`);
            throw s8.setError(Y2.malformed_pairing_uri), new Error(a5);
          }
          const o13 = ra(i11?.uri);
          if (!((n12 = o13?.relay) != null && n12.protocol)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", "pair() uri#relay-protocol");
            throw s8.setError(Y2.malformed_pairing_uri), new Error(a5);
          }
          if (!(o13 != null && o13.symKey)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", "pair() uri#symKey");
            throw s8.setError(Y2.malformed_pairing_uri), new Error(a5);
          }
          if (o13 != null && o13.expiryTimestamp && (0, import_time4.toMiliseconds)(o13?.expiryTimestamp) < Date.now()) {
            s8.setError(Y2.pairing_expired);
            const { message: a5 } = Et2("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
            throw new Error(a5);
          }
        }), p3(this, "isValidPing", async (i11) => {
          if (!Aa(i11)) {
            const { message: n12 } = Et2("MISSING_OR_INVALID", `ping() params: ${i11}`);
            throw new Error(n12);
          }
          const { topic: s8 } = i11;
          await this.isValidPairingTopic(s8);
        }), p3(this, "isValidDisconnect", async (i11) => {
          if (!Aa(i11)) {
            const { message: n12 } = Et2("MISSING_OR_INVALID", `disconnect() params: ${i11}`);
            throw new Error(n12);
          }
          const { topic: s8 } = i11;
          await this.isValidPairingTopic(s8);
        }), p3(this, "isValidPairingTopic", async (i11) => {
          if (!it2(i11, false)) {
            const { message: s8 } = Et2("MISSING_OR_INVALID", `pairing topic should be a string: ${i11}`);
            throw new Error(s8);
          }
          if (!this.pairings.keys.includes(i11)) {
            const { message: s8 } = Et2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i11}`);
            throw new Error(s8);
          }
          if (fi(this.pairings.get(i11).expiry)) {
            await this.deletePairing(i11);
            const { message: s8 } = Et2("EXPIRED", `pairing topic: ${i11}`);
            throw new Error(s8);
          }
        }), this.core = e10, this.logger = E2(t5, this.name), this.pairings = new Li2(this.core, this.logger, this.name, this.storagePrefix);
      }
      get context() {
        return y2(this.logger);
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
      registerRelayerEvents() {
        this.core.relayer.on(C3.message, async (e10) => {
          const { topic: t5, message: i11, transportType: s8 } = e10;
          if (this.pairings.keys.includes(t5) && s8 !== Q3.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i11))) try {
            const n12 = await this.core.crypto.decode(t5, i11);
            isJsonRpcRequest(n12) ? (this.core.history.set(t5, n12), await this.onRelayEventRequest({ topic: t5, payload: n12 })) : isJsonRpcResponse(n12) && (await this.core.history.resolve(n12), await this.onRelayEventResponse({ topic: t5, payload: n12 }), this.core.history.delete(t5, n12.id)), await this.core.relayer.messages.ack(t5, i11);
          } catch (n12) {
            this.logger.error(n12);
          }
        });
      }
      registerExpirerEvents() {
        this.core.expirer.on(M3.expired, async (e10) => {
          const { topic: t5 } = si(e10.target);
          t5 && this.pairings.keys.includes(t5) && (await this.deletePairing(t5, true), this.events.emit(re.expire, { topic: t5 }));
        });
      }
    };
    jo3 = Object.defineProperty;
    Uo3 = (r9, e10, t5) => e10 in r9 ? jo3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    O4 = (r9, e10, t5) => Uo3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    ji2 = class extends I2 {
      constructor(e10, t5) {
        super(e10, t5), this.core = e10, this.logger = t5, O4(this, "records", /* @__PURE__ */ new Map()), O4(this, "events", new import_events7.EventEmitter()), O4(this, "name", Bt3), O4(this, "version", Vt3), O4(this, "cached", []), O4(this, "initialized", false), O4(this, "storagePrefix", B2), O4(this, "init", async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i11) => this.records.set(i11.id, i11)), this.cached = [], this.registerEventListeners(), this.initialized = true);
        }), O4(this, "set", (i11, s8, n12) => {
          if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i11, request: s8, chainId: n12 }), this.records.has(s8.id)) return;
          const o13 = { id: s8.id, topic: i11, request: { method: s8.method, params: s8.params || null }, chainId: n12, expiry: ii(import_time4.THIRTY_DAYS) };
          this.records.set(o13.id, o13), this.persist(), this.events.emit(F2.created, o13);
        }), O4(this, "resolve", async (i11) => {
          if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i11 }), !this.records.has(i11.id)) return;
          const s8 = await this.getRecord(i11.id);
          typeof s8.response > "u" && (s8.response = isJsonRpcError(i11) ? { error: i11.error } : { result: i11.result }, this.records.set(s8.id, s8), this.persist(), this.events.emit(F2.updated, s8));
        }), O4(this, "get", async (i11, s8) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i11, id: s8 }), await this.getRecord(s8))), O4(this, "delete", (i11, s8) => {
          this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s8 }), this.values.forEach((n12) => {
            if (n12.topic === i11) {
              if (typeof s8 < "u" && n12.id !== s8) return;
              this.records.delete(n12.id), this.events.emit(F2.deleted, n12);
            }
          }), this.persist();
        }), O4(this, "exists", async (i11, s8) => (this.isInitialized(), this.records.has(s8) ? (await this.getRecord(s8)).topic === i11 : false)), O4(this, "on", (i11, s8) => {
          this.events.on(i11, s8);
        }), O4(this, "once", (i11, s8) => {
          this.events.once(i11, s8);
        }), O4(this, "off", (i11, s8) => {
          this.events.off(i11, s8);
        }), O4(this, "removeListener", (i11, s8) => {
          this.events.removeListener(i11, s8);
        }), this.logger = E2(t5, this.name);
      }
      get context() {
        return y2(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get size() {
        return this.records.size;
      }
      get keys() {
        return Array.from(this.records.keys());
      }
      get values() {
        return Array.from(this.records.values());
      }
      get pending() {
        const e10 = [];
        return this.values.forEach((t5) => {
          if (typeof t5.response < "u") return;
          const i11 = { topic: t5.topic, request: formatJsonRpcRequest(t5.request.method, t5.request.params, t5.id), chainId: t5.chainId };
          return e10.push(i11);
        }), e10;
      }
      async setJsonRpcRecords(e10) {
        await this.core.storage.setItem(this.storageKey, e10);
      }
      async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey);
      }
      getRecord(e10) {
        this.isInitialized();
        const t5 = this.records.get(e10);
        if (!t5) {
          const { message: i11 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e10}`);
          throw new Error(i11);
        }
        return t5;
      }
      async persist() {
        await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
      }
      async restore() {
        try {
          const e10 = await this.getJsonRpcRecords();
          if (typeof e10 > "u" || !e10.length) return;
          if (this.records.size) {
            const { message: t5 } = Et2("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t5), new Error(t5);
          }
          this.cached = e10, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
        } catch (e10) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e10);
        }
      }
      registerEventListeners() {
        this.events.on(F2.created, (e10) => {
          const t5 = F2.created;
          this.logger.info(`Emitting ${t5}`), this.logger.debug({ type: "event", event: t5, record: e10 });
        }), this.events.on(F2.updated, (e10) => {
          const t5 = F2.updated;
          this.logger.info(`Emitting ${t5}`), this.logger.debug({ type: "event", event: t5, record: e10 });
        }), this.events.on(F2.deleted, (e10) => {
          const t5 = F2.deleted;
          this.logger.info(`Emitting ${t5}`), this.logger.debug({ type: "event", event: t5, record: e10 });
        }), this.core.heartbeat.on(r.pulse, () => {
          this.cleanup();
        });
      }
      cleanup() {
        try {
          this.isInitialized();
          let e10 = false;
          this.records.forEach((t5) => {
            (0, import_time4.toMiliseconds)(t5.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t5.id}`), this.records.delete(t5.id), this.events.emit(F2.deleted, t5, false), e10 = true);
          }), e10 && this.persist();
        } catch (e10) {
          this.logger.warn(e10);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
    };
    Fo3 = Object.defineProperty;
    Mo3 = (r9, e10, t5) => e10 in r9 ? Fo3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    A2 = (r9, e10, t5) => Mo3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Ui2 = class extends S2 {
      constructor(e10, t5) {
        super(e10, t5), this.core = e10, this.logger = t5, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events7.EventEmitter()), A2(this, "name", qt3), A2(this, "version", Gt3), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B2), A2(this, "init", async () => {
          this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i11) => this.expirations.set(i11.target, i11)), this.cached = [], this.registerEventListeners(), this.initialized = true);
        }), A2(this, "has", (i11) => {
          try {
            const s8 = this.formatTarget(i11);
            return typeof this.getExpiration(s8) < "u";
          } catch {
            return false;
          }
        }), A2(this, "set", (i11, s8) => {
          this.isInitialized();
          const n12 = this.formatTarget(i11), o13 = { target: n12, expiry: s8 };
          this.expirations.set(n12, o13), this.checkExpiry(n12, o13), this.events.emit(M3.created, { target: n12, expiration: o13 });
        }), A2(this, "get", (i11) => {
          this.isInitialized();
          const s8 = this.formatTarget(i11);
          return this.getExpiration(s8);
        }), A2(this, "del", (i11) => {
          if (this.isInitialized(), this.has(i11)) {
            const s8 = this.formatTarget(i11), n12 = this.getExpiration(s8);
            this.expirations.delete(s8), this.events.emit(M3.deleted, { target: s8, expiration: n12 });
          }
        }), A2(this, "on", (i11, s8) => {
          this.events.on(i11, s8);
        }), A2(this, "once", (i11, s8) => {
          this.events.once(i11, s8);
        }), A2(this, "off", (i11, s8) => {
          this.events.off(i11, s8);
        }), A2(this, "removeListener", (i11, s8) => {
          this.events.removeListener(i11, s8);
        }), this.logger = E2(t5, this.name);
      }
      get context() {
        return y2(this.logger);
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
      }
      get length() {
        return this.expirations.size;
      }
      get keys() {
        return Array.from(this.expirations.keys());
      }
      get values() {
        return Array.from(this.expirations.values());
      }
      formatTarget(e10) {
        if (typeof e10 == "string") return ri(e10);
        if (typeof e10 == "number") return oi(e10);
        const { message: t5 } = Et2("UNKNOWN_TYPE", `Target type: ${typeof e10}`);
        throw new Error(t5);
      }
      async setExpirations(e10) {
        await this.core.storage.setItem(this.storageKey, e10);
      }
      async getExpirations() {
        return await this.core.storage.getItem(this.storageKey);
      }
      async persist() {
        await this.setExpirations(this.values), this.events.emit(M3.sync);
      }
      async restore() {
        try {
          const e10 = await this.getExpirations();
          if (typeof e10 > "u" || !e10.length) return;
          if (this.expirations.size) {
            const { message: t5 } = Et2("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(t5), new Error(t5);
          }
          this.cached = e10, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
        } catch (e10) {
          this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e10);
        }
      }
      getExpiration(e10) {
        const t5 = this.expirations.get(e10);
        if (!t5) {
          const { message: i11 } = Et2("NO_MATCHING_KEY", `${this.name}: ${e10}`);
          throw this.logger.warn(i11), new Error(i11);
        }
        return t5;
      }
      checkExpiry(e10, t5) {
        const { expiry: i11 } = t5;
        (0, import_time4.toMiliseconds)(i11) - Date.now() <= 0 && this.expire(e10, t5);
      }
      expire(e10, t5) {
        this.expirations.delete(e10), this.events.emit(M3.expired, { target: e10, expiration: t5 });
      }
      checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((e10, t5) => this.checkExpiry(t5, e10));
      }
      registerEventListeners() {
        this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M3.created, (e10) => {
          const t5 = M3.created;
          this.logger.info(`Emitting ${t5}`), this.logger.debug({ type: "event", event: t5, data: e10 }), this.persist();
        }), this.events.on(M3.expired, (e10) => {
          const t5 = M3.expired;
          this.logger.info(`Emitting ${t5}`), this.logger.debug({ type: "event", event: t5, data: e10 }), this.persist();
        }), this.events.on(M3.deleted, (e10) => {
          const t5 = M3.deleted;
          this.logger.info(`Emitting ${t5}`), this.logger.debug({ type: "event", event: t5, data: e10 }), this.persist();
        });
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: e10 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(e10);
        }
      }
    };
    Ko3 = Object.defineProperty;
    Bo3 = (r9, e10, t5) => e10 in r9 ? Ko3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    w3 = (r9, e10, t5) => Bo3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Fi2 = class extends M {
      constructor(e10, t5, i11) {
        super(e10, t5, i11), this.core = e10, this.logger = t5, this.store = i11, w3(this, "name", Wt3), w3(this, "abortController"), w3(this, "isDevEnv"), w3(this, "verifyUrlV3", Yt3), w3(this, "storagePrefix", B2), w3(this, "version", Le3), w3(this, "publicKey"), w3(this, "fetchPromise"), w3(this, "init", async () => {
          var s8;
          this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time4.toMiliseconds)((s8 = this.publicKey) == null ? void 0 : s8.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
        }), w3(this, "register", async (s8) => {
          if (!zt2() || this.isDevEnv) return;
          const n12 = window.location.origin, { id: o13, decryptedId: a5 } = s8, c12 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n12}&id=${o13}&decryptedId=${a5}`;
          try {
            const h12 = (0, import_window_getters2.getDocument)(), l10 = this.startAbortTimer(import_time4.ONE_SECOND * 5), d7 = await new Promise((g5, _5) => {
              const u6 = () => {
                window.removeEventListener("message", x7), h12.body.removeChild(b7), _5("attestation aborted");
              };
              this.abortController.signal.addEventListener("abort", u6);
              const b7 = h12.createElement("iframe");
              b7.src = c12, b7.style.display = "none", b7.addEventListener("error", u6, { signal: this.abortController.signal });
              const x7 = (I6) => {
                if (I6.data && typeof I6.data == "string") try {
                  const D4 = JSON.parse(I6.data);
                  if (D4.type === "verify_attestation") {
                    if (sn(D4.attestation).payload.id !== o13) return;
                    clearInterval(l10), h12.body.removeChild(b7), this.abortController.signal.removeEventListener("abort", u6), window.removeEventListener("message", x7), g5(D4.attestation === null ? "" : D4.attestation);
                  }
                } catch (D4) {
                  this.logger.warn(D4);
                }
              };
              h12.body.appendChild(b7), window.addEventListener("message", x7, { signal: this.abortController.signal });
            });
            return this.logger.debug("jwt attestation", d7), d7;
          } catch (h12) {
            this.logger.warn(h12);
          }
          return "";
        }), w3(this, "resolve", async (s8) => {
          if (this.isDevEnv) return "";
          const { attestationId: n12, hash: o13, encryptedId: a5 } = s8;
          if (n12 === "") {
            this.logger.debug("resolve: attestationId is empty, skipping");
            return;
          }
          if (n12) {
            if (sn(n12).payload.id !== a5) return;
            const h12 = await this.isValidJwtAttestation(n12);
            if (h12) {
              if (!h12.isVerified) {
                this.logger.warn("resolve: jwt attestation: origin url not verified");
                return;
              }
              return h12;
            }
          }
          if (!o13) return;
          const c12 = this.getVerifyUrl(s8?.verifyUrl);
          return this.fetchAttestation(o13, c12);
        }), w3(this, "fetchAttestation", async (s8, n12) => {
          this.logger.debug(`resolving attestation: ${s8} from url: ${n12}`);
          const o13 = this.startAbortTimer(import_time4.ONE_SECOND * 5), a5 = await fetch(`${n12}/attestation/${s8}?v2Supported=true`, { signal: this.abortController.signal });
          return clearTimeout(o13), a5.status === 200 ? await a5.json() : void 0;
        }), w3(this, "getVerifyUrl", (s8) => {
          let n12 = s8 || ue2;
          return Jt3.includes(n12) || (this.logger.info(`verify url: ${n12}, not included in trusted list, assigning default: ${ue2}`), n12 = ue2), n12;
        }), w3(this, "fetchPublicKey", async () => {
          try {
            this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
            const s8 = this.startAbortTimer(import_time4.FIVE_SECONDS), n12 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
            return clearTimeout(s8), await n12.json();
          } catch (s8) {
            this.logger.warn(s8);
          }
        }), w3(this, "persistPublicKey", async (s8) => {
          this.logger.debug("persisting public key to local storage", s8), await this.store.setItem(this.storeKey, s8), this.publicKey = s8;
        }), w3(this, "removePublicKey", async () => {
          this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
        }), w3(this, "isValidJwtAttestation", async (s8) => {
          const n12 = await this.getPublicKey();
          try {
            if (n12) return this.validateAttestation(s8, n12);
          } catch (a5) {
            this.logger.error(a5), this.logger.warn("error validating attestation");
          }
          const o13 = await this.fetchAndPersistPublicKey();
          try {
            if (o13) return this.validateAttestation(s8, o13);
          } catch (a5) {
            this.logger.error(a5), this.logger.warn("error validating attestation");
          }
        }), w3(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w3(this, "fetchAndPersistPublicKey", async () => {
          if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
          this.fetchPromise = new Promise(async (n12) => {
            const o13 = await this.fetchPublicKey();
            o13 && (await this.persistPublicKey(o13), n12(o13));
          });
          const s8 = await this.fetchPromise;
          return this.fetchPromise = void 0, s8;
        }), w3(this, "validateAttestation", (s8, n12) => {
          const o13 = ta(s8, n12.publicKey), a5 = { hasExpired: (0, import_time4.toMiliseconds)(o13.exp) < Date.now(), payload: o13 };
          if (a5.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
          return { origin: a5.payload.origin, isScam: a5.payload.isScam, isVerified: a5.payload.isVerified };
        }), this.logger = E2(t5, this.name), this.abortController = new AbortController(), this.isDevEnv = hi(), this.init();
      }
      get storeKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
      }
      get context() {
        return y2(this.logger);
      }
      startAbortTimer(e10) {
        return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time4.toMiliseconds)(e10));
      }
    };
    Vo3 = Object.defineProperty;
    qo3 = (r9, e10, t5) => e10 in r9 ? Vo3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    Mi2 = (r9, e10, t5) => qo3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Ki2 = class extends O3 {
      constructor(e10, t5) {
        super(e10, t5), this.projectId = e10, this.logger = t5, Mi2(this, "context", Xt3), Mi2(this, "registerDeviceToken", async (i11) => {
          const { clientId: s8, token: n12, notificationType: o13, enableEncrypted: a5 = false } = i11, c12 = `${Zt3}/${this.projectId}/clients`;
          await fetch(c12, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s8, type: o13, token: n12, always_raw: a5 }) });
        }), this.logger = E2(t5, this.context);
      }
    };
    Go3 = Object.defineProperty;
    Bi2 = Object.getOwnPropertySymbols;
    Wo3 = Object.prototype.hasOwnProperty;
    Ho3 = Object.prototype.propertyIsEnumerable;
    Ze3 = (r9, e10, t5) => e10 in r9 ? Go3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    be3 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) Wo3.call(e10, t5) && Ze3(r9, t5, e10[t5]);
      if (Bi2) for (var t5 of Bi2(e10)) Ho3.call(e10, t5) && Ze3(r9, t5, e10[t5]);
      return r9;
    };
    E3 = (r9, e10, t5) => Ze3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Vi2 = class extends R {
      constructor(e10, t5, i11 = true) {
        super(e10, t5, i11), this.core = e10, this.logger = t5, E3(this, "context", ei2), E3(this, "storagePrefix", B2), E3(this, "storageVersion", Qt3), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
          if (!hi()) try {
            const s8 = { eventId: di(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cr2(this.core.relayer.protocol, this.core.relayer.version, _e3) } } };
            await this.sendEvent([s8]);
          } catch (s8) {
            this.logger.warn(s8);
          }
        }), E3(this, "createEvent", (s8) => {
          const { event: n12 = "ERROR", type: o13 = "", properties: { topic: a5, trace: c12 } } = s8, h12 = di(), l10 = this.core.projectId || "", d7 = Date.now(), g5 = be3({ eventId: h12, timestamp: d7, props: { event: n12, type: o13, properties: { topic: a5, trace: c12 } }, bundleId: l10, domain: this.getAppDomain() }, this.setMethods(h12));
          return this.telemetryEnabled && (this.events.set(h12, g5), this.shouldPersist = true), g5;
        }), E3(this, "getEvent", (s8) => {
          const { eventId: n12, topic: o13 } = s8;
          if (n12) return this.events.get(n12);
          const a5 = Array.from(this.events.values()).find((c12) => c12.props.properties.topic === o13);
          if (a5) return be3(be3({}, a5), this.setMethods(a5.eventId));
        }), E3(this, "deleteEvent", (s8) => {
          const { eventId: n12 } = s8;
          this.events.delete(n12), this.shouldPersist = true;
        }), E3(this, "setEventListeners", () => {
          this.core.heartbeat.on(r.pulse, async () => {
            this.shouldPersist && await this.persist(), this.events.forEach((s8) => {
              (0, import_time4.fromMiliseconds)(Date.now()) - (0, import_time4.fromMiliseconds)(s8.timestamp) > ti && (this.events.delete(s8.eventId), this.shouldPersist = true);
            });
          });
        }), E3(this, "setMethods", (s8) => ({ addTrace: (n12) => this.addTrace(s8, n12), setError: (n12) => this.setError(s8, n12) })), E3(this, "addTrace", (s8, n12) => {
          const o13 = this.events.get(s8);
          o13 && (o13.props.properties.trace.push(n12), this.events.set(s8, o13), this.shouldPersist = true);
        }), E3(this, "setError", (s8, n12) => {
          const o13 = this.events.get(s8);
          o13 && (o13.props.type = n12, o13.timestamp = Date.now(), this.events.set(s8, o13), this.shouldPersist = true);
        }), E3(this, "persist", async () => {
          await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
        }), E3(this, "restore", async () => {
          try {
            const s8 = await this.core.storage.getItem(this.storageKey) || [];
            if (!s8.length) return;
            s8.forEach((n12) => {
              this.events.set(n12.eventId, be3(be3({}, n12), this.setMethods(n12.eventId)));
            });
          } catch (s8) {
            this.logger.warn(s8);
          }
        }), E3(this, "submit", async () => {
          if (!this.telemetryEnabled || this.events.size === 0) return;
          const s8 = [];
          for (const [n12, o13] of this.events) o13.props.type && s8.push(o13);
          if (s8.length !== 0) try {
            if ((await this.sendEvent(s8)).ok) for (const n12 of s8) this.events.delete(n12.eventId), this.shouldPersist = true;
          } catch (n12) {
            this.logger.warn(n12);
          }
        }), E3(this, "sendEvent", async (s8) => {
          const n12 = this.getAppDomain() ? "" : "&sp=desktop";
          return await fetch(`${ii2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e3}${n12}`, { method: "POST", body: JSON.stringify(s8) });
        }), E3(this, "getAppDomain", () => sr2().url), this.logger = E2(t5, this.context), this.telemetryEnabled = i11, i11 ? this.restore().then(async () => {
          await this.submit(), this.setEventListeners();
        }) : this.persist();
      }
      get storageKey() {
        return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
      }
    };
    Yo3 = Object.defineProperty;
    qi2 = Object.getOwnPropertySymbols;
    Jo3 = Object.prototype.hasOwnProperty;
    Xo2 = Object.prototype.propertyIsEnumerable;
    Qe3 = (r9, e10, t5) => e10 in r9 ? Yo3(r9, e10, { enumerable: true, configurable: true, writable: true, value: t5 }) : r9[e10] = t5;
    Gi2 = (r9, e10) => {
      for (var t5 in e10 || (e10 = {})) Jo3.call(e10, t5) && Qe3(r9, t5, e10[t5]);
      if (qi2) for (var t5 of qi2(e10)) Xo2.call(e10, t5) && Qe3(r9, t5, e10[t5]);
      return r9;
    };
    v4 = (r9, e10, t5) => Qe3(r9, typeof e10 != "symbol" ? e10 + "" : e10, t5);
    Te3 = class _Te extends h4 {
      constructor(e10) {
        var t5;
        super(e10), v4(this, "protocol", ze2), v4(this, "version", Le3), v4(this, "name", he3), v4(this, "relayUrl"), v4(this, "projectId"), v4(this, "customStoragePrefix"), v4(this, "events", new import_events7.EventEmitter()), v4(this, "logger"), v4(this, "heartbeat"), v4(this, "relayer"), v4(this, "crypto"), v4(this, "storage"), v4(this, "history"), v4(this, "expirer"), v4(this, "pairing"), v4(this, "verify"), v4(this, "echoClient"), v4(this, "linkModeSupportedApps"), v4(this, "eventClient"), v4(this, "initialized", false), v4(this, "logChunkController"), v4(this, "on", (a5, c12) => this.events.on(a5, c12)), v4(this, "once", (a5, c12) => this.events.once(a5, c12)), v4(this, "off", (a5, c12) => this.events.off(a5, c12)), v4(this, "removeListener", (a5, c12) => this.events.removeListener(a5, c12)), v4(this, "dispatchEnvelope", ({ topic: a5, message: c12, sessionExists: h12 }) => {
          if (!a5 || !c12) return;
          const l10 = { topic: a5, message: c12, publishedAt: Date.now(), transportType: Q3.link_mode };
          this.relayer.onLinkMessageEvent(l10, { sessionExists: h12 });
        });
        const i11 = this.getGlobalCore(e10?.customStoragePrefix);
        if (i11) try {
          return this.customStoragePrefix = i11.customStoragePrefix, this.logger = i11.logger, this.heartbeat = i11.heartbeat, this.crypto = i11.crypto, this.history = i11.history, this.expirer = i11.expirer, this.storage = i11.storage, this.relayer = i11.relayer, this.pairing = i11.pairing, this.verify = i11.verify, this.echoClient = i11.echoClient, this.linkModeSupportedApps = i11.linkModeSupportedApps, this.eventClient = i11.eventClient, this.initialized = i11.initialized, this.logChunkController = i11.logChunkController, i11;
        } catch (a5) {
          console.warn("Failed to copy global core", a5);
        }
        this.projectId = e10?.projectId, this.relayUrl = e10?.relayUrl || Ue3, this.customStoragePrefix = e10 != null && e10.customStoragePrefix ? `:${e10.customStoragePrefix}` : "";
        const s8 = k2({ level: typeof e10?.logger == "string" && e10.logger ? e10.logger : Et3.logger, name: he3 }), { logger: n12, chunkLoggerController: o13 } = A({ opts: s8, maxSizeInBytes: e10?.maxLogBlobSizeInBytes, loggerOverride: e10?.logger });
        this.logChunkController = o13, (t5 = this.logChunkController) != null && t5.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
          var a5, c12;
          (a5 = this.logChunkController) != null && a5.downloadLogsBlobInBrowser && ((c12 = this.logChunkController) == null || c12.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
        }), this.logger = E2(n12, this.name), this.heartbeat = new i(), this.crypto = new wi2(this, this.logger, e10?.keychain), this.history = new ji2(this, this.logger), this.expirer = new Ui2(this, this.logger), this.storage = e10 != null && e10.storage ? e10.storage : new h2(Gi2(Gi2({}, It3), e10?.storageOptions)), this.relayer = new Oi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ki2(this, this.logger), this.verify = new Fi2(this, this.logger, this.storage), this.echoClient = new Ki2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Vi2(this, this.logger, e10?.telemetryEnabled), this.setGlobalCore(this);
      }
      static async init(e10) {
        const t5 = new _Te(e10);
        await t5.initialize();
        const i11 = await t5.crypto.getClientId();
        return await t5.storage.setItem(jt3, i11), t5;
      }
      get context() {
        return y2(this.logger);
      }
      async start() {
        this.initialized || await this.initialize();
      }
      async getLogsBlob() {
        var e10;
        return (e10 = this.logChunkController) == null ? void 0 : e10.logsToBlob({ clientId: await this.crypto.getClientId() });
      }
      async addLinkModeSupportedApp(e10) {
        this.linkModeSupportedApps.includes(e10) || (this.linkModeSupportedApps.push(e10), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
        } catch (e10) {
          throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e10), this.logger.error(e10.message), e10;
        }
      }
      getGlobalCore(e10 = "") {
        try {
          if (this.isGlobalCoreDisabled()) return;
          const t5 = `_walletConnectCore_${e10}`, i11 = `${t5}_count`;
          return globalThis[i11] = (globalThis[i11] || 0) + 1, globalThis[i11] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i11]} times.`), globalThis[t5];
        } catch (t5) {
          console.warn("Failed to get global WalletConnect core", t5);
          return;
        }
      }
      setGlobalCore(e10) {
        var t5;
        try {
          if (this.isGlobalCoreDisabled()) return;
          const i11 = `_walletConnectCore_${((t5 = e10.opts) == null ? void 0 : t5.customStoragePrefix) || ""}`;
          globalThis[i11] = e10;
        } catch (i11) {
          console.warn("Failed to set global WalletConnect core", i11);
        }
      }
      isGlobalCoreDisabled() {
        try {
          return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
        } catch {
          return true;
        }
      }
    };
    Zo3 = Te3;
  }
});

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8, import_time5, Ce4, ke4, De3, me3, we3, Le4, ht3, Me4, dt3, X2, ut3, N11, _e4, $2, gt3, yt2, mt2, wt3, _t3, Et4, ft2, St4, ae2, ce2, Os, bs2, As, Rt4, xs2, Vs2, $e3, I3, x4, c5, Cs2, ks2, vt3, Ds, Ls2, Ms2, $s2, Ks2, Us, Ke4, Gs2, js2, Fs, f6, Ee3;
var init_index_es12 = __esm({
  "node_modules/@walletconnect/sign-client/dist/index.es.js"() {
    init_index_es11();
    init_index_es3();
    init_index_es4();
    init_index_es7();
    import_events8 = __toESM(require_events());
    import_time5 = __toESM(require_cjs());
    init_esm7();
    Ce4 = "wc";
    ke4 = 2;
    De3 = "client";
    me3 = `${Ce4}@${ke4}:${De3}:`;
    we3 = { name: De3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
    Le4 = "WALLETCONNECT_DEEPLINK_CHOICE";
    ht3 = "proposal";
    Me4 = "Proposal expired";
    dt3 = "session";
    X2 = import_time5.SEVEN_DAYS;
    ut3 = "engine";
    N11 = { wc_sessionPropose: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time5.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time5.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1119 } } };
    _e4 = { min: import_time5.FIVE_MINUTES, max: import_time5.SEVEN_DAYS };
    $2 = { idle: "IDLE", active: "ACTIVE" };
    gt3 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
    yt2 = "request";
    mt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
    wt3 = "wc";
    _t3 = "auth";
    Et4 = "authKeys";
    ft2 = "pairingTopics";
    St4 = "requests";
    ae2 = `${wt3}@${1.5}:${_t3}:`;
    ce2 = `${ae2}:PUB_KEY`;
    Os = Object.defineProperty;
    bs2 = Object.defineProperties;
    As = Object.getOwnPropertyDescriptors;
    Rt4 = Object.getOwnPropertySymbols;
    xs2 = Object.prototype.hasOwnProperty;
    Vs2 = Object.prototype.propertyIsEnumerable;
    $e3 = (S7, o13, t5) => o13 in S7 ? Os(S7, o13, { enumerable: true, configurable: true, writable: true, value: t5 }) : S7[o13] = t5;
    I3 = (S7, o13) => {
      for (var t5 in o13 || (o13 = {})) xs2.call(o13, t5) && $e3(S7, t5, o13[t5]);
      if (Rt4) for (var t5 of Rt4(o13)) Vs2.call(o13, t5) && $e3(S7, t5, o13[t5]);
      return S7;
    };
    x4 = (S7, o13) => bs2(S7, As(o13));
    c5 = (S7, o13, t5) => $e3(S7, typeof o13 != "symbol" ? o13 + "" : o13, t5);
    Cs2 = class extends V {
      constructor(o13) {
        super(o13), c5(this, "name", ut3), c5(this, "events", new import_events8.default()), c5(this, "initialized", false), c5(this, "requestQueue", { state: $2.idle, queue: [] }), c5(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c5(this, "emittedSessionRequests", new gi({ limit: 500 })), c5(this, "requestQueueDelay", import_time5.ONE_SECOND), c5(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedLimit", 200), c5(this, "relayMessageCache", []), c5(this, "pendingSessions", /* @__PURE__ */ new Map()), c5(this, "init", async () => {
          this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N11) }), this.initialized = true, setTimeout(async () => {
            await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
          }, (0, import_time5.toMiliseconds)(this.requestQueueDelay)));
        }), c5(this, "connect", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
          const e10 = x4(I3({}, t5), { requiredNamespaces: t5.requiredNamespaces || {}, optionalNamespaces: t5.optionalNamespaces || {} });
          await this.isValidConnect(e10), e10.optionalNamespaces = ba(e10.requiredNamespaces, e10.optionalNamespaces), e10.requiredNamespaces = {};
          const { pairingTopic: s8, requiredNamespaces: i11, optionalNamespaces: r9, sessionProperties: n12, scopedProperties: a5, relays: l10 } = e10;
          let p8 = s8, h12, u6 = false;
          try {
            if (p8) {
              const T6 = this.client.core.pairing.pairings.get(p8);
              this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u6 = T6.active;
            }
          } catch (T6) {
            throw this.client.logger.error(`connect() -> pairing.get(${p8}) failed`), T6;
          }
          if (!p8 || !u6) {
            const { topic: T6, uri: K5 } = await this.client.core.pairing.create();
            p8 = T6, h12 = K5;
          }
          if (!p8) {
            const { message: T6 } = Et2("NO_MATCHING_KEY", `connect() pairing topic: ${p8}`);
            throw new Error(T6);
          }
          const d7 = await this.client.core.crypto.generateKeyPair(), w6 = N11.wc_sessionPropose.req.ttl || import_time5.FIVE_MINUTES, m6 = ii(w6), y9 = x4(I3(I3({ requiredNamespaces: i11, optionalNamespaces: r9, relays: l10 ?? [{ protocol: xt3 }], proposer: { publicKey: d7, metadata: this.client.metadata }, expiryTimestamp: m6, pairingTopic: p8 }, n12 && { sessionProperties: n12 }), a5 && { scopedProperties: a5 }), { id: payloadId() }), E8 = ci("session_connect", y9.id), { reject: _5, resolve: V6, done: C7 } = ei(w6, Me4), v8 = ({ id: T6 }) => {
            T6 === y9.id && (this.client.events.off("proposal_expire", v8), this.pendingSessions.delete(y9.id), this.events.emit(E8, { error: { message: Me4, code: 0 } }));
          };
          return this.client.events.on("proposal_expire", v8), this.events.once(E8, ({ error: T6, session: K5 }) => {
            this.client.events.off("proposal_expire", v8), T6 ? _5(T6) : K5 && V6(K5);
          }), await this.sendRequest({ topic: p8, method: "wc_sessionPropose", params: y9, throwOnFailedPublish: true, clientRpcId: y9.id }), await this.setProposal(y9.id, y9), { uri: h12, approval: C7 };
        }), c5(this, "pair", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
          try {
            return await this.client.core.pairing.pair(t5);
          } catch (e10) {
            throw this.client.logger.error("pair() failed"), e10;
          }
        }), c5(this, "approve", async (t5) => {
          var e10, s8, i11;
          const r9 = this.client.core.eventClient.createEvent({ properties: { topic: (e10 = t5?.id) == null ? void 0 : e10.toString(), trace: [tr3.session_approve_started] } });
          try {
            this.isInitialized(), await this.confirmOnlineStateOrThrow();
          } catch (q3) {
            throw r9.setError(ir3.no_internet_connection), q3;
          }
          try {
            await this.isValidProposalId(t5?.id);
          } catch (q3) {
            throw this.client.logger.error(`approve() -> proposal.get(${t5?.id}) failed`), r9.setError(ir3.proposal_not_found), q3;
          }
          try {
            await this.isValidApprove(t5);
          } catch (q3) {
            throw this.client.logger.error("approve() -> isValidApprove() failed"), r9.setError(ir3.session_approve_namespace_validation_failure), q3;
          }
          const { id: n12, relayProtocol: a5, namespaces: l10, sessionProperties: p8, scopedProperties: h12, sessionConfig: u6 } = t5, d7 = this.client.proposal.get(n12);
          this.client.core.eventClient.deleteEvent({ eventId: r9.eventId });
          const { pairingTopic: w6, proposer: m6, requiredNamespaces: y9, optionalNamespaces: E8 } = d7;
          let _5 = (s8 = this.client.core.eventClient) == null ? void 0 : s8.getEvent({ topic: w6 });
          _5 || (_5 = (i11 = this.client.core.eventClient) == null ? void 0 : i11.createEvent({ type: tr3.session_approve_started, properties: { topic: w6, trace: [tr3.session_approve_started, tr3.session_namespaces_validation_success] } }));
          const V6 = await this.client.core.crypto.generateKeyPair(), C7 = m6.publicKey, v8 = await this.client.core.crypto.generateSharedKey(V6, C7), T6 = I3(I3(I3({ relay: { protocol: a5 ?? "irn" }, namespaces: l10, controller: { publicKey: V6, metadata: this.client.metadata }, expiry: ii(X2) }, p8 && { sessionProperties: p8 }), h12 && { scopedProperties: h12 }), u6 && { sessionConfig: u6 }), K5 = Q3.relay;
          _5.addTrace(tr3.subscribing_session_topic);
          try {
            await this.client.core.relayer.subscribe(v8, { transportType: K5 });
          } catch (q3) {
            throw _5.setError(ir3.subscribe_session_topic_failure), q3;
          }
          _5.addTrace(tr3.subscribe_session_topic_success);
          const fe6 = x4(I3({}, T6), { topic: v8, requiredNamespaces: y9, optionalNamespaces: E8, pairingTopic: w6, acknowledged: false, self: T6.controller, peer: { publicKey: m6.publicKey, metadata: m6.metadata }, controller: V6, transportType: Q3.relay });
          await this.client.session.set(v8, fe6), _5.addTrace(tr3.store_session);
          try {
            _5.addTrace(tr3.publishing_session_settle), await this.sendRequest({ topic: v8, method: "wc_sessionSettle", params: T6, throwOnFailedPublish: true }).catch((q3) => {
              throw _5?.setError(ir3.session_settle_publish_failure), q3;
            }), _5.addTrace(tr3.session_settle_publish_success), _5.addTrace(tr3.publishing_session_approve), await this.sendResult({ id: n12, topic: w6, result: { relay: { protocol: a5 ?? "irn" }, responderPublicKey: V6 }, throwOnFailedPublish: true }).catch((q3) => {
              throw _5?.setError(ir3.session_approve_publish_failure), q3;
            }), _5.addTrace(tr3.session_approve_publish_success);
          } catch (q3) {
            throw this.client.logger.error(q3), this.client.session.delete(v8, Kt2("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(v8), q3;
          }
          return this.client.core.eventClient.deleteEvent({ eventId: _5.eventId }), await this.client.core.pairing.updateMetadata({ topic: w6, metadata: m6.metadata }), await this.deleteProposal(n12), await this.client.core.pairing.activate({ topic: w6 }), await this.setExpiry(v8, ii(X2)), { topic: v8, acknowledged: () => Promise.resolve(this.client.session.get(v8)) };
        }), c5(this, "reject", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
          try {
            await this.isValidReject(t5);
          } catch (r9) {
            throw this.client.logger.error("reject() -> isValidReject() failed"), r9;
          }
          const { id: e10, reason: s8 } = t5;
          let i11;
          try {
            i11 = this.client.proposal.get(e10).pairingTopic;
          } catch (r9) {
            throw this.client.logger.error(`reject() -> proposal.get(${e10}) failed`), r9;
          }
          i11 && await this.sendError({ id: e10, topic: i11, error: s8, rpcOpts: N11.wc_sessionPropose.reject }), await this.deleteProposal(e10);
        }), c5(this, "update", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
          try {
            await this.isValidUpdate(t5);
          } catch (h12) {
            throw this.client.logger.error("update() -> isValidUpdate() failed"), h12;
          }
          const { topic: e10, namespaces: s8 } = t5, { done: i11, resolve: r9, reject: n12 } = ei(), a5 = payloadId(), l10 = getBigIntRpcId().toString(), p8 = this.client.session.get(e10).namespaces;
          return this.events.once(ci("session_update", a5), ({ error: h12 }) => {
            h12 ? n12(h12) : r9();
          }), await this.client.session.update(e10, { namespaces: s8 }), await this.sendRequest({ topic: e10, method: "wc_sessionUpdate", params: { namespaces: s8 }, throwOnFailedPublish: true, clientRpcId: a5, relayRpcId: l10 }).catch((h12) => {
            this.client.logger.error(h12), this.client.session.update(e10, { namespaces: p8 }), n12(h12);
          }), { acknowledged: i11 };
        }), c5(this, "extend", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
          try {
            await this.isValidExtend(t5);
          } catch (a5) {
            throw this.client.logger.error("extend() -> isValidExtend() failed"), a5;
          }
          const { topic: e10 } = t5, s8 = payloadId(), { done: i11, resolve: r9, reject: n12 } = ei();
          return this.events.once(ci("session_extend", s8), ({ error: a5 }) => {
            a5 ? n12(a5) : r9();
          }), await this.setExpiry(e10, ii(X2)), this.sendRequest({ topic: e10, method: "wc_sessionExtend", params: {}, clientRpcId: s8, throwOnFailedPublish: true }).catch((a5) => {
            n12(a5);
          }), { acknowledged: i11 };
        }), c5(this, "request", async (t5) => {
          this.isInitialized();
          try {
            await this.isValidRequest(t5);
          } catch (y9) {
            throw this.client.logger.error("request() -> isValidRequest() failed"), y9;
          }
          const { chainId: e10, request: s8, topic: i11, expiry: r9 = N11.wc_sessionRequest.req.ttl } = t5, n12 = this.client.session.get(i11);
          n12?.transportType === Q3.relay && await this.confirmOnlineStateOrThrow();
          const a5 = payloadId(), l10 = getBigIntRpcId().toString(), { done: p8, resolve: h12, reject: u6 } = ei(r9, "Request expired. Please try again.");
          this.events.once(ci("session_request", a5), ({ error: y9, result: E8 }) => {
            y9 ? u6(y9) : h12(E8);
          });
          const d7 = "wc_sessionRequest", w6 = this.getAppLinkIfEnabled(n12.peer.metadata, n12.transportType);
          if (w6) return await this.sendRequest({ clientRpcId: a5, relayRpcId: l10, topic: i11, method: d7, params: { request: x4(I3({}, s8), { expiryTimestamp: ii(r9) }), chainId: e10 }, expiry: r9, throwOnFailedPublish: true, appLink: w6 }).catch((y9) => u6(y9)), this.client.events.emit("session_request_sent", { topic: i11, request: s8, chainId: e10, id: a5 }), await p8();
          const m6 = { request: x4(I3({}, s8), { expiryTimestamp: ii(r9) }), chainId: e10 };
          return await Promise.all([new Promise(async (y9) => {
            await this.sendRequest({ clientRpcId: a5, relayRpcId: l10, topic: i11, method: d7, params: m6, expiry: r9, throwOnFailedPublish: true, tvf: this.getTVFParams(a5, m6) }).catch((E8) => u6(E8)), this.client.events.emit("session_request_sent", { topic: i11, request: s8, chainId: e10, id: a5 }), y9();
          }), new Promise(async (y9) => {
            var E8;
            if (!((E8 = n12.sessionConfig) != null && E8.disableDeepLink)) {
              const _5 = await ui(this.client.core.storage, Le4);
              await ai({ id: a5, topic: i11, wcDeepLink: _5 });
            }
            y9();
          }), p8()]).then((y9) => y9[2]);
        }), c5(this, "respond", async (t5) => {
          this.isInitialized(), await this.isValidRespond(t5);
          const { topic: e10, response: s8 } = t5, { id: i11 } = s8, r9 = this.client.session.get(e10);
          r9.transportType === Q3.relay && await this.confirmOnlineStateOrThrow();
          const n12 = this.getAppLinkIfEnabled(r9.peer.metadata, r9.transportType);
          isJsonRpcResult(s8) ? await this.sendResult({ id: i11, topic: e10, result: s8.result, throwOnFailedPublish: true, appLink: n12 }) : isJsonRpcError(s8) && await this.sendError({ id: i11, topic: e10, error: s8.error, appLink: n12 }), this.cleanupAfterResponse(t5);
        }), c5(this, "ping", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
          try {
            await this.isValidPing(t5);
          } catch (s8) {
            throw this.client.logger.error("ping() -> isValidPing() failed"), s8;
          }
          const { topic: e10 } = t5;
          if (this.client.session.keys.includes(e10)) {
            const s8 = payloadId(), i11 = getBigIntRpcId().toString(), { done: r9, resolve: n12, reject: a5 } = ei();
            this.events.once(ci("session_ping", s8), ({ error: l10 }) => {
              l10 ? a5(l10) : n12();
            }), await Promise.all([this.sendRequest({ topic: e10, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s8, relayRpcId: i11 }), r9()]);
          } else this.client.core.pairing.pairings.keys.includes(e10) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e10 }));
        }), c5(this, "emit", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t5);
          const { topic: e10, event: s8, chainId: i11 } = t5, r9 = getBigIntRpcId().toString(), n12 = payloadId();
          await this.sendRequest({ topic: e10, method: "wc_sessionEvent", params: { event: s8, chainId: i11 }, throwOnFailedPublish: true, relayRpcId: r9, clientRpcId: n12 });
        }), c5(this, "disconnect", async (t5) => {
          this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t5);
          const { topic: e10 } = t5;
          if (this.client.session.keys.includes(e10)) await this.sendRequest({ topic: e10, method: "wc_sessionDelete", params: Kt2("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e10, emitEvent: false });
          else if (this.client.core.pairing.pairings.keys.includes(e10)) await this.client.core.pairing.disconnect({ topic: e10 });
          else {
            const { message: s8 } = Et2("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e10}`);
            throw new Error(s8);
          }
        }), c5(this, "find", (t5) => (this.isInitialized(), this.client.session.getAll().filter((e10) => ya(e10, t5)))), c5(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c5(this, "authenticate", async (t5, e10) => {
          var s8;
          this.isInitialized(), this.isValidAuthenticate(t5);
          const i11 = e10 && this.client.core.linkModeSupportedApps.includes(e10) && ((s8 = this.client.metadata.redirect) == null ? void 0 : s8.linkMode), r9 = i11 ? Q3.link_mode : Q3.relay;
          r9 === Q3.relay && await this.confirmOnlineStateOrThrow();
          const { chains: n12, statement: a5 = "", uri: l10, domain: p8, nonce: h12, type: u6, exp: d7, nbf: w6, methods: m6 = [], expiry: y9 } = t5, E8 = [...t5.resources || []], { topic: _5, uri: V6 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r9 });
          this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _5, uri: V6 } });
          const C7 = await this.client.core.crypto.generateKeyPair(), v8 = Fc(C7);
          if (await Promise.all([this.client.auth.authKeys.set(ce2, { responseTopic: v8, publicKey: C7 }), this.client.auth.pairingTopics.set(v8, { topic: v8, pairingTopic: _5 })]), await this.client.core.relayer.subscribe(v8, { transportType: r9 }), this.client.logger.info(`sending request to new pairing topic: ${_5}`), m6.length > 0) {
            const { namespace: O8 } = Fe(n12[0]);
            let k7 = Ef(O8, "request", m6);
            Oe2(E8) && (k7 = Bf(k7, E8.pop())), E8.push(k7);
          }
          const T6 = y9 && y9 > N11.wc_sessionAuthenticate.req.ttl ? y9 : N11.wc_sessionAuthenticate.req.ttl, K5 = { authPayload: { type: u6 ?? "caip122", chains: n12, statement: a5, aud: l10, domain: p8, version: "1", nonce: h12, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d7, nbf: w6, resources: E8 }, requester: { publicKey: C7, metadata: this.client.metadata }, expiryTimestamp: ii(T6) }, fe6 = { eip155: { chains: n12, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m6])], events: ["chainChanged", "accountsChanged"] } }, q3 = { requiredNamespaces: {}, optionalNamespaces: fe6, relays: [{ protocol: "irn" }], pairingTopic: _5, proposer: { publicKey: C7, metadata: this.client.metadata }, expiryTimestamp: ii(N11.wc_sessionPropose.req.ttl), id: payloadId() }, { done: It5, resolve: Ue6, reject: Se6 } = ei(T6, "Request expired"), te5 = payloadId(), le5 = ci("session_connect", q3.id), Re5 = ci("session_request", te5), pe5 = async ({ error: O8, session: k7 }) => {
            this.events.off(Re5, ve4), O8 ? Se6(O8) : k7 && Ue6({ session: k7 });
          }, ve4 = async (O8) => {
            var k7, Ge4, je5;
            if (await this.deletePendingAuthRequest(te5, { message: "fulfilled", code: 0 }), O8.error) {
              const ie5 = Kt2("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
              return O8.error.code === ie5.code ? void 0 : (this.events.off(le5, pe5), Se6(O8.error.message));
            }
            await this.deleteProposal(q3.id), this.events.off(le5, pe5);
            const { cacaos: Fe5, responder: Q6 } = O8.result, Te5 = [], Qe6 = [];
            for (const ie5 of Fe5) {
              await yf({ cacao: ie5, projectId: this.client.core.projectId }) || (this.client.logger.error(ie5, "Signature verification failed"), Se6(Kt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
              const { p: qe5 } = ie5, Pe5 = Oe2(qe5.resources), He5 = [Vr2(qe5.iss)], Tt5 = dn(qe5.iss);
              if (Pe5) {
                const Ne5 = If(Pe5), qt5 = Af(Pe5);
                Te5.push(...Ne5), He5.push(...qt5);
              }
              for (const Ne5 of He5) Qe6.push(`${Ne5}:${Tt5}`);
            }
            const se5 = await this.client.core.crypto.generateSharedKey(C7, Q6.publicKey);
            let he5;
            Te5.length > 0 && (he5 = { topic: se5, acknowledged: true, self: { publicKey: C7, metadata: this.client.metadata }, peer: Q6, controller: Q6.publicKey, expiry: ii(X2), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _5, namespaces: ga([...new Set(Te5)], [...new Set(Qe6)]), transportType: r9 }, await this.client.core.relayer.subscribe(se5, { transportType: r9 }), await this.client.session.set(se5, he5), _5 && await this.client.core.pairing.updateMetadata({ topic: _5, metadata: Q6.metadata }), he5 = this.client.session.get(se5)), (k7 = this.client.metadata.redirect) != null && k7.linkMode && (Ge4 = Q6.metadata.redirect) != null && Ge4.linkMode && (je5 = Q6.metadata.redirect) != null && je5.universal && e10 && (this.client.core.addLinkModeSupportedApp(Q6.metadata.redirect.universal), this.client.session.update(se5, { transportType: Q3.link_mode })), Ue6({ auths: Fe5, session: he5 });
          };
          this.events.once(le5, pe5), this.events.once(Re5, ve4);
          let Ie6;
          try {
            if (i11) {
              const O8 = formatJsonRpcRequest("wc_sessionAuthenticate", K5, te5);
              this.client.core.history.set(_5, O8);
              const k7 = await this.client.core.crypto.encode("", O8, { type: ge2, encoding: De2 });
              Ie6 = sa(e10, _5, k7);
            } else await Promise.all([this.sendRequest({ topic: _5, method: "wc_sessionAuthenticate", params: K5, expiry: t5.expiry, throwOnFailedPublish: true, clientRpcId: te5 }), this.sendRequest({ topic: _5, method: "wc_sessionPropose", params: q3, expiry: N11.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q3.id })]);
          } catch (O8) {
            throw this.events.off(le5, pe5), this.events.off(Re5, ve4), O8;
          }
          return await this.setProposal(q3.id, q3), await this.setAuthRequest(te5, { request: x4(I3({}, K5), { verifyContext: {} }), pairingTopic: _5, transportType: r9 }), { uri: Ie6 ?? V6, response: It5 };
        }), c5(this, "approveSessionAuthenticate", async (t5) => {
          const { id: e10, auths: s8 } = t5, i11 = this.client.core.eventClient.createEvent({ properties: { topic: e10.toString(), trace: [sr3.authenticated_session_approve_started] } });
          try {
            this.isInitialized();
          } catch (y9) {
            throw i11.setError(rr3.no_internet_connection), y9;
          }
          const r9 = this.getPendingAuthRequest(e10);
          if (!r9) throw i11.setError(rr3.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e10}`);
          const n12 = r9.transportType || Q3.relay;
          n12 === Q3.relay && await this.confirmOnlineStateOrThrow();
          const a5 = r9.requester.publicKey, l10 = await this.client.core.crypto.generateKeyPair(), p8 = Fc(a5), h12 = { type: ee, receiverPublicKey: a5, senderPublicKey: l10 }, u6 = [], d7 = [];
          for (const y9 of s8) {
            if (!await yf({ cacao: y9, projectId: this.client.core.projectId })) {
              i11.setError(rr3.invalid_cacao);
              const v8 = Kt2("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
              throw await this.sendError({ id: e10, topic: p8, error: v8, encodeOpts: h12 }), new Error(v8.message);
            }
            i11.addTrace(sr3.cacaos_verified);
            const { p: E8 } = y9, _5 = Oe2(E8.resources), V6 = [Vr2(E8.iss)], C7 = dn(E8.iss);
            if (_5) {
              const v8 = If(_5), T6 = Af(_5);
              u6.push(...v8), V6.push(...T6);
            }
            for (const v8 of V6) d7.push(`${v8}:${C7}`);
          }
          const w6 = await this.client.core.crypto.generateSharedKey(l10, a5);
          i11.addTrace(sr3.create_authenticated_session_topic);
          let m6;
          if (u6?.length > 0) {
            m6 = { topic: w6, acknowledged: true, self: { publicKey: l10, metadata: this.client.metadata }, peer: { publicKey: a5, metadata: r9.requester.metadata }, controller: a5, expiry: ii(X2), authentication: s8, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r9.pairingTopic, namespaces: ga([...new Set(u6)], [...new Set(d7)]), transportType: n12 }, i11.addTrace(sr3.subscribing_authenticated_session_topic);
            try {
              await this.client.core.relayer.subscribe(w6, { transportType: n12 });
            } catch (y9) {
              throw i11.setError(rr3.subscribe_authenticated_session_topic_failure), y9;
            }
            i11.addTrace(sr3.subscribe_authenticated_session_topic_success), await this.client.session.set(w6, m6), i11.addTrace(sr3.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r9.pairingTopic, metadata: r9.requester.metadata });
          }
          i11.addTrace(sr3.publishing_authenticated_session_approve);
          try {
            await this.sendResult({ topic: p8, id: e10, result: { cacaos: s8, responder: { publicKey: l10, metadata: this.client.metadata } }, encodeOpts: h12, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r9.requester.metadata, n12) });
          } catch (y9) {
            throw i11.setError(rr3.authenticated_session_approve_publish_failure), y9;
          }
          return await this.client.auth.requests.delete(e10, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r9.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i11.eventId }), { session: m6 };
        }), c5(this, "rejectSessionAuthenticate", async (t5) => {
          this.isInitialized();
          const { id: e10, reason: s8 } = t5, i11 = this.getPendingAuthRequest(e10);
          if (!i11) throw new Error(`Could not find pending auth request with id ${e10}`);
          i11.transportType === Q3.relay && await this.confirmOnlineStateOrThrow();
          const r9 = i11.requester.publicKey, n12 = await this.client.core.crypto.generateKeyPair(), a5 = Fc(r9), l10 = { type: ee, receiverPublicKey: r9, senderPublicKey: n12 };
          await this.sendError({ id: e10, topic: a5, error: s8, encodeOpts: l10, rpcOpts: N11.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i11.requester.metadata, i11.transportType) }), await this.client.auth.requests.delete(e10, { message: "rejected", code: 0 }), await this.deleteProposal(e10);
        }), c5(this, "formatAuthMessage", (t5) => {
          this.isInitialized();
          const { request: e10, iss: s8 } = t5;
          return qr2(e10, s8);
        }), c5(this, "processRelayMessageCache", () => {
          setTimeout(async () => {
            if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
              const t5 = this.relayMessageCache.shift();
              t5 && await this.onRelayMessage(t5);
            } catch (t5) {
              this.client.logger.error(t5);
            }
          }, 50);
        }), c5(this, "cleanupDuplicatePairings", async (t5) => {
          if (t5.pairingTopic) try {
            const e10 = this.client.core.pairing.pairings.get(t5.pairingTopic), s8 = this.client.core.pairing.pairings.getAll().filter((i11) => {
              var r9, n12;
              return ((r9 = i11.peerMetadata) == null ? void 0 : r9.url) && ((n12 = i11.peerMetadata) == null ? void 0 : n12.url) === t5.peer.metadata.url && i11.topic && i11.topic !== e10.topic;
            });
            if (s8.length === 0) return;
            this.client.logger.info(`Cleaning up ${s8.length} duplicate pairing(s)`), await Promise.all(s8.map((i11) => this.client.core.pairing.disconnect({ topic: i11.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
          } catch (e10) {
            this.client.logger.error(e10);
          }
        }), c5(this, "deleteSession", async (t5) => {
          var e10;
          const { topic: s8, expirerHasDeleted: i11 = false, emitEvent: r9 = true, id: n12 = 0 } = t5, { self: a5 } = this.client.session.get(s8);
          await this.client.core.relayer.unsubscribe(s8), await this.client.session.delete(s8, Kt2("USER_DISCONNECTED")), this.addToRecentlyDeleted(s8, "session"), this.client.core.crypto.keychain.has(a5.publicKey) && await this.client.core.crypto.deleteKeyPair(a5.publicKey), this.client.core.crypto.keychain.has(s8) && await this.client.core.crypto.deleteSymKey(s8), i11 || this.client.core.expirer.del(s8), this.client.core.storage.removeItem(Le4).catch((l10) => this.client.logger.warn(l10)), this.getPendingSessionRequests().forEach((l10) => {
            l10.topic === s8 && this.deletePendingSessionRequest(l10.id, Kt2("USER_DISCONNECTED"));
          }), s8 === ((e10 = this.sessionRequestQueue.queue[0]) == null ? void 0 : e10.topic) && (this.sessionRequestQueue.state = $2.idle), r9 && this.client.events.emit("session_delete", { id: n12, topic: s8 });
        }), c5(this, "deleteProposal", async (t5, e10) => {
          if (e10) try {
            const s8 = this.client.proposal.get(t5), i11 = this.client.core.eventClient.getEvent({ topic: s8.pairingTopic });
            i11?.setError(ir3.proposal_expired);
          } catch {
          }
          await Promise.all([this.client.proposal.delete(t5, Kt2("USER_DISCONNECTED")), e10 ? Promise.resolve() : this.client.core.expirer.del(t5)]), this.addToRecentlyDeleted(t5, "proposal");
        }), c5(this, "deletePendingSessionRequest", async (t5, e10, s8 = false) => {
          await Promise.all([this.client.pendingRequest.delete(t5, e10), s8 ? Promise.resolve() : this.client.core.expirer.del(t5)]), this.addToRecentlyDeleted(t5, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i11) => i11.id !== t5), s8 && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: t5 }));
        }), c5(this, "deletePendingAuthRequest", async (t5, e10, s8 = false) => {
          await Promise.all([this.client.auth.requests.delete(t5, e10), s8 ? Promise.resolve() : this.client.core.expirer.del(t5)]);
        }), c5(this, "setExpiry", async (t5, e10) => {
          this.client.session.keys.includes(t5) && (this.client.core.expirer.set(t5, e10), await this.client.session.update(t5, { expiry: e10 }));
        }), c5(this, "setProposal", async (t5, e10) => {
          this.client.core.expirer.set(t5, ii(N11.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t5, e10);
        }), c5(this, "setAuthRequest", async (t5, e10) => {
          const { request: s8, pairingTopic: i11, transportType: r9 = Q3.relay } = e10;
          this.client.core.expirer.set(t5, s8.expiryTimestamp), await this.client.auth.requests.set(t5, { authPayload: s8.authPayload, requester: s8.requester, expiryTimestamp: s8.expiryTimestamp, id: t5, pairingTopic: i11, verifyContext: s8.verifyContext, transportType: r9 });
        }), c5(this, "setPendingSessionRequest", async (t5) => {
          const { id: e10, topic: s8, params: i11, verifyContext: r9 } = t5, n12 = i11.request.expiryTimestamp || ii(N11.wc_sessionRequest.req.ttl);
          this.client.core.expirer.set(e10, n12), await this.client.pendingRequest.set(e10, { id: e10, topic: s8, params: i11, verifyContext: r9 });
        }), c5(this, "sendRequest", async (t5) => {
          const { topic: e10, method: s8, params: i11, expiry: r9, relayRpcId: n12, clientRpcId: a5, throwOnFailedPublish: l10, appLink: p8, tvf: h12 } = t5, u6 = formatJsonRpcRequest(s8, i11, a5);
          let d7;
          const w6 = !!p8;
          try {
            const E8 = w6 ? De2 : Qt2;
            d7 = await this.client.core.crypto.encode(e10, u6, { encoding: E8 });
          } catch (E8) {
            throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e10} failed`), E8;
          }
          let m6;
          if (mt2.includes(s8)) {
            const E8 = zc(JSON.stringify(u6)), _5 = zc(d7);
            m6 = await this.client.core.verify.register({ id: _5, decryptedId: E8 });
          }
          const y9 = N11[s8].req;
          if (y9.attestation = m6, r9 && (y9.ttl = r9), n12 && (y9.id = n12), this.client.core.history.set(e10, u6), w6) {
            const E8 = sa(p8, e10, d7);
            await global.Linking.openURL(E8, this.client.name);
          } else {
            const E8 = N11[s8].req;
            r9 && (E8.ttl = r9), n12 && (E8.id = n12), E8.tvf = x4(I3({}, h12), { correlationId: u6.id }), l10 ? (E8.internal = x4(I3({}, E8.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e10, d7, E8)) : this.client.core.relayer.publish(e10, d7, E8).catch((_5) => this.client.logger.error(_5));
          }
          return u6.id;
        }), c5(this, "sendResult", async (t5) => {
          const { id: e10, topic: s8, result: i11, throwOnFailedPublish: r9, encodeOpts: n12, appLink: a5 } = t5, l10 = formatJsonRpcResult(e10, i11);
          let p8;
          const h12 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
          try {
            const w6 = h12 ? De2 : Qt2;
            p8 = await this.client.core.crypto.encode(s8, l10, x4(I3({}, n12 || {}), { encoding: w6 }));
          } catch (w6) {
            throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s8} failed`), w6;
          }
          let u6, d7;
          try {
            u6 = await this.client.core.history.get(s8, e10);
            const w6 = u6.request;
            try {
              d7 = this.getTVFParams(e10, w6.params, i11);
            } catch (m6) {
              this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m6?.message}`);
            }
          } catch (w6) {
            throw this.client.logger.error(`sendResult() -> history.get(${s8}, ${e10}) failed`), w6;
          }
          if (h12) {
            const w6 = sa(a5, s8, p8);
            await global.Linking.openURL(w6, this.client.name);
          } else {
            const w6 = u6.request.method, m6 = N11[w6].res;
            m6.tvf = x4(I3({}, d7), { correlationId: e10 }), r9 ? (m6.internal = x4(I3({}, m6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s8, p8, m6)) : this.client.core.relayer.publish(s8, p8, m6).catch((y9) => this.client.logger.error(y9));
          }
          await this.client.core.history.resolve(l10);
        }), c5(this, "sendError", async (t5) => {
          const { id: e10, topic: s8, error: i11, encodeOpts: r9, rpcOpts: n12, appLink: a5 } = t5, l10 = formatJsonRpcError(e10, i11);
          let p8;
          const h12 = a5 && typeof (global == null ? void 0 : global.Linking) < "u";
          try {
            const d7 = h12 ? De2 : Qt2;
            p8 = await this.client.core.crypto.encode(s8, l10, x4(I3({}, r9 || {}), { encoding: d7 }));
          } catch (d7) {
            throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s8} failed`), d7;
          }
          let u6;
          try {
            u6 = await this.client.core.history.get(s8, e10);
          } catch (d7) {
            throw this.client.logger.error(`sendError() -> history.get(${s8}, ${e10}) failed`), d7;
          }
          if (h12) {
            const d7 = sa(a5, s8, p8);
            await global.Linking.openURL(d7, this.client.name);
          } else {
            const d7 = u6.request.method, w6 = n12 || N11[d7].res;
            this.client.core.relayer.publish(s8, p8, w6);
          }
          await this.client.core.history.resolve(l10);
        }), c5(this, "cleanup", async () => {
          const t5 = [], e10 = [];
          this.client.session.getAll().forEach((s8) => {
            let i11 = false;
            fi(s8.expiry) && (i11 = true), this.client.core.crypto.keychain.has(s8.topic) || (i11 = true), i11 && t5.push(s8.topic);
          }), this.client.proposal.getAll().forEach((s8) => {
            fi(s8.expiryTimestamp) && e10.push(s8.id);
          }), await Promise.all([...t5.map((s8) => this.deleteSession({ topic: s8 })), ...e10.map((s8) => this.deleteProposal(s8))]);
        }), c5(this, "onProviderMessageEvent", async (t5) => {
          !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t5) : await this.onRelayMessage(t5);
        }), c5(this, "onRelayEventRequest", async (t5) => {
          this.requestQueue.queue.push(t5), await this.processRequestsQueue();
        }), c5(this, "processRequestsQueue", async () => {
          if (this.requestQueue.state === $2.active) {
            this.client.logger.info("Request queue already active, skipping...");
            return;
          }
          for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
            this.requestQueue.state = $2.active;
            const t5 = this.requestQueue.queue.shift();
            if (t5) try {
              await this.processRequest(t5);
            } catch (e10) {
              this.client.logger.warn(e10);
            }
          }
          this.requestQueue.state = $2.idle;
        }), c5(this, "processRequest", async (t5) => {
          const { topic: e10, payload: s8, attestation: i11, transportType: r9, encryptedId: n12 } = t5, a5 = s8.method;
          if (!this.shouldIgnorePairingRequest({ topic: e10, requestMethod: a5 })) switch (a5) {
            case "wc_sessionPropose":
              return await this.onSessionProposeRequest({ topic: e10, payload: s8, attestation: i11, encryptedId: n12 });
            case "wc_sessionSettle":
              return await this.onSessionSettleRequest(e10, s8);
            case "wc_sessionUpdate":
              return await this.onSessionUpdateRequest(e10, s8);
            case "wc_sessionExtend":
              return await this.onSessionExtendRequest(e10, s8);
            case "wc_sessionPing":
              return await this.onSessionPingRequest(e10, s8);
            case "wc_sessionDelete":
              return await this.onSessionDeleteRequest(e10, s8);
            case "wc_sessionRequest":
              return await this.onSessionRequest({ topic: e10, payload: s8, attestation: i11, encryptedId: n12, transportType: r9 });
            case "wc_sessionEvent":
              return await this.onSessionEventRequest(e10, s8);
            case "wc_sessionAuthenticate":
              return await this.onSessionAuthenticateRequest({ topic: e10, payload: s8, attestation: i11, encryptedId: n12, transportType: r9 });
            default:
              return this.client.logger.info(`Unsupported request method ${a5}`);
          }
        }), c5(this, "onRelayEventResponse", async (t5) => {
          const { topic: e10, payload: s8, transportType: i11 } = t5, r9 = (await this.client.core.history.get(e10, s8.id)).request.method;
          switch (r9) {
            case "wc_sessionPropose":
              return this.onSessionProposeResponse(e10, s8, i11);
            case "wc_sessionSettle":
              return this.onSessionSettleResponse(e10, s8);
            case "wc_sessionUpdate":
              return this.onSessionUpdateResponse(e10, s8);
            case "wc_sessionExtend":
              return this.onSessionExtendResponse(e10, s8);
            case "wc_sessionPing":
              return this.onSessionPingResponse(e10, s8);
            case "wc_sessionRequest":
              return this.onSessionRequestResponse(e10, s8);
            case "wc_sessionAuthenticate":
              return this.onSessionAuthenticateResponse(e10, s8);
            default:
              return this.client.logger.info(`Unsupported response method ${r9}`);
          }
        }), c5(this, "onRelayEventUnknownPayload", (t5) => {
          const { topic: e10 } = t5, { message: s8 } = Et2("MISSING_OR_INVALID", `Decoded payload on topic ${e10} is not identifiable as a JSON-RPC request or a response.`);
          throw new Error(s8);
        }), c5(this, "shouldIgnorePairingRequest", (t5) => {
          const { topic: e10, requestMethod: s8 } = t5, i11 = this.expectedPairingMethodMap.get(e10);
          return !i11 || i11.includes(s8) ? false : !!(i11.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
        }), c5(this, "onSessionProposeRequest", async (t5) => {
          const { topic: e10, payload: s8, attestation: i11, encryptedId: r9 } = t5, { params: n12, id: a5 } = s8;
          try {
            const l10 = this.client.core.eventClient.getEvent({ topic: e10 });
            this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l10?.setError(Y2.proposal_listener_not_found)), this.isValidConnect(I3({}, s8.params));
            const p8 = n12.expiryTimestamp || ii(N11.wc_sessionPropose.req.ttl), h12 = I3({ id: a5, pairingTopic: e10, expiryTimestamp: p8, attestation: i11, encryptedId: r9 }, n12);
            await this.setProposal(a5, h12);
            const u6 = await this.getVerifyContext({ attestationId: i11, hash: zc(JSON.stringify(s8)), encryptedId: r9, metadata: h12.proposer.metadata });
            l10?.addTrace(G3.emit_session_proposal), this.client.events.emit("session_proposal", { id: a5, params: h12, verifyContext: u6 });
          } catch (l10) {
            await this.sendError({ id: a5, topic: e10, error: l10, rpcOpts: N11.wc_sessionPropose.autoReject }), this.client.logger.error(l10);
          }
        }), c5(this, "onSessionProposeResponse", async (t5, e10, s8) => {
          const { id: i11 } = e10;
          if (isJsonRpcResult(e10)) {
            const { result: r9 } = e10;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r9 });
            const n12 = this.client.proposal.get(i11);
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n12 });
            const a5 = n12.proposer.publicKey;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a5 });
            const l10 = r9.responderPublicKey;
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l10 });
            const p8 = await this.client.core.crypto.generateSharedKey(a5, l10);
            this.pendingSessions.set(i11, { sessionTopic: p8, pairingTopic: t5, proposalId: i11, publicKey: a5 });
            const h12 = await this.client.core.relayer.subscribe(p8, { transportType: s8 });
            this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h12 }), await this.client.core.pairing.activate({ topic: t5 });
          } else if (isJsonRpcError(e10)) {
            await this.deleteProposal(i11);
            const r9 = ci("session_connect", i11);
            if (this.events.listenerCount(r9) === 0) throw new Error(`emitting ${r9} without any listeners, 954`);
            this.events.emit(r9, { error: e10.error });
          }
        }), c5(this, "onSessionSettleRequest", async (t5, e10) => {
          const { id: s8, params: i11 } = e10;
          try {
            this.isValidSessionSettleRequest(i11);
            const { relay: r9, controller: n12, expiry: a5, namespaces: l10, sessionProperties: p8, scopedProperties: h12, sessionConfig: u6 } = e10.params, d7 = [...this.pendingSessions.values()].find((y9) => y9.sessionTopic === t5);
            if (!d7) return this.client.logger.error(`Pending session not found for topic ${t5}`);
            const w6 = this.client.proposal.get(d7.proposalId), m6 = x4(I3(I3(I3({ topic: t5, relay: r9, expiry: a5, namespaces: l10, acknowledged: true, pairingTopic: d7.pairingTopic, requiredNamespaces: w6.requiredNamespaces, optionalNamespaces: w6.optionalNamespaces, controller: n12.publicKey, self: { publicKey: d7.publicKey, metadata: this.client.metadata }, peer: { publicKey: n12.publicKey, metadata: n12.metadata } }, p8 && { sessionProperties: p8 }), h12 && { scopedProperties: h12 }), u6 && { sessionConfig: u6 }), { transportType: Q3.relay });
            await this.client.session.set(m6.topic, m6), await this.setExpiry(m6.topic, m6.expiry), await this.client.core.pairing.updateMetadata({ topic: d7.pairingTopic, metadata: m6.peer.metadata }), this.client.events.emit("session_connect", { session: m6 }), this.events.emit(ci("session_connect", d7.proposalId), { session: m6 }), this.pendingSessions.delete(d7.proposalId), this.deleteProposal(d7.proposalId, false), this.cleanupDuplicatePairings(m6), await this.sendResult({ id: e10.id, topic: t5, result: true });
          } catch (r9) {
            await this.sendError({ id: s8, topic: t5, error: r9 }), this.client.logger.error(r9);
          }
        }), c5(this, "onSessionSettleResponse", async (t5, e10) => {
          const { id: s8 } = e10;
          isJsonRpcResult(e10) ? (await this.client.session.update(t5, { acknowledged: true }), this.events.emit(ci("session_approve", s8), {})) : isJsonRpcError(e10) && (await this.client.session.delete(t5, Kt2("USER_DISCONNECTED")), this.events.emit(ci("session_approve", s8), { error: e10.error }));
        }), c5(this, "onSessionUpdateRequest", async (t5, e10) => {
          const { params: s8, id: i11 } = e10;
          try {
            const r9 = `${t5}_session_update`, n12 = Ha.get(r9);
            if (n12 && this.isRequestOutOfSync(n12, i11)) {
              this.client.logger.warn(`Discarding out of sync request - ${i11}`), this.sendError({ id: i11, topic: t5, error: Kt2("INVALID_UPDATE_REQUEST") });
              return;
            }
            this.isValidUpdate(I3({ topic: t5 }, s8));
            try {
              Ha.set(r9, i11), await this.client.session.update(t5, { namespaces: s8.namespaces }), await this.sendResult({ id: i11, topic: t5, result: true });
            } catch (a5) {
              throw Ha.delete(r9), a5;
            }
            this.client.events.emit("session_update", { id: i11, topic: t5, params: s8 });
          } catch (r9) {
            await this.sendError({ id: i11, topic: t5, error: r9 }), this.client.logger.error(r9);
          }
        }), c5(this, "isRequestOutOfSync", (t5, e10) => e10.toString().slice(0, -3) < t5.toString().slice(0, -3)), c5(this, "onSessionUpdateResponse", (t5, e10) => {
          const { id: s8 } = e10, i11 = ci("session_update", s8);
          if (this.events.listenerCount(i11) === 0) throw new Error(`emitting ${i11} without any listeners`);
          isJsonRpcResult(e10) ? this.events.emit(ci("session_update", s8), {}) : isJsonRpcError(e10) && this.events.emit(ci("session_update", s8), { error: e10.error });
        }), c5(this, "onSessionExtendRequest", async (t5, e10) => {
          const { id: s8 } = e10;
          try {
            this.isValidExtend({ topic: t5 }), await this.setExpiry(t5, ii(X2)), await this.sendResult({ id: s8, topic: t5, result: true }), this.client.events.emit("session_extend", { id: s8, topic: t5 });
          } catch (i11) {
            await this.sendError({ id: s8, topic: t5, error: i11 }), this.client.logger.error(i11);
          }
        }), c5(this, "onSessionExtendResponse", (t5, e10) => {
          const { id: s8 } = e10, i11 = ci("session_extend", s8);
          if (this.events.listenerCount(i11) === 0) throw new Error(`emitting ${i11} without any listeners`);
          isJsonRpcResult(e10) ? this.events.emit(ci("session_extend", s8), {}) : isJsonRpcError(e10) && this.events.emit(ci("session_extend", s8), { error: e10.error });
        }), c5(this, "onSessionPingRequest", async (t5, e10) => {
          const { id: s8 } = e10;
          try {
            this.isValidPing({ topic: t5 }), await this.sendResult({ id: s8, topic: t5, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s8, topic: t5 });
          } catch (i11) {
            await this.sendError({ id: s8, topic: t5, error: i11 }), this.client.logger.error(i11);
          }
        }), c5(this, "onSessionPingResponse", (t5, e10) => {
          const { id: s8 } = e10, i11 = ci("session_ping", s8);
          setTimeout(() => {
            if (this.events.listenerCount(i11) === 0) throw new Error(`emitting ${i11} without any listeners 2176`);
            isJsonRpcResult(e10) ? this.events.emit(ci("session_ping", s8), {}) : isJsonRpcError(e10) && this.events.emit(ci("session_ping", s8), { error: e10.error });
          }, 500);
        }), c5(this, "onSessionDeleteRequest", async (t5, e10) => {
          const { id: s8 } = e10;
          try {
            this.isValidDisconnect({ topic: t5, reason: e10.params }), Promise.all([new Promise((i11) => {
              this.client.core.relayer.once(C3.publish, async () => {
                i11(await this.deleteSession({ topic: t5, id: s8 }));
              });
            }), this.sendResult({ id: s8, topic: t5, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t5, error: Kt2("USER_DISCONNECTED") })]).catch((i11) => this.client.logger.error(i11));
          } catch (i11) {
            this.client.logger.error(i11);
          }
        }), c5(this, "onSessionRequest", async (t5) => {
          var e10, s8, i11;
          const { topic: r9, payload: n12, attestation: a5, encryptedId: l10, transportType: p8 } = t5, { id: h12, params: u6 } = n12;
          try {
            await this.isValidRequest(I3({ topic: r9 }, u6));
            const d7 = this.client.session.get(r9), w6 = await this.getVerifyContext({ attestationId: a5, hash: zc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u6, h12))), encryptedId: l10, metadata: d7.peer.metadata, transportType: p8 }), m6 = { id: h12, topic: r9, params: u6, verifyContext: w6 };
            await this.setPendingSessionRequest(m6), p8 === Q3.link_mode && (e10 = d7.peer.metadata.redirect) != null && e10.universal && this.client.core.addLinkModeSupportedApp((s8 = d7.peer.metadata.redirect) == null ? void 0 : s8.universal), (i11 = this.client.signConfig) != null && i11.disableRequestQueue ? this.emitSessionRequest(m6) : (this.addSessionRequestToSessionRequestQueue(m6), this.processSessionRequestQueue());
          } catch (d7) {
            await this.sendError({ id: h12, topic: r9, error: d7 }), this.client.logger.error(d7);
          }
        }), c5(this, "onSessionRequestResponse", (t5, e10) => {
          const { id: s8 } = e10, i11 = ci("session_request", s8);
          if (this.events.listenerCount(i11) === 0) throw new Error(`emitting ${i11} without any listeners`);
          isJsonRpcResult(e10) ? this.events.emit(ci("session_request", s8), { result: e10.result }) : isJsonRpcError(e10) && this.events.emit(ci("session_request", s8), { error: e10.error });
        }), c5(this, "onSessionEventRequest", async (t5, e10) => {
          const { id: s8, params: i11 } = e10;
          try {
            const r9 = `${t5}_session_event_${i11.event.name}`, n12 = Ha.get(r9);
            if (n12 && this.isRequestOutOfSync(n12, s8)) {
              this.client.logger.info(`Discarding out of sync request - ${s8}`);
              return;
            }
            this.isValidEmit(I3({ topic: t5 }, i11)), this.client.events.emit("session_event", { id: s8, topic: t5, params: i11 }), Ha.set(r9, s8);
          } catch (r9) {
            await this.sendError({ id: s8, topic: t5, error: r9 }), this.client.logger.error(r9);
          }
        }), c5(this, "onSessionAuthenticateResponse", (t5, e10) => {
          const { id: s8 } = e10;
          this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t5, payload: e10 }), isJsonRpcResult(e10) ? this.events.emit(ci("session_request", s8), { result: e10.result }) : isJsonRpcError(e10) && this.events.emit(ci("session_request", s8), { error: e10.error });
        }), c5(this, "onSessionAuthenticateRequest", async (t5) => {
          var e10;
          const { topic: s8, payload: i11, attestation: r9, encryptedId: n12, transportType: a5 } = t5;
          try {
            const { requester: l10, authPayload: p8, expiryTimestamp: h12 } = i11.params, u6 = await this.getVerifyContext({ attestationId: r9, hash: zc(JSON.stringify(i11)), encryptedId: n12, metadata: l10.metadata, transportType: a5 }), d7 = { requester: l10, pairingTopic: s8, id: i11.id, authPayload: p8, verifyContext: u6, expiryTimestamp: h12 };
            await this.setAuthRequest(i11.id, { request: d7, pairingTopic: s8, transportType: a5 }), a5 === Q3.link_mode && (e10 = l10.metadata.redirect) != null && e10.universal && this.client.core.addLinkModeSupportedApp(l10.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s8, params: i11.params, id: i11.id, verifyContext: u6 });
          } catch (l10) {
            this.client.logger.error(l10);
            const p8 = i11.params.requester.publicKey, h12 = await this.client.core.crypto.generateKeyPair(), u6 = this.getAppLinkIfEnabled(i11.params.requester.metadata, a5), d7 = { type: ee, receiverPublicKey: p8, senderPublicKey: h12 };
            await this.sendError({ id: i11.id, topic: s8, error: l10, encodeOpts: d7, rpcOpts: N11.wc_sessionAuthenticate.autoReject, appLink: u6 });
          }
        }), c5(this, "addSessionRequestToSessionRequestQueue", (t5) => {
          this.sessionRequestQueue.queue.push(t5);
        }), c5(this, "cleanupAfterResponse", (t5) => {
          this.deletePendingSessionRequest(t5.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
            this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
          }, (0, import_time5.toMiliseconds)(this.requestQueueDelay));
        }), c5(this, "cleanupPendingSentRequestsForTopic", ({ topic: t5, error: e10 }) => {
          const s8 = this.client.core.history.pending;
          s8.length > 0 && s8.filter((i11) => i11.topic === t5 && i11.request.method === "wc_sessionRequest").forEach((i11) => {
            const r9 = i11.request.id, n12 = ci("session_request", r9);
            if (this.events.listenerCount(n12) === 0) throw new Error(`emitting ${n12} without any listeners`);
            this.events.emit(ci("session_request", i11.request.id), { error: e10 });
          });
        }), c5(this, "processSessionRequestQueue", () => {
          if (this.sessionRequestQueue.state === $2.active) {
            this.client.logger.info("session request queue is already active.");
            return;
          }
          const t5 = this.sessionRequestQueue.queue[0];
          if (!t5) {
            this.client.logger.info("session request queue is empty.");
            return;
          }
          try {
            this.emitSessionRequest(t5);
          } catch (e10) {
            this.client.logger.error(e10);
          }
        }), c5(this, "emitSessionRequest", (t5) => {
          if (this.emittedSessionRequests.has(t5.id)) {
            this.client.logger.warn({ id: t5.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t5.id}`);
            return;
          }
          this.sessionRequestQueue.state = $2.active, this.emittedSessionRequests.add(t5.id), this.client.events.emit("session_request", t5);
        }), c5(this, "onPairingCreated", (t5) => {
          if (t5.methods && this.expectedPairingMethodMap.set(t5.topic, t5.methods), t5.active) return;
          const e10 = this.client.proposal.getAll().find((s8) => s8.pairingTopic === t5.topic);
          e10 && this.onSessionProposeRequest({ topic: t5.topic, payload: formatJsonRpcRequest("wc_sessionPropose", x4(I3({}, e10), { requiredNamespaces: e10.requiredNamespaces, optionalNamespaces: e10.optionalNamespaces, relays: e10.relays, proposer: e10.proposer, sessionProperties: e10.sessionProperties, scopedProperties: e10.scopedProperties }), e10.id), attestation: e10.attestation, encryptedId: e10.encryptedId });
        }), c5(this, "isValidConnect", async (t5) => {
          if (!Aa(t5)) {
            const { message: l10 } = Et2("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t5)}`);
            throw new Error(l10);
          }
          const { pairingTopic: e10, requiredNamespaces: s8, optionalNamespaces: i11, sessionProperties: r9, scopedProperties: n12, relays: a5 } = t5;
          if (kt2(e10) || await this.isValidPairingTopic(e10), !Ba(a5, true)) {
            const { message: l10 } = Et2("MISSING_OR_INVALID", `connect() relays: ${a5}`);
            throw new Error(l10);
          }
          if (!kt2(s8) && Ve2(s8) !== 0) {
            const l10 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
            ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l10) : this.client.logger.warn(l10), this.validateNamespaces(s8, "requiredNamespaces");
          }
          if (!kt2(i11) && Ve2(i11) !== 0 && this.validateNamespaces(i11, "optionalNamespaces"), kt2(r9) || this.validateSessionProps(r9, "sessionProperties"), !kt2(n12)) {
            this.validateSessionProps(n12, "scopedProperties");
            const l10 = Object.keys(s8 || {}).concat(Object.keys(i11 || {}));
            if (!Object.keys(n12).every((p8) => l10.includes(p8.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n12)}, required/optional namespaces: ${JSON.stringify(l10)}`);
          }
        }), c5(this, "validateNamespaces", (t5, e10) => {
          const s8 = Ea(t5, "connect()", e10);
          if (s8) throw new Error(s8.message);
        }), c5(this, "isValidApprove", async (t5) => {
          if (!Aa(t5)) throw new Error(Et2("MISSING_OR_INVALID", `approve() params: ${t5}`).message);
          const { id: e10, namespaces: s8, relayProtocol: i11, sessionProperties: r9, scopedProperties: n12 } = t5;
          this.checkRecentlyDeleted(e10), await this.isValidProposalId(e10);
          const a5 = this.client.proposal.get(e10), l10 = is(s8, "approve()");
          if (l10) throw new Error(l10.message);
          const p8 = cs(a5.requiredNamespaces, s8, "approve()");
          if (p8) throw new Error(p8.message);
          if (!it2(i11, true)) {
            const { message: h12 } = Et2("MISSING_OR_INVALID", `approve() relayProtocol: ${i11}`);
            throw new Error(h12);
          }
          if (kt2(r9) || this.validateSessionProps(r9, "sessionProperties"), !kt2(n12)) {
            this.validateSessionProps(n12, "scopedProperties");
            const h12 = new Set(Object.keys(s8));
            if (!Object.keys(n12).every((u6) => h12.has(u6.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n12)}, approved namespaces: ${Array.from(h12).join(", ")}`);
          }
        }), c5(this, "isValidReject", async (t5) => {
          if (!Aa(t5)) {
            const { message: i11 } = Et2("MISSING_OR_INVALID", `reject() params: ${t5}`);
            throw new Error(i11);
          }
          const { id: e10, reason: s8 } = t5;
          if (this.checkRecentlyDeleted(e10), await this.isValidProposalId(e10), !Sa(s8)) {
            const { message: i11 } = Et2("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s8)}`);
            throw new Error(i11);
          }
        }), c5(this, "isValidSessionSettleRequest", (t5) => {
          if (!Aa(t5)) {
            const { message: l10 } = Et2("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t5}`);
            throw new Error(l10);
          }
          const { relay: e10, controller: s8, namespaces: i11, expiry: r9 } = t5;
          if (!fs(e10)) {
            const { message: l10 } = Et2("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
            throw new Error(l10);
          }
          const n12 = va(s8, "onSessionSettleRequest()");
          if (n12) throw new Error(n12.message);
          const a5 = is(i11, "onSessionSettleRequest()");
          if (a5) throw new Error(a5.message);
          if (fi(r9)) {
            const { message: l10 } = Et2("EXPIRED", "onSessionSettleRequest()");
            throw new Error(l10);
          }
        }), c5(this, "isValidUpdate", async (t5) => {
          if (!Aa(t5)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `update() params: ${t5}`);
            throw new Error(a5);
          }
          const { topic: e10, namespaces: s8 } = t5;
          this.checkRecentlyDeleted(e10), await this.isValidSessionTopic(e10);
          const i11 = this.client.session.get(e10), r9 = is(s8, "update()");
          if (r9) throw new Error(r9.message);
          const n12 = cs(i11.requiredNamespaces, s8, "update()");
          if (n12) throw new Error(n12.message);
        }), c5(this, "isValidExtend", async (t5) => {
          if (!Aa(t5)) {
            const { message: s8 } = Et2("MISSING_OR_INVALID", `extend() params: ${t5}`);
            throw new Error(s8);
          }
          const { topic: e10 } = t5;
          this.checkRecentlyDeleted(e10), await this.isValidSessionTopic(e10);
        }), c5(this, "isValidRequest", async (t5) => {
          if (!Aa(t5)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `request() params: ${t5}`);
            throw new Error(a5);
          }
          const { topic: e10, request: s8, chainId: i11, expiry: r9 } = t5;
          this.checkRecentlyDeleted(e10), await this.isValidSessionTopic(e10);
          const { namespaces: n12 } = this.client.session.get(e10);
          if (!_a(n12, i11)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `request() chainId: ${i11}`);
            throw new Error(a5);
          }
          if (!Na(s8)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `request() ${JSON.stringify(s8)}`);
            throw new Error(a5);
          }
          if (!Ta(n12, i11, s8.method)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `request() method: ${s8.method}`);
            throw new Error(a5);
          }
          if (r9 && !La(r9, _e4)) {
            const { message: a5 } = Et2("MISSING_OR_INVALID", `request() expiry: ${r9}. Expiry must be a number (in seconds) between ${_e4.min} and ${_e4.max}`);
            throw new Error(a5);
          }
        }), c5(this, "isValidRespond", async (t5) => {
          var e10;
          if (!Aa(t5)) {
            const { message: r9 } = Et2("MISSING_OR_INVALID", `respond() params: ${t5}`);
            throw new Error(r9);
          }
          const { topic: s8, response: i11 } = t5;
          try {
            await this.isValidSessionTopic(s8);
          } catch (r9) {
            throw (e10 = t5?.response) != null && e10.id && this.cleanupAfterResponse(t5), r9;
          }
          if (!Oa(i11)) {
            const { message: r9 } = Et2("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i11)}`);
            throw new Error(r9);
          }
        }), c5(this, "isValidPing", async (t5) => {
          if (!Aa(t5)) {
            const { message: s8 } = Et2("MISSING_OR_INVALID", `ping() params: ${t5}`);
            throw new Error(s8);
          }
          const { topic: e10 } = t5;
          await this.isValidSessionOrPairingTopic(e10);
        }), c5(this, "isValidEmit", async (t5) => {
          if (!Aa(t5)) {
            const { message: n12 } = Et2("MISSING_OR_INVALID", `emit() params: ${t5}`);
            throw new Error(n12);
          }
          const { topic: e10, event: s8, chainId: i11 } = t5;
          await this.isValidSessionTopic(e10);
          const { namespaces: r9 } = this.client.session.get(e10);
          if (!_a(r9, i11)) {
            const { message: n12 } = Et2("MISSING_OR_INVALID", `emit() chainId: ${i11}`);
            throw new Error(n12);
          }
          if (!Ua(s8)) {
            const { message: n12 } = Et2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s8)}`);
            throw new Error(n12);
          }
          if (!Ra(r9, i11, s8.name)) {
            const { message: n12 } = Et2("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s8)}`);
            throw new Error(n12);
          }
        }), c5(this, "isValidDisconnect", async (t5) => {
          if (!Aa(t5)) {
            const { message: s8 } = Et2("MISSING_OR_INVALID", `disconnect() params: ${t5}`);
            throw new Error(s8);
          }
          const { topic: e10 } = t5;
          await this.isValidSessionOrPairingTopic(e10);
        }), c5(this, "isValidAuthenticate", (t5) => {
          const { chains: e10, uri: s8, domain: i11, nonce: r9 } = t5;
          if (!Array.isArray(e10) || e10.length === 0) throw new Error("chains is required and must be a non-empty array");
          if (!it2(s8, false)) throw new Error("uri is required parameter");
          if (!it2(i11, false)) throw new Error("domain is required parameter");
          if (!it2(r9, false)) throw new Error("nonce is required parameter");
          if ([...new Set(e10.map((a5) => Fe(a5).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
          const { namespace: n12 } = Fe(e10[0]);
          if (n12 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
        }), c5(this, "getVerifyContext", async (t5) => {
          const { attestationId: e10, hash: s8, encryptedId: i11, metadata: r9, transportType: n12 } = t5, a5 = { verified: { verifyUrl: r9.verifyUrl || ue2, validation: "UNKNOWN", origin: r9.url || "" } };
          try {
            if (n12 === Q3.link_mode) {
              const p8 = this.getAppLinkIfEnabled(r9, n12);
              return a5.verified.validation = p8 && new URL(p8).origin === new URL(r9.url).origin ? "VALID" : "INVALID", a5;
            }
            const l10 = await this.client.core.verify.resolve({ attestationId: e10, hash: s8, encryptedId: i11, verifyUrl: r9.verifyUrl });
            l10 && (a5.verified.origin = l10.origin, a5.verified.isScam = l10.isScam, a5.verified.validation = l10.origin === new URL(r9.url).origin ? "VALID" : "INVALID");
          } catch (l10) {
            this.client.logger.warn(l10);
          }
          return this.client.logger.debug(`Verify context: ${JSON.stringify(a5)}`), a5;
        }), c5(this, "validateSessionProps", (t5, e10) => {
          Object.values(t5).forEach((s8, i11) => {
            if (s8 == null) {
              const { message: r9 } = Et2("MISSING_OR_INVALID", `${e10} must contain an existing value for each key. Received: ${s8} for key ${Object.keys(t5)[i11]}`);
              throw new Error(r9);
            }
          });
        }), c5(this, "getPendingAuthRequest", (t5) => {
          const e10 = this.client.auth.requests.get(t5);
          return typeof e10 == "object" ? e10 : void 0;
        }), c5(this, "addToRecentlyDeleted", (t5, e10) => {
          if (this.recentlyDeletedMap.set(t5, e10), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
            let s8 = 0;
            const i11 = this.recentlyDeletedLimit / 2;
            for (const r9 of this.recentlyDeletedMap.keys()) {
              if (s8++ >= i11) break;
              this.recentlyDeletedMap.delete(r9);
            }
          }
        }), c5(this, "checkRecentlyDeleted", (t5) => {
          const e10 = this.recentlyDeletedMap.get(t5);
          if (e10) {
            const { message: s8 } = Et2("MISSING_OR_INVALID", `Record was recently deleted - ${e10}: ${t5}`);
            throw new Error(s8);
          }
        }), c5(this, "isLinkModeEnabled", (t5, e10) => {
          var s8, i11, r9, n12, a5, l10, p8, h12, u6;
          return !t5 || e10 !== Q3.link_mode ? false : ((i11 = (s8 = this.client.metadata) == null ? void 0 : s8.redirect) == null ? void 0 : i11.linkMode) === true && ((n12 = (r9 = this.client.metadata) == null ? void 0 : r9.redirect) == null ? void 0 : n12.universal) !== void 0 && ((l10 = (a5 = this.client.metadata) == null ? void 0 : a5.redirect) == null ? void 0 : l10.universal) !== "" && ((p8 = t5?.redirect) == null ? void 0 : p8.universal) !== void 0 && ((h12 = t5?.redirect) == null ? void 0 : h12.universal) !== "" && ((u6 = t5?.redirect) == null ? void 0 : u6.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t5.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
        }), c5(this, "getAppLinkIfEnabled", (t5, e10) => {
          var s8;
          return this.isLinkModeEnabled(t5, e10) ? (s8 = t5?.redirect) == null ? void 0 : s8.universal : void 0;
        }), c5(this, "handleLinkModeMessage", ({ url: t5 }) => {
          if (!t5 || !t5.includes("wc_ev") || !t5.includes("topic")) return;
          const e10 = li(t5, "topic") || "", s8 = decodeURIComponent(li(t5, "wc_ev") || ""), i11 = this.client.session.keys.includes(e10);
          i11 && this.client.session.update(e10, { transportType: Q3.link_mode }), this.client.core.dispatchEnvelope({ topic: e10, message: s8, sessionExists: i11 });
        }), c5(this, "registerLinkModeListeners", async () => {
          var t5;
          if (hi() || Bt2() && (t5 = this.client.metadata.redirect) != null && t5.linkMode) {
            const e10 = global == null ? void 0 : global.Linking;
            if (typeof e10 < "u") {
              e10.addEventListener("url", this.handleLinkModeMessage, this.client.name);
              const s8 = await e10.getInitialURL();
              s8 && setTimeout(() => {
                this.handleLinkModeMessage({ url: s8 });
              }, 50);
            }
          }
        }), c5(this, "getTVFParams", (t5, e10, s8) => {
          var i11, r9, n12;
          if (!((i11 = e10.request) != null && i11.method)) return {};
          const a5 = { correlationId: t5, rpcMethods: [e10.request.method], chainId: e10.chainId };
          try {
            const l10 = this.extractTxHashesFromResult(e10.request, s8);
            a5.txHashes = l10, a5.contractAddresses = this.isValidContractData(e10.request.params) ? [(n12 = (r9 = e10.request.params) == null ? void 0 : r9[0]) == null ? void 0 : n12.to] : [];
          } catch (l10) {
            this.client.logger.warn("Error getting TVF params", l10);
          }
          return a5;
        }), c5(this, "isValidContractData", (t5) => {
          var e10;
          if (!t5) return false;
          try {
            const s8 = t5?.data || ((e10 = t5?.[0]) == null ? void 0 : e10.data);
            if (!s8.startsWith("0x")) return false;
            const i11 = s8.slice(2);
            return /^[0-9a-fA-F]*$/.test(i11) ? i11.length % 2 === 0 : false;
          } catch {
          }
          return false;
        }), c5(this, "extractTxHashesFromResult", (t5, e10) => {
          var s8;
          try {
            if (!e10) return [];
            const i11 = t5.method, r9 = gt3[i11];
            if (i11 === "sui_signTransaction") return [ff(e10.transactionBytes)];
            if (i11 === "near_signTransaction") return [cf(e10)];
            if (i11 === "near_signTransactions") return e10.map((a5) => cf(a5));
            if (i11 === "xrpl_signTransactionFor" || i11 === "xrpl_signTransaction") return [(s8 = e10.tx_json) == null ? void 0 : s8.hash];
            if (i11 === "polkadot_signTransaction") return [Ka({ transaction: t5.params.transactionPayload, signature: e10.signature })];
            if (i11 === "algo_signTxn") return me2(e10) ? e10.map((a5) => af(a5)) : [af(e10)];
            if (i11 === "cosmos_signDirect") return [uf(e10)];
            if (typeof e10 == "string") return [e10];
            const n12 = e10[r9.key];
            if (me2(n12)) return i11 === "solana_signAllTransactions" ? n12.map((a5) => sf(a5)) : n12;
            if (typeof n12 == "string") return [n12];
          } catch (i11) {
            this.client.logger.warn("Error extracting tx hashes from result", i11);
          }
          return [];
        });
      }
      async processPendingMessageEvents() {
        try {
          const o13 = this.client.session.keys, t5 = this.client.core.relayer.messages.getWithoutAck(o13);
          for (const [e10, s8] of Object.entries(t5)) for (const i11 of s8) try {
            await this.onProviderMessageEvent({ topic: e10, message: i11, publishedAt: Date.now() });
          } catch {
            this.client.logger.warn(`Error processing pending message event for topic: ${e10}, message: ${i11}`);
          }
        } catch (o13) {
          this.client.logger.warn("processPendingMessageEvents failed", o13);
        }
      }
      isInitialized() {
        if (!this.initialized) {
          const { message: o13 } = Et2("NOT_INITIALIZED", this.name);
          throw new Error(o13);
        }
      }
      async confirmOnlineStateOrThrow() {
        await this.client.core.relayer.confirmOnlineStateOrThrow();
      }
      registerRelayerEvents() {
        this.client.core.relayer.on(C3.message, (o13) => {
          this.onProviderMessageEvent(o13);
        });
      }
      async onRelayMessage(o13) {
        const { topic: t5, message: e10, attestation: s8, transportType: i11 } = o13, { publicKey: r9 } = this.client.auth.authKeys.keys.includes(ce2) ? this.client.auth.authKeys.get(ce2) : { responseTopic: void 0, publicKey: void 0 };
        try {
          const n12 = await this.client.core.crypto.decode(t5, e10, { receiverPublicKey: r9, encoding: i11 === Q3.link_mode ? De2 : Qt2 });
          isJsonRpcRequest(n12) ? (this.client.core.history.set(t5, n12), await this.onRelayEventRequest({ topic: t5, payload: n12, attestation: s8, transportType: i11, encryptedId: zc(e10) })) : isJsonRpcResponse(n12) ? (await this.client.core.history.resolve(n12), await this.onRelayEventResponse({ topic: t5, payload: n12, transportType: i11 }), this.client.core.history.delete(t5, n12.id)) : await this.onRelayEventUnknownPayload({ topic: t5, payload: n12, transportType: i11 }), await this.client.core.relayer.messages.ack(t5, e10);
        } catch (n12) {
          this.client.logger.error(n12);
        }
      }
      registerExpirerEvents() {
        this.client.core.expirer.on(M3.expired, async (o13) => {
          const { topic: t5, id: e10 } = si(o13.target);
          if (e10 && this.client.pendingRequest.keys.includes(e10)) return await this.deletePendingSessionRequest(e10, Et2("EXPIRED"), true);
          if (e10 && this.client.auth.requests.keys.includes(e10)) return await this.deletePendingAuthRequest(e10, Et2("EXPIRED"), true);
          t5 ? this.client.session.keys.includes(t5) && (await this.deleteSession({ topic: t5, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t5 })) : e10 && (await this.deleteProposal(e10, true), this.client.events.emit("proposal_expire", { id: e10 }));
        });
      }
      registerPairingEvents() {
        this.client.core.pairing.events.on(re.create, (o13) => this.onPairingCreated(o13)), this.client.core.pairing.events.on(re.delete, (o13) => {
          this.addToRecentlyDeleted(o13.topic, "pairing");
        });
      }
      isValidPairingTopic(o13) {
        if (!it2(o13, false)) {
          const { message: t5 } = Et2("MISSING_OR_INVALID", `pairing topic should be a string: ${o13}`);
          throw new Error(t5);
        }
        if (!this.client.core.pairing.pairings.keys.includes(o13)) {
          const { message: t5 } = Et2("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o13}`);
          throw new Error(t5);
        }
        if (fi(this.client.core.pairing.pairings.get(o13).expiry)) {
          const { message: t5 } = Et2("EXPIRED", `pairing topic: ${o13}`);
          throw new Error(t5);
        }
      }
      async isValidSessionTopic(o13) {
        if (!it2(o13, false)) {
          const { message: t5 } = Et2("MISSING_OR_INVALID", `session topic should be a string: ${o13}`);
          throw new Error(t5);
        }
        if (this.checkRecentlyDeleted(o13), !this.client.session.keys.includes(o13)) {
          const { message: t5 } = Et2("NO_MATCHING_KEY", `session topic doesn't exist: ${o13}`);
          throw new Error(t5);
        }
        if (fi(this.client.session.get(o13).expiry)) {
          await this.deleteSession({ topic: o13 });
          const { message: t5 } = Et2("EXPIRED", `session topic: ${o13}`);
          throw new Error(t5);
        }
        if (!this.client.core.crypto.keychain.has(o13)) {
          const { message: t5 } = Et2("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o13}`);
          throw await this.deleteSession({ topic: o13 }), new Error(t5);
        }
      }
      async isValidSessionOrPairingTopic(o13) {
        if (this.checkRecentlyDeleted(o13), this.client.session.keys.includes(o13)) await this.isValidSessionTopic(o13);
        else if (this.client.core.pairing.pairings.keys.includes(o13)) this.isValidPairingTopic(o13);
        else if (it2(o13, false)) {
          const { message: t5 } = Et2("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o13}`);
          throw new Error(t5);
        } else {
          const { message: t5 } = Et2("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o13}`);
          throw new Error(t5);
        }
      }
      async isValidProposalId(o13) {
        if (!Ia(o13)) {
          const { message: t5 } = Et2("MISSING_OR_INVALID", `proposal id should be a number: ${o13}`);
          throw new Error(t5);
        }
        if (!this.client.proposal.keys.includes(o13)) {
          const { message: t5 } = Et2("NO_MATCHING_KEY", `proposal id doesn't exist: ${o13}`);
          throw new Error(t5);
        }
        if (fi(this.client.proposal.get(o13).expiryTimestamp)) {
          await this.deleteProposal(o13);
          const { message: t5 } = Et2("EXPIRED", `proposal id: ${o13}`);
          throw new Error(t5);
        }
      }
    };
    ks2 = class extends Li2 {
      constructor(o13, t5) {
        super(o13, t5, ht3, me3), this.core = o13, this.logger = t5;
      }
    };
    vt3 = class extends Li2 {
      constructor(o13, t5) {
        super(o13, t5, dt3, me3), this.core = o13, this.logger = t5;
      }
    };
    Ds = class extends Li2 {
      constructor(o13, t5) {
        super(o13, t5, yt2, me3, (e10) => e10.id), this.core = o13, this.logger = t5;
      }
    };
    Ls2 = class extends Li2 {
      constructor(o13, t5) {
        super(o13, t5, Et4, ae2, () => ce2), this.core = o13, this.logger = t5;
      }
    };
    Ms2 = class extends Li2 {
      constructor(o13, t5) {
        super(o13, t5, ft2, ae2), this.core = o13, this.logger = t5;
      }
    };
    $s2 = class extends Li2 {
      constructor(o13, t5) {
        super(o13, t5, St4, ae2, (e10) => e10.id), this.core = o13, this.logger = t5;
      }
    };
    Ks2 = Object.defineProperty;
    Us = (S7, o13, t5) => o13 in S7 ? Ks2(S7, o13, { enumerable: true, configurable: true, writable: true, value: t5 }) : S7[o13] = t5;
    Ke4 = (S7, o13, t5) => Us(S7, typeof o13 != "symbol" ? o13 + "" : o13, t5);
    Gs2 = class {
      constructor(o13, t5) {
        this.core = o13, this.logger = t5, Ke4(this, "authKeys"), Ke4(this, "pairingTopics"), Ke4(this, "requests"), this.authKeys = new Ls2(this.core, this.logger), this.pairingTopics = new Ms2(this.core, this.logger), this.requests = new $s2(this.core, this.logger);
      }
      async init() {
        await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
      }
    };
    js2 = Object.defineProperty;
    Fs = (S7, o13, t5) => o13 in S7 ? js2(S7, o13, { enumerable: true, configurable: true, writable: true, value: t5 }) : S7[o13] = t5;
    f6 = (S7, o13, t5) => Fs(S7, typeof o13 != "symbol" ? o13 + "" : o13, t5);
    Ee3 = class _Ee extends J {
      constructor(o13) {
        super(o13), f6(this, "protocol", Ce4), f6(this, "version", ke4), f6(this, "name", we3.name), f6(this, "metadata"), f6(this, "core"), f6(this, "logger"), f6(this, "events", new import_events8.EventEmitter()), f6(this, "engine"), f6(this, "session"), f6(this, "proposal"), f6(this, "pendingRequest"), f6(this, "auth"), f6(this, "signConfig"), f6(this, "on", (e10, s8) => this.events.on(e10, s8)), f6(this, "once", (e10, s8) => this.events.once(e10, s8)), f6(this, "off", (e10, s8) => this.events.off(e10, s8)), f6(this, "removeListener", (e10, s8) => this.events.removeListener(e10, s8)), f6(this, "removeAllListeners", (e10) => this.events.removeAllListeners(e10)), f6(this, "connect", async (e10) => {
          try {
            return await this.engine.connect(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "pair", async (e10) => {
          try {
            return await this.engine.pair(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "approve", async (e10) => {
          try {
            return await this.engine.approve(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "reject", async (e10) => {
          try {
            return await this.engine.reject(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "update", async (e10) => {
          try {
            return await this.engine.update(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "extend", async (e10) => {
          try {
            return await this.engine.extend(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "request", async (e10) => {
          try {
            return await this.engine.request(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "respond", async (e10) => {
          try {
            return await this.engine.respond(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "ping", async (e10) => {
          try {
            return await this.engine.ping(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "emit", async (e10) => {
          try {
            return await this.engine.emit(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "disconnect", async (e10) => {
          try {
            return await this.engine.disconnect(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "find", (e10) => {
          try {
            return this.engine.find(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "getPendingSessionRequests", () => {
          try {
            return this.engine.getPendingSessionRequests();
          } catch (e10) {
            throw this.logger.error(e10.message), e10;
          }
        }), f6(this, "authenticate", async (e10, s8) => {
          try {
            return await this.engine.authenticate(e10, s8);
          } catch (i11) {
            throw this.logger.error(i11.message), i11;
          }
        }), f6(this, "formatAuthMessage", (e10) => {
          try {
            return this.engine.formatAuthMessage(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "approveSessionAuthenticate", async (e10) => {
          try {
            return await this.engine.approveSessionAuthenticate(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), f6(this, "rejectSessionAuthenticate", async (e10) => {
          try {
            return await this.engine.rejectSessionAuthenticate(e10);
          } catch (s8) {
            throw this.logger.error(s8.message), s8;
          }
        }), this.name = o13?.name || we3.name, this.metadata = Ks(o13?.metadata), this.signConfig = o13?.signConfig;
        const t5 = typeof o13?.logger < "u" && typeof o13?.logger != "string" ? o13.logger : (0, import_pino2.default)(k2({ level: o13?.logger || we3.logger }));
        this.core = o13?.core || new Zo3(o13), this.logger = E2(t5, this.name), this.session = new vt3(this.core, this.logger), this.proposal = new ks2(this.core, this.logger), this.pendingRequest = new Ds(this.core, this.logger), this.engine = new Cs2(this), this.auth = new Gs2(this.core, this.logger);
      }
      static async init(o13) {
        const t5 = new _Ee(o13);
        return await t5.initialize(), t5;
      }
      get context() {
        return y2(this.logger);
      }
      get pairing() {
        return this.core.pairing.pairings;
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
        } catch (o13) {
          throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o13.message), o13;
        }
      }
    };
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F4() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F4.prototype = __global__;
      return new F4();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g5 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g5,
          iterable: "Symbol" in g5 && "iterator" in Symbol,
          blob: "FileReader" in g5 && "Blob" in g5 && function() {
            try {
              new Blob();
              return true;
            } catch (e10) {
              return false;
            }
          }(),
          formData: "FormData" in g5,
          arrayBuffer: "ArrayBuffer" in g5
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
            throw new TypeError('Invalid character in header field name: "' + name2 + '"');
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers2.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers2.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers2.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i11 = 0; i11 < view.length; i11++) {
            chars[i11] = String.fromCharCode(view[i11]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode7);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g5) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode7(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes2) {
            if (bytes2) {
              var split3 = bytes2.split("=");
              var name2 = split3.shift().replace(/\+/g, " ");
              var value = split3.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error2) {
                console.warn("Response " + error2.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g5.DOMException;
        try {
          new exports2.DOMException();
        } catch (err2) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error2 = Error(message);
            this.stack = error2.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g5.location.href ? g5.location.href : url;
              } catch (e10) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g5.Headers && init.headers instanceof g5.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name2) {
                names.push(normalizeName(name2));
                xhr.setRequestHeader(name2, normalizeValue(init.headers[name2]));
              });
              request.headers.forEach(function(value, name2) {
                if (names.indexOf(name2) === -1) {
                  xhr.setRequestHeader(name2, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g5.fetch) {
          g5.fetch = fetch2;
          g5.Headers = Headers2;
          g5.Request = Request2;
          g5.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var import_events9, import_cross_fetch, P4, w4, E4, c6, L3, O5, l6, p4, v5, j3, T3, d4, g3, f7;
var init_index_es13 = __esm({
  "node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js"() {
    import_events9 = __toESM(require_events());
    import_cross_fetch = __toESM(require_browser_ponyfill());
    init_esm3();
    init_esm7();
    P4 = Object.defineProperty;
    w4 = Object.defineProperties;
    E4 = Object.getOwnPropertyDescriptors;
    c6 = Object.getOwnPropertySymbols;
    L3 = Object.prototype.hasOwnProperty;
    O5 = Object.prototype.propertyIsEnumerable;
    l6 = (r9, t5, e10) => t5 in r9 ? P4(r9, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : r9[t5] = e10;
    p4 = (r9, t5) => {
      for (var e10 in t5 || (t5 = {})) L3.call(t5, e10) && l6(r9, e10, t5[e10]);
      if (c6) for (var e10 of c6(t5)) O5.call(t5, e10) && l6(r9, e10, t5[e10]);
      return r9;
    };
    v5 = (r9, t5) => w4(r9, E4(t5));
    j3 = { Accept: "application/json", "Content-Type": "application/json" };
    T3 = "POST";
    d4 = { headers: j3, method: T3 };
    g3 = 10;
    f7 = class {
      constructor(t5, e10 = false) {
        if (this.url = t5, this.disableProviderPing = e10, this.events = new import_events9.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t5)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t5}`);
        this.url = t5, this.disableProviderPing = e10;
      }
      get connected() {
        return this.isAvailable;
      }
      get connecting() {
        return this.registering;
      }
      on(t5, e10) {
        this.events.on(t5, e10);
      }
      once(t5, e10) {
        this.events.once(t5, e10);
      }
      off(t5, e10) {
        this.events.off(t5, e10);
      }
      removeListener(t5, e10) {
        this.events.removeListener(t5, e10);
      }
      async open(t5 = this.url) {
        await this.register(t5);
      }
      async close() {
        if (!this.isAvailable) throw new Error("Connection already closed");
        this.onClose();
      }
      async send(t5) {
        this.isAvailable || await this.register();
        try {
          const e10 = safeJsonStringify(t5), s8 = await (await (0, import_cross_fetch.default)(this.url, v5(p4({}, d4), { body: e10 }))).json();
          this.onPayload({ data: s8 });
        } catch (e10) {
          this.onError(t5.id, e10);
        }
      }
      async register(t5 = this.url) {
        if (!isHttpUrl(t5)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t5}`);
        if (this.registering) {
          const e10 = this.events.getMaxListeners();
          return (this.events.listenerCount("register_error") >= e10 || this.events.listenerCount("open") >= e10) && this.events.setMaxListeners(e10 + 1), new Promise((s8, i11) => {
            this.events.once("register_error", (n12) => {
              this.resetMaxListeners(), i11(n12);
            }), this.events.once("open", () => {
              if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i11(new Error("HTTP connection is missing or invalid"));
              s8();
            });
          });
        }
        this.url = t5, this.registering = true;
        try {
          if (!this.disableProviderPing) {
            const e10 = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
            await (0, import_cross_fetch.default)(t5, v5(p4({}, d4), { body: e10 }));
          }
          this.onOpen();
        } catch (e10) {
          const s8 = this.parseError(e10);
          throw this.events.emit("register_error", s8), this.onClose(), s8;
        }
      }
      onOpen() {
        this.isAvailable = true, this.registering = false, this.events.emit("open");
      }
      onClose() {
        this.isAvailable = false, this.registering = false, this.events.emit("close");
      }
      onPayload(t5) {
        if (typeof t5.data > "u") return;
        const e10 = typeof t5.data == "string" ? safeJsonParse(t5.data) : t5.data;
        this.events.emit("payload", e10);
      }
      onError(t5, e10) {
        const s8 = this.parseError(e10), i11 = s8.message || s8.toString(), n12 = formatJsonRpcError(t5, i11);
        this.events.emit("payload", n12);
      }
      parseError(t5, e10 = this.url) {
        return parseConnectionError(t5, e10, "HTTP");
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > g3 && this.events.setMaxListeners(g3);
      }
    };
  }
});

// node_modules/@walletconnect/universal-provider/dist/index.es.js
function W4(i11) {
  return i11 == null || typeof i11 != "object" && typeof i11 != "function";
}
function at2(i11) {
  return Object.getOwnPropertySymbols(i11).filter((t5) => Object.prototype.propertyIsEnumerable.call(i11, t5));
}
function ct4(i11) {
  return i11 == null ? i11 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(i11);
}
function K3(i11) {
  return ArrayBuffer.isView(i11) && !(i11 instanceof DataView);
}
function ce3(i11, t5) {
  return $3(i11, void 0, i11, /* @__PURE__ */ new Map(), t5);
}
function $3(i11, t5, e10, s8 = /* @__PURE__ */ new Map(), n12 = void 0) {
  const a5 = n12?.(i11, t5, e10, s8);
  if (a5 != null) return a5;
  if (W4(i11)) return i11;
  if (s8.has(i11)) return s8.get(i11);
  if (Array.isArray(i11)) {
    const r9 = new Array(i11.length);
    s8.set(i11, r9);
    for (let c12 = 0; c12 < i11.length; c12++) r9[c12] = $3(i11[c12], c12, e10, s8, n12);
    return Object.hasOwn(i11, "index") && (r9.index = i11.index), Object.hasOwn(i11, "input") && (r9.input = i11.input), r9;
  }
  if (i11 instanceof Date) return new Date(i11.getTime());
  if (i11 instanceof RegExp) {
    const r9 = new RegExp(i11.source, i11.flags);
    return r9.lastIndex = i11.lastIndex, r9;
  }
  if (i11 instanceof Map) {
    const r9 = /* @__PURE__ */ new Map();
    s8.set(i11, r9);
    for (const [c12, o13] of i11) r9.set(c12, $3(o13, c12, e10, s8, n12));
    return r9;
  }
  if (i11 instanceof Set) {
    const r9 = /* @__PURE__ */ new Set();
    s8.set(i11, r9);
    for (const c12 of i11) r9.add($3(c12, void 0, e10, s8, n12));
    return r9;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(i11)) return i11.subarray();
  if (K3(i11)) {
    const r9 = new (Object.getPrototypeOf(i11)).constructor(i11.length);
    s8.set(i11, r9);
    for (let c12 = 0; c12 < i11.length; c12++) r9[c12] = $3(i11[c12], c12, e10, s8, n12);
    return r9;
  }
  if (i11 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && i11 instanceof SharedArrayBuffer) return i11.slice(0);
  if (i11 instanceof DataView) {
    const r9 = new DataView(i11.buffer.slice(0), i11.byteOffset, i11.byteLength);
    return s8.set(i11, r9), y5(r9, i11, e10, s8, n12), r9;
  }
  if (typeof File < "u" && i11 instanceof File) {
    const r9 = new File([i11], i11.name, { type: i11.type });
    return s8.set(i11, r9), y5(r9, i11, e10, s8, n12), r9;
  }
  if (i11 instanceof Blob) {
    const r9 = new Blob([i11], { type: i11.type });
    return s8.set(i11, r9), y5(r9, i11, e10, s8, n12), r9;
  }
  if (i11 instanceof Error) {
    const r9 = new i11.constructor();
    return s8.set(i11, r9), r9.message = i11.message, r9.name = i11.name, r9.stack = i11.stack, r9.cause = i11.cause, y5(r9, i11, e10, s8, n12), r9;
  }
  if (typeof i11 == "object" && oe(i11)) {
    const r9 = Object.create(Object.getPrototypeOf(i11));
    return s8.set(i11, r9), y5(r9, i11, e10, s8, n12), r9;
  }
  return i11;
}
function y5(i11, t5, e10 = i11, s8, n12) {
  const a5 = [...Object.keys(t5), ...at2(t5)];
  for (let r9 = 0; r9 < a5.length; r9++) {
    const c12 = a5[r9], o13 = Object.getOwnPropertyDescriptor(i11, c12);
    (o13 == null || o13.writable) && (i11[c12] = $3(t5[c12], c12, e10, s8, n12));
  }
}
function oe(i11) {
  switch (ct4(i11)) {
    case dt4:
    case Vt4:
    case Xt4:
    case Qt4:
    case pt3:
    case kt4:
    case ne3:
    case ae3:
    case ie3:
    case se3:
    case re2:
    case Wt4:
    case ht4:
    case Yt4:
    case Jt4:
    case Kt4:
    case ot2:
    case zt4:
    case Zt4:
    case Tt4:
    case te3:
    case ee3:
      return true;
    default:
      return false;
  }
}
function he4(i11, t5) {
  return ce3(i11, (e10, s8, n12, a5) => {
    const r9 = t5?.(e10, s8, n12, a5);
    if (r9 != null) return r9;
    if (typeof i11 == "object") switch (Object.prototype.toString.call(i11)) {
      case ht4:
      case ot2:
      case pt3: {
        const c12 = new i11.constructor(i11?.valueOf());
        return y5(c12, i11), c12;
      }
      case dt4: {
        const c12 = {};
        return y5(c12, i11), c12.length = i11.length, c12[Symbol.iterator] = i11[Symbol.iterator], c12;
      }
      default:
        return;
    }
  });
}
function ut4(i11) {
  return he4(i11);
}
function lt4(i11) {
  return i11 !== null && typeof i11 == "object" && ct4(i11) === "[object Arguments]";
}
function ft3(i11) {
  return typeof i11 == "object" && i11 !== null;
}
function pe4() {
}
function de4(i11) {
  return K3(i11);
}
function ue3(i11) {
  if (typeof i11 != "object" || i11 == null) return false;
  if (Object.getPrototypeOf(i11) === null) return true;
  if (Object.prototype.toString.call(i11) !== "[object Object]") {
    const e10 = i11[Symbol.toStringTag];
    return e10 == null || !Object.getOwnPropertyDescriptor(i11, Symbol.toStringTag)?.writable ? false : i11.toString() === `[object ${e10}]`;
  }
  let t5 = i11;
  for (; Object.getPrototypeOf(t5) !== null; ) t5 = Object.getPrototypeOf(t5);
  return Object.getPrototypeOf(i11) === t5;
}
function le4(i11) {
  if (W4(i11)) return i11;
  if (Array.isArray(i11) || K3(i11) || i11 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && i11 instanceof SharedArrayBuffer) return i11.slice(0);
  const t5 = Object.getPrototypeOf(i11), e10 = t5.constructor;
  if (i11 instanceof Date || i11 instanceof Map || i11 instanceof Set) return new e10(i11);
  if (i11 instanceof RegExp) {
    const s8 = new e10(i11);
    return s8.lastIndex = i11.lastIndex, s8;
  }
  if (i11 instanceof DataView) return new e10(i11.buffer.slice(0));
  if (i11 instanceof Error) {
    const s8 = new e10(i11.message);
    return s8.stack = i11.stack, s8.name = i11.name, s8.cause = i11.cause, s8;
  }
  if (typeof File < "u" && i11 instanceof File) return new e10([i11], i11.name, { type: i11.type, lastModified: i11.lastModified });
  if (typeof i11 == "object") {
    const s8 = Object.create(t5);
    return Object.assign(s8, i11);
  }
  return i11;
}
function fe4(i11, ...t5) {
  const e10 = t5.slice(0, -1), s8 = t5[t5.length - 1];
  let n12 = i11;
  for (let a5 = 0; a5 < e10.length; a5++) {
    const r9 = e10[a5];
    n12 = x5(n12, r9, s8, /* @__PURE__ */ new Map());
  }
  return n12;
}
function x5(i11, t5, e10, s8) {
  if (W4(i11) && (i11 = Object(i11)), t5 == null || typeof t5 != "object") return i11;
  if (s8.has(t5)) return le4(s8.get(t5));
  if (s8.set(t5, i11), Array.isArray(t5)) {
    t5 = t5.slice();
    for (let a5 = 0; a5 < t5.length; a5++) t5[a5] = t5[a5] ?? void 0;
  }
  const n12 = [...Object.keys(t5), ...at2(t5)];
  for (let a5 = 0; a5 < n12.length; a5++) {
    const r9 = n12[a5];
    let c12 = t5[r9], o13 = i11[r9];
    if (lt4(c12) && (c12 = { ...c12 }), lt4(o13) && (o13 = { ...o13 }), typeof Buffer < "u" && Buffer.isBuffer(c12) && (c12 = ut4(c12)), Array.isArray(c12)) if (typeof o13 == "object" && o13 != null) {
      const v8 = [], w6 = Reflect.ownKeys(o13);
      for (let P8 = 0; P8 < w6.length; P8++) {
        const d7 = w6[P8];
        v8[d7] = o13[d7];
      }
      o13 = v8;
    } else o13 = [];
    const p8 = e10(o13, c12, r9, i11, t5, s8);
    p8 != null ? i11[r9] = p8 : Array.isArray(c12) || ft3(o13) && ft3(c12) ? i11[r9] = x5(o13, c12, e10, s8) : o13 == null && ue3(c12) ? i11[r9] = x5({}, c12, e10, s8) : o13 == null && de4(c12) ? i11[r9] = ut4(c12) : (o13 === void 0 || c12 !== void 0) && (i11[r9] = c12);
  }
  return i11;
}
function me4(i11, ...t5) {
  return fe4(i11, ...t5, pe4);
}
function u2(i11, t5, e10) {
  var s8;
  const n12 = Fe(i11);
  return ((s8 = t5.rpcMap) == null ? void 0 : s8[n12.reference]) || `${nt3}?chainId=${n12.namespace}:${n12.reference}&projectId=${e10}`;
}
function b4(i11) {
  return i11.includes(":") ? i11.split(":")[1] : i11;
}
function gt4(i11) {
  return i11.map((t5) => `${t5.split(":")[0]}:${t5.split(":")[1]}`);
}
function Ie4(i11, t5) {
  const e10 = Object.keys(t5.namespaces).filter((n12) => n12.includes(i11));
  if (!e10.length) return [];
  const s8 = [];
  return e10.forEach((n12) => {
    const a5 = t5.namespaces[n12].accounts;
    s8.push(...a5);
  }), s8;
}
function Pt4(i11) {
  return Object.fromEntries(Object.entries(i11).filter(([t5, e10]) => {
    var s8, n12;
    return ((s8 = e10?.chains) == null ? void 0 : s8.length) && ((n12 = e10?.chains) == null ? void 0 : n12.length) > 0;
  }));
}
function M4(i11 = {}, t5 = {}) {
  const e10 = Pt4(wt4(i11)), s8 = Pt4(wt4(t5));
  return me4(e10, s8);
}
function wt4(i11) {
  var t5, e10, s8, n12, a5;
  const r9 = {};
  if (!Ve2(i11)) return r9;
  for (const [c12, o13] of Object.entries(i11)) {
    const p8 = Pn2(c12) ? [c12] : o13.chains, v8 = o13.methods || [], w6 = o13.events || [], P8 = o13.rpcMap || {}, d7 = Yo2(c12);
    r9[d7] = be4(L4(L4({}, r9[d7]), o13), { chains: ct2(p8, (t5 = r9[d7]) == null ? void 0 : t5.chains), methods: ct2(v8, (e10 = r9[d7]) == null ? void 0 : e10.methods), events: ct2(w6, (s8 = r9[d7]) == null ? void 0 : s8.events) }), (Ve2(P8) || Ve2(((n12 = r9[d7]) == null ? void 0 : n12.rpcMap) || {})) && (r9[d7].rpcMap = L4(L4({}, P8), (a5 = r9[d7]) == null ? void 0 : a5.rpcMap));
  }
  return r9;
}
function yt3(i11) {
  return i11.includes(":") ? i11.split(":")[2] : i11;
}
function bt3(i11) {
  const t5 = {};
  for (const [e10, s8] of Object.entries(i11)) {
    const n12 = s8.methods || [], a5 = s8.events || [], r9 = s8.accounts || [], c12 = Pn2(e10) ? [e10] : s8.chains ? s8.chains : gt4(s8.accounts);
    t5[e10] = { chains: c12, methods: n12, events: a5, accounts: r9 };
  }
  return t5;
}
function V3(i11) {
  return typeof i11 == "number" ? i11 : i11.includes("0x") ? parseInt(i11, 16) : (i11 = i11.includes(":") ? i11.split(":")[1] : i11, isNaN(Number(i11)) ? i11 : Number(i11));
}
var import_events10, rt3, Lt4, Mt4, Bt4, U3, nt3, I4, Gt4, l7, Jt4, ot2, ht4, pt3, dt4, zt4, kt4, Wt4, Kt4, Vt4, Xt4, Yt4, Qt4, Zt4, Tt4, te3, ee3, ie3, se3, re2, ne3, ae3, ve3, ge4, Pe4, mt3, we4, ye4, vt4, L4, be4, It4, h6, X3, $e4, $t4, Oe3, Ae3, Ot4, At3, Ct3, Ce5, Ee4, Y3, Et5, He4, Se4, Ne3, O6, De4, qe4, je4, Re3, Ht4, _e5, Fe3, Q4, St5, Nt4, A4, Ue4, xe3, Le5, C4, Me5, Be4, Ge3, E5, Je3, ze3, ke5, H2, We3, Ke5, Ve4, S4, Xe4, Ye4, Qe4, N12, Ze4, Te4, ti2, D3, ei3, ii3, si3, q, ri3, ni3, ai3, j4, ci3, oi3, hi3, R3, pi3, di3, ui3, li3, Dt3, fi3, mi3, Z2, B3, T4, f8, G4, vi3;
var init_index_es14 = __esm({
  "node_modules/@walletconnect/universal-provider/dist/index.es.js"() {
    init_index_es12();
    init_index_es7();
    init_index_es3();
    init_index_es13();
    init_index_es9();
    init_esm7();
    import_events10 = __toESM(require_events());
    rt3 = "error";
    Lt4 = "wss://relay.walletconnect.org";
    Mt4 = "wc";
    Bt4 = "universal_provider";
    U3 = `${Mt4}@2:${Bt4}:`;
    nt3 = "https://rpc.walletconnect.org/v1/";
    I4 = "generic";
    Gt4 = `${nt3}bundler`;
    l7 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
    Jt4 = "[object RegExp]";
    ot2 = "[object String]";
    ht4 = "[object Number]";
    pt3 = "[object Boolean]";
    dt4 = "[object Arguments]";
    zt4 = "[object Symbol]";
    kt4 = "[object Date]";
    Wt4 = "[object Map]";
    Kt4 = "[object Set]";
    Vt4 = "[object Array]";
    Xt4 = "[object ArrayBuffer]";
    Yt4 = "[object Object]";
    Qt4 = "[object DataView]";
    Zt4 = "[object Uint8Array]";
    Tt4 = "[object Uint8ClampedArray]";
    te3 = "[object Uint16Array]";
    ee3 = "[object Uint32Array]";
    ie3 = "[object Int8Array]";
    se3 = "[object Int16Array]";
    re2 = "[object Int32Array]";
    ne3 = "[object Float32Array]";
    ae3 = "[object Float64Array]";
    ve3 = Object.defineProperty;
    ge4 = Object.defineProperties;
    Pe4 = Object.getOwnPropertyDescriptors;
    mt3 = Object.getOwnPropertySymbols;
    we4 = Object.prototype.hasOwnProperty;
    ye4 = Object.prototype.propertyIsEnumerable;
    vt4 = (i11, t5, e10) => t5 in i11 ? ve3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    L4 = (i11, t5) => {
      for (var e10 in t5 || (t5 = {})) we4.call(t5, e10) && vt4(i11, e10, t5[e10]);
      if (mt3) for (var e10 of mt3(t5)) ye4.call(t5, e10) && vt4(i11, e10, t5[e10]);
      return i11;
    };
    be4 = (i11, t5) => ge4(i11, Pe4(t5));
    It4 = {};
    h6 = (i11) => It4[i11];
    X3 = (i11, t5) => {
      It4[i11] = t5;
    };
    $e4 = Object.defineProperty;
    $t4 = Object.getOwnPropertySymbols;
    Oe3 = Object.prototype.hasOwnProperty;
    Ae3 = Object.prototype.propertyIsEnumerable;
    Ot4 = (i11, t5, e10) => t5 in i11 ? $e4(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    At3 = (i11, t5) => {
      for (var e10 in t5 || (t5 = {})) Oe3.call(t5, e10) && Ot4(i11, e10, t5[e10]);
      if ($t4) for (var e10 of $t4(t5)) Ae3.call(t5, e10) && Ot4(i11, e10, t5[e10]);
      return i11;
    };
    Ct3 = "eip155";
    Ce5 = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"];
    Ee4 = (i11) => i11 && i11.startsWith("0x") ? BigInt(i11).toString(10) : i11;
    Y3 = (i11) => i11 && i11.startsWith("0x") ? i11 : `0x${BigInt(i11).toString(16)}`;
    Et5 = (i11) => Object.keys(i11).filter((t5) => Ce5.includes(t5)).reduce((t5, e10) => (t5[e10] = i11[e10], t5), {});
    He4 = (i11, t5, e10) => {
      const { sessionProperties: s8 = {}, scopedProperties: n12 = {} } = i11, a5 = {};
      if (!Ve2(n12) && !Ve2(s8)) return;
      const r9 = Et5(s8);
      for (const c12 of e10) {
        const o13 = Ee4(c12);
        if (!o13) continue;
        a5[Y3(o13)] = r9;
        const p8 = n12?.[`${Ct3}:${o13}`];
        if (p8) {
          const v8 = p8?.[`${Ct3}:${o13}:${t5}`];
          a5[Y3(o13)] = At3(At3({}, a5[Y3(o13)]), Et5(v8 || p8));
        }
      }
      for (const [c12, o13] of Object.entries(a5)) Object.keys(o13).length === 0 && delete a5[c12];
      return Object.keys(a5).length > 0 ? a5 : void 0;
    };
    Se4 = Object.defineProperty;
    Ne3 = (i11, t5, e10) => t5 in i11 ? Se4(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    O6 = (i11, t5, e10) => Ne3(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    De4 = class {
      constructor(t5) {
        O6(this, "name", "polkadot"), O6(this, "client"), O6(this, "httpProviders"), O6(this, "events"), O6(this, "namespace"), O6(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${t5}`);
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]) || [] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          const n12 = b4(e10);
          t5[n12] = this.createHttpProvider(n12, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    qe4 = Object.defineProperty;
    je4 = Object.defineProperties;
    Re3 = Object.getOwnPropertyDescriptors;
    Ht4 = Object.getOwnPropertySymbols;
    _e5 = Object.prototype.hasOwnProperty;
    Fe3 = Object.prototype.propertyIsEnumerable;
    Q4 = (i11, t5, e10) => t5 in i11 ? qe4(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    St5 = (i11, t5) => {
      for (var e10 in t5 || (t5 = {})) _e5.call(t5, e10) && Q4(i11, e10, t5[e10]);
      if (Ht4) for (var e10 of Ht4(t5)) Fe3.call(t5, e10) && Q4(i11, e10, t5[e10]);
      return i11;
    };
    Nt4 = (i11, t5) => je4(i11, Re3(t5));
    A4 = (i11, t5, e10) => Q4(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    Ue4 = class {
      constructor(t5) {
        A4(this, "name", "eip155"), A4(this, "client"), A4(this, "chainId"), A4(this, "namespace"), A4(this, "httpProviders"), A4(this, "events"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
      }
      async request(t5) {
        switch (t5.request.method) {
          case "eth_requestAccounts":
            return this.getAccounts();
          case "eth_accounts":
            return this.getAccounts();
          case "wallet_switchEthereumChain":
            return await this.handleSwitchChain(t5);
          case "eth_chainId":
            return parseInt(this.getDefaultChain());
          case "wallet_getCapabilities":
            return await this.getCapabilities(t5);
          case "wallet_getCallsStatus":
            return await this.getCallStatus(t5);
        }
        return this.namespace.methods.includes(t5.request.method) ? await this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(parseInt(t5), e10), this.chainId = parseInt(t5), this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${t5}`);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(`${this.name}:${t5}`, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          const n12 = parseInt(b4(e10));
          t5[n12] = this.createHttpProvider(n12, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      getHttpProvider() {
        const t5 = this.chainId, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      async handleSwitchChain(t5) {
        var e10, s8;
        let n12 = t5.request.params ? (e10 = t5.request.params[0]) == null ? void 0 : e10.chainId : "0x0";
        n12 = n12.startsWith("0x") ? n12 : `0x${n12}`;
        const a5 = parseInt(n12, 16);
        if (this.isChainApproved(a5)) this.setDefaultChain(`${a5}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t5.topic, request: { method: t5.request.method, params: [{ chainId: n12 }] }, chainId: (s8 = this.namespace.chains) == null ? void 0 : s8[0] }), this.setDefaultChain(`${a5}`);
        else throw new Error(`Failed to switch to chain 'eip155:${a5}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
        return null;
      }
      isChainApproved(t5) {
        return this.namespace.chains.includes(`${this.name}:${t5}`);
      }
      async getCapabilities(t5) {
        var e10, s8, n12, a5, r9;
        const c12 = (s8 = (e10 = t5.request) == null ? void 0 : e10.params) == null ? void 0 : s8[0], o13 = ((a5 = (n12 = t5.request) == null ? void 0 : n12.params) == null ? void 0 : a5[1]) || [];
        if (!c12) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
        const p8 = this.client.session.get(t5.topic), v8 = ((r9 = p8?.sessionProperties) == null ? void 0 : r9.capabilities) || {}, w6 = `${c12}${o13.join(",")}`, P8 = v8?.[w6];
        if (P8) return P8;
        let d7;
        try {
          d7 = He4(p8, c12, o13);
        } catch (J5) {
          console.warn("Failed to extract capabilities from session", J5);
        }
        if (d7) return d7;
        const tt3 = await this.client.request(t5);
        try {
          await this.client.session.update(t5.topic, { sessionProperties: Nt4(St5({}, p8.sessionProperties || {}), { capabilities: Nt4(St5({}, v8 || {}), { [w6]: tt3 }) }) });
        } catch (J5) {
          console.warn("Failed to update session with capabilities", J5);
        }
        return tt3;
      }
      async getCallStatus(t5) {
        var e10, s8;
        const n12 = this.client.session.get(t5.topic), a5 = (e10 = n12.sessionProperties) == null ? void 0 : e10.bundler_name;
        if (a5) {
          const c12 = this.getBundlerUrl(t5.chainId, a5);
          try {
            return await this.getUserOperationReceipt(c12, t5);
          } catch (o13) {
            console.warn("Failed to fetch call status from bundler", o13, c12);
          }
        }
        const r9 = (s8 = n12.sessionProperties) == null ? void 0 : s8.bundler_url;
        if (r9) try {
          return await this.getUserOperationReceipt(r9, t5);
        } catch (c12) {
          console.warn("Failed to fetch call status from custom bundler", c12, r9);
        }
        if (this.namespace.methods.includes(t5.request.method)) return await this.client.request(t5);
        throw new Error("Fetching call status not approved by the wallet.");
      }
      async getUserOperationReceipt(t5, e10) {
        var s8;
        const n12 = new URL(t5), a5 = await fetch(n12, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(s8 = e10.request.params) == null ? void 0 : s8[0]])) });
        if (!a5.ok) throw new Error(`Failed to fetch user operation receipt - ${a5.status}`);
        return await a5.json();
      }
      getBundlerUrl(t5, e10) {
        return `${Gt4}?projectId=${this.client.core.projectId}&chainId=${t5}&bundler=${e10}`;
      }
    };
    xe3 = Object.defineProperty;
    Le5 = (i11, t5, e10) => t5 in i11 ? xe3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    C4 = (i11, t5, e10) => Le5(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    Me5 = class {
      constructor(t5) {
        C4(this, "name", "solana"), C4(this, "client"), C4(this, "httpProviders"), C4(this, "events"), C4(this, "namespace"), C4(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${t5}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          const n12 = b4(e10);
          t5[n12] = this.createHttpProvider(n12, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    Be4 = Object.defineProperty;
    Ge3 = (i11, t5, e10) => t5 in i11 ? Be4(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    E5 = (i11, t5, e10) => Ge3(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    Je3 = class {
      constructor(t5) {
        E5(this, "name", "cosmos"), E5(this, "client"), E5(this, "httpProviders"), E5(this, "events"), E5(this, "namespace"), E5(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          const n12 = b4(e10);
          t5[n12] = this.createHttpProvider(n12, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    ze3 = Object.defineProperty;
    ke5 = (i11, t5, e10) => t5 in i11 ? ze3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    H2 = (i11, t5, e10) => ke5(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    We3 = class {
      constructor(t5) {
        H2(this, "name", "algorand"), H2(this, "client"), H2(this, "httpProviders"), H2(this, "events"), H2(this, "namespace"), H2(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        if (!this.httpProviders[t5]) {
          const s8 = e10 || u2(`${this.name}:${t5}`, this.namespace, this.client.core.projectId);
          if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
          this.setHttpProvider(t5, s8);
        }
        this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          t5[e10] = this.createHttpProvider(e10, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        return typeof s8 > "u" ? void 0 : new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    Ke5 = Object.defineProperty;
    Ve4 = (i11, t5, e10) => t5 in i11 ? Ke5(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    S4 = (i11, t5, e10) => Ve4(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    Xe4 = class {
      constructor(t5) {
        S4(this, "name", "cip34"), S4(this, "client"), S4(this, "httpProviders"), S4(this, "events"), S4(this, "namespace"), S4(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          const s8 = this.getCardanoRPCUrl(e10), n12 = b4(e10);
          t5[n12] = this.createHttpProvider(n12, s8);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      getCardanoRPCUrl(t5) {
        const e10 = this.namespace.rpcMap;
        if (e10) return e10[t5];
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || this.getCardanoRPCUrl(t5);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    Ye4 = Object.defineProperty;
    Qe4 = (i11, t5, e10) => t5 in i11 ? Ye4(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    N12 = (i11, t5, e10) => Qe4(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    Ze4 = class {
      constructor(t5) {
        N12(this, "name", "elrond"), N12(this, "client"), N12(this, "httpProviders"), N12(this, "events"), N12(this, "namespace"), N12(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${t5}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          const n12 = b4(e10);
          t5[n12] = this.createHttpProvider(n12, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    Te4 = Object.defineProperty;
    ti2 = (i11, t5, e10) => t5 in i11 ? Te4(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    D3 = (i11, t5, e10) => ti2(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    ei3 = class {
      constructor(t5) {
        D3(this, "name", "multiversx"), D3(this, "client"), D3(this, "httpProviders"), D3(this, "events"), D3(this, "namespace"), D3(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${t5}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          const n12 = b4(e10);
          t5[n12] = this.createHttpProvider(n12, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    ii3 = Object.defineProperty;
    si3 = (i11, t5, e10) => t5 in i11 ? ii3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    q = (i11, t5, e10) => si3(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    ri3 = class {
      constructor(t5) {
        q(this, "name", "near"), q(this, "client"), q(this, "httpProviders"), q(this, "events"), q(this, "namespace"), q(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        if (this.chainId = t5, !this.httpProviders[t5]) {
          const s8 = e10 || u2(`${this.name}:${t5}`, this.namespace);
          if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
          this.setHttpProvider(t5, s8);
        }
        this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]) || [] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          var s8;
          t5[e10] = this.createHttpProvider(e10, (s8 = this.namespace.rpcMap) == null ? void 0 : s8[e10]);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace);
        return typeof s8 > "u" ? void 0 : new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    ni3 = Object.defineProperty;
    ai3 = (i11, t5, e10) => t5 in i11 ? ni3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    j4 = (i11, t5, e10) => ai3(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    ci3 = class {
      constructor(t5) {
        j4(this, "name", "tezos"), j4(this, "client"), j4(this, "httpProviders"), j4(this, "events"), j4(this, "namespace"), j4(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace = Object.assign(this.namespace, t5);
      }
      requestAccounts() {
        return this.getAccounts();
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider().request(t5.request);
      }
      setDefaultChain(t5, e10) {
        if (this.chainId = t5, !this.httpProviders[t5]) {
          const s8 = e10 || u2(`${this.name}:${t5}`, this.namespace);
          if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
          this.setHttpProvider(t5, s8);
        }
        this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]) || [] : [];
      }
      createHttpProviders() {
        const t5 = {};
        return this.namespace.chains.forEach((e10) => {
          t5[e10] = this.createHttpProvider(e10);
        }), t5;
      }
      getHttpProvider() {
        const t5 = `${this.name}:${this.chainId}`, e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace);
        return typeof s8 > "u" ? void 0 : new o3(new f7(s8));
      }
    };
    oi3 = Object.defineProperty;
    hi3 = (i11, t5, e10) => t5 in i11 ? oi3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    R3 = (i11, t5, e10) => hi3(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    pi3 = class {
      constructor(t5) {
        R3(this, "name", I4), R3(this, "client"), R3(this, "httpProviders"), R3(this, "events"), R3(this, "namespace"), R3(this, "chainId"), this.namespace = t5.namespace, this.events = h6("events"), this.client = h6("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
      }
      updateNamespace(t5) {
        this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t5.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t5.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t5.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t5.events || []))], this.httpProviders = this.createHttpProviders();
      }
      requestAccounts() {
        return this.getAccounts();
      }
      request(t5) {
        return this.namespace.methods.includes(t5.request.method) ? this.client.request(t5) : this.getHttpProvider(t5.chainId).request(t5.request);
      }
      setDefaultChain(t5, e10) {
        this.httpProviders[t5] || this.setHttpProvider(t5, e10), this.chainId = t5, this.events.emit(l7.DEFAULT_CHAIN_CHANGED, `${this.name}:${t5}`);
      }
      getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const t5 = this.namespace.chains[0];
        if (!t5) throw new Error("ChainId not found");
        return t5.split(":")[1];
      }
      getAccounts() {
        const t5 = this.namespace.accounts;
        return t5 ? [...new Set(t5.filter((e10) => e10.split(":")[1] === this.chainId.toString()).map((e10) => e10.split(":")[2]))] : [];
      }
      createHttpProviders() {
        var t5, e10;
        const s8 = {};
        return (e10 = (t5 = this.namespace) == null ? void 0 : t5.accounts) == null || e10.forEach((n12) => {
          const a5 = Fe(n12);
          s8[`${a5.namespace}:${a5.reference}`] = this.createHttpProvider(n12);
        }), s8;
      }
      getHttpProvider(t5) {
        const e10 = this.httpProviders[t5];
        if (typeof e10 > "u") throw new Error(`JSON-RPC provider for ${t5} not found`);
        return e10;
      }
      setHttpProvider(t5, e10) {
        const s8 = this.createHttpProvider(t5, e10);
        s8 && (this.httpProviders[t5] = s8);
      }
      createHttpProvider(t5, e10) {
        const s8 = e10 || u2(t5, this.namespace, this.client.core.projectId);
        if (!s8) throw new Error(`No RPC url provided for chainId: ${t5}`);
        return new o3(new f7(s8, h6("disableProviderPing")));
      }
    };
    di3 = Object.defineProperty;
    ui3 = Object.defineProperties;
    li3 = Object.getOwnPropertyDescriptors;
    Dt3 = Object.getOwnPropertySymbols;
    fi3 = Object.prototype.hasOwnProperty;
    mi3 = Object.prototype.propertyIsEnumerable;
    Z2 = (i11, t5, e10) => t5 in i11 ? di3(i11, t5, { enumerable: true, configurable: true, writable: true, value: e10 }) : i11[t5] = e10;
    B3 = (i11, t5) => {
      for (var e10 in t5 || (t5 = {})) fi3.call(t5, e10) && Z2(i11, e10, t5[e10]);
      if (Dt3) for (var e10 of Dt3(t5)) mi3.call(t5, e10) && Z2(i11, e10, t5[e10]);
      return i11;
    };
    T4 = (i11, t5) => ui3(i11, li3(t5));
    f8 = (i11, t5, e10) => Z2(i11, typeof t5 != "symbol" ? t5 + "" : t5, e10);
    G4 = class _G {
      constructor(t5) {
        f8(this, "client"), f8(this, "namespaces"), f8(this, "optionalNamespaces"), f8(this, "sessionProperties"), f8(this, "scopedProperties"), f8(this, "events", new import_events10.default()), f8(this, "rpcProviders", {}), f8(this, "session"), f8(this, "providerOpts"), f8(this, "logger"), f8(this, "uri"), f8(this, "disableProviderPing", false), this.providerOpts = t5, this.logger = typeof t5?.logger < "u" && typeof t5?.logger != "string" ? t5.logger : (0, import_pino2.default)(k2({ level: t5?.logger || rt3 })), this.disableProviderPing = t5?.disableProviderPing || false;
      }
      static async init(t5) {
        const e10 = new _G(t5);
        return await e10.initialize(), e10;
      }
      async request(t5, e10, s8) {
        const [n12, a5] = this.validateChain(e10);
        if (!this.session) throw new Error("Please call connect() before request()");
        return await this.getProvider(n12).request({ request: B3({}, t5), chainId: `${n12}:${a5}`, topic: this.session.topic, expiry: s8 });
      }
      sendAsync(t5, e10, s8, n12) {
        const a5 = (/* @__PURE__ */ new Date()).getTime();
        this.request(t5, s8, n12).then((r9) => e10(null, formatJsonRpcResult(a5, r9))).catch((r9) => e10(r9, void 0));
      }
      async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
      }
      async disconnect() {
        var t5;
        if (!this.session) throw new Error("Please call connect() before enable()");
        await this.client.disconnect({ topic: (t5 = this.session) == null ? void 0 : t5.topic, reason: Kt2("USER_DISCONNECTED") }), await this.cleanup();
      }
      async connect(t5) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (this.setNamespaces(t5), await this.cleanupPendingPairings(), !t5.skipPairing) return await this.pair(t5.pairingTopic);
      }
      async authenticate(t5, e10) {
        if (!this.client) throw new Error("Sign Client not initialized");
        this.setNamespaces(t5), await this.cleanupPendingPairings();
        const { uri: s8, response: n12 } = await this.client.authenticate(t5, e10);
        s8 && (this.uri = s8, this.events.emit("display_uri", s8));
        const a5 = await n12();
        if (this.session = a5.session, this.session) {
          const r9 = bt3(this.session.namespaces);
          this.namespaces = M4(this.namespaces, r9), await this.persist("namespaces", this.namespaces), this.onConnect();
        }
        return a5;
      }
      on(t5, e10) {
        this.events.on(t5, e10);
      }
      once(t5, e10) {
        this.events.once(t5, e10);
      }
      removeListener(t5, e10) {
        this.events.removeListener(t5, e10);
      }
      off(t5, e10) {
        this.events.off(t5, e10);
      }
      get isWalletConnect() {
        return true;
      }
      async pair(t5) {
        const { uri: e10, approval: s8 } = await this.client.connect({ pairingTopic: t5, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
        e10 && (this.uri = e10, this.events.emit("display_uri", e10));
        const n12 = await s8();
        this.session = n12;
        const a5 = bt3(n12.namespaces);
        return this.namespaces = M4(this.namespaces, a5), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
      }
      setDefaultChain(t5, e10) {
        try {
          if (!this.session) return;
          const [s8, n12] = this.validateChain(t5), a5 = this.getProvider(s8);
          a5.name === I4 ? a5.setDefaultChain(`${s8}:${n12}`, e10) : a5.setDefaultChain(n12, e10);
        } catch (s8) {
          if (!/Please call connect/.test(s8.message)) throw s8;
        }
      }
      async cleanupPendingPairings(t5 = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        const e10 = this.client.pairing.getAll();
        if (me2(e10)) {
          for (const s8 of e10) t5.deletePairings ? this.client.core.expirer.set(s8.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s8.topic);
          this.logger.info(`Inactive pairings cleared: ${e10.length}`);
        }
      }
      abortPairingAttempt() {
        this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
      }
      async checkStorage() {
        this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
      }
      async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
      }
      async createClient() {
        var t5, e10;
        if (this.client = this.providerOpts.client || await Ee3.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || rt3, relayUrl: this.providerOpts.relayUrl || Lt4, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
          this.session = this.client.session.get(this.providerOpts.session.topic);
        } catch (s8) {
          throw this.logger.error("Failed to get session", s8), new Error(`The provided session: ${(e10 = (t5 = this.providerOpts) == null ? void 0 : t5.session) == null ? void 0 : e10.topic} doesn't exist in the Sign client`);
        }
        else {
          const s8 = this.client.session.getAll();
          this.session = s8[0];
        }
        this.logger.trace("SignClient Initialized");
      }
      createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
        const t5 = [...new Set(Object.keys(this.session.namespaces).map((e10) => Yo2(e10)))];
        X3("client", this.client), X3("events", this.events), X3("disableProviderPing", this.disableProviderPing), t5.forEach((e10) => {
          if (!this.session) return;
          const s8 = Ie4(e10, this.session);
          if (s8?.length === 0) return;
          const n12 = gt4(s8), a5 = M4(this.namespaces, this.optionalNamespaces), r9 = T4(B3({}, a5[e10]), { accounts: s8, chains: n12 });
          switch (e10) {
            case "eip155":
              this.rpcProviders[e10] = new Ue4({ namespace: r9 });
              break;
            case "algorand":
              this.rpcProviders[e10] = new We3({ namespace: r9 });
              break;
            case "solana":
              this.rpcProviders[e10] = new Me5({ namespace: r9 });
              break;
            case "cosmos":
              this.rpcProviders[e10] = new Je3({ namespace: r9 });
              break;
            case "polkadot":
              this.rpcProviders[e10] = new De4({ namespace: r9 });
              break;
            case "cip34":
              this.rpcProviders[e10] = new Xe4({ namespace: r9 });
              break;
            case "elrond":
              this.rpcProviders[e10] = new Ze4({ namespace: r9 });
              break;
            case "multiversx":
              this.rpcProviders[e10] = new ei3({ namespace: r9 });
              break;
            case "near":
              this.rpcProviders[e10] = new ri3({ namespace: r9 });
              break;
            case "tezos":
              this.rpcProviders[e10] = new ci3({ namespace: r9 });
              break;
            default:
              this.rpcProviders[I4] ? this.rpcProviders[I4].updateNamespace(r9) : this.rpcProviders[I4] = new pi3({ namespace: r9 });
          }
        });
      }
      registerEventListeners() {
        if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", (t5) => {
          var e10;
          const { topic: s8 } = t5;
          s8 === ((e10 = this.session) == null ? void 0 : e10.topic) && this.events.emit("session_ping", t5);
        }), this.client.on("session_event", (t5) => {
          var e10;
          const { params: s8, topic: n12 } = t5;
          if (n12 !== ((e10 = this.session) == null ? void 0 : e10.topic)) return;
          const { event: a5 } = s8;
          if (a5.name === "accountsChanged") {
            const r9 = a5.data;
            r9 && me2(r9) && this.events.emit("accountsChanged", r9.map(yt3));
          } else if (a5.name === "chainChanged") {
            const r9 = s8.chainId, c12 = s8.event.data, o13 = Yo2(r9), p8 = V3(r9) !== V3(c12) ? `${o13}:${V3(c12)}` : r9;
            this.onChainChanged(p8);
          } else this.events.emit(a5.name, a5.data);
          this.events.emit("session_event", t5);
        }), this.client.on("session_update", ({ topic: t5, params: e10 }) => {
          var s8, n12;
          if (t5 !== ((s8 = this.session) == null ? void 0 : s8.topic)) return;
          const { namespaces: a5 } = e10, r9 = (n12 = this.client) == null ? void 0 : n12.session.get(t5);
          this.session = T4(B3({}, r9), { namespaces: a5 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t5, params: e10 });
        }), this.client.on("session_delete", async (t5) => {
          var e10;
          t5.topic === ((e10 = this.session) == null ? void 0 : e10.topic) && (await this.cleanup(), this.events.emit("session_delete", t5), this.events.emit("disconnect", T4(B3({}, Kt2("USER_DISCONNECTED")), { data: t5.topic })));
        }), this.on(l7.DEFAULT_CHAIN_CHANGED, (t5) => {
          this.onChainChanged(t5, true);
        });
      }
      getProvider(t5) {
        return this.rpcProviders[t5] || this.rpcProviders[I4];
      }
      onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach((t5) => {
          var e10;
          this.getProvider(t5).updateNamespace((e10 = this.session) == null ? void 0 : e10.namespaces[t5]);
        });
      }
      setNamespaces(t5) {
        const { namespaces: e10 = {}, optionalNamespaces: s8 = {}, sessionProperties: n12, scopedProperties: a5 } = t5;
        this.optionalNamespaces = M4(e10, s8), this.sessionProperties = n12, this.scopedProperties = a5;
      }
      validateChain(t5) {
        const [e10, s8] = t5?.split(":") || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length) return [e10, s8];
        if (e10 && !Object.keys(this.namespaces || {}).map((r9) => Yo2(r9)).includes(e10)) throw new Error(`Namespace '${e10}' is not configured. Please call connect() first with namespace config.`);
        if (e10 && s8) return [e10, s8];
        const n12 = Yo2(Object.keys(this.namespaces)[0]), a5 = this.rpcProviders[n12].getDefaultChain();
        return [n12, a5];
      }
      async requestAccounts() {
        const [t5] = this.validateChain();
        return await this.getProvider(t5).requestAccounts();
      }
      async onChainChanged(t5, e10 = false) {
        if (!this.namespaces) return;
        const [s8, n12] = this.validateChain(t5);
        if (!n12) return;
        this.updateNamespaceChain(s8, n12), this.events.emit("chainChanged", n12);
        const a5 = this.getProvider(s8).getDefaultChain();
        e10 || this.getProvider(s8).setDefaultChain(n12), this.emitAccountsChangedOnChainChange({ namespace: s8, previousChainId: a5, newChainId: t5 }), await this.persist("namespaces", this.namespaces);
      }
      emitAccountsChangedOnChainChange({ namespace: t5, previousChainId: e10, newChainId: s8 }) {
        var n12, a5;
        try {
          if (e10 === s8) return;
          const r9 = (a5 = (n12 = this.session) == null ? void 0 : n12.namespaces[t5]) == null ? void 0 : a5.accounts;
          if (!r9) return;
          const c12 = r9.filter((o13) => o13.includes(`${s8}:`)).map(yt3);
          if (!me2(c12)) return;
          this.events.emit("accountsChanged", c12);
        } catch (r9) {
          this.logger.warn("Failed to emit accountsChanged on chain change", r9);
        }
      }
      updateNamespaceChain(t5, e10) {
        if (!this.namespaces) return;
        const s8 = this.namespaces[t5] ? t5 : `${t5}:${e10}`, n12 = { chains: [], methods: [], events: [], defaultChain: e10 };
        this.namespaces[s8] ? this.namespaces[s8] && (this.namespaces[s8].defaultChain = e10) : this.namespaces[s8] = n12;
      }
      onConnect() {
        this.createProviders(), this.events.emit("connect", { session: this.session });
      }
      async cleanup() {
        this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
      }
      async persist(t5, e10) {
        var s8;
        const n12 = ((s8 = this.session) == null ? void 0 : s8.topic) || "";
        await this.client.core.storage.setItem(`${U3}/${t5}${n12}`, e10);
      }
      async getFromStore(t5) {
        var e10;
        const s8 = ((e10 = this.session) == null ? void 0 : e10.topic) || "";
        return await this.client.core.storage.getItem(`${U3}/${t5}${s8}`);
      }
      async deleteFromStore(t5) {
        var e10;
        const s8 = ((e10 = this.session) == null ? void 0 : e10.topic) || "";
        await this.client.core.storage.removeItem(`${U3}/${t5}${s8}`);
      }
      async cleanupStorage() {
        var t5;
        try {
          if (((t5 = this.client) == null ? void 0 : t5.session.length) > 0) return;
          const e10 = await this.client.core.storage.getKeys();
          for (const s8 of e10) s8.startsWith(U3) && await this.client.core.storage.removeItem(s8);
        } catch (e10) {
          this.logger.warn("Failed to cleanup storage", e10);
        }
      }
    };
    vi3 = G4;
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil;
var init_ConstantsUtil = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/ConstantsUtil.js"() {
    ConstantsUtil = {
      WC_NAME_SUFFIX: ".reown.id",
      WC_NAME_SUFFIX_LEGACY: ".wcn.id",
      BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
      PULSE_API_URL: "https://pulse.walletconnect.org",
      W3M_API_URL: "https://api.web3modal.org",
      CONNECTOR_ID: {
        WALLET_CONNECT: "walletConnect",
        INJECTED: "injected",
        WALLET_STANDARD: "announced",
        COINBASE: "coinbaseWallet",
        COINBASE_SDK: "coinbaseWalletSDK",
        SAFE: "safe",
        LEDGER: "ledger",
        OKX: "okx",
        EIP6963: "eip6963",
        AUTH: "ID_AUTH"
      },
      CONNECTOR_NAMES: {
        AUTH: "Auth"
      },
      AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
      LIMITS: {
        PENDING_TRANSACTIONS: 99
      },
      CHAIN: {
        EVM: "eip155",
        SOLANA: "solana",
        POLKADOT: "polkadot",
        BITCOIN: "bip122"
      },
      CHAIN_NAME_MAP: {
        eip155: "EVM Networks",
        solana: "Solana",
        polkadot: "Polkadot",
        bip122: "Bitcoin",
        cosmos: "Cosmos",
        sui: "Sui",
        stacks: "Stacks"
      },
      ADAPTER_TYPES: {
        BITCOIN: "bitcoin",
        SOLANA: "solana",
        WAGMI: "wagmi",
        ETHERS: "ethers",
        ETHERS5: "ethers5"
      },
      USDT_CONTRACT_ADDRESSES: [
        "0xdac17f958d2ee523a2206206994597c13d831ec7",
        "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
        "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
        "0x919C1c267BC06a7039e03fcc2eF738525769109c",
        "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
        "0x55d398326f99059fF775485246999027B3197955",
        "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9"
      ],
      HTTP_STATUS_CODES: {
        SERVER_ERROR: 500,
        TOO_MANY_REQUESTS: 429,
        SERVICE_UNAVAILABLE: 503,
        FORBIDDEN: 403
      },
      UNSUPPORTED_NETWORK_NAME: "Unknown Network",
      SECURE_SITE_SDK_ORIGIN: (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org",
      REMOTE_FEATURES_ALERTS: {
        MULTI_WALLET_NOT_ENABLED: {
          DEFAULT: {
            displayMessage: "Multi-Wallet Not Enabled",
            debugMessage: "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com."
          },
          CONNECTIONS_HOOK: {
            displayMessage: "Multi-Wallet Not Enabled",
            debugMessage: "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com to use the useAppKitConnections hook."
          },
          CONNECTION_HOOK: {
            displayMessage: "Multi-Wallet Not Enabled",
            debugMessage: "Multi-wallet support is not enabled. Please enable it in your AppKit configuration at cloud.reown.com to use the useAppKitConnection hook."
          }
        }
      }
    };
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/NetworkUtil.js
var NetworkUtil, AVAILABLE_NAMESPACES;
var init_NetworkUtil = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/NetworkUtil.js"() {
    init_ConstantsUtil();
    NetworkUtil = {
      caipNetworkIdToNumber(caipnetworkId) {
        return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
      },
      parseEvmChainId(chainId) {
        return typeof chainId === "string" ? this.caipNetworkIdToNumber(chainId) : chainId;
      },
      getNetworksByNamespace(networks, namespace) {
        return networks?.filter((network) => network.chainNamespace === namespace) || [];
      },
      getFirstNetworkByNamespace(networks, namespace) {
        return this.getNetworksByNamespace(networks, namespace)[0];
      },
      getNetworkNameByCaipNetworkId(caipNetworks, caipNetworkId) {
        if (!caipNetworkId) {
          return void 0;
        }
        const caipNetwork = caipNetworks.find((network) => network.caipNetworkId === caipNetworkId);
        if (caipNetwork) {
          return caipNetwork.name;
        }
        const [namespace] = caipNetworkId.split(":");
        return ConstantsUtil.CHAIN_NAME_MAP?.[namespace] || void 0;
      }
    };
    AVAILABLE_NAMESPACES = [
      "eip155",
      "solana",
      "polkadot",
      "bip122",
      "cosmos",
      "sui",
      "stacks"
    ];
  }
});

// node_modules/big.js/big.mjs
function _Big_() {
  function Big2(n12) {
    var x7 = this;
    if (!(x7 instanceof Big2)) return n12 === UNDEFINED ? _Big_() : new Big2(n12);
    if (n12 instanceof Big2) {
      x7.s = n12.s;
      x7.e = n12.e;
      x7.c = n12.c.slice();
    } else {
      if (typeof n12 !== "string") {
        if (Big2.strict === true && typeof n12 !== "bigint") {
          throw TypeError(INVALID + "value");
        }
        n12 = n12 === 0 && 1 / n12 < 0 ? "-0" : String(n12);
      }
      parse3(x7, n12);
    }
    x7.constructor = Big2;
  }
  Big2.prototype = P5;
  Big2.DP = DP;
  Big2.RM = RM;
  Big2.NE = NE;
  Big2.PE = PE;
  Big2.strict = STRICT;
  Big2.roundDown = 0;
  Big2.roundHalfUp = 1;
  Big2.roundHalfEven = 2;
  Big2.roundUp = 3;
  return Big2;
}
function parse3(x7, n12) {
  var e10, i11, nl;
  if (!NUMERIC.test(n12)) {
    throw Error(INVALID + "number");
  }
  x7.s = n12.charAt(0) == "-" ? (n12 = n12.slice(1), -1) : 1;
  if ((e10 = n12.indexOf(".")) > -1) n12 = n12.replace(".", "");
  if ((i11 = n12.search(/e/i)) > 0) {
    if (e10 < 0) e10 = i11;
    e10 += +n12.slice(i11 + 1);
    n12 = n12.substring(0, i11);
  } else if (e10 < 0) {
    e10 = n12.length;
  }
  nl = n12.length;
  for (i11 = 0; i11 < nl && n12.charAt(i11) == "0"; ) ++i11;
  if (i11 == nl) {
    x7.c = [x7.e = 0];
  } else {
    for (; nl > 0 && n12.charAt(--nl) == "0"; ) ;
    x7.e = e10 - i11 - 1;
    x7.c = [];
    for (e10 = 0; i11 <= nl; ) x7.c[e10++] = +n12.charAt(i11++);
  }
  return x7;
}
function round(x7, sd, rm, more) {
  var xc2 = x7.c;
  if (rm === UNDEFINED) rm = x7.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc2[0]) || sd === 0 && (rm === 1 && xc2[0] >= 5 || rm === 2 && (xc2[0] > 5 || xc2[0] === 5 && (more || xc2[1] !== UNDEFINED)));
    xc2.length = 1;
    if (more) {
      x7.e = x7.e - sd + 1;
      xc2[0] = 1;
    } else {
      xc2[0] = x7.e = 0;
    }
  } else if (sd < xc2.length) {
    more = rm === 1 && xc2[sd] >= 5 || rm === 2 && (xc2[sd] > 5 || xc2[sd] === 5 && (more || xc2[sd + 1] !== UNDEFINED || xc2[sd - 1] & 1)) || rm === 3 && (more || !!xc2[0]);
    xc2.length = sd;
    if (more) {
      for (; ++xc2[--sd] > 9; ) {
        xc2[sd] = 0;
        if (sd === 0) {
          ++x7.e;
          xc2.unshift(1);
          break;
        }
      }
    }
    for (sd = xc2.length; !xc2[--sd]; ) xc2.pop();
  }
  return x7;
}
function stringify4(x7, doExponential, isNonzero) {
  var e10 = x7.e, s8 = x7.c.join(""), n12 = s8.length;
  if (doExponential) {
    s8 = s8.charAt(0) + (n12 > 1 ? "." + s8.slice(1) : "") + (e10 < 0 ? "e" : "e+") + e10;
  } else if (e10 < 0) {
    for (; ++e10; ) s8 = "0" + s8;
    s8 = "0." + s8;
  } else if (e10 > 0) {
    if (++e10 > n12) {
      for (e10 -= n12; e10--; ) s8 += "0";
    } else if (e10 < n12) {
      s8 = s8.slice(0, e10) + "." + s8.slice(e10);
    }
  } else if (n12 > 1) {
    s8 = s8.charAt(0) + "." + s8.slice(1);
  }
  return x7.s < 0 && isNonzero ? "-" + s8 : s8;
}
var DP, RM, MAX_DP, MAX_POWER, NE, PE, STRICT, NAME, INVALID, INVALID_DP, INVALID_RM, DIV_BY_ZERO, P5, UNDEFINED, NUMERIC, Big, big_default;
var init_big = __esm({
  "node_modules/big.js/big.mjs"() {
    DP = 20;
    RM = 1;
    MAX_DP = 1e6;
    MAX_POWER = 1e6;
    NE = -7;
    PE = 21;
    STRICT = false;
    NAME = "[big.js] ";
    INVALID = NAME + "Invalid ";
    INVALID_DP = INVALID + "decimal places";
    INVALID_RM = INVALID + "rounding mode";
    DIV_BY_ZERO = NAME + "Division by zero";
    P5 = {};
    UNDEFINED = void 0;
    NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    P5.abs = function() {
      var x7 = new this.constructor(this);
      x7.s = 1;
      return x7;
    };
    P5.cmp = function(y9) {
      var isneg, x7 = this, xc2 = x7.c, yc2 = (y9 = new x7.constructor(y9)).c, i11 = x7.s, j7 = y9.s, k7 = x7.e, l10 = y9.e;
      if (!xc2[0] || !yc2[0]) return !xc2[0] ? !yc2[0] ? 0 : -j7 : i11;
      if (i11 != j7) return i11;
      isneg = i11 < 0;
      if (k7 != l10) return k7 > l10 ^ isneg ? 1 : -1;
      j7 = (k7 = xc2.length) < (l10 = yc2.length) ? k7 : l10;
      for (i11 = -1; ++i11 < j7; ) {
        if (xc2[i11] != yc2[i11]) return xc2[i11] > yc2[i11] ^ isneg ? 1 : -1;
      }
      return k7 == l10 ? 0 : k7 > l10 ^ isneg ? 1 : -1;
    };
    P5.div = function(y9) {
      var x7 = this, Big2 = x7.constructor, a5 = x7.c, b7 = (y9 = new Big2(y9)).c, k7 = x7.s == y9.s ? 1 : -1, dp = Big2.DP;
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      if (!b7[0]) {
        throw Error(DIV_BY_ZERO);
      }
      if (!a5[0]) {
        y9.s = k7;
        y9.c = [y9.e = 0];
        return y9;
      }
      var bl, bt4, n12, cmp, ri4, bz = b7.slice(), ai4 = bl = b7.length, al = a5.length, r9 = a5.slice(0, bl), rl = r9.length, q3 = y9, qc2 = q3.c = [], qi3 = 0, p8 = dp + (q3.e = x7.e - y9.e) + 1;
      q3.s = k7;
      k7 = p8 < 0 ? 0 : p8;
      bz.unshift(0);
      for (; rl++ < bl; ) r9.push(0);
      do {
        for (n12 = 0; n12 < 10; n12++) {
          if (bl != (rl = r9.length)) {
            cmp = bl > rl ? 1 : -1;
          } else {
            for (ri4 = -1, cmp = 0; ++ri4 < bl; ) {
              if (b7[ri4] != r9[ri4]) {
                cmp = b7[ri4] > r9[ri4] ? 1 : -1;
                break;
              }
            }
          }
          if (cmp < 0) {
            for (bt4 = rl == bl ? b7 : bz; rl; ) {
              if (r9[--rl] < bt4[rl]) {
                ri4 = rl;
                for (; ri4 && !r9[--ri4]; ) r9[ri4] = 9;
                --r9[ri4];
                r9[rl] += 10;
              }
              r9[rl] -= bt4[rl];
            }
            for (; !r9[0]; ) r9.shift();
          } else {
            break;
          }
        }
        qc2[qi3++] = cmp ? n12 : ++n12;
        if (r9[0] && cmp) r9[rl] = a5[ai4] || 0;
        else r9 = [a5[ai4]];
      } while ((ai4++ < al || r9[0] !== UNDEFINED) && k7--);
      if (!qc2[0] && qi3 != 1) {
        qc2.shift();
        q3.e--;
        p8--;
      }
      if (qi3 > p8) round(q3, p8, Big2.RM, r9[0] !== UNDEFINED);
      return q3;
    };
    P5.eq = function(y9) {
      return this.cmp(y9) === 0;
    };
    P5.gt = function(y9) {
      return this.cmp(y9) > 0;
    };
    P5.gte = function(y9) {
      return this.cmp(y9) > -1;
    };
    P5.lt = function(y9) {
      return this.cmp(y9) < 0;
    };
    P5.lte = function(y9) {
      return this.cmp(y9) < 1;
    };
    P5.minus = P5.sub = function(y9) {
      var i11, j7, t5, xlty, x7 = this, Big2 = x7.constructor, a5 = x7.s, b7 = (y9 = new Big2(y9)).s;
      if (a5 != b7) {
        y9.s = -b7;
        return x7.plus(y9);
      }
      var xc2 = x7.c.slice(), xe4 = x7.e, yc2 = y9.c, ye6 = y9.e;
      if (!xc2[0] || !yc2[0]) {
        if (yc2[0]) {
          y9.s = -b7;
        } else if (xc2[0]) {
          y9 = new Big2(x7);
        } else {
          y9.s = 1;
        }
        return y9;
      }
      if (a5 = xe4 - ye6) {
        if (xlty = a5 < 0) {
          a5 = -a5;
          t5 = xc2;
        } else {
          ye6 = xe4;
          t5 = yc2;
        }
        t5.reverse();
        for (b7 = a5; b7--; ) t5.push(0);
        t5.reverse();
      } else {
        j7 = ((xlty = xc2.length < yc2.length) ? xc2 : yc2).length;
        for (a5 = b7 = 0; b7 < j7; b7++) {
          if (xc2[b7] != yc2[b7]) {
            xlty = xc2[b7] < yc2[b7];
            break;
          }
        }
      }
      if (xlty) {
        t5 = xc2;
        xc2 = yc2;
        yc2 = t5;
        y9.s = -y9.s;
      }
      if ((b7 = (j7 = yc2.length) - (i11 = xc2.length)) > 0) for (; b7--; ) xc2[i11++] = 0;
      for (b7 = i11; j7 > a5; ) {
        if (xc2[--j7] < yc2[j7]) {
          for (i11 = j7; i11 && !xc2[--i11]; ) xc2[i11] = 9;
          --xc2[i11];
          xc2[j7] += 10;
        }
        xc2[j7] -= yc2[j7];
      }
      for (; xc2[--b7] === 0; ) xc2.pop();
      for (; xc2[0] === 0; ) {
        xc2.shift();
        --ye6;
      }
      if (!xc2[0]) {
        y9.s = 1;
        xc2 = [ye6 = 0];
      }
      y9.c = xc2;
      y9.e = ye6;
      return y9;
    };
    P5.mod = function(y9) {
      var ygtx, x7 = this, Big2 = x7.constructor, a5 = x7.s, b7 = (y9 = new Big2(y9)).s;
      if (!y9.c[0]) {
        throw Error(DIV_BY_ZERO);
      }
      x7.s = y9.s = 1;
      ygtx = y9.cmp(x7) == 1;
      x7.s = a5;
      y9.s = b7;
      if (ygtx) return new Big2(x7);
      a5 = Big2.DP;
      b7 = Big2.RM;
      Big2.DP = Big2.RM = 0;
      x7 = x7.div(y9);
      Big2.DP = a5;
      Big2.RM = b7;
      return this.minus(x7.times(y9));
    };
    P5.neg = function() {
      var x7 = new this.constructor(this);
      x7.s = -x7.s;
      return x7;
    };
    P5.plus = P5.add = function(y9) {
      var e10, k7, t5, x7 = this, Big2 = x7.constructor;
      y9 = new Big2(y9);
      if (x7.s != y9.s) {
        y9.s = -y9.s;
        return x7.minus(y9);
      }
      var xe4 = x7.e, xc2 = x7.c, ye6 = y9.e, yc2 = y9.c;
      if (!xc2[0] || !yc2[0]) {
        if (!yc2[0]) {
          if (xc2[0]) {
            y9 = new Big2(x7);
          } else {
            y9.s = x7.s;
          }
        }
        return y9;
      }
      xc2 = xc2.slice();
      if (e10 = xe4 - ye6) {
        if (e10 > 0) {
          ye6 = xe4;
          t5 = yc2;
        } else {
          e10 = -e10;
          t5 = xc2;
        }
        t5.reverse();
        for (; e10--; ) t5.push(0);
        t5.reverse();
      }
      if (xc2.length - yc2.length < 0) {
        t5 = yc2;
        yc2 = xc2;
        xc2 = t5;
      }
      e10 = yc2.length;
      for (k7 = 0; e10; xc2[e10] %= 10) k7 = (xc2[--e10] = xc2[e10] + yc2[e10] + k7) / 10 | 0;
      if (k7) {
        xc2.unshift(k7);
        ++ye6;
      }
      for (e10 = xc2.length; xc2[--e10] === 0; ) xc2.pop();
      y9.c = xc2;
      y9.e = ye6;
      return y9;
    };
    P5.pow = function(n12) {
      var x7 = this, one = new x7.constructor("1"), y9 = one, isneg = n12 < 0;
      if (n12 !== ~~n12 || n12 < -MAX_POWER || n12 > MAX_POWER) {
        throw Error(INVALID + "exponent");
      }
      if (isneg) n12 = -n12;
      for (; ; ) {
        if (n12 & 1) y9 = y9.times(x7);
        n12 >>= 1;
        if (!n12) break;
        x7 = x7.times(x7);
      }
      return isneg ? one.div(y9) : y9;
    };
    P5.prec = function(sd, rm) {
      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
        throw Error(INVALID + "precision");
      }
      return round(new this.constructor(this), sd, rm);
    };
    P5.round = function(dp, rm) {
      if (dp === UNDEFINED) dp = 0;
      else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      return round(new this.constructor(this), dp + this.e + 1, rm);
    };
    P5.sqrt = function() {
      var r9, c12, t5, x7 = this, Big2 = x7.constructor, s8 = x7.s, e10 = x7.e, half = new Big2("0.5");
      if (!x7.c[0]) return new Big2(x7);
      if (s8 < 0) {
        throw Error(NAME + "No square root");
      }
      s8 = Math.sqrt(+stringify4(x7, true, true));
      if (s8 === 0 || s8 === 1 / 0) {
        c12 = x7.c.join("");
        if (!(c12.length + e10 & 1)) c12 += "0";
        s8 = Math.sqrt(c12);
        e10 = ((e10 + 1) / 2 | 0) - (e10 < 0 || e10 & 1);
        r9 = new Big2((s8 == 1 / 0 ? "5e" : (s8 = s8.toExponential()).slice(0, s8.indexOf("e") + 1)) + e10);
      } else {
        r9 = new Big2(s8 + "");
      }
      e10 = r9.e + (Big2.DP += 4);
      do {
        t5 = r9;
        r9 = half.times(t5.plus(x7.div(t5)));
      } while (t5.c.slice(0, e10).join("") !== r9.c.slice(0, e10).join(""));
      return round(r9, (Big2.DP -= 4) + r9.e + 1, Big2.RM);
    };
    P5.times = P5.mul = function(y9) {
      var c12, x7 = this, Big2 = x7.constructor, xc2 = x7.c, yc2 = (y9 = new Big2(y9)).c, a5 = xc2.length, b7 = yc2.length, i11 = x7.e, j7 = y9.e;
      y9.s = x7.s == y9.s ? 1 : -1;
      if (!xc2[0] || !yc2[0]) {
        y9.c = [y9.e = 0];
        return y9;
      }
      y9.e = i11 + j7;
      if (a5 < b7) {
        c12 = xc2;
        xc2 = yc2;
        yc2 = c12;
        j7 = a5;
        a5 = b7;
        b7 = j7;
      }
      for (c12 = new Array(j7 = a5 + b7); j7--; ) c12[j7] = 0;
      for (i11 = b7; i11--; ) {
        b7 = 0;
        for (j7 = a5 + i11; j7 > i11; ) {
          b7 = c12[j7] + yc2[i11] * xc2[j7 - i11 - 1] + b7;
          c12[j7--] = b7 % 10;
          b7 = b7 / 10 | 0;
        }
        c12[j7] = b7;
      }
      if (b7) ++y9.e;
      else c12.shift();
      for (i11 = c12.length; !c12[--i11]; ) c12.pop();
      y9.c = c12;
      return y9;
    };
    P5.toExponential = function(dp, rm) {
      var x7 = this, n12 = x7.c[0];
      if (dp !== UNDEFINED) {
        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
          throw Error(INVALID_DP);
        }
        x7 = round(new x7.constructor(x7), ++dp, rm);
        for (; x7.c.length < dp; ) x7.c.push(0);
      }
      return stringify4(x7, true, !!n12);
    };
    P5.toFixed = function(dp, rm) {
      var x7 = this, n12 = x7.c[0];
      if (dp !== UNDEFINED) {
        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
          throw Error(INVALID_DP);
        }
        x7 = round(new x7.constructor(x7), dp + x7.e + 1, rm);
        for (dp = dp + x7.e + 1; x7.c.length < dp; ) x7.c.push(0);
      }
      return stringify4(x7, false, !!n12);
    };
    P5[Symbol.for("nodejs.util.inspect.custom")] = P5.toJSON = P5.toString = function() {
      var x7 = this, Big2 = x7.constructor;
      return stringify4(x7, x7.e <= Big2.NE || x7.e >= Big2.PE, !!x7.c[0]);
    };
    P5.toNumber = function() {
      var n12 = +stringify4(this, true, true);
      if (this.constructor.strict === true && !this.eq(n12.toString())) {
        throw Error(NAME + "Imprecise conversion");
      }
      return n12;
    };
    P5.toPrecision = function(sd, rm) {
      var x7 = this, Big2 = x7.constructor, n12 = x7.c[0];
      if (sd !== UNDEFINED) {
        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
          throw Error(INVALID + "precision");
        }
        x7 = round(new Big2(x7), sd, rm);
        for (; x7.c.length < sd; ) x7.c.push(0);
      }
      return stringify4(x7, sd <= x7.e || x7.e <= Big2.NE || x7.e >= Big2.PE, !!n12);
    };
    P5.valueOf = function() {
      var x7 = this, Big2 = x7.constructor;
      if (Big2.strict === true) {
        throw Error(NAME + "valueOf disallowed");
      }
      return stringify4(x7, x7.e <= Big2.NE || x7.e >= Big2.PE, true);
    };
    Big = _Big_();
    big_default = Big;
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/NumberUtil.js
var NumberUtil;
var init_NumberUtil = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/NumberUtil.js"() {
    init_big();
    NumberUtil = {
      bigNumber(value) {
        if (!value) {
          return new big_default(0);
        }
        return new big_default(value);
      },
      multiply(a5, b7) {
        if (a5 === void 0 || b7 === void 0) {
          return new big_default(0);
        }
        const aBigNumber = new big_default(a5);
        const bBigNumber = new big_default(b7);
        return aBigNumber.times(bBigNumber);
      },
      formatNumberToLocalString(value, decimals = 2) {
        if (value === void 0) {
          return "0.00";
        }
        if (typeof value === "number") {
          return value.toLocaleString("en-US", {
            maximumFractionDigits: decimals,
            minimumFractionDigits: decimals
          });
        }
        return parseFloat(value).toLocaleString("en-US", {
          maximumFractionDigits: decimals,
          minimumFractionDigits: decimals
        });
      },
      parseLocalStringToNumber(value) {
        if (value === void 0) {
          return 0;
        }
        return parseFloat(value.replace(/,/gu, ""));
      }
    };
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/contracts/erc20.js
var erc20ABI;
var init_erc20 = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/contracts/erc20.js"() {
    erc20ABI = [
      {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "_to",
            type: "address"
          },
          {
            name: "_value",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "_from",
            type: "address"
          },
          {
            name: "_to",
            type: "address"
          },
          {
            name: "_value",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      }
    ];
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/contracts/swap.js
var swapABI;
var init_swap = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/contracts/swap.js"() {
    swapABI = [
      {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
          { name: "spender", type: "address" },
          { name: "amount", type: "uint256" }
        ],
        outputs: [{ type: "bool" }]
      }
    ];
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/contracts/usdt.js
var usdtABI;
var init_usdt = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/contracts/usdt.js"() {
    usdtABI = [
      {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      }
    ];
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/ContractUtil.js
var ContractUtil;
var init_ContractUtil = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/ContractUtil.js"() {
    init_erc20();
    init_swap();
    init_usdt();
    init_ConstantsUtil();
    ContractUtil = {
      getERC20Abi: (tokenAddress) => {
        if (ConstantsUtil.USDT_CONTRACT_ADDRESSES.includes(tokenAddress)) {
          return usdtABI;
        }
        return erc20ABI;
      },
      getSwapAbi: () => swapABI
    };
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/ParseUtil.js
var ParseUtil;
var init_ParseUtil = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/ParseUtil.js"() {
    ParseUtil = {
      validateCaipAddress(address2) {
        if (address2.split(":")?.length !== 3) {
          throw new Error("Invalid CAIP Address");
        }
        return address2;
      },
      parseCaipAddress(caipAddress) {
        const parts = caipAddress.split(":");
        if (parts.length !== 3) {
          throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
        }
        const [chainNamespace, chainId, address2] = parts;
        if (!chainNamespace || !chainId || !address2) {
          throw new Error(`Invalid CAIP-10 address: ${caipAddress}`);
        }
        return {
          chainNamespace,
          chainId,
          address: address2
        };
      },
      parseCaipNetworkId(caipNetworkId) {
        const parts = caipNetworkId.split(":");
        if (parts.length !== 2) {
          throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
        }
        const [chainNamespace, chainId] = parts;
        if (!chainNamespace || !chainId) {
          throw new Error(`Invalid CAIP-2 network id: ${caipNetworkId}`);
        }
        return {
          chainNamespace,
          chainId
        };
      }
    };
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/SafeLocalStorage.js
function getSafeConnectorIdKey(namespace) {
  if (!namespace) {
    throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
  }
  return `@appkit/${namespace}:connected_connector_id`;
}
function isSafe() {
  return typeof window !== "undefined" && typeof localStorage !== "undefined";
}
var SafeLocalStorageKeys, SafeLocalStorage;
var init_SafeLocalStorage = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/SafeLocalStorage.js"() {
    SafeLocalStorageKeys = {
      WALLET_ID: "@appkit/wallet_id",
      WALLET_NAME: "@appkit/wallet_name",
      SOLANA_WALLET: "@appkit/solana_wallet",
      SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
      ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
      CONNECTED_SOCIAL: "@appkit/connected_social",
      CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
      RECENT_WALLETS: "@appkit/recent_wallets",
      DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
      ACTIVE_NAMESPACE: "@appkit/active_namespace",
      CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
      CONNECTION_STATUS: "@appkit/connection_status",
      SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
      SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
      TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
      NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
      PORTFOLIO_CACHE: "@appkit/portfolio_cache",
      ENS_CACHE: "@appkit/ens_cache",
      IDENTITY_CACHE: "@appkit/identity_cache",
      PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
      CONNECTIONS: "@appkit/connections",
      DISCONNECTED_CONNECTOR_IDS: "@appkit/disconnected_connector_ids",
      HISTORY_TRANSACTIONS_CACHE: "@appkit/history_transactions_cache",
      TOKEN_PRICE_CACHE: "@appkit/token_price_cache",
      RECENT_EMAILS: "@appkit/recent_emails"
    };
    SafeLocalStorage = {
      setItem(key, value) {
        if (isSafe() && value !== void 0) {
          localStorage.setItem(key, value);
        }
      },
      getItem(key) {
        if (isSafe()) {
          return localStorage.getItem(key) || void 0;
        }
        return void 0;
      },
      removeItem(key) {
        if (isSafe()) {
          localStorage.removeItem(key);
        }
      },
      clear() {
        if (isSafe()) {
          localStorage.clear();
        }
      }
    };
  }
});

// node_modules/@reown/appkit-common/dist/esm/src/utils/ThemeUtil.js
function getW3mThemeVariables(themeVariables, themeType) {
  if (themeType === "light") {
    return {
      "--w3m-accent": themeVariables?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
      "--w3m-background": "#fff"
    };
  }
  return {
    "--w3m-accent": themeVariables?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}
var init_ThemeUtil = __esm({
  "node_modules/@reown/appkit-common/dist/esm/src/utils/ThemeUtil.js"() {
  }
});

// node_modules/@reown/appkit-common/dist/esm/index.js
var init_esm8 = __esm({
  "node_modules/@reown/appkit-common/dist/esm/index.js"() {
    init_NetworkUtil();
    init_NumberUtil();
    init_ContractUtil();
    init_ConstantsUtil();
    init_ParseUtil();
    init_SafeLocalStorage();
    init_ThemeUtil();
  }
});

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL, GET_ORIGINAL_SYMBOL, getProto, objectsToTrack, isObjectToTrack, getUntracked, markToTrack;
var init_dist5 = __esm({
  "node_modules/proxy-compare/dist/index.js"() {
    TRACK_MEMO_SYMBOL = Symbol();
    GET_ORIGINAL_SYMBOL = Symbol();
    getProto = Object.getPrototypeOf;
    objectsToTrack = /* @__PURE__ */ new WeakMap();
    isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
    getUntracked = (obj) => {
      if (isObjectToTrack(obj)) {
        return obj[GET_ORIGINAL_SYMBOL] || null;
      }
      return null;
    };
    markToTrack = (obj, mark = true) => {
      objectsToTrack.set(obj, mark);
    };
  }
});

// node_modules/valtio/esm/vanilla.mjs
function proxy(baseObject = {}) {
  if (!isObject(baseObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(baseObject);
  if (found) {
    return found;
  }
  let version4 = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version4 !== nextVersion) {
      version4 = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version4) {
          version4 = propVersion;
        }
      });
    }
    return version4;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propValue) => {
    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);
    if (propProxyState) {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && propProxyStates.has(prop)) {
        throw new Error("prop listener already exists");
      }
      if (listeners.size) {
        const remove = propProxyState[2](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      } else {
        propProxyStates.set(prop, [propProxyState]);
      }
    }
  };
  const removePropListener = (prop) => {
    var _a2;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[2](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  let initializing = true;
  const handler = createHandler(
    () => initializing,
    addPropListener,
    removePropListener,
    notifyUpdate
  );
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(baseObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(baseObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      baseObject,
      key
    );
    if ("value" in desc && desc.writable) {
      proxyObject[key] = baseObject[key];
    }
  });
  initializing = false;
  return proxyObject;
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[2];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function unstable_getInternalStates() {
  return {
    proxyStateMap,
    refSet,
    snapCache,
    versionHolder,
    proxyCache
  };
}
var isObject, canProxyDefault, createSnapshotDefault, createHandlerDefault, proxyStateMap, refSet, snapCache, versionHolder, proxyCache, objectIs, newProxy, canProxy, createSnapshot, createHandler;
var init_vanilla = __esm({
  "node_modules/valtio/esm/vanilla.mjs"() {
    init_dist5();
    isObject = (x7) => typeof x7 === "object" && x7 !== null;
    canProxyDefault = (x7) => isObject(x7) && !refSet.has(x7) && (Array.isArray(x7) || !(Symbol.iterator in x7)) && !(x7 instanceof WeakMap) && !(x7 instanceof WeakSet) && !(x7 instanceof Error) && !(x7 instanceof Number) && !(x7 instanceof Date) && !(x7 instanceof String) && !(x7 instanceof RegExp) && !(x7 instanceof ArrayBuffer) && !(x7 instanceof Promise);
    createSnapshotDefault = (target, version4) => {
      const cache = snapCache.get(target);
      if ((cache == null ? void 0 : cache[0]) === version4) {
        return cache[1];
      }
      const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
      markToTrack(snap, true);
      snapCache.set(target, [version4, snap]);
      Reflect.ownKeys(target).forEach((key) => {
        if (Object.getOwnPropertyDescriptor(snap, key)) {
          return;
        }
        const value = Reflect.get(target, key);
        const { enumerable } = Reflect.getOwnPropertyDescriptor(
          target,
          key
        );
        const desc = {
          value,
          enumerable,
          // This is intentional to avoid copying with proxy-compare.
          // It's still non-writable, so it avoids assigning a value.
          configurable: true
        };
        if (refSet.has(value)) {
          markToTrack(value, false);
        } else if (proxyStateMap.has(value)) {
          const [target2, ensureVersion] = proxyStateMap.get(
            value
          );
          desc.value = createSnapshotDefault(target2, ensureVersion());
        }
        Object.defineProperty(snap, key, desc);
      });
      return Object.preventExtensions(snap);
    };
    createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
      deleteProperty(target, prop) {
        const prevValue = Reflect.get(target, prop);
        removePropListener(prop);
        const deleted = Reflect.deleteProperty(target, prop);
        if (deleted) {
          notifyUpdate(["delete", [prop], prevValue]);
        }
        return deleted;
      },
      set(target, prop, value, receiver) {
        const hasPrevValue = !isInitializing() && Reflect.has(target, prop);
        const prevValue = Reflect.get(target, prop, receiver);
        if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
          return true;
        }
        removePropListener(prop);
        if (isObject(value)) {
          value = getUntracked(value) || value;
        }
        const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;
        addPropListener(prop, nextValue);
        Reflect.set(target, prop, nextValue, receiver);
        notifyUpdate(["set", [prop], value, prevValue]);
        return true;
      }
    });
    proxyStateMap = /* @__PURE__ */ new WeakMap();
    refSet = /* @__PURE__ */ new WeakSet();
    snapCache = /* @__PURE__ */ new WeakMap();
    versionHolder = [1, 1];
    proxyCache = /* @__PURE__ */ new WeakMap();
    objectIs = Object.is;
    newProxy = (target, handler) => new Proxy(target, handler);
    canProxy = canProxyDefault;
    createSnapshot = createSnapshotDefault;
    createHandler = createHandlerDefault;
  }
});

// node_modules/valtio/esm/vanilla/utils.mjs
function subscribeKey(proxyObject, key, callback, notifyInSync) {
  let prevValue = proxyObject[key];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    },
    notifyInSync
  );
}
function proxyMap(entries2) {
  const initialData = [];
  let initialIndex = 0;
  const indexMap = /* @__PURE__ */ new Map();
  const snapMapCache = /* @__PURE__ */ new WeakMap();
  const registerSnapMap = () => {
    const cache = snapCache$1.get(vObject);
    const latestSnap = cache == null ? void 0 : cache[1];
    if (latestSnap && !snapMapCache.has(latestSnap)) {
      const clonedMap = new Map(indexMap);
      snapMapCache.set(latestSnap, clonedMap);
    }
  };
  const getMapForThis = (x7) => snapMapCache.get(x7) || indexMap;
  if (entries2) {
    if (typeof entries2[Symbol.iterator] !== "function") {
      throw new TypeError(
        "proxyMap:\n	initial state must be iterable\n		tip: structure should be [[key, value]]"
      );
    }
    for (const [key, value] of entries2) {
      indexMap.set(key, initialIndex);
      initialData[initialIndex++] = value;
    }
  }
  const vObject = {
    data: initialData,
    index: initialIndex,
    epoch: 0,
    get size() {
      if (!isProxy$1(this)) {
        registerSnapMap();
      }
      const map2 = getMapForThis(this);
      return map2.size;
    },
    get(key) {
      const map2 = getMapForThis(this);
      const index2 = map2.get(key);
      if (index2 === void 0) {
        this.epoch;
        return void 0;
      }
      return this.data[index2];
    },
    has(key) {
      const map2 = getMapForThis(this);
      this.epoch;
      return map2.has(key);
    },
    set(key, value) {
      if (!isProxy$1(this)) {
        throw new Error("Cannot perform mutations on a snapshot");
      }
      const index2 = indexMap.get(key);
      if (index2 === void 0) {
        indexMap.set(key, this.index);
        this.data[this.index++] = value;
      } else {
        this.data[index2] = value;
      }
      this.epoch++;
      return this;
    },
    delete(key) {
      if (!isProxy$1(this)) {
        throw new Error("Cannot perform mutations on a snapshot");
      }
      const index2 = indexMap.get(key);
      if (index2 === void 0) {
        return false;
      }
      delete this.data[index2];
      indexMap.delete(key);
      this.epoch++;
      return true;
    },
    clear() {
      if (!isProxy$1(this)) {
        throw new Error("Cannot perform mutations on a snapshot");
      }
      this.data.length = 0;
      this.index = 0;
      this.epoch++;
      indexMap.clear();
    },
    forEach(cb) {
      this.epoch;
      const map2 = getMapForThis(this);
      map2.forEach((index2, key) => {
        cb(this.data[index2], key, this);
      });
    },
    *entries() {
      this.epoch;
      const map2 = getMapForThis(this);
      for (const [key, index2] of map2) {
        yield [key, this.data[index2]];
      }
    },
    *keys() {
      this.epoch;
      const map2 = getMapForThis(this);
      for (const key of map2.keys()) {
        yield key;
      }
    },
    *values() {
      this.epoch;
      const map2 = getMapForThis(this);
      for (const index2 of map2.values()) {
        yield this.data[index2];
      }
    },
    [Symbol.iterator]() {
      return this.entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    toJSON() {
      return new Map(this.entries());
    }
  };
  const proxiedObject = proxy(vObject);
  Object.defineProperties(proxiedObject, {
    size: { enumerable: false },
    index: { enumerable: false },
    epoch: { enumerable: false },
    data: { enumerable: false },
    toJSON: { enumerable: false }
  });
  Object.seal(proxiedObject);
  return proxiedObject;
}
var DEVTOOLS, proxyStateMap$1, snapCache$1, isProxy$1, proxyStateMap2, snapCache2;
var init_utils3 = __esm({
  "node_modules/valtio/esm/vanilla/utils.mjs"() {
    init_vanilla();
    DEVTOOLS = Symbol();
    ({ proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates());
    isProxy$1 = (x7) => proxyStateMap$1.has(x7);
    ({ proxyStateMap: proxyStateMap2, snapCache: snapCache2 } = unstable_getInternalStates());
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js
var SECURE_SITE, ONRAMP_PROVIDERS, MELD_PUBLIC_KEY, ConstantsUtil2;
var init_ConstantsUtil2 = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConstantsUtil.js"() {
    init_esm8();
    SECURE_SITE = // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
    (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org";
    ONRAMP_PROVIDERS = [
      {
        label: "Meld.io",
        name: "meld",
        feeRange: "1-2%",
        url: "https://meldcrypto.com",
        supportedChains: ["eip155", "solana"]
      }
    ];
    MELD_PUBLIC_KEY = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU";
    ConstantsUtil2 = {
      FOUR_MINUTES_MS: 24e4,
      TEN_SEC_MS: 1e4,
      FIVE_SEC_MS: 5e3,
      THREE_SEC_MS: 3e3,
      ONE_SEC_MS: 1e3,
      SECURE_SITE,
      SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
      SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
      RESTRICTED_TIMEZONES: [
        "ASIA/SHANGHAI",
        "ASIA/URUMQI",
        "ASIA/CHONGQING",
        "ASIA/HARBIN",
        "ASIA/KASHGAR",
        "ASIA/MACAU",
        "ASIA/HONG_KONG",
        "ASIA/MACAO",
        "ASIA/BEIJING",
        "ASIA/HARBIN"
      ],
      SWAP_SUGGESTED_TOKENS: [
        "ETH",
        "UNI",
        "1INCH",
        "AAVE",
        "SOL",
        "ADA",
        "AVAX",
        "DOT",
        "LINK",
        "NITRO",
        "GAIA",
        "MILK",
        "TRX",
        "NEAR",
        "GNO",
        "WBTC",
        "DAI",
        "WETH",
        "USDC",
        "USDT",
        "ARB",
        "BAL",
        "BICO",
        "CRV",
        "ENS",
        "MATIC",
        "OP"
      ],
      SWAP_POPULAR_TOKENS: [
        "ETH",
        "UNI",
        "1INCH",
        "AAVE",
        "SOL",
        "ADA",
        "AVAX",
        "DOT",
        "LINK",
        "NITRO",
        "GAIA",
        "MILK",
        "TRX",
        "NEAR",
        "GNO",
        "WBTC",
        "DAI",
        "WETH",
        "USDC",
        "USDT",
        "ARB",
        "BAL",
        "BICO",
        "CRV",
        "ENS",
        "MATIC",
        "OP",
        "METAL",
        "DAI",
        "CHAMP",
        "WOLF",
        "SALE",
        "BAL",
        "BUSD",
        "MUST",
        "BTCpx",
        "ROUTE",
        "HEX",
        "WELT",
        "amDAI",
        "VSQ",
        "VISION",
        "AURUM",
        "pSP",
        "SNX",
        "VC",
        "LINK",
        "CHP",
        "amUSDT",
        "SPHERE",
        "FOX",
        "GIDDY",
        "GFC",
        "OMEN",
        "OX_OLD",
        "DE",
        "WNT"
      ],
      BALANCE_SUPPORTED_CHAINS: [
        ConstantsUtil.CHAIN.EVM,
        ConstantsUtil.CHAIN.SOLANA
      ],
      SWAP_SUPPORTED_NETWORKS: [
        // Ethereum'
        "eip155:1",
        // Arbitrum One'
        "eip155:42161",
        // Optimism'
        "eip155:10",
        // ZKSync Era'
        "eip155:324",
        // Base'
        "eip155:8453",
        // BNB Smart Chain'
        "eip155:56",
        // Polygon'
        "eip155:137",
        // Gnosis'
        "eip155:100",
        // Avalanche'
        "eip155:43114",
        // Fantom'
        "eip155:250",
        // Klaytn'
        "eip155:8217",
        // Aurora
        "eip155:1313161554"
      ],
      NAMES_SUPPORTED_CHAIN_NAMESPACES: [ConstantsUtil.CHAIN.EVM],
      ONRAMP_SUPPORTED_CHAIN_NAMESPACES: [
        ConstantsUtil.CHAIN.EVM,
        ConstantsUtil.CHAIN.SOLANA
      ],
      ACTIVITY_ENABLED_CHAIN_NAMESPACES: [ConstantsUtil.CHAIN.EVM],
      NATIVE_TOKEN_ADDRESS: {
        eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
        solana: "So11111111111111111111111111111111111111111",
        polkadot: "0x",
        bip122: "0x",
        cosmos: "0x",
        sui: "0x",
        stacks: "0x"
      },
      CONVERT_SLIPPAGE_TOLERANCE: 1,
      CONNECT_LABELS: {
        MOBILE: "Open and continue in the wallet app",
        WEB: "Open and continue in the wallet app"
      },
      SEND_SUPPORTED_NAMESPACES: [
        ConstantsUtil.CHAIN.EVM,
        ConstantsUtil.CHAIN.SOLANA
      ],
      DEFAULT_REMOTE_FEATURES: {
        swaps: ["1inch"],
        onramp: ["meld"],
        email: true,
        socials: [
          "google",
          "x",
          "discord",
          "farcaster",
          "github",
          "apple",
          "facebook"
        ],
        activity: true,
        reownBranding: true,
        multiWallet: false,
        emailCapture: false
      },
      DEFAULT_REMOTE_FEATURES_DISABLED: {
        email: false,
        socials: false,
        swaps: false,
        onramp: false,
        activity: false,
        reownBranding: false,
        emailCapture: false
      },
      DEFAULT_FEATURES: {
        receive: true,
        send: true,
        emailShowWallets: true,
        connectorTypeOrder: [
          "walletConnect",
          "recent",
          "injected",
          "featured",
          "custom",
          "external",
          "recommended"
        ],
        analytics: true,
        allWallets: true,
        legalCheckbox: false,
        smartSessions: false,
        collapseWallets: false,
        walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
        connectMethodsOrder: void 0,
        pay: false
      },
      DEFAULT_SOCIALS: [
        "google",
        "x",
        "farcaster",
        "discord",
        "apple",
        "github",
        "facebook"
      ],
      DEFAULT_ACCOUNT_TYPES: {
        bip122: "payment",
        eip155: "smartAccount",
        polkadot: "eoa",
        solana: "eoa"
      },
      ADAPTER_TYPES: {
        UNIVERSAL: "universal",
        SOLANA: "solana",
        WAGMI: "wagmi",
        ETHERS: "ethers",
        ETHERS5: "ethers5",
        BITCOIN: "bitcoin"
      },
      SIWX_DEFAULTS: {
        signOutOnDisconnect: true
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/StorageUtil.js
var StorageUtil;
var init_StorageUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/StorageUtil.js"() {
    init_esm8();
    StorageUtil = {
      // Cache expiry in milliseconds
      cacheExpiry: {
        portfolio: 3e4,
        nativeBalance: 3e4,
        ens: 3e5,
        identity: 3e5,
        transactionsHistory: 15e3,
        tokenPrice: 15e3
      },
      isCacheExpired(timestamp, cacheExpiry) {
        return Date.now() - timestamp > cacheExpiry;
      },
      getActiveNetworkProps() {
        const namespace = StorageUtil.getActiveNamespace();
        const caipNetworkId = StorageUtil.getActiveCaipNetworkId();
        const stringChainId = caipNetworkId ? caipNetworkId.split(":")[1] : void 0;
        const chainId = stringChainId ? isNaN(Number(stringChainId)) ? stringChainId : Number(stringChainId) : void 0;
        return {
          namespace,
          caipNetworkId,
          chainId
        };
      },
      setWalletConnectDeepLink({ name: name2, href }) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.DEEPLINK_CHOICE, JSON.stringify({ href, name: name2 }));
        } catch {
          console.info("Unable to set WalletConnect deep link");
        }
      },
      getWalletConnectDeepLink() {
        try {
          const deepLink = SafeLocalStorage.getItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
          if (deepLink) {
            return JSON.parse(deepLink);
          }
        } catch {
          console.info("Unable to get WalletConnect deep link");
        }
        return void 0;
      },
      deleteWalletConnectDeepLink() {
        try {
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.DEEPLINK_CHOICE);
        } catch {
          console.info("Unable to delete WalletConnect deep link");
        }
      },
      setActiveNamespace(namespace) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE, namespace);
        } catch {
          console.info("Unable to set active namespace");
        }
      },
      setActiveCaipNetworkId(caipNetworkId) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID, caipNetworkId);
          StorageUtil.setActiveNamespace(caipNetworkId.split(":")[0]);
        } catch {
          console.info("Unable to set active caip network id");
        }
      },
      getActiveCaipNetworkId() {
        try {
          return SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
        } catch {
          console.info("Unable to get active caip network id");
          return void 0;
        }
      },
      deleteActiveCaipNetworkId() {
        try {
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
        } catch {
          console.info("Unable to delete active caip network id");
        }
      },
      deleteConnectedConnectorId(namespace) {
        try {
          const key = getSafeConnectorIdKey(namespace);
          SafeLocalStorage.removeItem(key);
        } catch {
          console.info("Unable to delete connected connector id");
        }
      },
      setAppKitRecent(wallet) {
        try {
          const recentWallets = StorageUtil.getRecentWallets();
          const exists2 = recentWallets.find((w6) => w6.id === wallet.id);
          if (!exists2) {
            recentWallets.unshift(wallet);
            if (recentWallets.length > 2) {
              recentWallets.pop();
            }
            SafeLocalStorage.setItem(SafeLocalStorageKeys.RECENT_WALLETS, JSON.stringify(recentWallets));
          }
        } catch {
          console.info("Unable to set AppKit recent");
        }
      },
      getRecentWallets() {
        try {
          const recent = SafeLocalStorage.getItem(SafeLocalStorageKeys.RECENT_WALLETS);
          return recent ? JSON.parse(recent) : [];
        } catch {
          console.info("Unable to get AppKit recent");
        }
        return [];
      },
      setConnectedConnectorId(namespace, connectorId) {
        try {
          const key = getSafeConnectorIdKey(namespace);
          SafeLocalStorage.setItem(key, connectorId);
        } catch {
          console.info("Unable to set Connected Connector Id");
        }
      },
      getActiveNamespace() {
        try {
          const activeNamespace = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_NAMESPACE);
          return activeNamespace;
        } catch {
          console.info("Unable to get active namespace");
        }
        return void 0;
      },
      getConnectedConnectorId(namespace) {
        if (!namespace) {
          return void 0;
        }
        try {
          const key = getSafeConnectorIdKey(namespace);
          return SafeLocalStorage.getItem(key);
        } catch (e10) {
          console.info("Unable to get connected connector id in namespace", namespace);
        }
        return void 0;
      },
      setConnectedSocialProvider(socialProvider) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_SOCIAL, socialProvider);
        } catch {
          console.info("Unable to set connected social provider");
        }
      },
      getConnectedSocialProvider() {
        try {
          return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
        } catch {
          console.info("Unable to get connected social provider");
        }
        return void 0;
      },
      deleteConnectedSocialProvider() {
        try {
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.CONNECTED_SOCIAL);
        } catch {
          console.info("Unable to delete connected social provider");
        }
      },
      getConnectedSocialUsername() {
        try {
          return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_SOCIAL_USERNAME);
        } catch {
          console.info("Unable to get connected social username");
        }
        return void 0;
      },
      getStoredActiveCaipNetworkId() {
        const storedCaipNetworkId = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
        const networkId = storedCaipNetworkId?.split(":")?.[1];
        return networkId;
      },
      setConnectionStatus(status) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTION_STATUS, status);
        } catch {
          console.info("Unable to set connection status");
        }
      },
      getConnectionStatus() {
        try {
          return SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTION_STATUS);
        } catch {
          return void 0;
        }
      },
      getConnectedNamespaces() {
        try {
          const namespaces = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES);
          if (!namespaces?.length) {
            return [];
          }
          return namespaces.split(",");
        } catch {
          return [];
        }
      },
      setConnectedNamespaces(namespaces) {
        try {
          const uniqueNamespaces = Array.from(new Set(namespaces));
          SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTED_NAMESPACES, uniqueNamespaces.join(","));
        } catch {
          console.info("Unable to set namespaces in storage");
        }
      },
      addConnectedNamespace(namespace) {
        try {
          const namespaces = StorageUtil.getConnectedNamespaces();
          if (!namespaces.includes(namespace)) {
            namespaces.push(namespace);
            StorageUtil.setConnectedNamespaces(namespaces);
          }
        } catch {
          console.info("Unable to add connected namespace");
        }
      },
      removeConnectedNamespace(namespace) {
        try {
          const namespaces = StorageUtil.getConnectedNamespaces();
          const index2 = namespaces.indexOf(namespace);
          if (index2 > -1) {
            namespaces.splice(index2, 1);
            StorageUtil.setConnectedNamespaces(namespaces);
          }
        } catch {
          console.info("Unable to remove connected namespace");
        }
      },
      getTelegramSocialProvider() {
        try {
          return SafeLocalStorage.getItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER);
        } catch {
          console.info("Unable to get telegram social provider");
          return null;
        }
      },
      setTelegramSocialProvider(socialProvider) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER, socialProvider);
        } catch {
          console.info("Unable to set telegram social provider");
        }
      },
      removeTelegramSocialProvider() {
        try {
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.TELEGRAM_SOCIAL_PROVIDER);
        } catch {
          console.info("Unable to remove telegram social provider");
        }
      },
      getBalanceCache() {
        let cache = {};
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
          cache = result ? JSON.parse(result) : {};
        } catch {
          console.info("Unable to get balance cache");
        }
        return cache;
      },
      removeAddressFromBalanceCache(caipAddress) {
        try {
          const cache = StorageUtil.getBalanceCache();
          SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
        } catch {
          console.info("Unable to remove address from balance cache", caipAddress);
        }
      },
      getBalanceCacheForCaipAddress(caipAddress) {
        try {
          const cache = StorageUtil.getBalanceCache();
          const balanceCache = cache[caipAddress];
          if (balanceCache && !this.isCacheExpired(balanceCache.timestamp, this.cacheExpiry.portfolio)) {
            return balanceCache.balance;
          }
          StorageUtil.removeAddressFromBalanceCache(caipAddress);
        } catch {
          console.info("Unable to get balance cache for address", caipAddress);
        }
        return void 0;
      },
      updateBalanceCache(params) {
        try {
          const cache = StorageUtil.getBalanceCache();
          cache[params.caipAddress] = params;
          SafeLocalStorage.setItem(SafeLocalStorageKeys.PORTFOLIO_CACHE, JSON.stringify(cache));
        } catch {
          console.info("Unable to update balance cache", params);
        }
      },
      getNativeBalanceCache() {
        let cache = {};
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
          cache = result ? JSON.parse(result) : {};
        } catch {
          console.info("Unable to get balance cache");
        }
        return cache;
      },
      removeAddressFromNativeBalanceCache(caipAddress) {
        try {
          const cache = StorageUtil.getBalanceCache();
          SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify({ ...cache, [caipAddress]: void 0 }));
        } catch {
          console.info("Unable to remove address from balance cache", caipAddress);
        }
      },
      getNativeBalanceCacheForCaipAddress(caipAddress) {
        try {
          const cache = StorageUtil.getNativeBalanceCache();
          const nativeBalanceCache = cache[caipAddress];
          if (nativeBalanceCache && !this.isCacheExpired(nativeBalanceCache.timestamp, this.cacheExpiry.nativeBalance)) {
            return nativeBalanceCache;
          }
          console.info("Discarding cache for address", caipAddress);
          StorageUtil.removeAddressFromBalanceCache(caipAddress);
        } catch {
          console.info("Unable to get balance cache for address", caipAddress);
        }
        return void 0;
      },
      updateNativeBalanceCache(params) {
        try {
          const cache = StorageUtil.getNativeBalanceCache();
          cache[params.caipAddress] = params;
          SafeLocalStorage.setItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE, JSON.stringify(cache));
        } catch {
          console.info("Unable to update balance cache", params);
        }
      },
      getEnsCache() {
        let cache = {};
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.ENS_CACHE);
          cache = result ? JSON.parse(result) : {};
        } catch {
          console.info("Unable to get ens name cache");
        }
        return cache;
      },
      getEnsFromCacheForAddress(address2) {
        try {
          const cache = StorageUtil.getEnsCache();
          const ensCache = cache[address2];
          if (ensCache && !this.isCacheExpired(ensCache.timestamp, this.cacheExpiry.ens)) {
            return ensCache.ens;
          }
          StorageUtil.removeEnsFromCache(address2);
        } catch {
          console.info("Unable to get ens name from cache", address2);
        }
        return void 0;
      },
      updateEnsCache(params) {
        try {
          const cache = StorageUtil.getEnsCache();
          cache[params.address] = params;
          SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify(cache));
        } catch {
          console.info("Unable to update ens name cache", params);
        }
      },
      removeEnsFromCache(address2) {
        try {
          const cache = StorageUtil.getEnsCache();
          SafeLocalStorage.setItem(SafeLocalStorageKeys.ENS_CACHE, JSON.stringify({ ...cache, [address2]: void 0 }));
        } catch {
          console.info("Unable to remove ens name from cache", address2);
        }
      },
      getIdentityCache() {
        let cache = {};
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.IDENTITY_CACHE);
          cache = result ? JSON.parse(result) : {};
        } catch {
          console.info("Unable to get identity cache");
        }
        return cache;
      },
      getIdentityFromCacheForAddress(address2) {
        try {
          const cache = StorageUtil.getIdentityCache();
          const identityCache = cache[address2];
          if (identityCache && !this.isCacheExpired(identityCache.timestamp, this.cacheExpiry.identity)) {
            return identityCache.identity;
          }
          StorageUtil.removeIdentityFromCache(address2);
        } catch {
          console.info("Unable to get identity from cache", address2);
        }
        return void 0;
      },
      updateIdentityCache(params) {
        try {
          const cache = StorageUtil.getIdentityCache();
          cache[params.address] = {
            identity: params.identity,
            timestamp: params.timestamp
          };
          SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify(cache));
        } catch {
          console.info("Unable to update identity cache", params);
        }
      },
      removeIdentityFromCache(address2) {
        try {
          const cache = StorageUtil.getIdentityCache();
          SafeLocalStorage.setItem(SafeLocalStorageKeys.IDENTITY_CACHE, JSON.stringify({ ...cache, [address2]: void 0 }));
        } catch {
          console.info("Unable to remove identity from cache", address2);
        }
      },
      clearAddressCache() {
        try {
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.PORTFOLIO_CACHE);
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.NATIVE_BALANCE_CACHE);
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.ENS_CACHE);
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.IDENTITY_CACHE);
          SafeLocalStorage.removeItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE);
        } catch {
          console.info("Unable to clear address cache");
        }
      },
      setPreferredAccountTypes(accountTypes) {
        try {
          SafeLocalStorage.setItem(SafeLocalStorageKeys.PREFERRED_ACCOUNT_TYPES, JSON.stringify(accountTypes));
        } catch {
          console.info("Unable to set preferred account types", accountTypes);
        }
      },
      getPreferredAccountTypes() {
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.PREFERRED_ACCOUNT_TYPES);
          if (!result) {
            return {};
          }
          return JSON.parse(result);
        } catch {
          console.info("Unable to get preferred account types");
        }
        return {};
      },
      setConnections(connections, chainNamespace) {
        try {
          const existingConnections = StorageUtil.getConnections();
          const existing = existingConnections[chainNamespace] ?? [];
          const connectorConnectionMap = /* @__PURE__ */ new Map();
          for (const conn of existing) {
            connectorConnectionMap.set(conn.connectorId, { ...conn });
          }
          for (const conn of connections) {
            const existingConn = connectorConnectionMap.get(conn.connectorId);
            const isAuth = conn.connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
            if (existingConn && !isAuth) {
              const existingAddrs = new Set(existingConn.accounts.map((a5) => a5.address.toLowerCase()));
              const newAccounts = conn.accounts.filter((a5) => !existingAddrs.has(a5.address.toLowerCase()));
              existingConn.accounts.push(...newAccounts);
            } else {
              connectorConnectionMap.set(conn.connectorId, { ...conn });
            }
          }
          const dedupedConnections = {
            ...existingConnections,
            [chainNamespace]: Array.from(connectorConnectionMap.values())
          };
          SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTIONS, JSON.stringify(dedupedConnections));
        } catch (error2) {
          console.error("Unable to sync connections to storage", error2);
        }
      },
      getConnections() {
        try {
          const connectionsStorage = SafeLocalStorage.getItem(SafeLocalStorageKeys.CONNECTIONS);
          if (!connectionsStorage) {
            return {};
          }
          return JSON.parse(connectionsStorage);
        } catch (error2) {
          console.error("Unable to get connections from storage", error2);
          return {};
        }
      },
      deleteAddressFromConnection({ connectorId, address: address2, namespace }) {
        try {
          const connections = StorageUtil.getConnections();
          const namespaceConnections = connections[namespace] ?? [];
          const connectionMap = new Map(namespaceConnections.map((conn) => [conn.connectorId, conn]));
          const connector = connectionMap.get(connectorId);
          if (connector) {
            const updatedAccounts = connector.accounts.filter((acc) => acc.address.toLowerCase() !== address2.toLowerCase());
            if (updatedAccounts.length === 0) {
              connectionMap.delete(connectorId);
            } else {
              connectionMap.set(connectorId, {
                ...connector,
                accounts: connector.accounts.filter((acc) => acc.address.toLowerCase() !== address2.toLowerCase())
              });
            }
          }
          SafeLocalStorage.setItem(SafeLocalStorageKeys.CONNECTIONS, JSON.stringify({
            ...connections,
            [namespace]: Array.from(connectionMap.values())
          }));
        } catch {
          console.error(`Unable to remove address "${address2}" from connector "${connectorId}" in namespace "${namespace}"`);
        }
      },
      getDisconnectedConnectorIds() {
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.DISCONNECTED_CONNECTOR_IDS);
          if (!result) {
            return {};
          }
          return JSON.parse(result);
        } catch {
          console.info("Unable to get disconnected connector ids");
        }
        return {};
      },
      addDisconnectedConnectorId(connectorId, chainNamespace) {
        try {
          const currentDisconnectedConnectorIds = StorageUtil.getDisconnectedConnectorIds();
          const disconnectedConnectorIdsByNamespace = currentDisconnectedConnectorIds[chainNamespace] ?? [];
          disconnectedConnectorIdsByNamespace.push(connectorId);
          SafeLocalStorage.setItem(SafeLocalStorageKeys.DISCONNECTED_CONNECTOR_IDS, JSON.stringify({
            ...currentDisconnectedConnectorIds,
            [chainNamespace]: Array.from(new Set(disconnectedConnectorIdsByNamespace))
          }));
        } catch {
          console.error(`Unable to set disconnected connector id "${connectorId}" for namespace "${chainNamespace}"`);
        }
      },
      removeDisconnectedConnectorId(connectorId, chainNamespace) {
        try {
          const currentDisconnectedConnectorIds = StorageUtil.getDisconnectedConnectorIds();
          let disconnectedConnectorIdsByNamespace = currentDisconnectedConnectorIds[chainNamespace] ?? [];
          disconnectedConnectorIdsByNamespace = disconnectedConnectorIdsByNamespace.filter((id) => id.toLowerCase() !== connectorId.toLowerCase());
          SafeLocalStorage.setItem(SafeLocalStorageKeys.DISCONNECTED_CONNECTOR_IDS, JSON.stringify({
            ...currentDisconnectedConnectorIds,
            [chainNamespace]: Array.from(new Set(disconnectedConnectorIdsByNamespace))
          }));
        } catch {
          console.error(`Unable to remove disconnected connector id "${connectorId}" for namespace "${chainNamespace}"`);
        }
      },
      isConnectorDisconnected(connectorId, chainNamespace) {
        try {
          const currentDisconnectedConnectorIds = StorageUtil.getDisconnectedConnectorIds();
          const disconnectedConnectorIdsByNamespace = currentDisconnectedConnectorIds[chainNamespace] ?? [];
          return disconnectedConnectorIdsByNamespace.some((id) => id.toLowerCase() === connectorId.toLowerCase());
        } catch {
          console.info(`Unable to get disconnected connector id "${connectorId}" for namespace "${chainNamespace}"`);
        }
        return false;
      },
      getTransactionsCache() {
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE);
          return result ? JSON.parse(result) : {};
        } catch {
          console.info("Unable to get transactions cache");
        }
        return {};
      },
      getTransactionsCacheForAddress({ address: address2, chainId = "" }) {
        try {
          const cache = StorageUtil.getTransactionsCache();
          const transactionsCache = cache[address2]?.[chainId];
          if (transactionsCache && !this.isCacheExpired(transactionsCache.timestamp, this.cacheExpiry.transactionsHistory)) {
            return transactionsCache.transactions;
          }
          StorageUtil.removeTransactionsCache({ address: address2, chainId });
        } catch {
          console.info("Unable to get transactions cache");
        }
        return void 0;
      },
      updateTransactionsCache({ address: address2, chainId = "", timestamp, transactions }) {
        try {
          const cache = StorageUtil.getTransactionsCache();
          cache[address2] = {
            ...cache[address2],
            [chainId]: {
              timestamp,
              transactions
            }
          };
          SafeLocalStorage.setItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE, JSON.stringify(cache));
        } catch {
          console.info("Unable to update transactions cache", {
            address: address2,
            chainId,
            timestamp,
            transactions
          });
        }
      },
      removeTransactionsCache({ address: address2, chainId }) {
        try {
          const cache = StorageUtil.getTransactionsCache();
          const addressCache = cache?.[address2] || {};
          const { [chainId]: _removed, ...updatedChainData } = addressCache;
          SafeLocalStorage.setItem(SafeLocalStorageKeys.HISTORY_TRANSACTIONS_CACHE, JSON.stringify({
            ...cache,
            [address2]: updatedChainData
          }));
        } catch {
          console.info("Unable to remove transactions cache", { address: address2, chainId });
        }
      },
      getTokenPriceCache() {
        try {
          const result = SafeLocalStorage.getItem(SafeLocalStorageKeys.TOKEN_PRICE_CACHE);
          return result ? JSON.parse(result) : {};
        } catch {
          console.info("Unable to get token price cache");
        }
        return {};
      },
      getTokenPriceCacheForAddresses(addresses) {
        try {
          const cache = StorageUtil.getTokenPriceCache();
          const tokenPriceCache = cache[addresses.join(",")];
          if (tokenPriceCache && !this.isCacheExpired(tokenPriceCache.timestamp, this.cacheExpiry.tokenPrice)) {
            return tokenPriceCache.tokenPrice;
          }
          StorageUtil.removeTokenPriceCache(addresses);
        } catch {
          console.info("Unable to get token price cache for addresses", addresses);
        }
        return void 0;
      },
      updateTokenPriceCache(params) {
        try {
          const cache = StorageUtil.getTokenPriceCache();
          cache[params.addresses.join(",")] = {
            timestamp: params.timestamp,
            tokenPrice: params.tokenPrice
          };
          SafeLocalStorage.setItem(SafeLocalStorageKeys.TOKEN_PRICE_CACHE, JSON.stringify(cache));
        } catch {
          console.info("Unable to update token price cache", params);
        }
      },
      removeTokenPriceCache(addresses) {
        try {
          const cache = StorageUtil.getTokenPriceCache();
          SafeLocalStorage.setItem(SafeLocalStorageKeys.TOKEN_PRICE_CACHE, JSON.stringify({ ...cache, [addresses.join(",")]: void 0 }));
        } catch {
          console.info("Unable to remove token price cache", addresses);
        }
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js
var CoreHelperUtil;
var init_CoreHelperUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/CoreHelperUtil.js"() {
    init_esm8();
    init_ConstantsUtil2();
    init_StorageUtil();
    CoreHelperUtil = {
      isMobile() {
        if (this.isClient()) {
          return Boolean(window?.matchMedia && typeof window.matchMedia === "function" && window.matchMedia("(pointer:coarse)")?.matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
        }
        return false;
      },
      checkCaipNetwork(network, networkName = "") {
        return network?.caipNetworkId.toLocaleLowerCase().includes(networkName.toLowerCase());
      },
      isAndroid() {
        if (!this.isMobile()) {
          return false;
        }
        const ua2 = window?.navigator.userAgent.toLowerCase();
        return CoreHelperUtil.isMobile() && ua2.includes("android");
      },
      isIos() {
        if (!this.isMobile()) {
          return false;
        }
        const ua2 = window?.navigator.userAgent.toLowerCase();
        return ua2.includes("iphone") || ua2.includes("ipad");
      },
      isSafari() {
        if (!this.isClient()) {
          return false;
        }
        const ua2 = window?.navigator.userAgent.toLowerCase();
        return ua2.includes("safari");
      },
      isClient() {
        return typeof window !== "undefined";
      },
      isPairingExpired(expiry) {
        return expiry ? expiry - Date.now() <= ConstantsUtil2.TEN_SEC_MS : true;
      },
      isAllowedRetry(lastRetry, differenceMs = ConstantsUtil2.ONE_SEC_MS) {
        return Date.now() - lastRetry >= differenceMs;
      },
      copyToClopboard(text) {
        navigator.clipboard.writeText(text);
      },
      isIframe() {
        try {
          return window?.self !== window?.top;
        } catch (e10) {
          return false;
        }
      },
      isSafeApp() {
        if (CoreHelperUtil.isClient() && window.self !== window.top) {
          try {
            const ancestor = window?.location?.ancestorOrigins?.[0];
            const safeAppUrl = "https://app.safe.global";
            if (ancestor) {
              const ancestorUrl = new URL(ancestor);
              const safeUrl = new URL(safeAppUrl);
              return ancestorUrl.hostname === safeUrl.hostname;
            }
          } catch {
            return false;
          }
        }
        return false;
      },
      getPairingExpiry() {
        return Date.now() + ConstantsUtil2.FOUR_MINUTES_MS;
      },
      getNetworkId(caipAddress) {
        return caipAddress?.split(":")[1];
      },
      getPlainAddress(caipAddress) {
        return caipAddress?.split(":")[2];
      },
      async wait(milliseconds) {
        return new Promise((resolve) => {
          setTimeout(resolve, milliseconds);
        });
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      debounce(func, timeout = 500) {
        let timer = void 0;
        return (...args) => {
          function next() {
            func(...args);
          }
          if (timer) {
            clearTimeout(timer);
          }
          timer = setTimeout(next, timeout);
        };
      },
      isHttpUrl(url) {
        return url.startsWith("http://") || url.startsWith("https://");
      },
      formatNativeUrl(appUrl, wcUri, universalLink = null) {
        if (CoreHelperUtil.isHttpUrl(appUrl)) {
          return this.formatUniversalUrl(appUrl, wcUri);
        }
        let safeAppUrl = appUrl;
        let safeUniversalLink = universalLink;
        if (!safeAppUrl.includes("://")) {
          safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
          safeAppUrl = `${safeAppUrl}://`;
        }
        if (!safeAppUrl.endsWith("/")) {
          safeAppUrl = `${safeAppUrl}/`;
        }
        if (safeUniversalLink && !safeUniversalLink?.endsWith("/")) {
          safeUniversalLink = `${safeUniversalLink}/`;
        }
        if (this.isTelegram() && this.isAndroid()) {
          wcUri = encodeURIComponent(wcUri);
        }
        const encodedWcUrl = encodeURIComponent(wcUri);
        return {
          redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
          redirectUniversalLink: safeUniversalLink ? `${safeUniversalLink}wc?uri=${encodedWcUrl}` : void 0,
          href: safeAppUrl
        };
      },
      formatUniversalUrl(appUrl, wcUri) {
        if (!CoreHelperUtil.isHttpUrl(appUrl)) {
          return this.formatNativeUrl(appUrl, wcUri);
        }
        let safeAppUrl = appUrl;
        if (!safeAppUrl.endsWith("/")) {
          safeAppUrl = `${safeAppUrl}/`;
        }
        const encodedWcUrl = encodeURIComponent(wcUri);
        return {
          redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
          href: safeAppUrl
        };
      },
      getOpenTargetForPlatform(target) {
        if (target === "popupWindow") {
          return target;
        }
        if (this.isTelegram()) {
          if (StorageUtil.getTelegramSocialProvider()) {
            return "_top";
          }
          return "_blank";
        }
        return target;
      },
      openHref(href, target, features) {
        window?.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
      },
      returnOpenHref(href, target, features) {
        return window?.open(href, this.getOpenTargetForPlatform(target), features || "noreferrer noopener");
      },
      isTelegram() {
        return typeof window !== "undefined" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (Boolean(window.TelegramWebviewProxy) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Boolean(window.Telegram) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Boolean(window.TelegramWebviewProxyProto));
      },
      isPWA() {
        if (typeof window === "undefined") {
          return false;
        }
        const isStandaloneDisplayMode = window?.matchMedia && typeof window.matchMedia === "function" ? window.matchMedia("(display-mode: standalone)")?.matches : false;
        const isIOSStandalone = window?.navigator?.standalone;
        return Boolean(isStandaloneDisplayMode || isIOSStandalone);
      },
      async preloadImage(src2) {
        const imagePromise = new Promise((resolve, reject) => {
          const image = new Image();
          image.onload = resolve;
          image.onerror = reject;
          image.crossOrigin = "anonymous";
          image.src = src2;
        });
        return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
      },
      formatBalance(balance, symbol) {
        let formattedBalance = "0.000";
        if (typeof balance === "string") {
          const number2 = Number(balance);
          if (number2) {
            const formattedValue = Math.floor(number2 * 1e3) / 1e3;
            if (formattedValue) {
              formattedBalance = formattedValue.toString();
            }
          }
        }
        return `${formattedBalance}${symbol ? ` ${symbol}` : ""}`;
      },
      formatBalance2(balance, symbol) {
        let formattedBalance = void 0;
        if (balance === "0") {
          formattedBalance = "0";
        } else if (typeof balance === "string") {
          const number2 = Number(balance);
          if (number2) {
            formattedBalance = number2.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
          }
        }
        return {
          value: formattedBalance ?? "0",
          rest: formattedBalance === "0" ? "000" : "",
          symbol
        };
      },
      getApiUrl() {
        return ConstantsUtil.W3M_API_URL;
      },
      getBlockchainApiUrl() {
        return ConstantsUtil.BLOCKCHAIN_API_RPC_URL;
      },
      getAnalyticsUrl() {
        return ConstantsUtil.PULSE_API_URL;
      },
      getUUID() {
        if (crypto?.randomUUID) {
          return crypto.randomUUID();
        }
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c12) => {
          const r9 = Math.random() * 16 | 0;
          const v8 = c12 === "x" ? r9 : r9 & 3 | 8;
          return v8.toString(16);
        });
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parseError(error2) {
        if (typeof error2 === "string") {
          return error2;
        } else if (typeof error2?.issues?.[0]?.message === "string") {
          return error2.issues[0].message;
        } else if (error2 instanceof Error) {
          return error2.message;
        }
        return "Unknown error";
      },
      sortRequestedNetworks(approvedIds, requestedNetworks = []) {
        const approvedIndexMap = {};
        if (requestedNetworks && approvedIds) {
          approvedIds.forEach((id, index2) => {
            approvedIndexMap[id] = index2;
          });
          requestedNetworks.sort((a5, b7) => {
            const indexA = approvedIndexMap[a5.id];
            const indexB = approvedIndexMap[b7.id];
            if (indexA !== void 0 && indexB !== void 0) {
              return indexA - indexB;
            } else if (indexA !== void 0) {
              return -1;
            } else if (indexB !== void 0) {
              return 1;
            }
            return 0;
          });
        }
        return requestedNetworks;
      },
      calculateBalance(array) {
        let sum = 0;
        for (const item of array) {
          sum += item.value ?? 0;
        }
        return sum;
      },
      formatTokenBalance(number2) {
        const roundedNumber = number2.toFixed(2);
        const [dollars, pennies] = roundedNumber.split(".");
        return { dollars, pennies };
      },
      isAddress(address2, chain3 = "eip155") {
        switch (chain3) {
          case "eip155":
            if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address2)) {
              return false;
            } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address2) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address2)) {
              return true;
            }
            return false;
          case "solana":
            return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address2);
          default:
            return false;
        }
      },
      uniqueBy(arr, key) {
        const set2 = /* @__PURE__ */ new Set();
        return arr.filter((item) => {
          const keyValue = item[key];
          if (set2.has(keyValue)) {
            return false;
          }
          set2.add(keyValue);
          return true;
        });
      },
      generateSdkVersion(adapters, platform, version4) {
        const hasNoAdapters = adapters.length === 0;
        const adapterNames = hasNoAdapters ? ConstantsUtil2.ADAPTER_TYPES.UNIVERSAL : adapters.map((adapter) => adapter.adapterType).join(",");
        return `${platform}-${adapterNames}-${version4}`;
      },
      // eslint-disable-next-line max-params
      createAccount(namespace, address2, type, publicKey, path) {
        return {
          namespace,
          address: address2,
          type,
          publicKey,
          path
        };
      },
      isCaipAddress(address2) {
        if (typeof address2 !== "string") {
          return false;
        }
        const sections = address2.split(":");
        const namespace = sections[0];
        return sections.filter(Boolean).length === 3 && namespace in ConstantsUtil.CHAIN_NAME_MAP;
      },
      getAccount(account) {
        if (!account) {
          return {
            address: void 0,
            chainId: void 0
          };
        }
        if (typeof account === "string") {
          return {
            address: account,
            chainId: void 0
          };
        }
        return {
          address: account.address,
          chainId: account.chainId
        };
      },
      isMac() {
        const ua2 = window?.navigator.userAgent.toLowerCase();
        return ua2.includes("macintosh") && !ua2.includes("safari");
      },
      formatTelegramSocialLoginUrl(url) {
        const valueToInject = `--${encodeURIComponent(window?.location.href)}`;
        const paramToInject = "state=";
        const parsedUrl = new URL(url);
        if (parsedUrl.host === "auth.magic.link") {
          const providerParam = "provider_authorization_url=";
          const providerUrl = url.substring(url.indexOf(providerParam) + providerParam.length);
          const resultUrl = this.injectIntoUrl(decodeURIComponent(providerUrl), paramToInject, valueToInject);
          return url.replace(providerUrl, encodeURIComponent(resultUrl));
        }
        return this.injectIntoUrl(url, paramToInject, valueToInject);
      },
      injectIntoUrl(url, key, appendString) {
        const keyIndex = url.indexOf(key);
        if (keyIndex === -1) {
          throw new Error(`${key} parameter not found in the URL: ${url}`);
        }
        const keyEndIndex = url.indexOf("&", keyIndex);
        const keyLength = key.length;
        const keyParamEnd = keyEndIndex !== -1 ? keyEndIndex : url.length;
        const beforeKeyValue = url.substring(0, keyIndex + keyLength);
        const currentKeyValue = url.substring(keyIndex + keyLength, keyParamEnd);
        const afterKeyValue = url.substring(keyEndIndex);
        const newKeyValue = currentKeyValue + appendString;
        const newUrl = beforeKeyValue + newKeyValue + afterKeyValue;
        return newUrl;
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/FetchUtil.js
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err2 = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err2;
  }
  return response;
}
var FetchUtil;
var init_FetchUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/FetchUtil.js"() {
    FetchUtil = class {
      constructor({ baseUrl: baseUrl4, clientId }) {
        this.baseUrl = baseUrl4;
        this.clientId = clientId;
      }
      async get({ headers, signal, cache, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, { method: "GET", headers, signal, cache });
        return response.json();
      }
      async getBlob({ headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, { method: "GET", headers, signal });
        return response.blob();
      }
      async post({ body, headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, {
          method: "POST",
          headers,
          body: body ? JSON.stringify(body) : void 0,
          signal
        });
        return response.json();
      }
      async put({ body, headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, {
          method: "PUT",
          headers,
          body: body ? JSON.stringify(body) : void 0,
          signal
        });
        return response.json();
      }
      async delete({ body, headers, signal, ...args }) {
        const url = this.createUrl(args);
        const response = await fetchData(url, {
          method: "DELETE",
          headers,
          body: body ? JSON.stringify(body) : void 0,
          signal
        });
        return response.json();
      }
      createUrl({ path, params }) {
        const url = new URL(path, this.baseUrl);
        if (params) {
          Object.entries(params).forEach(([key, value]) => {
            if (value) {
              url.searchParams.append(key, value);
            }
          });
        }
        if (this.clientId) {
          url.searchParams.append("clientId", this.clientId);
        }
        return url;
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/OptionsUtil.js
var OptionsUtil;
var init_OptionsUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/OptionsUtil.js"() {
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    OptionsUtil = {
      getFeatureValue(key, features) {
        const optionValue = features?.[key];
        if (optionValue === void 0) {
          return ConstantsUtil2.DEFAULT_FEATURES[key];
        }
        return optionValue;
      },
      filterSocialsByPlatform(socials) {
        if (!socials || !socials.length) {
          return socials;
        }
        if (CoreHelperUtil.isTelegram()) {
          if (CoreHelperUtil.isIos()) {
            return socials.filter((s8) => s8 !== "google");
          }
          if (CoreHelperUtil.isMac()) {
            return socials.filter((s8) => s8 !== "x");
          }
          if (CoreHelperUtil.isAndroid()) {
            return socials.filter((s8) => !["facebook", "x"].includes(s8));
          }
        }
        return socials;
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js
var state, OptionsController;
var init_OptionsController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OptionsController.js"() {
    init_vanilla();
    init_utils3();
    init_ConstantsUtil2();
    init_OptionsUtil();
    state = proxy({
      features: ConstantsUtil2.DEFAULT_FEATURES,
      projectId: "",
      sdkType: "appkit",
      sdkVersion: "html-wagmi-undefined",
      defaultAccountTypes: ConstantsUtil2.DEFAULT_ACCOUNT_TYPES,
      enableNetworkSwitch: true,
      experimental_preferUniversalLinks: false,
      remoteFeatures: {}
    });
    OptionsController = {
      state,
      subscribeKey(key, callback) {
        return subscribeKey(state, key, callback);
      },
      setOptions(options) {
        Object.assign(state, options);
      },
      setRemoteFeatures(remoteFeatures) {
        if (!remoteFeatures) {
          return;
        }
        const newRemoteFeatures = { ...state.remoteFeatures, ...remoteFeatures };
        state.remoteFeatures = newRemoteFeatures;
        if (state.remoteFeatures?.socials) {
          state.remoteFeatures.socials = OptionsUtil.filterSocialsByPlatform(state.remoteFeatures.socials);
        }
        if (state.features?.pay) {
          state.remoteFeatures.email = false;
          state.remoteFeatures.socials = false;
        }
      },
      setFeatures(features) {
        if (!features) {
          return;
        }
        if (!state.features) {
          state.features = ConstantsUtil2.DEFAULT_FEATURES;
        }
        const newFeatures = { ...state.features, ...features };
        state.features = newFeatures;
        if (state.features?.pay && state.remoteFeatures) {
          state.remoteFeatures.email = false;
          state.remoteFeatures.socials = false;
        }
      },
      setProjectId(projectId) {
        state.projectId = projectId;
      },
      setCustomRpcUrls(customRpcUrls) {
        state.customRpcUrls = customRpcUrls;
      },
      setAllWallets(allWallets) {
        state.allWallets = allWallets;
      },
      setIncludeWalletIds(includeWalletIds) {
        state.includeWalletIds = includeWalletIds;
      },
      setExcludeWalletIds(excludeWalletIds) {
        state.excludeWalletIds = excludeWalletIds;
      },
      setFeaturedWalletIds(featuredWalletIds) {
        state.featuredWalletIds = featuredWalletIds;
      },
      setTokens(tokens) {
        state.tokens = tokens;
      },
      setTermsConditionsUrl(termsConditionsUrl) {
        state.termsConditionsUrl = termsConditionsUrl;
      },
      setPrivacyPolicyUrl(privacyPolicyUrl) {
        state.privacyPolicyUrl = privacyPolicyUrl;
      },
      setCustomWallets(customWallets) {
        state.customWallets = customWallets;
      },
      setIsSiweEnabled(isSiweEnabled) {
        state.isSiweEnabled = isSiweEnabled;
      },
      setIsUniversalProvider(isUniversalProvider) {
        state.isUniversalProvider = isUniversalProvider;
      },
      setSdkVersion(sdkVersion) {
        state.sdkVersion = sdkVersion;
      },
      setMetadata(metadata) {
        state.metadata = metadata;
      },
      setDisableAppend(disableAppend) {
        state.disableAppend = disableAppend;
      },
      setEIP6963Enabled(enableEIP6963) {
        state.enableEIP6963 = enableEIP6963;
      },
      setDebug(debug) {
        state.debug = debug;
      },
      setEnableWalletConnect(enableWalletConnect) {
        state.enableWalletConnect = enableWalletConnect;
      },
      setEnableWalletGuide(enableWalletGuide) {
        state.enableWalletGuide = enableWalletGuide;
      },
      setEnableAuthLogger(enableAuthLogger) {
        state.enableAuthLogger = enableAuthLogger;
      },
      setEnableWallets(enableWallets) {
        state.enableWallets = enableWallets;
      },
      setPreferUniversalLinks(preferUniversalLinks) {
        state.experimental_preferUniversalLinks = preferUniversalLinks;
      },
      setSIWX(siwx) {
        if (siwx) {
          for (const [key, isVal] of Object.entries(ConstantsUtil2.SIWX_DEFAULTS)) {
            siwx[key] ?? (siwx[key] = isVal);
          }
        }
        state.siwx = siwx;
      },
      setConnectMethodsOrder(connectMethodsOrder) {
        state.features = {
          ...state.features,
          connectMethodsOrder
        };
      },
      setWalletFeaturesOrder(walletFeaturesOrder) {
        state.features = {
          ...state.features,
          walletFeaturesOrder
        };
      },
      setSocialsOrder(socialsOrder) {
        state.remoteFeatures = {
          ...state.remoteFeatures,
          socials: socialsOrder
        };
      },
      setCollapseWallets(collapseWallets) {
        state.features = {
          ...state.features,
          collapseWallets
        };
      },
      setEnableEmbedded(enableEmbedded) {
        state.enableEmbedded = enableEmbedded;
      },
      setAllowUnsupportedChain(allowUnsupportedChain) {
        state.allowUnsupportedChain = allowUnsupportedChain;
      },
      setManualWCControl(manualWCControl) {
        state.manualWCControl = manualWCControl;
      },
      setEnableNetworkSwitch(enableNetworkSwitch) {
        state.enableNetworkSwitch = enableNetworkSwitch;
      },
      setEnableReconnect(enableReconnect) {
        state.enableReconnect = enableReconnect;
      },
      setDefaultAccountTypes(defaultAccountType = {}) {
        Object.entries(defaultAccountType).forEach(([namespace, accountType]) => {
          if (accountType) {
            state.defaultAccountTypes[namespace] = accountType;
          }
        });
      },
      setUniversalProviderConfigOverride(universalProviderConfigOverride) {
        state.universalProviderConfigOverride = universalProviderConfigOverride;
      },
      getUniversalProviderConfigOverride() {
        return state.universalProviderConfigOverride;
      },
      getSnapshot() {
        return snapshot(state);
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TelemetryController.js
var DEFAULT_STATE, api, MAX_ERRORS_PER_MINUTE, ONE_MINUTE_MS, state2, TelemetryController;
var init_TelemetryController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TelemetryController.js"() {
    init_vanilla();
    init_utils3();
    init_CoreHelperUtil();
    init_FetchUtil();
    init_OptionsController();
    DEFAULT_STATE = Object.freeze({
      enabled: true,
      events: []
    });
    api = new FetchUtil({ baseUrl: CoreHelperUtil.getAnalyticsUrl(), clientId: null });
    MAX_ERRORS_PER_MINUTE = 5;
    ONE_MINUTE_MS = 60 * 1e3;
    state2 = proxy({
      ...DEFAULT_STATE
    });
    TelemetryController = {
      state: state2,
      subscribeKey(key, callback) {
        return subscribeKey(state2, key, callback);
      },
      async sendError(error2, category) {
        if (!state2.enabled) {
          return;
        }
        const now = Date.now();
        const recentErrors = state2.events.filter((event) => {
          const eventTime = new Date(event.properties.timestamp || "").getTime();
          return now - eventTime < ONE_MINUTE_MS;
        });
        if (recentErrors.length >= MAX_ERRORS_PER_MINUTE) {
          return;
        }
        const errorEvent = {
          type: "error",
          event: category,
          properties: {
            errorType: error2.name,
            errorMessage: error2.message,
            stackTrace: error2.stack,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        };
        state2.events.push(errorEvent);
        try {
          if (typeof window === "undefined") {
            return;
          }
          const { projectId, sdkType, sdkVersion } = OptionsController.state;
          await api.post({
            path: "/e",
            params: {
              projectId,
              st: sdkType,
              sv: sdkVersion || "html-wagmi-4.2.2"
            },
            body: {
              eventId: CoreHelperUtil.getUUID(),
              url: window.location.href,
              domain: window.location.hostname,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              props: {
                type: "error",
                event: category,
                errorType: error2.name,
                errorMessage: error2.message,
                stackTrace: error2.stack
              }
            }
          });
        } catch {
        }
      },
      enable() {
        state2.enabled = true;
      },
      disable() {
        state2.enabled = false;
      },
      clearEvents() {
        state2.events = [];
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js
function errorHandler(err2, defaultCategory) {
  const error2 = err2 instanceof AppKitError ? err2 : new AppKitError(err2 instanceof Error ? err2.message : String(err2), defaultCategory, err2);
  TelemetryController.sendError(error2, error2.category);
  throw error2;
}
function withErrorBoundary(controller16, defaultCategory = "INTERNAL_SDK_ERROR") {
  const newController = {};
  Object.keys(controller16).forEach((key) => {
    const original = controller16[key];
    if (typeof original === "function") {
      let wrapped = original;
      if (original.constructor.name === "AsyncFunction") {
        wrapped = async (...args) => {
          try {
            return await original(...args);
          } catch (err2) {
            return errorHandler(err2, defaultCategory);
          }
        };
      } else {
        wrapped = (...args) => {
          try {
            return original(...args);
          } catch (err2) {
            return errorHandler(err2, defaultCategory);
          }
        };
      }
      newController[key] = wrapped;
    } else {
      newController[key] = original;
    }
  });
  return newController;
}
var AppKitError;
var init_withErrorBoundary = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/withErrorBoundary.js"() {
    init_TelemetryController();
    AppKitError = class _AppKitError extends Error {
      constructor(message, category, originalError) {
        super(message);
        this.name = "AppKitError";
        this.category = category;
        this.originalError = originalError;
        Object.setPrototypeOf(this, _AppKitError.prototype);
        let isStackConstructedFromOriginal = false;
        if (originalError instanceof Error && typeof originalError.stack === "string" && originalError.stack) {
          const originalErrorStack = originalError.stack;
          const firstNewlineIndex = originalErrorStack.indexOf("\n");
          if (firstNewlineIndex > -1) {
            const originalFrames = originalErrorStack.substring(firstNewlineIndex + 1);
            this.stack = `${this.name}: ${this.message}
${originalFrames}`;
            isStackConstructedFromOriginal = true;
          }
        }
        if (!isStackConstructedFromOriginal) {
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _AppKitError);
          } else if (!this.stack) {
            this.stack = `${this.name}: ${this.message}`;
          }
        }
      }
    };
  }
});

// node_modules/@reown/appkit-wallet/dist/esm/src/W3mFrameConstants.js
var DEFAULT_SDK_URL, SECURE_SITE_SDK, DEFAULT_LOG_LEVEL, SECURE_SITE_SDK_VERSION, W3mFrameRpcConstants;
var init_W3mFrameConstants = __esm({
  "node_modules/@reown/appkit-wallet/dist/esm/src/W3mFrameConstants.js"() {
    DEFAULT_SDK_URL = "https://secure.walletconnect.org/sdk";
    SECURE_SITE_SDK = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_SDK_URL"] : void 0) || DEFAULT_SDK_URL;
    DEFAULT_LOG_LEVEL = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_DEFAULT_LOG_LEVEL"] : void 0) || "error";
    SECURE_SITE_SDK_VERSION = (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_SDK_VERSION"] : void 0) || "4";
    W3mFrameRpcConstants = {
      SAFE_RPC_METHODS: [
        "eth_accounts",
        "eth_blockNumber",
        "eth_call",
        "eth_chainId",
        "eth_estimateGas",
        "eth_feeHistory",
        "eth_gasPrice",
        "eth_getAccount",
        "eth_getBalance",
        "eth_getBlockByHash",
        "eth_getBlockByNumber",
        "eth_getBlockReceipts",
        "eth_getBlockTransactionCountByHash",
        "eth_getBlockTransactionCountByNumber",
        "eth_getCode",
        "eth_getFilterChanges",
        "eth_getFilterLogs",
        "eth_getLogs",
        "eth_getProof",
        "eth_getStorageAt",
        "eth_getTransactionByBlockHashAndIndex",
        "eth_getTransactionByBlockNumberAndIndex",
        "eth_getTransactionByHash",
        "eth_getTransactionCount",
        "eth_getTransactionReceipt",
        "eth_getUncleCountByBlockHash",
        "eth_getUncleCountByBlockNumber",
        "eth_maxPriorityFeePerGas",
        "eth_newBlockFilter",
        "eth_newFilter",
        "eth_newPendingTransactionFilter",
        "eth_sendRawTransaction",
        "eth_syncing",
        "eth_uninstallFilter",
        "wallet_getCapabilities",
        "wallet_getCallsStatus",
        "eth_getUserOperationReceipt",
        "eth_estimateUserOperationGas",
        "eth_getUserOperationByHash",
        "eth_supportedEntryPoints",
        "wallet_getAssets"
      ],
      NOT_SAFE_RPC_METHODS: [
        "personal_sign",
        "eth_signTypedData_v4",
        "eth_sendTransaction",
        "solana_signMessage",
        "solana_signTransaction",
        "solana_signAllTransactions",
        "solana_signAndSendTransaction",
        "wallet_sendCalls",
        "wallet_grantPermissions",
        "wallet_revokePermissions",
        "eth_sendUserOperation"
      ],
      GET_CHAIN_ID: "eth_chainId",
      RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
      RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
      ACCOUNT_TYPES: {
        EOA: "eoa",
        SMART_ACCOUNT: "smartAccount"
      }
    };
  }
});

// node_modules/@reown/appkit-wallet/dist/esm/exports/utils.js
var init_utils4 = __esm({
  "node_modules/@reown/appkit-wallet/dist/esm/exports/utils.js"() {
    init_W3mFrameConstants();
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/MobileWallet.js
var CUSTOM_DEEPLINK_WALLETS, MobileWalletUtil;
var init_MobileWallet = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/MobileWallet.js"() {
    init_esm8();
    CUSTOM_DEEPLINK_WALLETS = {
      PHANTOM: {
        id: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
        url: "https://phantom.app"
      },
      SOLFLARE: {
        id: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
        url: "https://solflare.com"
      },
      COINBASE: {
        id: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
        url: "https://go.cb-w.com"
      }
    };
    MobileWalletUtil = {
      /**
       * Handles mobile wallet redirection for wallets that have Universal Links and doesn't support WalletConnect Deep Links.
       *
       * @param {string} id - The id of the wallet.
       * @param {ChainNamespace} namespace - The namespace of the chain.
       */
      handleMobileDeeplinkRedirect(id, namespace) {
        const href = window.location.href;
        const encodedHref = encodeURIComponent(href);
        if (id === CUSTOM_DEEPLINK_WALLETS.PHANTOM.id && !("phantom" in window)) {
          const protocol = href.startsWith("https") ? "https" : "http";
          const host = href.split("/")[2];
          const encodedRef = encodeURIComponent(`${protocol}://${host}`);
          window.location.href = `${CUSTOM_DEEPLINK_WALLETS.PHANTOM.url}/ul/browse/${encodedHref}?ref=${encodedRef}`;
        }
        if (id === CUSTOM_DEEPLINK_WALLETS.SOLFLARE.id && !("solflare" in window)) {
          window.location.href = `${CUSTOM_DEEPLINK_WALLETS.SOLFLARE.url}/ul/v1/browse/${encodedHref}?ref=${encodedHref}`;
        }
        if (namespace === ConstantsUtil.CHAIN.SOLANA) {
          if (id === CUSTOM_DEEPLINK_WALLETS.COINBASE.id && !("coinbaseSolana" in window)) {
            window.location.href = `${CUSTOM_DEEPLINK_WALLETS.COINBASE.url}/dapp?cb_url=${encodedHref}`;
          }
        }
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AssetController.js
var state3, controller, AssetController;
var init_AssetController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AssetController.js"() {
    init_vanilla();
    init_utils3();
    init_withErrorBoundary();
    state3 = proxy({
      walletImages: {},
      networkImages: {},
      chainImages: {},
      connectorImages: {},
      tokenImages: {},
      currencyImages: {}
    });
    controller = {
      state: state3,
      subscribeNetworkImages(callback) {
        return subscribe(state3.networkImages, () => callback(state3.networkImages));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state3, key, callback);
      },
      subscribe(callback) {
        return subscribe(state3, () => callback(state3));
      },
      setWalletImage(key, value) {
        state3.walletImages[key] = value;
      },
      setNetworkImage(key, value) {
        state3.networkImages[key] = value;
      },
      setChainImage(key, value) {
        state3.chainImages[key] = value;
      },
      setConnectorImage(key, value) {
        state3.connectorImages = { ...state3.connectorImages, [key]: value };
      },
      setTokenImage(key, value) {
        state3.tokenImages[key] = value;
      },
      setCurrencyImage(key, value) {
        state3.currencyImages[key] = value;
      }
    };
    AssetController = withErrorBoundary(controller);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/AssetUtil.js
var namespaceImageIds, state4, AssetUtil;
var init_AssetUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/AssetUtil.js"() {
    init_vanilla();
    init_ApiController();
    init_AssetController();
    namespaceImageIds = {
      // Ethereum
      eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
      // Solana
      solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
      // Polkadot
      polkadot: "",
      // Bitcoin
      bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
      // Cosmos
      cosmos: "",
      // Sui
      sui: "",
      // Stacks
      stacks: ""
    };
    state4 = proxy({
      networkImagePromises: {}
    });
    AssetUtil = {
      async fetchWalletImage(imageId) {
        if (!imageId) {
          return void 0;
        }
        await ApiController._fetchWalletImage(imageId);
        return this.getWalletImageById(imageId);
      },
      async fetchNetworkImage(imageId) {
        if (!imageId) {
          return void 0;
        }
        const existingImage = this.getNetworkImageById(imageId);
        if (existingImage) {
          return existingImage;
        }
        if (!state4.networkImagePromises[imageId]) {
          state4.networkImagePromises[imageId] = ApiController._fetchNetworkImage(imageId);
        }
        await state4.networkImagePromises[imageId];
        return this.getNetworkImageById(imageId);
      },
      getWalletImageById(imageId) {
        if (!imageId) {
          return void 0;
        }
        return AssetController.state.walletImages[imageId];
      },
      getWalletImage(wallet) {
        if (wallet?.image_url) {
          return wallet?.image_url;
        }
        if (wallet?.image_id) {
          return AssetController.state.walletImages[wallet.image_id];
        }
        return void 0;
      },
      getNetworkImage(network) {
        if (network?.assets?.imageUrl) {
          return network?.assets?.imageUrl;
        }
        if (network?.assets?.imageId) {
          return AssetController.state.networkImages[network.assets.imageId];
        }
        return void 0;
      },
      getNetworkImageById(imageId) {
        if (!imageId) {
          return void 0;
        }
        return AssetController.state.networkImages[imageId];
      },
      getConnectorImage(connector) {
        if (connector?.imageUrl) {
          return connector.imageUrl;
        }
        if (connector?.info?.icon) {
          return connector.info.icon;
        }
        if (connector?.imageId) {
          return AssetController.state.connectorImages[connector.imageId];
        }
        return void 0;
      },
      getChainImage(chain3) {
        return AssetController.state.networkImages[namespaceImageIds[chain3]];
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AlertController.js
var state5, controller2, AlertController;
var init_AlertController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AlertController.js"() {
    init_vanilla();
    init_utils3();
    init_withErrorBoundary();
    init_OptionsController();
    state5 = proxy({
      message: "",
      variant: "info",
      open: false
    });
    controller2 = {
      state: state5,
      subscribeKey(key, callback) {
        return subscribeKey(state5, key, callback);
      },
      open(message, variant) {
        const { debug } = OptionsController.state;
        const { code: code2, displayMessage, debugMessage } = message;
        if (displayMessage && debug) {
          state5.message = displayMessage;
          state5.variant = variant;
          state5.open = true;
        }
        if (debugMessage) {
          console.error(typeof debugMessage === "function" ? debugMessage() : debugMessage, code2 ? { code: code2 } : void 0);
        }
      },
      close() {
        state5.open = false;
        state5.message = "";
        state5.variant = "info";
      }
    };
    AlertController = withErrorBoundary(controller2);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js
var baseUrl, api2, excluded, state6, EventsController;
var init_EventsController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EventsController.js"() {
    init_vanilla();
    init_esm8();
    init_CoreHelperUtil();
    init_FetchUtil();
    init_AccountController();
    init_AlertController();
    init_OptionsController();
    baseUrl = CoreHelperUtil.getAnalyticsUrl();
    api2 = new FetchUtil({ baseUrl, clientId: null });
    excluded = ["MODAL_CREATED"];
    state6 = proxy({
      timestamp: Date.now(),
      reportedErrors: {},
      data: {
        type: "track",
        event: "MODAL_CREATED"
      }
    });
    EventsController = {
      state: state6,
      subscribe(callback) {
        return subscribe(state6, () => callback(state6));
      },
      getSdkProperties() {
        const { projectId, sdkType, sdkVersion } = OptionsController.state;
        return {
          projectId,
          st: sdkType,
          sv: sdkVersion || "html-wagmi-4.2.2"
        };
      },
      async _sendAnalyticsEvent(payload) {
        try {
          const address2 = AccountController.state.address;
          if (excluded.includes(payload.data.event) || typeof window === "undefined") {
            return;
          }
          await api2.post({
            path: "/e",
            params: EventsController.getSdkProperties(),
            body: {
              eventId: CoreHelperUtil.getUUID(),
              url: window.location.href,
              domain: window.location.hostname,
              timestamp: payload.timestamp,
              props: { ...payload.data, address: address2 }
            }
          });
          state6.reportedErrors["FORBIDDEN"] = false;
        } catch (err2) {
          const isForbiddenError = err2 instanceof Error && err2.cause instanceof Response && err2.cause.status === ConstantsUtil.HTTP_STATUS_CODES.FORBIDDEN && !state6.reportedErrors["FORBIDDEN"];
          if (isForbiddenError) {
            AlertController.open({
              displayMessage: "Invalid App Configuration",
              debugMessage: `Origin ${isSafe() ? window.origin : "uknown"} not found on Allowlist - update configuration on cloud.reown.com`
            }, "error");
            state6.reportedErrors["FORBIDDEN"] = true;
          }
        }
      },
      sendEvent(data) {
        state6.timestamp = Date.now();
        state6.data = data;
        if (OptionsController.state.features?.analytics || data.event === "INITIALIZE") {
          EventsController._sendAnalyticsEvent(state6);
        }
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js
var baseUrl2, api3, entries, recommendedEntries, imageCountToFetch, state7, ApiController;
var init_ApiController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ApiController.js"() {
    init_vanilla();
    init_utils3();
    init_esm8();
    init_AssetUtil();
    init_CoreHelperUtil();
    init_FetchUtil();
    init_MobileWallet();
    init_StorageUtil();
    init_AssetController();
    init_ChainController();
    init_ConnectorController();
    init_EventsController();
    init_OptionsController();
    baseUrl2 = CoreHelperUtil.getApiUrl();
    api3 = new FetchUtil({
      baseUrl: baseUrl2,
      clientId: null
    });
    entries = 40;
    recommendedEntries = 4;
    imageCountToFetch = 20;
    state7 = proxy({
      promises: {},
      page: 1,
      count: 0,
      featured: [],
      allFeatured: [],
      recommended: [],
      allRecommended: [],
      wallets: [],
      filteredWallets: [],
      search: [],
      isAnalyticsEnabled: false,
      excludedWallets: [],
      isFetchingRecommendedWallets: false
    });
    ApiController = {
      state: state7,
      subscribeKey(key, callback) {
        return subscribeKey(state7, key, callback);
      },
      _getSdkProperties() {
        const { projectId, sdkType, sdkVersion } = OptionsController.state;
        return {
          projectId,
          st: sdkType || "appkit",
          sv: sdkVersion || "html-wagmi-4.2.2"
        };
      },
      _filterOutExtensions(wallets) {
        if (OptionsController.state.isUniversalProvider) {
          return wallets.filter((w6) => Boolean(w6.mobile_link || w6.desktop_link || w6.webapp_link));
        }
        return wallets;
      },
      async _fetchWalletImage(imageId) {
        const imageUrl = `${api3.baseUrl}/getWalletImage/${imageId}`;
        const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
      },
      async _fetchNetworkImage(imageId) {
        const imageUrl = `${api3.baseUrl}/public/getAssetImage/${imageId}`;
        const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
      },
      async _fetchConnectorImage(imageId) {
        const imageUrl = `${api3.baseUrl}/public/getAssetImage/${imageId}`;
        const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
      },
      async _fetchCurrencyImage(countryCode) {
        const imageUrl = `${api3.baseUrl}/public/getCurrencyImage/${countryCode}`;
        const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
      },
      async _fetchTokenImage(symbol) {
        const imageUrl = `${api3.baseUrl}/public/getTokenImage/${symbol}`;
        const blob = await api3.getBlob({ path: imageUrl, params: ApiController._getSdkProperties() });
        AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
      },
      _filterWalletsByPlatform(wallets) {
        const filteredWallets = CoreHelperUtil.isMobile() ? wallets?.filter((w6) => {
          if (w6.mobile_link) {
            return true;
          }
          if (w6.id === CUSTOM_DEEPLINK_WALLETS.COINBASE.id) {
            return true;
          }
          const isSolana = ChainController.state.activeChain === "solana";
          return isSolana && (w6.id === CUSTOM_DEEPLINK_WALLETS.SOLFLARE.id || w6.id === CUSTOM_DEEPLINK_WALLETS.PHANTOM.id);
        }) : wallets;
        return filteredWallets;
      },
      async fetchProjectConfig() {
        const response = await api3.get({
          path: "/appkit/v1/config",
          params: ApiController._getSdkProperties()
        });
        return response.features;
      },
      async fetchAllowedOrigins() {
        try {
          const { allowedOrigins } = await api3.get({
            path: "/projects/v1/origins",
            params: ApiController._getSdkProperties()
          });
          return allowedOrigins;
        } catch (error2) {
          if (error2 instanceof Error && error2.cause instanceof Response) {
            const status = error2.cause.status;
            if (status === ConstantsUtil.HTTP_STATUS_CODES.TOO_MANY_REQUESTS) {
              throw new Error("RATE_LIMITED", { cause: error2 });
            }
            if (status >= ConstantsUtil.HTTP_STATUS_CODES.SERVER_ERROR && status < 600) {
              throw new Error("SERVER_ERROR", { cause: error2 });
            }
            return [];
          }
          return [];
        }
      },
      async fetchNetworkImages() {
        const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
        const ids = requestedCaipNetworks?.map(({ assets }) => assets?.imageId).filter(Boolean).filter((imageId) => !AssetUtil.getNetworkImageById(imageId));
        if (ids) {
          await Promise.allSettled(ids.map((id) => ApiController._fetchNetworkImage(id)));
        }
      },
      async fetchConnectorImages() {
        const { connectors } = ConnectorController.state;
        const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
        await Promise.allSettled(ids.map((id) => ApiController._fetchConnectorImage(id)));
      },
      async fetchCurrencyImages(currencies = []) {
        await Promise.allSettled(currencies.map((currency) => ApiController._fetchCurrencyImage(currency)));
      },
      async fetchTokenImages(tokens = []) {
        await Promise.allSettled(tokens.map((token) => ApiController._fetchTokenImage(token)));
      },
      async fetchWallets(params) {
        const exclude = params.exclude ?? [];
        const sdkProperties = ApiController._getSdkProperties();
        if (sdkProperties.sv.startsWith("html-core-")) {
          exclude.push(...Object.values(CUSTOM_DEEPLINK_WALLETS).map((w6) => w6.id));
        }
        const wallets = await api3.get({
          path: "/getWallets",
          params: {
            ...ApiController._getSdkProperties(),
            ...params,
            page: String(params.page),
            entries: String(params.entries),
            include: params.include?.join(","),
            exclude: exclude.join(",")
          }
        });
        const filteredWallets = ApiController._filterWalletsByPlatform(wallets?.data);
        return {
          data: filteredWallets || [],
          // Keep original count for display on main page
          count: wallets?.count
        };
      },
      async fetchFeaturedWallets() {
        const { featuredWalletIds } = OptionsController.state;
        if (featuredWalletIds?.length) {
          const params = {
            ...ApiController._getSdkProperties(),
            page: 1,
            entries: featuredWalletIds?.length ?? recommendedEntries,
            include: featuredWalletIds
          };
          const { data } = await ApiController.fetchWallets(params);
          const sortedData = [...data].sort((a5, b7) => featuredWalletIds.indexOf(a5.id) - featuredWalletIds.indexOf(b7.id));
          const images = sortedData.map((d7) => d7.image_id).filter(Boolean);
          await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
          state7.featured = sortedData;
          state7.allFeatured = sortedData;
        }
      },
      async fetchRecommendedWallets() {
        try {
          state7.isFetchingRecommendedWallets = true;
          const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
          const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
          const chains = ChainController.getRequestedCaipNetworkIds().join(",");
          const params = {
            page: 1,
            entries: recommendedEntries,
            include: includeWalletIds,
            exclude,
            chains
          };
          const { data, count } = await ApiController.fetchWallets(params);
          const recent = StorageUtil.getRecentWallets();
          const recommendedImages = data.map((d7) => d7.image_id).filter(Boolean);
          const recentImages = recent.map((r9) => r9.image_id).filter(Boolean);
          await Promise.allSettled([...recommendedImages, ...recentImages].map((id) => ApiController._fetchWalletImage(id)));
          state7.recommended = data;
          state7.allRecommended = data;
          state7.count = count ?? 0;
        } catch {
        } finally {
          state7.isFetchingRecommendedWallets = false;
        }
      },
      async fetchWalletsByPage({ page }) {
        const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
        const chains = ChainController.getRequestedCaipNetworkIds().join(",");
        const exclude = [
          ...state7.recommended.map(({ id }) => id),
          ...excludeWalletIds ?? [],
          ...featuredWalletIds ?? []
        ].filter(Boolean);
        const params = {
          page,
          entries,
          include: includeWalletIds,
          exclude,
          chains
        };
        const { data, count } = await ApiController.fetchWallets(params);
        const images = data.slice(0, imageCountToFetch).map((w6) => w6.image_id).filter(Boolean);
        await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
        state7.wallets = CoreHelperUtil.uniqueBy([...state7.wallets, ...ApiController._filterOutExtensions(data)], "id").filter((w6) => w6.chains?.some((chain3) => chains.includes(chain3)));
        state7.count = count > state7.count ? count : state7.count;
        state7.page = page;
      },
      async initializeExcludedWallets({ ids }) {
        const params = {
          page: 1,
          entries: ids.length,
          include: ids
        };
        const { data } = await ApiController.fetchWallets(params);
        if (data) {
          data.forEach((wallet) => {
            state7.excludedWallets.push({ rdns: wallet.rdns, name: wallet.name });
          });
        }
      },
      async searchWallet({ search, badge }) {
        const { includeWalletIds, excludeWalletIds } = OptionsController.state;
        const chains = ChainController.getRequestedCaipNetworkIds().join(",");
        state7.search = [];
        const params = {
          page: 1,
          entries: 100,
          search: search?.trim(),
          badge_type: badge,
          include: includeWalletIds,
          exclude: excludeWalletIds,
          chains
        };
        const { data } = await ApiController.fetchWallets(params);
        EventsController.sendEvent({
          type: "track",
          event: "SEARCH_WALLET",
          properties: { badge: badge ?? "", search: search ?? "" }
        });
        const images = data.map((w6) => w6.image_id).filter(Boolean);
        await Promise.allSettled([
          ...images.map((id) => ApiController._fetchWalletImage(id)),
          CoreHelperUtil.wait(300)
        ]);
        state7.search = ApiController._filterOutExtensions(data);
      },
      initPromise(key, fetchFn) {
        const existingPromise = state7.promises[key];
        if (existingPromise) {
          return existingPromise;
        }
        return state7.promises[key] = fetchFn();
      },
      prefetch({ fetchConnectorImages = true, fetchFeaturedWallets = true, fetchRecommendedWallets = true, fetchNetworkImages = true } = {}) {
        const promises = [
          fetchConnectorImages && ApiController.initPromise("connectorImages", ApiController.fetchConnectorImages),
          fetchFeaturedWallets && ApiController.initPromise("featuredWallets", ApiController.fetchFeaturedWallets),
          fetchRecommendedWallets && ApiController.initPromise("recommendedWallets", ApiController.fetchRecommendedWallets),
          fetchNetworkImages && ApiController.initPromise("networkImages", ApiController.fetchNetworkImages)
        ].filter(Boolean);
        return Promise.allSettled(promises);
      },
      prefetchAnalyticsConfig() {
        if (OptionsController.state.features?.analytics) {
          ApiController.fetchAnalyticsConfig();
        }
      },
      async fetchAnalyticsConfig() {
        try {
          const { isAnalyticsEnabled } = await api3.get({
            path: "/getAnalyticsConfig",
            params: ApiController._getSdkProperties()
          });
          OptionsController.setFeatures({ analytics: isAnalyticsEnabled });
        } catch (error2) {
          OptionsController.setFeatures({ analytics: false });
        }
      },
      filterByNamespaces(namespaces) {
        if (!namespaces?.length) {
          state7.featured = state7.allFeatured;
          state7.recommended = state7.allRecommended;
          return;
        }
        const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
        state7.featured = state7.allFeatured.filter((wallet) => wallet.chains?.some((chain3) => caipNetworkIds.includes(chain3)));
        state7.recommended = state7.allRecommended.filter((wallet) => wallet.chains?.some((chain3) => caipNetworkIds.includes(chain3)));
        state7.filteredWallets = state7.wallets.filter((wallet) => wallet.chains?.some((chain3) => caipNetworkIds.includes(chain3)));
      },
      clearFilterByNamespaces() {
        state7.filteredWallets = [];
      },
      setFilterByNamespace(namespace) {
        if (!namespace) {
          state7.featured = state7.allFeatured;
          state7.recommended = state7.allRecommended;
          return;
        }
        const caipNetworkIds = ChainController.getRequestedCaipNetworkIds().join(",");
        state7.featured = state7.allFeatured.filter((wallet) => wallet.chains?.some((chain3) => caipNetworkIds.includes(chain3)));
        state7.recommended = state7.allRecommended.filter((wallet) => wallet.chains?.some((chain3) => caipNetworkIds.includes(chain3)));
        state7.filteredWallets = state7.wallets.filter((wallet) => wallet.chains?.some((chain3) => caipNetworkIds.includes(chain3)));
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js
var state8, controller3, RouterController;
var init_RouterController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/RouterController.js"() {
    init_vanilla();
    init_utils3();
    init_withErrorBoundary();
    init_AccountController();
    init_ChainController();
    init_ConnectorController();
    init_ModalController();
    init_OptionsController();
    state8 = proxy({
      view: "Connect",
      history: ["Connect"],
      transactionStack: []
    });
    controller3 = {
      state: state8,
      subscribeKey(key, callback) {
        return subscribeKey(state8, key, callback);
      },
      pushTransactionStack(action) {
        state8.transactionStack.push(action);
      },
      popTransactionStack(status) {
        const action = state8.transactionStack.pop();
        if (!action) {
          return;
        }
        const { onSuccess, onError, onCancel } = action;
        switch (status) {
          case "success":
            onSuccess?.();
            break;
          case "error":
            onError?.();
            RouterController.goBack();
            break;
          case "cancel":
            onCancel?.();
            RouterController.goBack();
            break;
          default:
        }
      },
      push(view, data) {
        if (view !== state8.view) {
          state8.view = view;
          state8.history.push(view);
          state8.data = data;
        }
      },
      reset(view, data) {
        state8.view = view;
        state8.history = [view];
        state8.data = data;
      },
      replace(view, data) {
        const lastView = state8.history.at(-1);
        const isSameView = lastView === view;
        if (!isSameView) {
          state8.view = view;
          state8.history[state8.history.length - 1] = view;
          state8.data = data;
        }
      },
      goBack() {
        const isConnected = ChainController.state.activeCaipAddress;
        const isFarcasterView = RouterController.state.view === "ConnectingFarcaster";
        const shouldReload = !isConnected && isFarcasterView;
        if (state8.history.length > 1) {
          state8.history.pop();
          const [last] = state8.history.slice(-1);
          if (last) {
            const isConnectView = last === "Connect";
            if (isConnected && isConnectView) {
              state8.view = "Account";
            } else {
              state8.view = last;
            }
          }
        } else {
          ModalController.close();
        }
        if (state8.data?.wallet) {
          state8.data.wallet = void 0;
        }
        setTimeout(() => {
          if (shouldReload) {
            AccountController.setFarcasterUrl(void 0, ChainController.state.activeChain);
            const authConnector = ConnectorController.getAuthConnector();
            authConnector?.provider?.reload();
            const optionsState = snapshot(OptionsController.state);
            authConnector?.provider?.syncDappData?.({
              metadata: optionsState.metadata,
              sdkVersion: optionsState.sdkVersion,
              projectId: optionsState.projectId,
              sdkType: optionsState.sdkType
            });
          }
        }, 100);
      },
      goBackToIndex(historyIndex) {
        if (state8.history.length > 1) {
          state8.history = state8.history.slice(0, historyIndex + 1);
          const [last] = state8.history.slice(-1);
          if (last) {
            state8.view = last;
          }
        }
      },
      goBackOrCloseModal() {
        if (RouterController.state.history.length > 1) {
          RouterController.goBack();
        } else {
          ModalController.close();
        }
      }
    };
    RouterController = withErrorBoundary(controller3);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ThemeController.js
var state9, controller4, ThemeController;
var init_ThemeController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ThemeController.js"() {
    init_vanilla();
    init_esm8();
    init_withErrorBoundary();
    init_ConnectorController();
    state9 = proxy({
      themeMode: "dark",
      themeVariables: {},
      w3mThemeVariables: void 0
    });
    controller4 = {
      state: state9,
      subscribe(callback) {
        return subscribe(state9, () => callback(state9));
      },
      setThemeMode(themeMode) {
        state9.themeMode = themeMode;
        try {
          const authConnector = ConnectorController.getAuthConnector();
          if (authConnector) {
            const themeVariables = controller4.getSnapshot().themeVariables;
            authConnector.provider.syncTheme({
              themeMode,
              themeVariables,
              w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
            });
          }
        } catch {
          console.info("Unable to sync theme to auth connector");
        }
      },
      setThemeVariables(themeVariables) {
        state9.themeVariables = { ...state9.themeVariables, ...themeVariables };
        try {
          const authConnector = ConnectorController.getAuthConnector();
          if (authConnector) {
            const themeVariablesSnapshot = controller4.getSnapshot().themeVariables;
            authConnector.provider.syncTheme({
              themeVariables: themeVariablesSnapshot,
              w3mThemeVariables: getW3mThemeVariables(state9.themeVariables, state9.themeMode)
            });
          }
        } catch {
          console.info("Unable to sync theme to auth connector");
        }
      },
      getSnapshot() {
        return snapshot(state9);
      }
    };
    ThemeController = withErrorBoundary(controller4);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js
var defaultActiveConnectors, defaultFilterByNamespaceMap, state10, controller5, ConnectorController;
var init_ConnectorController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectorController.js"() {
    init_vanilla();
    init_utils3();
    init_esm8();
    init_utils4();
    init_ChainControllerUtil();
    init_MobileWallet();
    init_StorageUtil();
    init_withErrorBoundary();
    init_ApiController();
    init_ChainController();
    init_OptionsController();
    init_RouterController();
    init_ThemeController();
    defaultActiveConnectors = Object.fromEntries(AVAILABLE_NAMESPACES.map((namespace) => [namespace, void 0]));
    defaultFilterByNamespaceMap = Object.fromEntries(AVAILABLE_NAMESPACES.map((namespace) => [namespace, true]));
    state10 = proxy({
      allConnectors: [],
      connectors: [],
      activeConnector: void 0,
      filterByNamespace: void 0,
      activeConnectorIds: defaultActiveConnectors,
      filterByNamespaceMap: defaultFilterByNamespaceMap
    });
    controller5 = {
      state: state10,
      subscribe(callback) {
        return subscribe(state10, () => {
          callback(state10);
        });
      },
      subscribeKey(key, callback) {
        return subscribeKey(state10, key, callback);
      },
      initialize(namespaces) {
        namespaces.forEach((namespace) => {
          const connectorId = StorageUtil.getConnectedConnectorId(namespace);
          if (connectorId) {
            ConnectorController.setConnectorId(connectorId, namespace);
          }
        });
      },
      setActiveConnector(connector) {
        if (connector) {
          state10.activeConnector = ref(connector);
        }
      },
      setConnectors(connectors) {
        const newConnectors = connectors.filter((newConnector) => !state10.allConnectors.some((existingConnector) => existingConnector.id === newConnector.id && ConnectorController.getConnectorName(existingConnector.name) === ConnectorController.getConnectorName(newConnector.name) && existingConnector.chain === newConnector.chain));
        newConnectors.forEach((connector) => {
          if (connector.type !== "MULTI_CHAIN") {
            state10.allConnectors.push(ref(connector));
          }
        });
        const enabledNamespaces = ConnectorController.getEnabledNamespaces();
        const connectorsFilteredByNamespaces = ConnectorController.getEnabledConnectors(enabledNamespaces);
        state10.connectors = ConnectorController.mergeMultiChainConnectors(connectorsFilteredByNamespaces);
      },
      filterByNamespaces(enabledNamespaces) {
        Object.keys(state10.filterByNamespaceMap).forEach((namespace) => {
          state10.filterByNamespaceMap[namespace] = false;
        });
        enabledNamespaces.forEach((namespace) => {
          state10.filterByNamespaceMap[namespace] = true;
        });
        ConnectorController.updateConnectorsForEnabledNamespaces();
      },
      filterByNamespace(namespace, enabled) {
        state10.filterByNamespaceMap[namespace] = enabled;
        ConnectorController.updateConnectorsForEnabledNamespaces();
      },
      updateConnectorsForEnabledNamespaces() {
        const enabledNamespaces = ConnectorController.getEnabledNamespaces();
        const enabledConnectors = ConnectorController.getEnabledConnectors(enabledNamespaces);
        const areAllNamespacesEnabled = ConnectorController.areAllNamespacesEnabled();
        state10.connectors = ConnectorController.mergeMultiChainConnectors(enabledConnectors);
        if (areAllNamespacesEnabled) {
          ApiController.clearFilterByNamespaces();
        } else {
          ApiController.filterByNamespaces(enabledNamespaces);
        }
      },
      getEnabledNamespaces() {
        return Object.entries(state10.filterByNamespaceMap).filter(([_5, enabled]) => enabled).map(([namespace]) => namespace);
      },
      getEnabledConnectors(enabledNamespaces) {
        return state10.allConnectors.filter((connector) => enabledNamespaces.includes(connector.chain));
      },
      areAllNamespacesEnabled() {
        return Object.values(state10.filterByNamespaceMap).every((enabled) => enabled);
      },
      mergeMultiChainConnectors(connectors) {
        const connectorsByNameMap = ConnectorController.generateConnectorMapByName(connectors);
        const mergedConnectors = [];
        connectorsByNameMap.forEach((keyConnectors) => {
          const firstItem = keyConnectors[0];
          const isAuthConnector = firstItem?.id === ConstantsUtil.CONNECTOR_ID.AUTH;
          if (keyConnectors.length > 1 && firstItem) {
            mergedConnectors.push({
              name: firstItem.name,
              imageUrl: firstItem.imageUrl,
              imageId: firstItem.imageId,
              connectors: [...keyConnectors],
              type: isAuthConnector ? "AUTH" : "MULTI_CHAIN",
              // These values are just placeholders, we don't use them in multi-chain connector select screen
              chain: "eip155",
              id: firstItem?.id || ""
            });
          } else if (firstItem) {
            mergedConnectors.push(firstItem);
          }
        });
        return mergedConnectors;
      },
      generateConnectorMapByName(connectors) {
        const connectorsByNameMap = /* @__PURE__ */ new Map();
        connectors.forEach((connector) => {
          const { name: name2 } = connector;
          const connectorName = ConnectorController.getConnectorName(name2);
          if (!connectorName) {
            return;
          }
          const connectorsByName = connectorsByNameMap.get(connectorName) || [];
          const haveSameConnector = connectorsByName.find((c12) => c12.chain === connector.chain);
          if (!haveSameConnector) {
            connectorsByName.push(connector);
          }
          connectorsByNameMap.set(connectorName, connectorsByName);
        });
        return connectorsByNameMap;
      },
      getConnectorName(name2) {
        if (!name2) {
          return name2;
        }
        const nameOverrideMap = {
          "Trust Wallet": "Trust"
        };
        return nameOverrideMap[name2] || name2;
      },
      getUniqueConnectorsByName(connectors) {
        const uniqueConnectors = [];
        connectors.forEach((c12) => {
          if (!uniqueConnectors.find((uc2) => uc2.chain === c12.chain)) {
            uniqueConnectors.push(c12);
          }
        });
        return uniqueConnectors;
      },
      addConnector(connector) {
        if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
          const authConnector = connector;
          const optionsState = snapshot(OptionsController.state);
          const themeMode = ThemeController.getSnapshot().themeMode;
          const themeVariables = ThemeController.getSnapshot().themeVariables;
          authConnector?.provider?.syncDappData?.({
            metadata: optionsState.metadata,
            sdkVersion: optionsState.sdkVersion,
            projectId: optionsState.projectId,
            sdkType: optionsState.sdkType
          });
          authConnector?.provider?.syncTheme({
            themeMode,
            themeVariables,
            w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
          });
          ConnectorController.setConnectors([connector]);
        } else {
          ConnectorController.setConnectors([connector]);
        }
      },
      getAuthConnector(chainNamespace) {
        const activeNamespace = chainNamespace || ChainController.state.activeChain;
        const authConnector = state10.connectors.find((c12) => c12.id === ConstantsUtil.CONNECTOR_ID.AUTH);
        if (!authConnector) {
          return void 0;
        }
        if (authConnector?.connectors?.length) {
          const connector = authConnector.connectors.find((c12) => c12.chain === activeNamespace);
          return connector;
        }
        return authConnector;
      },
      getAnnouncedConnectorRdns() {
        return state10.connectors.filter((c12) => c12.type === "ANNOUNCED").map((c12) => c12.info?.rdns);
      },
      getConnectorById(id) {
        return state10.allConnectors.find((c12) => c12.id === id);
      },
      getConnector({ id, rdns, namespace }) {
        const namespaceToUse = namespace || ChainController.state.activeChain;
        const connectorsByNamespace = state10.allConnectors.filter((c12) => c12.chain === namespaceToUse);
        return connectorsByNamespace.find((c12) => c12.explorerId === id || c12.info?.rdns === rdns);
      },
      syncIfAuthConnector(connector) {
        if (connector.id !== "ID_AUTH") {
          return;
        }
        const authConnector = connector;
        const optionsState = snapshot(OptionsController.state);
        const themeMode = ThemeController.getSnapshot().themeMode;
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector?.provider?.syncDappData?.({
          metadata: optionsState.metadata,
          sdkVersion: optionsState.sdkVersion,
          sdkType: optionsState.sdkType,
          projectId: optionsState.projectId
        });
        authConnector.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      },
      /**
       * Returns the connectors filtered by namespace.
       * @param namespace - The namespace to filter the connectors by.
       * @returns ConnectorWithProviders[].
       */
      getConnectorsByNamespace(namespace) {
        const namespaceConnectors = state10.allConnectors.filter((connector) => connector.chain === namespace);
        return ConnectorController.mergeMultiChainConnectors(namespaceConnectors);
      },
      canSwitchToSmartAccount(namespace) {
        const isSmartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
        return isSmartAccountEnabled && getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.EOA;
      },
      selectWalletConnector(wallet) {
        const connector = ConnectorController.getConnector({
          id: wallet.id,
          rdns: wallet.rdns
        });
        MobileWalletUtil.handleMobileDeeplinkRedirect(connector?.explorerId || wallet.id, ChainController.state.activeChain);
        if (connector) {
          RouterController.push("ConnectingExternal", { connector, wallet });
        } else {
          RouterController.push("ConnectingWalletConnect", { wallet });
        }
      },
      /**
       * Returns the connectors. If a namespace is provided, the connectors are filtered by namespace.
       * @param namespace - The namespace to filter the connectors by. If not provided, all connectors are returned.
       * @returns ConnectorWithProviders[].
       */
      getConnectors(namespace) {
        if (namespace) {
          return ConnectorController.getConnectorsByNamespace(namespace);
        }
        return ConnectorController.mergeMultiChainConnectors(state10.allConnectors);
      },
      /**
       * Sets the filter by namespace and updates the connectors.
       * @param namespace - The namespace to filter the connectors by.
       */
      setFilterByNamespace(namespace) {
        state10.filterByNamespace = namespace;
        state10.connectors = ConnectorController.getConnectors(namespace);
        ApiController.setFilterByNamespace(namespace);
      },
      setConnectorId(connectorId, namespace) {
        if (connectorId) {
          state10.activeConnectorIds = {
            ...state10.activeConnectorIds,
            [namespace]: connectorId
          };
          StorageUtil.setConnectedConnectorId(namespace, connectorId);
        }
      },
      removeConnectorId(namespace) {
        state10.activeConnectorIds = {
          ...state10.activeConnectorIds,
          [namespace]: void 0
        };
        StorageUtil.deleteConnectedConnectorId(namespace);
      },
      getConnectorId(namespace) {
        if (!namespace) {
          return void 0;
        }
        return state10.activeConnectorIds[namespace];
      },
      isConnected(namespace) {
        if (!namespace) {
          return Object.values(state10.activeConnectorIds).some((id) => Boolean(id));
        }
        return Boolean(state10.activeConnectorIds[namespace]);
      },
      resetConnectorIds() {
        state10.activeConnectorIds = { ...defaultActiveConnectors };
      }
    };
    ConnectorController = withErrorBoundary(controller5);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js
var UPDATE_EMAIL_INTERVAL_MS, ConnectorControllerUtil;
var init_ConnectorControllerUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectorControllerUtil.js"() {
    init_esm8();
    init_esm8();
    init_utils4();
    init_AccountController();
    init_ChainController();
    init_ConnectionController();
    init_ConnectorController();
    init_EventsController();
    init_ModalController();
    init_RouterController();
    init_ChainControllerUtil();
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    init_StorageUtil();
    UPDATE_EMAIL_INTERVAL_MS = 1e3;
    ConnectorControllerUtil = {
      checkNamespaceConnectorId(namespace, connectorId) {
        return ConnectorController.getConnectorId(namespace) === connectorId;
      },
      isSocialProvider(socialProvider) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials.includes(socialProvider);
      },
      connectWalletConnect({ walletConnect, connector, closeModalOnConnect = true, redirectViewOnModalClose = "Connect", onOpen, onConnect }) {
        return new Promise((resolve, reject) => {
          if (walletConnect) {
            ConnectorController.setActiveConnector(connector);
          }
          onOpen?.(CoreHelperUtil.isMobile() && walletConnect);
          if (redirectViewOnModalClose) {
            const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
              if (!val) {
                if (RouterController.state.view !== redirectViewOnModalClose) {
                  RouterController.replace(redirectViewOnModalClose);
                }
                unsubscribeModalController();
                reject(new Error("Modal closed"));
              }
            });
          }
          const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
            if (val) {
              onConnect?.();
              if (closeModalOnConnect) {
                ModalController.close();
              }
              unsubscribeChainController();
              resolve(ParseUtil.parseCaipAddress(val));
            }
          });
        });
      },
      connectExternal(connector) {
        return new Promise((resolve, reject) => {
          const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
            if (val) {
              ModalController.close();
              unsubscribeChainController();
              resolve(ParseUtil.parseCaipAddress(val));
            }
          });
          ConnectionController.connectExternal(connector, connector.chain).catch(() => {
            unsubscribeChainController();
            reject(new Error("Connection rejected"));
          });
        });
      },
      connectSocial({ social, namespace, closeModalOnConnect = true, onOpenFarcaster, onConnect }) {
        let socialWindow = AccountController.state.socialWindow;
        let socialProvider = AccountController.state.socialProvider;
        let connectingSocial = false;
        let popupWindow = null;
        const namespaceToUse = namespace || ChainController.state.activeChain;
        const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
          if (val) {
            if (closeModalOnConnect) {
              ModalController.close();
            }
            unsubscribeChainController();
          }
        });
        return new Promise((resolve, reject) => {
          async function handleSocialConnection(event) {
            if (event.data?.resultUri) {
              if (event.origin === ConstantsUtil.SECURE_SITE_SDK_ORIGIN) {
                window.removeEventListener("message", handleSocialConnection, false);
                try {
                  const authConnector = ConnectorController.getAuthConnector(namespaceToUse);
                  if (authConnector && !connectingSocial) {
                    if (socialWindow) {
                      socialWindow.close();
                      AccountController.setSocialWindow(void 0, namespaceToUse);
                      socialWindow = AccountController.state.socialWindow;
                    }
                    connectingSocial = true;
                    const uri = event.data.resultUri;
                    if (socialProvider) {
                      EventsController.sendEvent({
                        type: "track",
                        event: "SOCIAL_LOGIN_REQUEST_USER_DATA",
                        properties: { provider: socialProvider }
                      });
                    }
                    if (socialProvider) {
                      StorageUtil.setConnectedSocialProvider(socialProvider);
                      await ConnectionController.connectExternal({
                        id: authConnector.id,
                        type: authConnector.type,
                        socialUri: uri
                      }, authConnector.chain);
                      const caipAddress = ChainController.state.activeCaipAddress;
                      if (!caipAddress) {
                        reject(new Error("Failed to connect"));
                        return;
                      }
                      resolve(ParseUtil.parseCaipAddress(caipAddress));
                      EventsController.sendEvent({
                        type: "track",
                        event: "SOCIAL_LOGIN_SUCCESS",
                        properties: {
                          provider: socialProvider,
                          caipNetworkId: ChainController.getActiveCaipNetwork()?.caipNetworkId
                        }
                      });
                    }
                  }
                } catch (err2) {
                  if (socialProvider) {
                    EventsController.sendEvent({
                      type: "track",
                      event: "SOCIAL_LOGIN_ERROR",
                      properties: { provider: socialProvider }
                    });
                  }
                  reject(new Error("Failed to connect"));
                }
              } else if (socialProvider) {
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_ERROR",
                  properties: { provider: socialProvider }
                });
              }
            }
          }
          async function connectSocial() {
            if (social) {
              AccountController.setSocialProvider(social, namespaceToUse);
              socialProvider = AccountController.state.socialProvider;
              EventsController.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_STARTED",
                properties: { provider: socialProvider }
              });
            }
            if (socialProvider === "farcaster") {
              onOpenFarcaster?.();
              const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
                if (!val && social === "farcaster") {
                  reject(new Error("Popup closed"));
                  onConnect?.();
                  unsubscribeModalController();
                }
              });
              const authConnector = ConnectorController.getAuthConnector();
              if (authConnector) {
                if (!AccountController.state.farcasterUrl) {
                  try {
                    const { url } = await authConnector.provider.getFarcasterUri();
                    AccountController.setFarcasterUrl(url, namespaceToUse);
                  } catch {
                    reject(new Error("Failed to connect to farcaster"));
                  }
                }
              }
            } else {
              const authConnector = ConnectorController.getAuthConnector();
              popupWindow = CoreHelperUtil.returnOpenHref(`${ConstantsUtil.SECURE_SITE_SDK_ORIGIN}/loading`, "popupWindow", "width=600,height=800,scrollbars=yes");
              try {
                if (authConnector && socialProvider) {
                  const { uri } = await authConnector.provider.getSocialRedirectUri({
                    provider: socialProvider
                  });
                  if (popupWindow && uri) {
                    AccountController.setSocialWindow(popupWindow, namespaceToUse);
                    socialWindow = AccountController.state.socialWindow;
                    popupWindow.location.href = uri;
                    const interval = setInterval(() => {
                      if (socialWindow?.closed && !connectingSocial) {
                        reject(new Error("Popup closed"));
                        clearInterval(interval);
                      }
                    }, 1e3);
                    window.addEventListener("message", handleSocialConnection, false);
                  } else {
                    popupWindow?.close();
                    reject(new Error("Failed to initiate social connection"));
                  }
                }
              } catch {
                reject(new Error("Failed to initiate social connection"));
                popupWindow?.close();
              }
            }
          }
          connectSocial();
        });
      },
      connectEmail({ closeModalOnConnect = true, redirectViewOnModalClose = "Connect", onOpen, onConnect }) {
        return new Promise((resolve, reject) => {
          onOpen?.();
          if (redirectViewOnModalClose) {
            const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
              if (!val) {
                if (RouterController.state.view !== redirectViewOnModalClose) {
                  RouterController.replace(redirectViewOnModalClose);
                }
                unsubscribeModalController();
                reject(new Error("Modal closed"));
              }
            });
          }
          const unsubscribeChainController = ChainController.subscribeKey("activeCaipAddress", (val) => {
            if (val) {
              onConnect?.();
              if (closeModalOnConnect) {
                ModalController.close();
              }
              unsubscribeChainController();
              resolve(ParseUtil.parseCaipAddress(val));
            }
          });
        });
      },
      async updateEmail() {
        const connectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
        const authConnector = ConnectorController.getAuthConnector();
        if (!authConnector) {
          throw new Error("No auth connector found");
        }
        if (connectorId !== ConstantsUtil.CONNECTOR_ID.AUTH) {
          throw new Error("Not connected to email or social");
        }
        const initialEmail = authConnector.provider.getEmail() ?? "";
        await ModalController.open({
          view: "UpdateEmailWallet",
          data: {
            email: initialEmail,
            redirectView: void 0
          }
        });
        return new Promise((resolve, reject) => {
          const interval = setInterval(() => {
            const newEmail = authConnector.provider.getEmail() ?? "";
            if (newEmail !== initialEmail) {
              ModalController.close();
              clearInterval(interval);
              unsubscribeModalController();
              resolve({ email: newEmail });
            }
          }, UPDATE_EMAIL_INTERVAL_MS);
          const unsubscribeModalController = ModalController.subscribeKey("open", (val) => {
            if (!val) {
              if (RouterController.state.view !== "Connect") {
                RouterController.push("Connect");
              }
              clearInterval(interval);
              unsubscribeModalController();
              reject(new Error("Modal closed"));
            }
          });
        });
      },
      canSwitchToSmartAccount(namespace) {
        const isSmartAccountEnabled = ChainController.checkIfSmartAccountEnabled();
        return isSmartAccountEnabled && getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.EOA;
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js
function getActiveNetworkTokenAddress() {
  const namespace = ChainController.state.activeCaipNetwork?.chainNamespace || "eip155";
  const chainId = ChainController.state.activeCaipNetwork?.id || 1;
  const address2 = ConstantsUtil2.NATIVE_TOKEN_ADDRESS[namespace];
  return `${namespace}:${chainId}:${address2}`;
}
function getPreferredAccountType(namespace) {
  const preferredAccountType = ChainController.getAccountData(namespace)?.preferredAccountType;
  return preferredAccountType;
}
function getActiveCaipNetwork(chainNamespace) {
  if (chainNamespace) {
    return ChainController.state.chains.get(chainNamespace)?.networkState?.caipNetwork;
  }
  return ChainController.state.activeCaipNetwork;
}
var init_ChainControllerUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/ChainControllerUtil.js"() {
    init_ChainController();
    init_ConstantsUtil2();
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectionControllerUtil.js
var ConnectionControllerUtil;
var init_ConnectionControllerUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/ConnectionControllerUtil.js"() {
    init_ConnectionController();
    init_ConnectorController();
    init_OptionsController();
    ConnectionControllerUtil = {
      getConnectionStatus(connection, namespace) {
        const connectedConnectorId = ConnectorController.state.activeConnectorIds[namespace];
        const connections = ConnectionController.getConnections(namespace);
        const isConnectorConnected = Boolean(connectedConnectorId) && connection.connectorId === connectedConnectorId;
        if (isConnectorConnected) {
          return "connected";
        }
        const isConnectionConnected = connections.some((c12) => c12.connectorId.toLowerCase() === connection.connectorId.toLowerCase());
        if (isConnectionConnected) {
          return "active";
        }
        return "disconnected";
      },
      excludeConnectorAddressFromConnections({ connections, connectorId, addresses }) {
        return connections.map((connection) => {
          const isConnectorMatch = connectorId ? connection.connectorId.toLowerCase() === connectorId.toLowerCase() : false;
          if (isConnectorMatch && addresses) {
            const filteredAccounts = connection.accounts.filter((account) => {
              const isAddressIncluded = addresses.some((address2) => address2.toLowerCase() === account.address.toLowerCase());
              return !isAddressIncluded;
            });
            return { ...connection, accounts: filteredAccounts };
          }
          return connection;
        });
      },
      excludeExistingConnections(connectorIds, newConnections) {
        const existingConnectorIds = new Set(connectorIds);
        return newConnections.filter((c12) => !existingConnectorIds.has(c12.connectorId));
      },
      getConnectionsByConnectorId(connections, connectorId) {
        return connections.filter((c12) => c12.connectorId.toLowerCase() === connectorId.toLowerCase());
      },
      getConnectionsData(namespace) {
        const isMultiWalletEnabled = Boolean(OptionsController.state.remoteFeatures?.multiWallet);
        const activeConnectorId = ConnectorController.state.activeConnectorIds[namespace];
        const connections = ConnectionController.getConnections(namespace);
        const recentConnections = ConnectionController.state.recentConnections.get(namespace) ?? [];
        const recentConnectionsWithCurrentActiveConnectors = recentConnections.filter((connection) => ConnectorController.getConnectorById(connection.connectorId));
        const dedupedRecentConnections = ConnectionControllerUtil.excludeExistingConnections([...connections.map((c12) => c12.connectorId), ...activeConnectorId ? [activeConnectorId] : []], recentConnectionsWithCurrentActiveConnectors);
        if (!isMultiWalletEnabled) {
          return {
            connections: connections.filter((c12) => c12.connectorId.toLowerCase() === activeConnectorId?.toLowerCase()),
            recentConnections: []
          };
        }
        return {
          connections,
          recentConnections: dedupedRecentConnections
        };
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js
var DEFAULT_STATE2, state11, controller6, SnackController;
var init_SnackController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SnackController.js"() {
    init_vanilla();
    init_utils3();
    init_CoreHelperUtil();
    DEFAULT_STATE2 = Object.freeze({
      message: "",
      variant: "success",
      svg: void 0,
      open: false,
      autoClose: true
    });
    state11 = proxy({
      ...DEFAULT_STATE2
    });
    controller6 = {
      state: state11,
      subscribeKey(key, callback) {
        return subscribeKey(state11, key, callback);
      },
      showLoading(message, options = {}) {
        this._showMessage({ message, variant: "loading", ...options });
      },
      showSuccess(message) {
        this._showMessage({ message, variant: "success" });
      },
      showSvg(message, svg) {
        this._showMessage({ message, svg });
      },
      showError(message) {
        const errorMessage = CoreHelperUtil.parseError(message);
        this._showMessage({ message: errorMessage, variant: "error" });
      },
      hide() {
        state11.message = DEFAULT_STATE2.message;
        state11.variant = DEFAULT_STATE2.variant;
        state11.svg = DEFAULT_STATE2.svg;
        state11.open = DEFAULT_STATE2.open;
        state11.autoClose = DEFAULT_STATE2.autoClose;
      },
      _showMessage({ message, svg, variant = "success", autoClose = DEFAULT_STATE2.autoClose }) {
        if (state11.open) {
          state11.open = false;
          setTimeout(() => {
            state11.message = message;
            state11.variant = variant;
            state11.svg = svg;
            state11.open = true;
            state11.autoClose = autoClose;
          }, 150);
        } else {
          state11.message = message;
          state11.variant = variant;
          state11.svg = svg;
          state11.open = true;
          state11.autoClose = autoClose;
        }
      }
    };
    SnackController = controller6;
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TransactionsController.js
var state12, controller7, TransactionsController;
var init_TransactionsController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TransactionsController.js"() {
    init_vanilla();
    init_utils4();
    init_ChainControllerUtil();
    init_withErrorBoundary();
    init_BlockchainApiController();
    init_ChainController();
    init_EventsController();
    init_OptionsController();
    init_SnackController();
    state12 = proxy({
      transactions: [],
      transactionsByYear: {},
      lastNetworkInView: void 0,
      loading: false,
      empty: false,
      next: void 0
    });
    controller7 = {
      state: state12,
      subscribe(callback) {
        return subscribe(state12, () => callback(state12));
      },
      setLastNetworkInView(lastNetworkInView) {
        state12.lastNetworkInView = lastNetworkInView;
      },
      async fetchTransactions(accountAddress) {
        if (!accountAddress) {
          throw new Error("Transactions can't be fetched without an accountAddress");
        }
        state12.loading = true;
        try {
          const response = await BlockchainApiController.fetchTransactions({
            account: accountAddress,
            cursor: state12.next,
            chainId: ChainController.state.activeCaipNetwork?.caipNetworkId
          });
          const nonSpamTransactions = TransactionsController.filterSpamTransactions(response.data);
          const sameChainTransactions = TransactionsController.filterByConnectedChain(nonSpamTransactions);
          const filteredTransactions = [...state12.transactions, ...sameChainTransactions];
          state12.loading = false;
          state12.transactions = filteredTransactions;
          state12.transactionsByYear = TransactionsController.groupTransactionsByYearAndMonth(state12.transactionsByYear, sameChainTransactions);
          state12.empty = filteredTransactions.length === 0;
          state12.next = response.next ? response.next : void 0;
        } catch (error2) {
          const activeChainNamespace = ChainController.state.activeChain;
          EventsController.sendEvent({
            type: "track",
            event: "ERROR_FETCH_TRANSACTIONS",
            properties: {
              address: accountAddress,
              projectId: OptionsController.state.projectId,
              cursor: state12.next,
              isSmartAccount: getPreferredAccountType(activeChainNamespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
            }
          });
          SnackController.showError("Failed to fetch transactions");
          state12.loading = false;
          state12.empty = true;
          state12.next = void 0;
        }
      },
      groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
        const grouped = transactionsMap;
        transactions.forEach((transaction) => {
          const year = new Date(transaction.metadata.minedAt).getFullYear();
          const month = new Date(transaction.metadata.minedAt).getMonth();
          const yearTransactions = grouped[year] ?? {};
          const monthTransactions = yearTransactions[month] ?? [];
          const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
          grouped[year] = {
            ...yearTransactions,
            [month]: [...newMonthTransactions, transaction].sort((a5, b7) => new Date(b7.metadata.minedAt).getTime() - new Date(a5.metadata.minedAt).getTime())
          };
        });
        return grouped;
      },
      filterSpamTransactions(transactions) {
        return transactions.filter((transaction) => {
          const isAllSpam = transaction.transfers.every((transfer) => transfer.nft_info?.flags.is_spam === true);
          return !isAllSpam;
        });
      },
      filterByConnectedChain(transactions) {
        const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;
        const filteredTransactions = transactions.filter((transaction) => transaction.metadata.chain === chainId);
        return filteredTransactions;
      },
      clearCursor() {
        state12.next = void 0;
      },
      resetTransactions() {
        state12.transactions = [];
        state12.transactionsByYear = {};
        state12.lastNetworkInView = void 0;
        state12.loading = false;
        state12.empty = false;
        state12.next = void 0;
      }
    };
    TransactionsController = withErrorBoundary(controller7, "API_ERROR");
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js
var state13, wcConnectionPromise, controller8, ConnectionController;
var init_ConnectionController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ConnectionController.js"() {
    init_vanilla();
    init_utils3();
    init_esm8();
    init_ChainControllerUtil();
    init_ConnectionControllerUtil();
    init_ConnectorControllerUtil();
    init_CoreHelperUtil();
    init_StorageUtil();
    init_withErrorBoundary();
    init_AccountController();
    init_ChainController();
    init_ConnectorController();
    init_EventsController();
    init_ModalController();
    init_RouterController();
    init_TransactionsController();
    state13 = proxy({
      connections: /* @__PURE__ */ new Map(),
      recentConnections: /* @__PURE__ */ new Map(),
      isSwitchingConnection: false,
      wcError: false,
      buffering: false,
      status: "disconnected"
    });
    controller8 = {
      state: state13,
      subscribe(callback) {
        return subscribe(state13, () => callback(state13));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state13, key, callback);
      },
      _getClient() {
        return state13._client;
      },
      setClient(client) {
        state13._client = ref(client);
      },
      initialize(adapters) {
        const namespaces = adapters.filter((a5) => Boolean(a5.namespace)).map((a5) => a5.namespace);
        ConnectionController.syncStorageConnections(namespaces);
      },
      syncStorageConnections(namespaces) {
        const storageConnections = StorageUtil.getConnections();
        const namespacesToSync = namespaces ?? Array.from(ChainController.state.chains.keys());
        for (const namespace of namespacesToSync) {
          const storageConnectionsByNamespace = storageConnections[namespace] ?? [];
          const recentConnectionsMap = new Map(state13.recentConnections);
          recentConnectionsMap.set(namespace, storageConnectionsByNamespace);
          state13.recentConnections = recentConnectionsMap;
        }
      },
      getConnections(namespace) {
        return namespace ? state13.connections.get(namespace) ?? [] : [];
      },
      hasAnyConnection(connectorId) {
        const connections = ConnectionController.state.connections;
        return Array.from(connections.values()).flatMap((_connections) => _connections).some(({ connectorId: _connectorId }) => _connectorId === connectorId);
      },
      async connectWalletConnect() {
        if (CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari() && CoreHelperUtil.isIos()) {
          if (wcConnectionPromise) {
            await wcConnectionPromise;
            wcConnectionPromise = void 0;
            return;
          }
          if (!CoreHelperUtil.isPairingExpired(state13?.wcPairingExpiry)) {
            const link = state13.wcUri;
            state13.wcUri = link;
            return;
          }
          wcConnectionPromise = ConnectionController._getClient()?.connectWalletConnect?.().catch(() => void 0);
          ConnectionController.state.status = "connecting";
          await wcConnectionPromise;
          wcConnectionPromise = void 0;
          state13.wcPairingExpiry = void 0;
          ConnectionController.state.status = "connected";
        } else {
          await ConnectionController._getClient()?.connectWalletConnect?.();
        }
      },
      async connectExternal(options, chain3, setChain = true) {
        const connectData = await ConnectionController._getClient()?.connectExternal?.(options);
        if (setChain) {
          ChainController.setActiveNamespace(chain3);
        }
        return connectData;
      },
      async reconnectExternal(options) {
        await ConnectionController._getClient()?.reconnectExternal?.(options);
        const namespace = options.chain || ChainController.state.activeChain;
        if (namespace) {
          ConnectorController.setConnectorId(options.id, namespace);
        }
      },
      async setPreferredAccountType(accountType, namespace) {
        if (!namespace) {
          return;
        }
        ModalController.setLoading(true, ChainController.state.activeChain);
        const authConnector = ConnectorController.getAuthConnector();
        if (!authConnector) {
          return;
        }
        AccountController.setPreferredAccountType(accountType, namespace);
        await authConnector.provider.setPreferredAccount(accountType);
        StorageUtil.setPreferredAccountTypes(Object.entries(ChainController.state.chains).reduce((acc, [key, _5]) => {
          const namespace2 = key;
          const accountType2 = getPreferredAccountType(namespace2);
          if (accountType2 !== void 0) {
            ;
            acc[namespace2] = accountType2;
          }
          return acc;
        }, {}));
        await ConnectionController.reconnectExternal(authConnector);
        ModalController.setLoading(false, ChainController.state.activeChain);
        EventsController.sendEvent({
          type: "track",
          event: "SET_PREFERRED_ACCOUNT_TYPE",
          properties: {
            accountType,
            network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
          }
        });
      },
      async signMessage(message) {
        return ConnectionController._getClient()?.signMessage(message);
      },
      parseUnits(value, decimals) {
        return ConnectionController._getClient()?.parseUnits(value, decimals);
      },
      formatUnits(value, decimals) {
        return ConnectionController._getClient()?.formatUnits(value, decimals);
      },
      async sendTransaction(args) {
        return ConnectionController._getClient()?.sendTransaction(args);
      },
      async getCapabilities(params) {
        return ConnectionController._getClient()?.getCapabilities(params);
      },
      async grantPermissions(params) {
        return ConnectionController._getClient()?.grantPermissions(params);
      },
      async walletGetAssets(params) {
        return ConnectionController._getClient()?.walletGetAssets(params) ?? {};
      },
      async estimateGas(args) {
        return ConnectionController._getClient()?.estimateGas(args);
      },
      async writeContract(args) {
        return ConnectionController._getClient()?.writeContract(args);
      },
      async getEnsAddress(value) {
        return ConnectionController._getClient()?.getEnsAddress(value);
      },
      async getEnsAvatar(value) {
        return ConnectionController._getClient()?.getEnsAvatar(value);
      },
      checkInstalled(ids) {
        return ConnectionController._getClient()?.checkInstalled?.(ids) || false;
      },
      resetWcConnection() {
        state13.wcUri = void 0;
        state13.wcPairingExpiry = void 0;
        state13.wcLinking = void 0;
        state13.recentWallet = void 0;
        state13.status = "disconnected";
        TransactionsController.resetTransactions();
        StorageUtil.deleteWalletConnectDeepLink();
      },
      resetUri() {
        state13.wcUri = void 0;
        state13.wcPairingExpiry = void 0;
        wcConnectionPromise = void 0;
      },
      finalizeWcConnection() {
        const { wcLinking, recentWallet } = ConnectionController.state;
        if (wcLinking) {
          StorageUtil.setWalletConnectDeepLink(wcLinking);
        }
        if (recentWallet) {
          StorageUtil.setAppKitRecent(recentWallet);
        }
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: {
            method: wcLinking ? "mobile" : "qrcode",
            name: RouterController.state.data?.wallet?.name || "Unknown",
            caipNetworkId: ChainController.getActiveCaipNetwork()?.caipNetworkId
          }
        });
      },
      setWcBasic(wcBasic) {
        state13.wcBasic = wcBasic;
      },
      setUri(uri) {
        state13.wcUri = uri;
        state13.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
      },
      setWcLinking(wcLinking) {
        state13.wcLinking = wcLinking;
      },
      setWcError(wcError) {
        state13.wcError = wcError;
        state13.buffering = false;
      },
      setRecentWallet(wallet) {
        state13.recentWallet = wallet;
      },
      setBuffering(buffering) {
        state13.buffering = buffering;
      },
      setStatus(status) {
        state13.status = status;
      },
      setIsSwitchingConnection(isSwitchingConnection) {
        state13.isSwitchingConnection = isSwitchingConnection;
      },
      async disconnect({ id, namespace, initialDisconnect } = {}) {
        try {
          await ConnectionController._getClient()?.disconnect({
            id,
            chainNamespace: namespace,
            initialDisconnect
          });
        } catch (error2) {
          throw new AppKitError("Failed to disconnect", "INTERNAL_SDK_ERROR", error2);
        }
      },
      setConnections(connections, chainNamespace) {
        const connectionsMap = new Map(state13.connections);
        connectionsMap.set(chainNamespace, connections);
        state13.connections = connectionsMap;
      },
      async handleAuthAccountSwitch({ address: address2, namespace }) {
        const smartAccount = AccountController.state.user?.accounts?.find((c12) => c12.type === "smartAccount");
        const accountType = smartAccount && smartAccount.address.toLowerCase() === address2.toLowerCase() && ConnectorControllerUtil.canSwitchToSmartAccount(namespace) ? "smartAccount" : "eoa";
        await ConnectionController.setPreferredAccountType(accountType, namespace);
      },
      async handleActiveConnection({ connection, namespace, address: address2 }) {
        const connector = ConnectorController.getConnectorById(connection.connectorId);
        const isAuthConnector = connection.connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        if (!connector) {
          throw new Error(`No connector found for connection: ${connection.connectorId}`);
        }
        if (!isAuthConnector) {
          const connectData = await ConnectionController.connectExternal({
            id: connector.id,
            type: connector.type,
            provider: connector.provider,
            address: address2,
            chain: namespace
          }, namespace);
          return connectData?.address;
        } else if (isAuthConnector && address2) {
          await ConnectionController.handleAuthAccountSwitch({ address: address2, namespace });
        }
        return address2;
      },
      async handleDisconnectedConnection({ connection, namespace, address: address2, closeModalOnConnect }) {
        const connector = ConnectorController.getConnectorById(connection.connectorId);
        const authName = connection.auth?.name?.toLowerCase();
        const isAuthConnector = connection.connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        const isWCConnector = connection.connectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
        if (!connector) {
          throw new Error(`No connector found for connection: ${connection.connectorId}`);
        }
        let newAddress = void 0;
        if (isAuthConnector) {
          if (authName && ConnectorControllerUtil.isSocialProvider(authName)) {
            const { address: socialAddress } = await ConnectorControllerUtil.connectSocial({
              social: authName,
              closeModalOnConnect,
              onOpenFarcaster() {
                ModalController.open({ view: "ConnectingFarcaster" });
              },
              onConnect() {
                RouterController.replace("ProfileWallets");
              }
            });
            newAddress = socialAddress;
          } else {
            const { address: emailAddress } = await ConnectorControllerUtil.connectEmail({
              closeModalOnConnect,
              onOpen() {
                ModalController.open({ view: "EmailLogin" });
              },
              onConnect() {
                RouterController.replace("ProfileWallets");
              }
            });
            newAddress = emailAddress;
          }
        } else if (isWCConnector) {
          const { address: wcAddress } = await ConnectorControllerUtil.connectWalletConnect({
            walletConnect: true,
            connector,
            closeModalOnConnect,
            onOpen(isMobile) {
              ModalController.open({ view: isMobile ? "AllWallets" : "ConnectingWalletConnect" });
            },
            onConnect() {
              RouterController.replace("ProfileWallets");
            }
          });
          newAddress = wcAddress;
        } else {
          const connectData = await ConnectionController.connectExternal({
            id: connector.id,
            type: connector.type,
            provider: connector.provider,
            chain: namespace
          }, namespace);
          if (connectData) {
            newAddress = connectData.address;
          }
        }
        if (isAuthConnector && address2) {
          await ConnectionController.handleAuthAccountSwitch({ address: address2, namespace });
        }
        return newAddress;
      },
      async switchConnection({ connection, address: address2, namespace, closeModalOnConnect, onChange }) {
        let currentAddress = void 0;
        const caipAddress = AccountController.getCaipAddress(namespace);
        if (caipAddress) {
          const { address: currentAddressParsed } = ParseUtil.parseCaipAddress(caipAddress);
          currentAddress = currentAddressParsed;
        }
        const status = ConnectionControllerUtil.getConnectionStatus(connection, namespace);
        switch (status) {
          case "connected":
          case "active": {
            const newAddress = await ConnectionController.handleActiveConnection({
              connection,
              namespace,
              address: address2
            });
            if (currentAddress && newAddress) {
              const hasSwitchedAccount = newAddress.toLowerCase() !== currentAddress.toLowerCase();
              onChange?.({
                address: newAddress,
                namespace,
                hasSwitchedAccount,
                hasSwitchedWallet: status === "active"
              });
            }
            break;
          }
          case "disconnected": {
            const newAddress = await ConnectionController.handleDisconnectedConnection({
              connection,
              namespace,
              address: address2,
              closeModalOnConnect
            });
            if (newAddress) {
              onChange?.({
                address: newAddress,
                namespace,
                hasSwitchedAccount: true,
                hasSwitchedWallet: true
              });
            }
            break;
          }
          default:
            throw new Error(`Invalid connection status: ${status}`);
        }
      }
    };
    ConnectionController = withErrorBoundary(controller8);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/PublicStateController.js
var state14, PublicStateController;
var init_PublicStateController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/PublicStateController.js"() {
    init_vanilla();
    init_utils3();
    state14 = proxy({
      loading: false,
      open: false,
      selectedNetworkId: void 0,
      activeChain: void 0,
      initialized: false
    });
    PublicStateController = {
      state: state14,
      subscribe(callback) {
        return subscribe(state14, () => callback(state14));
      },
      subscribeOpen(callback) {
        return subscribeKey(state14, "open", callback);
      },
      set(newState) {
        Object.assign(state14, { ...state14, ...newState });
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SwapApiUtil.js
var SwapApiUtil;
var init_SwapApiUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/SwapApiUtil.js"() {
    init_AccountController();
    init_BlockchainApiController();
    init_ChainController();
    init_ConnectionController();
    init_BalanceUtil();
    init_ChainControllerUtil();
    SwapApiUtil = {
      async getTokenList() {
        const caipNetwork = ChainController.state.activeCaipNetwork;
        const response = await BlockchainApiController.fetchSwapTokens({
          chainId: caipNetwork?.caipNetworkId
        });
        const tokens = response?.tokens?.map((token) => ({
          ...token,
          eip2612: false,
          quantity: {
            decimals: "0",
            numeric: "0"
          },
          price: 0,
          value: 0
        })) || [];
        return tokens;
      },
      async fetchGasPrice() {
        const caipNetwork = ChainController.state.activeCaipNetwork;
        if (!caipNetwork) {
          return null;
        }
        try {
          switch (caipNetwork.chainNamespace) {
            case "solana":
              const lamportsPerSignature = (await ConnectionController?.estimateGas({ chainNamespace: "solana" }))?.toString();
              return {
                standard: lamportsPerSignature,
                fast: lamportsPerSignature,
                instant: lamportsPerSignature
              };
            case "eip155":
            default:
              return await BlockchainApiController.fetchGasPrice({
                chainId: caipNetwork.caipNetworkId
              });
          }
        } catch {
          return null;
        }
      },
      async fetchSwapAllowance({ tokenAddress, userAddress, sourceTokenAmount, sourceTokenDecimals }) {
        const response = await BlockchainApiController.fetchSwapAllowance({
          tokenAddress,
          userAddress
        });
        if (response?.allowance && sourceTokenAmount && sourceTokenDecimals) {
          const parsedValue = ConnectionController.parseUnits(sourceTokenAmount, sourceTokenDecimals) || 0;
          const hasAllowance = BigInt(response.allowance) >= parsedValue;
          return hasAllowance;
        }
        return false;
      },
      async getMyTokensWithBalance(forceUpdate) {
        const balances = await BalanceUtil.getMyTokensWithBalance(forceUpdate);
        AccountController.setTokenBalance(balances, ChainController.state.activeChain);
        return this.mapBalancesToSwapTokens(balances);
      },
      /**
       * Maps the balances from Blockchain API to SwapTokenWithBalance array
       * @param balances
       * @returns SwapTokenWithBalance[]
       */
      mapBalancesToSwapTokens(balances) {
        return balances?.map((token) => ({
          ...token,
          address: token?.address ? token.address : getActiveNetworkTokenAddress(),
          decimals: parseInt(token.quantity.decimals, 10),
          logoUri: token.iconUrl,
          eip2612: false
        })) || [];
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js
var state15, controller9, SendController;
var init_SendController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/SendController.js"() {
    init_vanilla();
    init_utils3();
    init_esm8();
    init_esm8();
    init_utils4();
    init_BalanceUtil();
    init_ChainControllerUtil();
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    init_SwapApiUtil();
    init_withErrorBoundary();
    init_AccountController();
    init_ChainController();
    init_ConnectionController();
    init_EventsController();
    init_RouterController();
    init_SnackController();
    state15 = proxy({
      tokenBalances: [],
      loading: false
    });
    controller9 = {
      state: state15,
      subscribe(callback) {
        return subscribe(state15, () => callback(state15));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state15, key, callback);
      },
      setToken(token) {
        if (token) {
          state15.token = ref(token);
        }
      },
      setTokenAmount(sendTokenAmount) {
        state15.sendTokenAmount = sendTokenAmount;
      },
      setReceiverAddress(receiverAddress) {
        state15.receiverAddress = receiverAddress;
      },
      setReceiverProfileImageUrl(receiverProfileImageUrl) {
        state15.receiverProfileImageUrl = receiverProfileImageUrl;
      },
      setReceiverProfileName(receiverProfileName) {
        state15.receiverProfileName = receiverProfileName;
      },
      setNetworkBalanceInUsd(networkBalanceInUSD) {
        state15.networkBalanceInUSD = networkBalanceInUSD;
      },
      setLoading(loading) {
        state15.loading = loading;
      },
      async sendToken() {
        try {
          SendController.setLoading(true);
          switch (ChainController.state.activeCaipNetwork?.chainNamespace) {
            case "eip155":
              await SendController.sendEvmToken();
              return;
            case "solana":
              await SendController.sendSolanaToken();
              return;
            default:
              throw new Error("Unsupported chain");
          }
        } finally {
          SendController.setLoading(false);
        }
      },
      async sendEvmToken() {
        const activeChainNamespace = ChainController.state.activeChain;
        if (!activeChainNamespace) {
          throw new Error("SendController:sendEvmToken - activeChainNamespace is required");
        }
        const activeAccountType = getPreferredAccountType(activeChainNamespace);
        if (!SendController.state.sendTokenAmount || !SendController.state.receiverAddress) {
          throw new Error("An amount and receiver address are required");
        }
        if (!SendController.state.token) {
          throw new Error("A token is required");
        }
        if (SendController.state.token?.address) {
          EventsController.sendEvent({
            type: "track",
            event: "SEND_INITIATED",
            properties: {
              isSmartAccount: activeAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: SendController.state.token.address,
              amount: SendController.state.sendTokenAmount,
              network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
            }
          });
          await SendController.sendERC20Token({
            receiverAddress: SendController.state.receiverAddress,
            tokenAddress: SendController.state.token.address,
            sendTokenAmount: SendController.state.sendTokenAmount,
            decimals: SendController.state.token.quantity.decimals
          });
        } else {
          EventsController.sendEvent({
            type: "track",
            event: "SEND_INITIATED",
            properties: {
              isSmartAccount: activeAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: SendController.state.token.symbol || "",
              amount: SendController.state.sendTokenAmount,
              network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
            }
          });
          await SendController.sendNativeToken({
            receiverAddress: SendController.state.receiverAddress,
            sendTokenAmount: SendController.state.sendTokenAmount,
            decimals: SendController.state.token.quantity.decimals
          });
        }
      },
      async fetchTokenBalance(onError) {
        state15.loading = true;
        const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;
        const chain3 = ChainController.state.activeCaipNetwork?.chainNamespace;
        const caipAddress = ChainController.state.activeCaipAddress;
        const address2 = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
        if (state15.lastRetry && !CoreHelperUtil.isAllowedRetry(state15.lastRetry, 30 * ConstantsUtil2.ONE_SEC_MS)) {
          state15.loading = false;
          return [];
        }
        try {
          if (address2 && chainId && chain3) {
            const balances = await BalanceUtil.getMyTokensWithBalance();
            state15.tokenBalances = balances;
            state15.lastRetry = void 0;
            return balances;
          }
        } catch (error2) {
          state15.lastRetry = Date.now();
          onError?.(error2);
          SnackController.showError("Token Balance Unavailable");
        } finally {
          state15.loading = false;
        }
        return [];
      },
      fetchNetworkBalance() {
        if (state15.tokenBalances.length === 0) {
          return;
        }
        const networkTokenBalances = SwapApiUtil.mapBalancesToSwapTokens(state15.tokenBalances);
        if (!networkTokenBalances) {
          return;
        }
        const networkToken = networkTokenBalances.find((token) => token.address === getActiveNetworkTokenAddress());
        if (!networkToken) {
          return;
        }
        state15.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
      },
      async sendNativeToken(params) {
        RouterController.pushTransactionStack({});
        const to4 = params.receiverAddress;
        const address2 = AccountController.state.address;
        const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
        const data = "0x";
        await ConnectionController.sendTransaction({
          chainNamespace: ConstantsUtil.CHAIN.EVM,
          to: to4,
          address: address2,
          data,
          value: value ?? BigInt(0)
        });
        EventsController.sendEvent({
          type: "track",
          event: "SEND_SUCCESS",
          properties: {
            isSmartAccount: getPreferredAccountType("eip155") === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: SendController.state.token?.symbol || "",
            amount: params.sendTokenAmount,
            network: ChainController.state.activeCaipNetwork?.caipNetworkId || ""
          }
        });
        ConnectionController._getClient()?.updateBalance("eip155");
        SendController.resetSend();
      },
      async sendERC20Token(params) {
        RouterController.pushTransactionStack({
          onSuccess() {
            RouterController.replace("Account");
          }
        });
        const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
        if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {
          const tokenAddress = CoreHelperUtil.getPlainAddress(params.tokenAddress);
          if (!tokenAddress) {
            throw new Error("SendController:sendERC20Token - tokenAddress is required");
          }
          await ConnectionController.writeContract({
            fromAddress: AccountController.state.address,
            tokenAddress,
            args: [params.receiverAddress, amount ?? BigInt(0)],
            method: "transfer",
            abi: ContractUtil.getERC20Abi(tokenAddress),
            chainNamespace: ConstantsUtil.CHAIN.EVM
          });
          SendController.resetSend();
        }
      },
      async sendSolanaToken() {
        if (!SendController.state.sendTokenAmount || !SendController.state.receiverAddress) {
          throw new Error("An amount and receiver address are required");
        }
        RouterController.pushTransactionStack({
          onSuccess() {
            RouterController.replace("Account");
          }
        });
        await ConnectionController.sendTransaction({
          chainNamespace: "solana",
          to: SendController.state.receiverAddress,
          value: SendController.state.sendTokenAmount
        });
        ConnectionController._getClient()?.updateBalance("solana");
        SendController.resetSend();
      },
      resetSend() {
        state15.token = void 0;
        state15.sendTokenAmount = void 0;
        state15.receiverAddress = void 0;
        state15.receiverProfileImageUrl = void 0;
        state15.receiverProfileName = void 0;
        state15.loading = false;
        state15.tokenBalances = [];
      }
    };
    SendController = withErrorBoundary(controller9);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js
var accountState, networkState, state16, controller10, ChainController;
var init_ChainController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ChainController.js"() {
    init_vanilla();
    init_utils3();
    init_esm8();
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    init_StorageUtil();
    init_withErrorBoundary();
    init_AccountController();
    init_ConnectionController();
    init_ConnectorController();
    init_EventsController();
    init_ModalController();
    init_OptionsController();
    init_PublicStateController();
    init_RouterController();
    init_SendController();
    accountState = {
      currentTab: 0,
      tokenBalance: [],
      smartAccountDeployed: false,
      addressLabels: /* @__PURE__ */ new Map(),
      user: void 0,
      preferredAccountType: void 0
    };
    networkState = {
      caipNetwork: void 0,
      supportsAllNetworks: true,
      smartAccountEnabledNetworks: []
    };
    state16 = proxy({
      chains: proxyMap(),
      activeCaipAddress: void 0,
      activeChain: void 0,
      activeCaipNetwork: void 0,
      noAdapters: false,
      universalAdapter: {
        networkControllerClient: void 0,
        connectionControllerClient: void 0
      },
      isSwitchingNamespace: false
    });
    controller10 = {
      state: state16,
      subscribe(callback) {
        return subscribe(state16, () => {
          callback(state16);
        });
      },
      subscribeKey(key, callback) {
        return subscribeKey(state16, key, callback);
      },
      subscribeChainProp(property, callback, chain3) {
        let prev = void 0;
        return subscribe(state16.chains, () => {
          const activeChain = chain3 || state16.activeChain;
          if (activeChain) {
            const nextValue = state16.chains.get(activeChain)?.[property];
            if (prev !== nextValue) {
              prev = nextValue;
              callback(nextValue);
            }
          }
        });
      },
      initialize(adapters, caipNetworks, clients) {
        const { chainId: activeChainId, namespace: activeNamespace } = StorageUtil.getActiveNetworkProps();
        const activeCaipNetwork = caipNetworks?.find((network) => network.id.toString() === activeChainId?.toString());
        const defaultAdapter = adapters.find((adapter) => adapter?.namespace === activeNamespace);
        const adapterToActivate = defaultAdapter || adapters?.[0];
        const namespacesFromAdapters = adapters.map((a5) => a5.namespace).filter((n12) => n12 !== void 0);
        const namespaces = OptionsController.state.enableEmbedded ? /* @__PURE__ */ new Set([...namespacesFromAdapters]) : /* @__PURE__ */ new Set([...caipNetworks?.map((network) => network.chainNamespace) ?? []]);
        if (adapters?.length === 0 || !adapterToActivate) {
          state16.noAdapters = true;
        }
        if (!state16.noAdapters) {
          state16.activeChain = adapterToActivate?.namespace;
          state16.activeCaipNetwork = activeCaipNetwork;
          ChainController.setChainNetworkData(adapterToActivate?.namespace, {
            caipNetwork: activeCaipNetwork
          });
          if (state16.activeChain) {
            PublicStateController.set({ activeChain: adapterToActivate?.namespace });
          }
        }
        namespaces.forEach((namespace) => {
          const namespaceNetworks = caipNetworks?.filter((network) => network.chainNamespace === namespace);
          const storedAccountTypes = StorageUtil.getPreferredAccountTypes() || {};
          const defaultTypes = { ...OptionsController.state.defaultAccountTypes, ...storedAccountTypes };
          ChainController.state.chains.set(namespace, {
            namespace,
            networkState: proxy({ ...networkState, caipNetwork: namespaceNetworks?.[0] }),
            accountState: proxy({ ...accountState, preferredAccountType: defaultTypes[namespace] }),
            caipNetworks: namespaceNetworks ?? [],
            ...clients
          });
          ChainController.setRequestedCaipNetworks(namespaceNetworks ?? [], namespace);
        });
      },
      removeAdapter(namespace) {
        if (state16.activeChain === namespace) {
          const nextAdapter = Array.from(state16.chains.entries()).find(([chainNamespace]) => chainNamespace !== namespace);
          if (nextAdapter) {
            const caipNetwork = nextAdapter[1]?.caipNetworks?.[0];
            if (caipNetwork) {
              ChainController.setActiveCaipNetwork(caipNetwork);
            }
          }
        }
        state16.chains.delete(namespace);
      },
      addAdapter(adapter, { networkControllerClient, connectionControllerClient }, caipNetworks) {
        if (!adapter.namespace) {
          throw new Error("ChainController:addAdapter - adapter must have a namespace");
        }
        state16.chains.set(adapter.namespace, {
          namespace: adapter.namespace,
          networkState: { ...networkState, caipNetwork: caipNetworks[0] },
          accountState,
          caipNetworks,
          connectionControllerClient,
          networkControllerClient
        });
        ChainController.setRequestedCaipNetworks(caipNetworks?.filter((caipNetwork) => caipNetwork.chainNamespace === adapter.namespace) ?? [], adapter.namespace);
      },
      addNetwork(network) {
        const chainAdapter = state16.chains.get(network.chainNamespace);
        if (chainAdapter) {
          const newNetworks = [...chainAdapter.caipNetworks || []];
          if (!chainAdapter.caipNetworks?.find((caipNetwork) => caipNetwork.id === network.id)) {
            newNetworks.push(network);
          }
          state16.chains.set(network.chainNamespace, { ...chainAdapter, caipNetworks: newNetworks });
          ChainController.setRequestedCaipNetworks(newNetworks, network.chainNamespace);
          ConnectorController.filterByNamespace(network.chainNamespace, true);
        }
      },
      removeNetwork(namespace, networkId) {
        const chainAdapter = state16.chains.get(namespace);
        if (chainAdapter) {
          const isActiveNetwork = state16.activeCaipNetwork?.id === networkId;
          const newCaipNetworksOfAdapter = [
            ...chainAdapter.caipNetworks?.filter((network) => network.id !== networkId) || []
          ];
          if (isActiveNetwork && chainAdapter?.caipNetworks?.[0]) {
            ChainController.setActiveCaipNetwork(chainAdapter.caipNetworks[0]);
          }
          state16.chains.set(namespace, { ...chainAdapter, caipNetworks: newCaipNetworksOfAdapter });
          ChainController.setRequestedCaipNetworks(newCaipNetworksOfAdapter || [], namespace);
          if (newCaipNetworksOfAdapter.length === 0) {
            ConnectorController.filterByNamespace(namespace, false);
          }
        }
      },
      setAdapterNetworkState(chain3, props) {
        const chainAdapter = state16.chains.get(chain3);
        if (chainAdapter) {
          chainAdapter.networkState = {
            ...chainAdapter.networkState || networkState,
            ...props
          };
          state16.chains.set(chain3, chainAdapter);
        }
      },
      setChainAccountData(chain3, accountProps, _unknown = true) {
        if (!chain3) {
          throw new Error("Chain is required to update chain account data");
        }
        const chainAdapter = state16.chains.get(chain3);
        if (chainAdapter) {
          const newAccountState = { ...chainAdapter.accountState || accountState, ...accountProps };
          state16.chains.set(chain3, { ...chainAdapter, accountState: newAccountState });
          if (state16.chains.size === 1 || state16.activeChain === chain3) {
            if (accountProps.caipAddress) {
              state16.activeCaipAddress = accountProps.caipAddress;
            }
            AccountController.replaceState(newAccountState);
          }
        }
      },
      setChainNetworkData(chain3, networkProps) {
        if (!chain3) {
          return;
        }
        const chainAdapter = state16.chains.get(chain3);
        if (chainAdapter) {
          const newNetworkState = { ...chainAdapter.networkState || networkState, ...networkProps };
          state16.chains.set(chain3, { ...chainAdapter, networkState: newNetworkState });
        }
      },
      // eslint-disable-next-line max-params
      setAccountProp(prop, value, chain3, replaceState = true) {
        ChainController.setChainAccountData(chain3, { [prop]: value }, replaceState);
      },
      setActiveNamespace(chain3) {
        state16.activeChain = chain3;
        const newAdapter = chain3 ? state16.chains.get(chain3) : void 0;
        const caipNetwork = newAdapter?.networkState?.caipNetwork;
        if (caipNetwork?.id && chain3) {
          state16.activeCaipAddress = newAdapter?.accountState?.caipAddress;
          state16.activeCaipNetwork = caipNetwork;
          ChainController.setChainNetworkData(chain3, { caipNetwork });
          StorageUtil.setActiveCaipNetworkId(caipNetwork?.caipNetworkId);
          PublicStateController.set({
            activeChain: chain3,
            selectedNetworkId: caipNetwork?.caipNetworkId
          });
        }
      },
      setActiveCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
          return;
        }
        if (state16.activeChain !== caipNetwork.chainNamespace) {
          ChainController.setIsSwitchingNamespace(true);
        }
        const newAdapter = state16.chains.get(caipNetwork.chainNamespace);
        state16.activeChain = caipNetwork.chainNamespace;
        state16.activeCaipNetwork = caipNetwork;
        ChainController.setChainNetworkData(caipNetwork.chainNamespace, { caipNetwork });
        if (newAdapter?.accountState?.address) {
          state16.activeCaipAddress = `${caipNetwork.chainNamespace}:${caipNetwork.id}:${newAdapter?.accountState?.address}`;
        } else {
          state16.activeCaipAddress = void 0;
        }
        ChainController.setAccountProp("caipAddress", state16.activeCaipAddress, caipNetwork.chainNamespace);
        if (newAdapter) {
          AccountController.replaceState(newAdapter.accountState);
        }
        SendController.resetSend();
        PublicStateController.set({
          activeChain: state16.activeChain,
          selectedNetworkId: state16.activeCaipNetwork?.caipNetworkId
        });
        StorageUtil.setActiveCaipNetworkId(caipNetwork.caipNetworkId);
        const isSupported = ChainController.checkIfSupportedNetwork(caipNetwork.chainNamespace);
        if (!isSupported && OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && !ConnectionController.state.wcBasic) {
          ChainController.showUnsupportedChainUI();
        }
      },
      addCaipNetwork(caipNetwork) {
        if (!caipNetwork) {
          return;
        }
        const chain3 = state16.chains.get(caipNetwork.chainNamespace);
        if (chain3) {
          chain3?.caipNetworks?.push(caipNetwork);
        }
      },
      async switchActiveNamespace(namespace) {
        if (!namespace) {
          return;
        }
        const isDifferentChain = namespace !== ChainController.state.activeChain;
        const caipNetworkOfNamespace = ChainController.getNetworkData(namespace)?.caipNetwork;
        const firstNetworkWithChain = ChainController.getCaipNetworkByNamespace(namespace, caipNetworkOfNamespace?.id);
        if (isDifferentChain && firstNetworkWithChain) {
          await ChainController.switchActiveNetwork(firstNetworkWithChain);
        }
      },
      async switchActiveNetwork(network) {
        const namespace = ChainController.state.activeChain;
        if (!namespace) {
          throw new Error("ChainController:switchActiveNetwork - namespace is required");
        }
        const activeAdapter = ChainController.state.chains.get(namespace);
        const unsupportedNetwork = !activeAdapter?.caipNetworks?.some((caipNetwork) => caipNetwork.id === state16.activeCaipNetwork?.id);
        const networkControllerClient = ChainController.getNetworkControllerClient(network.chainNamespace);
        if (networkControllerClient) {
          try {
            await networkControllerClient.switchCaipNetwork(network);
            if (unsupportedNetwork) {
              ModalController.close();
            }
          } catch (error2) {
            RouterController.goBack();
          }
          EventsController.sendEvent({
            type: "track",
            event: "SWITCH_NETWORK",
            properties: { network: network.caipNetworkId }
          });
        }
      },
      getNetworkControllerClient(chainNamespace) {
        const chain3 = chainNamespace || state16.activeChain;
        if (!chain3) {
          throw new Error("ChainController:getNetworkControllerClient - chain is required");
        }
        const chainAdapter = state16.chains.get(chain3);
        if (!chainAdapter) {
          throw new Error("Chain adapter not found");
        }
        if (!chainAdapter.networkControllerClient) {
          throw new Error("NetworkController client not set");
        }
        return chainAdapter.networkControllerClient;
      },
      getConnectionControllerClient(_chain) {
        const chain3 = _chain || state16.activeChain;
        if (!chain3) {
          throw new Error("Chain is required to get connection controller client");
        }
        const chainAdapter = state16.chains.get(chain3);
        if (!chainAdapter?.connectionControllerClient) {
          throw new Error("ConnectionController client not set");
        }
        return chainAdapter.connectionControllerClient;
      },
      getNetworkProp(key, namespace) {
        const chainNetworkState = state16.chains.get(namespace)?.networkState;
        if (!chainNetworkState) {
          return void 0;
        }
        return chainNetworkState[key];
      },
      getRequestedCaipNetworks(chainToFilter) {
        const adapter = state16.chains.get(chainToFilter);
        const { approvedCaipNetworkIds = [], requestedCaipNetworks = [] } = adapter?.networkState || {};
        const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
        const filteredNetworks = sortedNetworks.filter((network) => network?.id);
        return filteredNetworks;
      },
      getAllRequestedCaipNetworks() {
        const requestedCaipNetworks = [];
        state16.chains.forEach((chainAdapter) => {
          if (!chainAdapter.namespace) {
            throw new Error("ChainController:getAllRequestedCaipNetworks - chainAdapter must have a namespace");
          }
          const caipNetworks = ChainController.getRequestedCaipNetworks(chainAdapter.namespace);
          requestedCaipNetworks.push(...caipNetworks);
        });
        return requestedCaipNetworks;
      },
      setRequestedCaipNetworks(caipNetworks, chain3) {
        ChainController.setAdapterNetworkState(chain3, { requestedCaipNetworks: caipNetworks });
        const allRequestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
        const namespaces = allRequestedCaipNetworks.map((network) => network.chainNamespace);
        const uniqueNamespaces = Array.from(new Set(namespaces));
        ConnectorController.filterByNamespaces(uniqueNamespaces);
      },
      getAllApprovedCaipNetworkIds() {
        const approvedCaipNetworkIds = [];
        state16.chains.forEach((chainAdapter) => {
          if (!chainAdapter.namespace) {
            throw new Error("ChainController:getAllApprovedCaipNetworkIds - chainAdapter must have a namespace");
          }
          const approvedIds = ChainController.getApprovedCaipNetworkIds(chainAdapter.namespace);
          approvedCaipNetworkIds.push(...approvedIds);
        });
        return approvedCaipNetworkIds;
      },
      getActiveCaipNetwork(chainNamespace) {
        if (chainNamespace) {
          return state16.chains.get(chainNamespace)?.networkState?.caipNetwork;
        }
        return state16.activeCaipNetwork;
      },
      getActiveCaipAddress() {
        return state16.activeCaipAddress;
      },
      getApprovedCaipNetworkIds(namespace) {
        const adapter = state16.chains.get(namespace);
        const approvedCaipNetworkIds = adapter?.networkState?.approvedCaipNetworkIds || [];
        return approvedCaipNetworkIds;
      },
      async setApprovedCaipNetworksData(namespace) {
        const networkControllerClient = ChainController.getNetworkControllerClient();
        const data = await networkControllerClient?.getApprovedCaipNetworksData();
        ChainController.setAdapterNetworkState(namespace, {
          approvedCaipNetworkIds: data?.approvedCaipNetworkIds,
          supportsAllNetworks: data?.supportsAllNetworks
        });
      },
      checkIfSupportedNetwork(namespace, caipNetworkId) {
        const activeCaipNetworkId = caipNetworkId || state16.activeCaipNetwork?.caipNetworkId;
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(namespace);
        if (!requestedCaipNetworks.length) {
          return true;
        }
        return requestedCaipNetworks?.some((network) => network.caipNetworkId === activeCaipNetworkId);
      },
      checkIfSupportedChainId(chainId) {
        if (!state16.activeChain) {
          return true;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(state16.activeChain);
        return requestedCaipNetworks?.some((network) => network.id === chainId);
      },
      // Smart Account Network Handlers
      setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain3) {
        ChainController.setAdapterNetworkState(chain3, { smartAccountEnabledNetworks });
      },
      checkIfSmartAccountEnabled() {
        const networkId = NetworkUtil.caipNetworkIdToNumber(state16.activeCaipNetwork?.caipNetworkId);
        const activeChain = state16.activeChain;
        if (!activeChain || !networkId) {
          return false;
        }
        const smartAccountEnabledNetworks = ChainController.getNetworkProp("smartAccountEnabledNetworks", activeChain);
        return Boolean(smartAccountEnabledNetworks?.includes(Number(networkId)));
      },
      showUnsupportedChainUI() {
        ModalController.open({ view: "UnsupportedChain" });
      },
      checkIfNamesSupported() {
        const activeCaipNetwork = state16.activeCaipNetwork;
        return Boolean(activeCaipNetwork?.chainNamespace && ConstantsUtil2.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(activeCaipNetwork.chainNamespace));
      },
      resetNetwork(namespace) {
        ChainController.setAdapterNetworkState(namespace, {
          approvedCaipNetworkIds: void 0,
          supportsAllNetworks: true
        });
      },
      resetAccount(chain3) {
        const chainToWrite = chain3;
        if (!chainToWrite) {
          throw new Error("Chain is required to set account prop");
        }
        const currentAccountType = ChainController.state.chains.get(chainToWrite)?.accountState?.preferredAccountType;
        const optionsAccountType = OptionsController.state.defaultAccountTypes[chainToWrite];
        state16.activeCaipAddress = void 0;
        ChainController.setChainAccountData(chainToWrite, {
          smartAccountDeployed: false,
          currentTab: 0,
          caipAddress: void 0,
          address: void 0,
          balance: void 0,
          balanceSymbol: void 0,
          profileName: void 0,
          profileImage: void 0,
          addressExplorerUrl: void 0,
          tokenBalance: [],
          connectedWalletInfo: void 0,
          preferredAccountType: optionsAccountType || currentAccountType,
          socialProvider: void 0,
          socialWindow: void 0,
          farcasterUrl: void 0,
          user: void 0,
          status: "disconnected"
        });
        ConnectorController.removeConnectorId(chainToWrite);
      },
      setIsSwitchingNamespace(isSwitchingNamespace) {
        state16.isSwitchingNamespace = isSwitchingNamespace;
      },
      getFirstCaipNetworkSupportsAuthConnector() {
        const availableChains = [];
        let firstCaipNetwork = void 0;
        state16.chains.forEach((chain3) => {
          if (ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((ns3) => ns3 === chain3.namespace)) {
            if (chain3.namespace) {
              availableChains.push(chain3.namespace);
            }
          }
        });
        if (availableChains.length > 0) {
          const firstAvailableChain = availableChains[0];
          firstCaipNetwork = firstAvailableChain ? state16.chains.get(firstAvailableChain)?.caipNetworks?.[0] : void 0;
          return firstCaipNetwork;
        }
        return void 0;
      },
      getAccountData(chainNamespace) {
        const namespace = chainNamespace || state16.activeChain;
        if (!namespace) {
          return void 0;
        }
        return ChainController.state.chains.get(namespace)?.accountState;
      },
      getNetworkData(chainNamespace) {
        const namespace = chainNamespace || state16.activeChain;
        if (!namespace) {
          return void 0;
        }
        return ChainController.state.chains.get(namespace)?.networkState;
      },
      getCaipNetworkByNamespace(chainNamespace, chainId) {
        if (!chainNamespace) {
          return void 0;
        }
        const chain3 = ChainController.state.chains.get(chainNamespace);
        const byChainId = chain3?.caipNetworks?.find((network) => network.id === chainId);
        if (byChainId) {
          return byChainId;
        }
        return chain3?.networkState?.caipNetwork || chain3?.caipNetworks?.[0];
      },
      /**
       * Get the requested CaipNetwork IDs for a given namespace. If namespace is not provided, all requested CaipNetwork IDs will be returned
       * @param namespace - The namespace to get the requested CaipNetwork IDs for
       * @returns The requested CaipNetwork IDs
       */
      getRequestedCaipNetworkIds() {
        const namespace = ConnectorController.state.filterByNamespace;
        const chains = namespace ? [state16.chains.get(namespace)] : Array.from(state16.chains.values());
        return chains.flatMap((chain3) => chain3?.caipNetworks || []).map((caipNetwork) => caipNetwork.caipNetworkId);
      },
      getCaipNetworks(namespace) {
        if (namespace) {
          return ChainController.getRequestedCaipNetworks(namespace);
        }
        return ChainController.getAllRequestedCaipNetworks();
      },
      setLastConnectedSIWECaipNetwork(network) {
        state16.lastConnectedSIWECaipNetwork = network;
      },
      getLastConnectedSIWECaipNetwork() {
        return state16.lastConnectedSIWECaipNetwork;
      }
    };
    ChainController = withErrorBoundary(controller10);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js
var DEFAULT_OPTIONS, baseUrl3, state17, BlockchainApiController;
var init_BlockchainApiController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/BlockchainApiController.js"() {
    init_vanilla();
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    init_FetchUtil();
    init_StorageUtil();
    init_AccountController();
    init_ChainController();
    init_OptionsController();
    init_SnackController();
    DEFAULT_OPTIONS = {
      purchaseCurrencies: [
        {
          id: "2b92315d-eab7-5bef-84fa-089a131333f5",
          name: "USD Coin",
          symbol: "USDC",
          networks: [
            {
              name: "ethereum-mainnet",
              display_name: "Ethereum",
              chain_id: "1",
              contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
            },
            {
              name: "polygon-mainnet",
              display_name: "Polygon",
              chain_id: "137",
              contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
            }
          ]
        },
        {
          id: "2b92315d-eab7-5bef-84fa-089a131333f5",
          name: "Ether",
          symbol: "ETH",
          networks: [
            {
              name: "ethereum-mainnet",
              display_name: "Ethereum",
              chain_id: "1",
              contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
            },
            {
              name: "polygon-mainnet",
              display_name: "Polygon",
              chain_id: "137",
              contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
            }
          ]
        }
      ],
      paymentCurrencies: [
        {
          id: "USD",
          payment_method_limits: [
            {
              id: "card",
              min: "10.00",
              max: "7500.00"
            },
            {
              id: "ach_bank_account",
              min: "10.00",
              max: "25000.00"
            }
          ]
        },
        {
          id: "EUR",
          payment_method_limits: [
            {
              id: "card",
              min: "10.00",
              max: "7500.00"
            },
            {
              id: "ach_bank_account",
              min: "10.00",
              max: "25000.00"
            }
          ]
        }
      ]
    };
    baseUrl3 = CoreHelperUtil.getBlockchainApiUrl();
    state17 = proxy({
      clientId: null,
      api: new FetchUtil({ baseUrl: baseUrl3, clientId: null }),
      supportedChains: { http: [], ws: [] }
    });
    BlockchainApiController = {
      state: state17,
      async get(request) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const projectId = OptionsController.state.projectId;
        const params = {
          ...request.params || {},
          st,
          sv,
          projectId
        };
        return state17.api.get({
          ...request,
          params
        });
      },
      getSdkProperties() {
        const { sdkType, sdkVersion } = OptionsController.state;
        return {
          st: sdkType || "unknown",
          sv: sdkVersion || "unknown"
        };
      },
      async isNetworkSupported(networkId) {
        if (!networkId) {
          return false;
        }
        try {
          if (!state17.supportedChains.http.length) {
            await BlockchainApiController.getSupportedNetworks();
          }
        } catch (e10) {
          return false;
        }
        return state17.supportedChains.http.includes(networkId);
      },
      async getSupportedNetworks() {
        try {
          const supportedChains = await BlockchainApiController.get({
            path: "v1/supported-chains"
          });
          state17.supportedChains = supportedChains;
          return supportedChains;
        } catch {
          return state17.supportedChains;
        }
      },
      async fetchIdentity({ address: address2, caipNetworkId }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(caipNetworkId);
        if (!isSupported) {
          return { avatar: "", name: "" };
        }
        const identityCache = StorageUtil.getIdentityFromCacheForAddress(address2);
        if (identityCache) {
          return identityCache;
        }
        const result = await BlockchainApiController.get({
          path: `/v1/identity/${address2}`,
          params: {
            sender: ChainController.state.activeCaipAddress ? CoreHelperUtil.getPlainAddress(ChainController.state.activeCaipAddress) : void 0
          }
        });
        StorageUtil.updateIdentityCache({
          address: address2,
          identity: result,
          timestamp: Date.now()
        });
        return result;
      },
      async fetchTransactions({ account, cursor, signal, cache, chainId }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { data: [], next: void 0 };
        }
        const transactionsCache = StorageUtil.getTransactionsCacheForAddress({
          address: account,
          chainId
        });
        if (transactionsCache) {
          return transactionsCache;
        }
        const result = await BlockchainApiController.get({
          path: `/v1/account/${account}/history`,
          params: {
            cursor,
            chainId
          },
          signal,
          cache
        });
        StorageUtil.updateTransactionsCache({
          address: account,
          chainId,
          timestamp: Date.now(),
          transactions: result
        });
        return result;
      },
      async fetchSwapQuote({ amount, userAddress, from: from3, to: to4, gasPrice }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { quotes: [] };
        }
        return BlockchainApiController.get({
          path: `/v1/convert/quotes`,
          headers: {
            "Content-Type": "application/json"
          },
          params: {
            amount,
            userAddress,
            from: from3,
            to: to4,
            gasPrice
          }
        });
      },
      async fetchSwapTokens({ chainId }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { tokens: [] };
        }
        return BlockchainApiController.get({
          path: `/v1/convert/tokens`,
          params: { chainId }
        });
      },
      async fetchTokenPrice({ addresses }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { fungibles: [] };
        }
        const tokenPriceCache = StorageUtil.getTokenPriceCacheForAddresses(addresses);
        if (tokenPriceCache) {
          return tokenPriceCache;
        }
        const result = await state17.api.post({
          path: "/v1/fungible/price",
          body: {
            currency: "usd",
            addresses,
            projectId: OptionsController.state.projectId
          },
          headers: {
            "Content-Type": "application/json"
          }
        });
        StorageUtil.updateTokenPriceCache({
          addresses,
          timestamp: Date.now(),
          tokenPrice: result
        });
        return result;
      },
      async fetchSwapAllowance({ tokenAddress, userAddress }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { allowance: "0" };
        }
        return BlockchainApiController.get({
          path: `/v1/convert/allowance`,
          params: {
            tokenAddress,
            userAddress
          },
          headers: {
            "Content-Type": "application/json"
          }
        });
      },
      async fetchGasPrice({ chainId }) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          throw new Error("Network not supported for Gas Price");
        }
        return BlockchainApiController.get({
          path: `/v1/convert/gas-price`,
          headers: {
            "Content-Type": "application/json"
          },
          params: {
            chainId,
            st,
            sv
          }
        });
      },
      async generateSwapCalldata({ amount, from: from3, to: to4, userAddress, disableEstimate }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          throw new Error("Network not supported for Swaps");
        }
        return state17.api.post({
          path: "/v1/convert/build-transaction",
          headers: {
            "Content-Type": "application/json"
          },
          body: {
            amount,
            eip155: {
              slippage: ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE
            },
            projectId: OptionsController.state.projectId,
            from: from3,
            to: to4,
            userAddress,
            disableEstimate
          }
        });
      },
      async generateApproveCalldata({ from: from3, to: to4, userAddress }) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          throw new Error("Network not supported for Swaps");
        }
        return BlockchainApiController.get({
          path: `/v1/convert/build-approve`,
          headers: {
            "Content-Type": "application/json"
          },
          params: {
            userAddress,
            from: from3,
            to: to4,
            st,
            sv
          }
        });
      },
      async getBalance(address2, chainId, forceUpdate) {
        const { st, sv } = BlockchainApiController.getSdkProperties();
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          SnackController.showError("Token Balance Unavailable");
          return { balances: [] };
        }
        const caipAddress = `${chainId}:${address2}`;
        const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);
        if (cachedBalance) {
          return cachedBalance;
        }
        const balance = await BlockchainApiController.get({
          path: `/v1/account/${address2}/balance`,
          params: {
            currency: "usd",
            chainId,
            forceUpdate,
            st,
            sv
          }
        });
        StorageUtil.updateBalanceCache({
          caipAddress,
          balance,
          timestamp: Date.now()
        });
        return balance;
      },
      async lookupEnsName(name2) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { addresses: {}, attributes: [] };
        }
        return BlockchainApiController.get({
          path: `/v1/profile/account/${name2}`,
          params: { apiVersion: "2" }
        });
      },
      async reverseLookupEnsName({ address: address2 }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return [];
        }
        return BlockchainApiController.get({
          path: `/v1/profile/reverse/${address2}`,
          params: {
            sender: AccountController.state.address,
            apiVersion: "2"
          }
        });
      },
      async getEnsNameSuggestions(name2) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { suggestions: [] };
        }
        return BlockchainApiController.get({
          path: `/v1/profile/suggestions/${name2}`,
          params: { zone: "reown.id" }
        });
      },
      async registerEnsName({ coinType, address: address2, message, signature }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { success: false };
        }
        return state17.api.post({
          path: `/v1/profile/account`,
          body: { coin_type: coinType, address: address2, message, signature },
          headers: {
            "Content-Type": "application/json"
          }
        });
      },
      async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return "";
        }
        const response = await state17.api.post({
          path: `/v1/generators/onrampurl`,
          params: {
            projectId: OptionsController.state.projectId
          },
          body: {
            destinationWallets,
            defaultNetwork,
            partnerUserId,
            defaultExperience: "buy",
            presetCryptoAmount: purchaseAmount,
            presetFiatAmount: paymentAmount
          }
        });
        return response.url;
      },
      async getOnrampOptions() {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { paymentCurrencies: [], purchaseCurrencies: [] };
        }
        try {
          const response = await BlockchainApiController.get({
            path: `/v1/onramp/options`
          });
          return response;
        } catch (e10) {
          return DEFAULT_OPTIONS;
        }
      },
      async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
        try {
          const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
          if (!isSupported) {
            return null;
          }
          const response = await state17.api.post({
            path: `/v1/onramp/quote`,
            params: {
              projectId: OptionsController.state.projectId
            },
            body: {
              purchaseCurrency,
              paymentCurrency,
              amount,
              network
            }
          });
          return response;
        } catch (e10) {
          return {
            networkFee: { amount, currency: paymentCurrency.id },
            paymentSubtotal: { amount, currency: paymentCurrency.id },
            paymentTotal: { amount, currency: paymentCurrency.id },
            purchaseAmount: { amount, currency: paymentCurrency.id },
            quoteId: "mocked-quote-id"
          };
        }
      },
      async getSmartSessions(caipAddress) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return [];
        }
        return BlockchainApiController.get({
          path: `/v1/sessions/${caipAddress}`
        });
      },
      async revokeSmartSession(address2, pci, signature) {
        const isSupported = await BlockchainApiController.isNetworkSupported(ChainController.state.activeCaipNetwork?.caipNetworkId);
        if (!isSupported) {
          return { success: false };
        }
        return state17.api.post({
          path: `/v1/sessions/${address2}/revoke`,
          params: {
            projectId: OptionsController.state.projectId
          },
          body: {
            pci,
            signature
          }
        });
      },
      setClientId(clientId) {
        state17.clientId = clientId;
        state17.api = new FetchUtil({ baseUrl: baseUrl3, clientId });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex2(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex2 = __esm({
  "node_modules/viem/_esm/utils/data/isHex.js"() {
  }
});

// node_modules/viem/_esm/utils/data/size.js
function size2(value) {
  if (isHex2(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size2 = __esm({
  "node_modules/viem/_esm/utils/data/size.js"() {
    init_isHex2();
  }
});

// node_modules/viem/_esm/errors/version.js
var version3;
var init_version2 = __esm({
  "node_modules/viem/_esm/errors/version.js"() {
    version3 = "2.38.1";
  }
});

// node_modules/viem/_esm/errors/base.js
function walk2(err2, fn3) {
  if (fn3?.(err2))
    return err2;
  if (err2 && typeof err2 === "object" && "cause" in err2 && err2.cause !== void 0)
    return walk2(err2.cause, fn3);
  return fn3 ? null : err2;
}
var errorConfig2, BaseError2;
var init_base3 = __esm({
  "node_modules/viem/_esm/errors/base.js"() {
    init_version2();
    errorConfig2 = {
      getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
      version: `viem@${version3}`
    };
    BaseError2 = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        const details = (() => {
          if (args.cause instanceof _BaseError)
            return args.cause.details;
          if (args.cause?.message)
            return args.cause.message;
          return args.details;
        })();
        const docsPath = (() => {
          if (args.cause instanceof _BaseError)
            return args.cause.docsPath || args.docsPath;
          return args.docsPath;
        })();
        const docsUrl = errorConfig2.getDocsUrl?.({ ...args, docsPath });
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsUrl ? [`Docs: ${docsUrl}`] : [],
          ...details ? [`Details: ${details}`] : [],
          ...errorConfig2.version ? [`Version: ${errorConfig2.version}`] : []
        ].join("\n");
        super(message, args.cause ? { cause: args.cause } : void 0);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseError"
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version3;
      }
      walk(fn3) {
        return walk2(this, fn3);
      }
    };
  }
});

// node_modules/viem/_esm/errors/data.js
var SizeExceedsPaddingSizeError2;
var init_data2 = __esm({
  "node_modules/viem/_esm/errors/data.js"() {
    init_base3();
    SizeExceedsPaddingSizeError2 = class extends BaseError2 {
      constructor({ size: size4, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size4}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/pad.js
function pad2(hexOrBytes, { dir, size: size4 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex2(hexOrBytes, { dir, size: size4 });
  return padBytes2(hexOrBytes, { dir, size: size4 });
}
function padHex2(hex_, { dir, size: size4 = 32 } = {}) {
  if (size4 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}
function padBytes2(bytes2, { dir, size: size4 = 32 } = {}) {
  if (size4 === null)
    return bytes2;
  if (bytes2.length > size4)
    throw new SizeExceedsPaddingSizeError2({
      size: bytes2.length,
      targetSize: size4,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size4);
  for (let i11 = 0; i11 < size4; i11++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i11 : size4 - i11 - 1] = bytes2[padEnd ? i11 : bytes2.length - i11 - 1];
  }
  return paddedBytes;
}
var init_pad2 = __esm({
  "node_modules/viem/_esm/utils/data/pad.js"() {
    init_data2();
  }
});

// node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError2, SizeOverflowError2;
var init_encoding2 = __esm({
  "node_modules/viem/_esm/errors/encoding.js"() {
    init_base3();
    IntegerOutOfRangeError2 = class extends BaseError2 {
      constructor({ max, min, signed, size: size4, value }) {
        super(`Number "${value}" is not in safe ${size4 ? `${size4 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
      }
    };
    SizeOverflowError2 = class extends BaseError2 {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
      }
    };
  }
});

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize2(hexOrBytes, { size: size4 }) {
  if (size2(hexOrBytes) > size4)
    throw new SizeOverflowError2({
      givenSize: size2(hexOrBytes),
      maxSize: size4
    });
}
var init_fromHex2 = __esm({
  "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
    init_encoding2();
    init_size2();
  }
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex2(value, opts);
  if (typeof value === "string") {
    return stringToHex2(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex2(value, opts);
  return bytesToHex6(value, opts);
}
function boolToHex2(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize2(hex, { size: opts.size });
    return pad2(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex6(value, opts = {}) {
  let string2 = "";
  for (let i11 = 0; i11 < value.length; i11++) {
    string2 += hexes7[value[i11]];
  }
  const hex = `0x${string2}`;
  if (typeof opts.size === "number") {
    assertSize2(hex, { size: opts.size });
    return pad2(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex2(value_, opts = {}) {
  const { signed, size: size4 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError2({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size4)
    return pad2(hex, { size: size4 });
  return hex;
}
function stringToHex2(value_, opts = {}) {
  const value = encoder3.encode(value_);
  return bytesToHex6(value, opts);
}
var hexes7, encoder3;
var init_toHex2 = __esm({
  "node_modules/viem/_esm/utils/encoding/toHex.js"() {
    init_encoding2();
    init_pad2();
    init_fromHex2();
    hexes7 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i11) => i11.toString(16).padStart(2, "0"));
    encoder3 = /* @__PURE__ */ new TextEncoder();
  }
});

// node_modules/viem/_esm/utils/lru.js
var LruMap2;
var init_lru2 = __esm({
  "node_modules/viem/_esm/utils/lru.js"() {
    LruMap2 = class extends Map {
      constructor(size4) {
        super();
        Object.defineProperty(this, "maxSize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxSize = size4;
      }
      get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== void 0) {
          this.delete(key);
          super.set(key, value);
        }
        return value;
      }
      set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
          const firstKey = this.keys().next().value;
          if (firstKey)
            this.delete(firstKey);
        }
        return this;
      }
    };
  }
});

// node_modules/viem/_esm/utils/stringify.js
var stringify5;
var init_stringify = __esm({
  "node_modules/viem/_esm/utils/stringify.js"() {
    stringify5 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
      const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
      return typeof replacer === "function" ? replacer(key, value2) : value2;
    }, space);
  }
});

// node_modules/viem/_esm/constants/unit.js
var gweiUnits;
var init_unit = __esm({
  "node_modules/viem/_esm/constants/unit.js"() {
    gweiUnits = {
      ether: -9,
      wei: 9
    };
  }
});

// node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
var init_formatUnits = __esm({
  "node_modules/viem/_esm/utils/unit/formatUnits.js"() {
  }
});

// node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm({
  "node_modules/viem/_esm/utils/unit/formatGwei.js"() {
    init_unit();
    init_formatUnits();
  }
});

// node_modules/viem/_esm/errors/utils.js
var getUrl;
var init_utils5 = __esm({
  "node_modules/viem/_esm/errors/utils.js"() {
    getUrl = (url) => url;
  }
});

// node_modules/viem/_esm/errors/request.js
var HttpRequestError, RpcRequestError, TimeoutError;
var init_request = __esm({
  "node_modules/viem/_esm/errors/request.js"() {
    init_stringify();
    init_base3();
    init_utils5();
    HttpRequestError = class extends BaseError2 {
      constructor({ body, cause, details, headers, status, url }) {
        super("HTTP request failed.", {
          cause,
          details,
          metaMessages: [
            status && `Status: ${status}`,
            `URL: ${getUrl(url)}`,
            body && `Request body: ${stringify5(body)}`
          ].filter(Boolean),
          name: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
      }
    };
    RpcRequestError = class extends BaseError2 {
      constructor({ body, error: error2, url }) {
        super("RPC Request failed.", {
          cause: error2,
          details: error2.message,
          metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify5(body)}`],
          name: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = error2.code;
        this.data = error2.data;
      }
    };
    TimeoutError = class extends BaseError2 {
      constructor({ body, url }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify5(body)}`],
          name: "TimeoutError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/errors/rpc.js
var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnsupportedNonOptionalCapabilityError, UnsupportedChainIdError, DuplicateIdError, UnknownBundleIdError, BundleTooLargeError, AtomicReadyWalletRejectedUpgradeError, AtomicityNotSupportedError, UnknownRpcError;
var init_rpc = __esm({
  "node_modules/viem/_esm/errors/rpc.js"() {
    init_base3();
    init_request();
    unknownErrorCode = -1;
    RpcError = class extends BaseError2 {
      constructor(cause, { code: code2, docsPath, metaMessages, name: name2, shortMessage }) {
        super(shortMessage, {
          cause,
          docsPath,
          metaMessages: metaMessages || cause?.metaMessages,
          name: name2 || "RpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = name2 || cause.name;
        this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
      }
    };
    ProviderRpcError = class extends RpcError {
      constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = options.data;
      }
    };
    ParseRpcError = class _ParseRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ParseRpcError.code,
          name: "ParseRpcError",
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
      }
    };
    Object.defineProperty(ParseRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidRequestRpcError.code,
          name: "InvalidRequestRpcError",
          shortMessage: "JSON is not a valid request object."
        });
      }
    };
    Object.defineProperty(InvalidRequestRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {
      constructor(cause, { method } = {}) {
        super(cause, {
          code: _MethodNotFoundRpcError.code,
          name: "MethodNotFoundRpcError",
          shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
        });
      }
    };
    Object.defineProperty(MethodNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidParamsRpcError.code,
          name: "InvalidParamsRpcError",
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
      }
    };
    Object.defineProperty(InvalidParamsRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    InternalRpcError = class _InternalRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InternalRpcError.code,
          name: "InternalRpcError",
          shortMessage: "An internal error was received."
        });
      }
    };
    Object.defineProperty(InternalRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _InvalidInputRpcError.code,
          name: "InvalidInputRpcError",
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
      }
    };
    Object.defineProperty(InvalidInputRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ResourceNotFoundRpcError.code,
          name: "ResourceNotFoundRpcError",
          shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _ResourceUnavailableRpcError.code,
          name: "ResourceUnavailableRpcError",
          shortMessage: "Requested resource not available."
        });
      }
    };
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _TransactionRejectedRpcError.code,
          name: "TransactionRejectedRpcError",
          shortMessage: "Transaction creation failed."
        });
      }
    };
    Object.defineProperty(TransactionRejectedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {
      constructor(cause, { method } = {}) {
        super(cause, {
          code: _MethodNotSupportedRpcError.code,
          name: "MethodNotSupportedRpcError",
          shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
        });
      }
    };
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _LimitExceededRpcError.code,
          name: "LimitExceededRpcError",
          shortMessage: "Request exceeds defined limit."
        });
      }
    };
    Object.defineProperty(LimitExceededRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {
      constructor(cause) {
        super(cause, {
          code: _JsonRpcVersionUnsupportedError.code,
          name: "JsonRpcVersionUnsupportedError",
          shortMessage: "Version of JSON-RPC protocol is not supported."
        });
      }
    };
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UserRejectedRequestError.code,
          name: "UserRejectedRequestError",
          shortMessage: "User rejected the request."
        });
      }
    };
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnauthorizedProviderError.code,
          name: "UnauthorizedProviderError",
          shortMessage: "The requested method and/or account has not been authorized by the user."
        });
      }
    };
    Object.defineProperty(UnauthorizedProviderError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {
      constructor(cause, { method } = {}) {
        super(cause, {
          code: _UnsupportedProviderMethodError.code,
          name: "UnsupportedProviderMethodError",
          shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
        });
      }
    };
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _ProviderDisconnectedError.code,
          name: "ProviderDisconnectedError",
          shortMessage: "The Provider is disconnected from all chains."
        });
      }
    };
    Object.defineProperty(ProviderDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _ChainDisconnectedError.code,
          name: "ChainDisconnectedError",
          shortMessage: "The Provider is not connected to the requested chain."
        });
      }
    };
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    SwitchChainError = class _SwitchChainError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _SwitchChainError.code,
          name: "SwitchChainError",
          shortMessage: "An error occurred when attempting to switch chain."
        });
      }
    };
    Object.defineProperty(SwitchChainError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    UnsupportedNonOptionalCapabilityError = class _UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnsupportedNonOptionalCapabilityError.code,
          name: "UnsupportedNonOptionalCapabilityError",
          shortMessage: "This Wallet does not support a capability that was not marked as optional."
        });
      }
    };
    Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5700
    });
    UnsupportedChainIdError = class _UnsupportedChainIdError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnsupportedChainIdError.code,
          name: "UnsupportedChainIdError",
          shortMessage: "This Wallet does not support the requested chain ID."
        });
      }
    };
    Object.defineProperty(UnsupportedChainIdError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5710
    });
    DuplicateIdError = class _DuplicateIdError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _DuplicateIdError.code,
          name: "DuplicateIdError",
          shortMessage: "There is already a bundle submitted with this ID."
        });
      }
    };
    Object.defineProperty(DuplicateIdError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5720
    });
    UnknownBundleIdError = class _UnknownBundleIdError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _UnknownBundleIdError.code,
          name: "UnknownBundleIdError",
          shortMessage: "This bundle id is unknown / has not been submitted"
        });
      }
    };
    Object.defineProperty(UnknownBundleIdError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5730
    });
    BundleTooLargeError = class _BundleTooLargeError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _BundleTooLargeError.code,
          name: "BundleTooLargeError",
          shortMessage: "The call bundle is too large for the Wallet to process."
        });
      }
    };
    Object.defineProperty(BundleTooLargeError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5740
    });
    AtomicReadyWalletRejectedUpgradeError = class _AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _AtomicReadyWalletRejectedUpgradeError.code,
          name: "AtomicReadyWalletRejectedUpgradeError",
          shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
        });
      }
    };
    Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5750
    });
    AtomicityNotSupportedError = class _AtomicityNotSupportedError extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: _AtomicityNotSupportedError.code,
          name: "AtomicityNotSupportedError",
          shortMessage: "The wallet does not support atomic execution but the request requires it."
        });
      }
    };
    Object.defineProperty(AtomicityNotSupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5760
    });
    UnknownRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          name: "UnknownRpcError",
          shortMessage: "An unknown RPC error occurred."
        });
      }
    };
  }
});

// node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError;
var init_node = __esm({
  "node_modules/viem/_esm/errors/node.js"() {
    init_formatGwei();
    init_base3();
    ExecutionRevertedError = class extends BaseError2 {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause,
          name: "ExecutionRevertedError"
        });
      }
    };
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    FeeCapTooHighError = class extends BaseError2 {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause,
          name: "FeeCapTooHighError"
        });
      }
    };
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    FeeCapTooLowError = class extends BaseError2 {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause,
          name: "FeeCapTooLowError"
        });
      }
    };
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    NonceTooHighError = class extends BaseError2 {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
      }
    };
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    NonceTooLowError = class extends BaseError2 {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause, name: "NonceTooLowError" });
      }
    };
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported|already known/
    });
    NonceMaxValueError = class extends BaseError2 {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
      }
    };
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    InsufficientFundsError = class extends BaseError2 {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ],
          name: "InsufficientFundsError"
        });
      }
    };
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds|exceeds transaction sender account balance/
    });
    IntrinsicGasTooHighError = class extends BaseError2 {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause,
          name: "IntrinsicGasTooHighError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    IntrinsicGasTooLowError = class extends BaseError2 {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause,
          name: "IntrinsicGasTooLowError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    TransactionTypeNotSupportedError = class extends BaseError2 {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause,
          name: "TransactionTypeNotSupportedError"
        });
      }
    };
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    TipAboveFeeCapError = class extends BaseError2 {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause,
          name: "TipAboveFeeCapError"
        });
      }
    };
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
  }
});

// node_modules/viem/_esm/utils/promise/withResolvers.js
function withResolvers() {
  let resolve = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}
var init_withResolvers = __esm({
  "node_modules/viem/_esm/utils/promise/withResolvers.js"() {
  }
});

// node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn: fn3, id, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush2();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn3(args).then((data) => {
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i11 = 0; i11 < scheduler.length; i11++) {
        const { resolve } = scheduler[i11];
        resolve?.([data[i11], data]);
      }
    }).catch((err2) => {
      for (let i11 = 0; i11 < scheduler.length; i11++) {
        const { reject } = scheduler[i11];
        reject?.(err2);
      }
    });
  };
  const flush2 = () => schedulerCache.delete(id);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush: flush2,
    async schedule(args) {
      const { promise, resolve, reject } = withResolvers();
      const split3 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split3)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject });
        return promise;
      }
      setScheduler({ args, resolve, reject });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
var schedulerCache;
var init_createBatchScheduler = __esm({
  "node_modules/viem/_esm/utils/promise/createBatchScheduler.js"() {
    init_withResolvers();
    schedulerCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}
var init_wait = __esm({
  "node_modules/viem/_esm/utils/wait.js"() {
  }
});

// node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn3, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error: error2 }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error: error2 }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn3();
        resolve(data);
      } catch (err2) {
        if (count < retryCount && await shouldRetry2({ count, error: err2 }))
          return retry({ error: err2 });
        reject(err2);
      }
    };
    attemptRetry();
  });
}
var init_withRetry = __esm({
  "node_modules/viem/_esm/utils/promise/withRetry.js"() {
    init_wait();
  }
});

// node_modules/viem/_esm/utils/uid.js
function uid(length2 = 11) {
  if (!buffer2 || index + length2 > size3 * 2) {
    buffer2 = "";
    index = 0;
    for (let i11 = 0; i11 < size3; i11++) {
      buffer2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer2.substring(index, index++ + length2);
}
var size3, index, buffer2;
var init_uid = __esm({
  "node_modules/viem/_esm/utils/uid.js"() {
    size3 = 256;
    index = size3;
  }
});

// node_modules/viem/_esm/utils/promise/withDedupe.js
function withDedupe(fn3, { enabled = true, id }) {
  if (!enabled || !id)
    return fn3();
  if (promiseCache.get(id))
    return promiseCache.get(id);
  const promise = fn3().finally(() => promiseCache.delete(id));
  promiseCache.set(id, promise);
  return promise;
}
var promiseCache;
var init_withDedupe = __esm({
  "node_modules/viem/_esm/utils/promise/withDedupe.js"() {
    init_lru2();
    promiseCache = /* @__PURE__ */ new LruMap2(8192);
  }
});

// node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = args;
    if (methods?.exclude?.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if (methods?.include && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe ? stringToHex2(`${uid2}.${stringify5(args)}`) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err2 = err_;
        switch (err2.code) {
          // -32700
          case ParseRpcError.code:
            throw new ParseRpcError(err2);
          // -32600
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err2);
          // -32601
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err2, { method: args.method });
          // -32602
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err2);
          // -32603
          case InternalRpcError.code:
            throw new InternalRpcError(err2);
          // -32000
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err2);
          // -32001
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err2);
          // -32002
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err2);
          // -32003
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err2);
          // -32004
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err2, {
              method: args.method
            });
          // -32005
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err2);
          // -32006
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err2);
          // 4001
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err2);
          // 4100
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err2);
          // 4200
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err2);
          // 4900
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err2);
          // 4901
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err2);
          // 4902
          case SwitchChainError.code:
            throw new SwitchChainError(err2);
          // 5700
          case UnsupportedNonOptionalCapabilityError.code:
            throw new UnsupportedNonOptionalCapabilityError(err2);
          // 5710
          case UnsupportedChainIdError.code:
            throw new UnsupportedChainIdError(err2);
          // 5720
          case DuplicateIdError.code:
            throw new DuplicateIdError(err2);
          // 5730
          case UnknownBundleIdError.code:
            throw new UnknownBundleIdError(err2);
          // 5740
          case BundleTooLargeError.code:
            throw new BundleTooLargeError(err2);
          // 5750
          case AtomicReadyWalletRejectedUpgradeError.code:
            throw new AtomicReadyWalletRejectedUpgradeError(err2);
          // 5760
          case AtomicityNotSupportedError.code:
            throw new AtomicityNotSupportedError(err2);
          // CAIP-25: User Rejected Error
          // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
          case 5e3:
            throw new UserRejectedRequestError(err2);
          default:
            if (err_ instanceof BaseError2)
              throw err_;
            throw new UnknownRpcError(err2);
        }
      }
    }, {
      delay: ({ count, error: error2 }) => {
        if (error2 && error2 instanceof HttpRequestError) {
          const retryAfter = error2?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return Number.parseInt(retryAfter, 10) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error: error2 }) => shouldRetry(error2)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error2) {
  if ("code" in error2 && typeof error2.code === "number") {
    if (error2.code === -1)
      return true;
    if (error2.code === LimitExceededRpcError.code)
      return true;
    if (error2.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error2 instanceof HttpRequestError && error2.status) {
    if (error2.status === 403)
      return true;
    if (error2.status === 408)
      return true;
    if (error2.status === 413)
      return true;
    if (error2.status === 429)
      return true;
    if (error2.status === 500)
      return true;
    if (error2.status === 502)
      return true;
    if (error2.status === 503)
      return true;
    if (error2.status === 504)
      return true;
    return false;
  }
  return true;
}
var init_buildRequest = __esm({
  "node_modules/viem/_esm/utils/buildRequest.js"() {
    init_base3();
    init_request();
    init_rpc();
    init_toHex2();
    init_withDedupe();
    init_withRetry();
    init_stringify();
  }
});

// node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn3, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller16 = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller16.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn3({ signal: controller16?.signal || null }));
      } catch (err2) {
        if (err2?.name === "AbortError")
          reject(errorInstance);
        reject(err2);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
var init_withTimeout = __esm({
  "node_modules/viem/_esm/utils/promise/withTimeout.js"() {
  }
});

// node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache;
var init_id = __esm({
  "node_modules/viem/_esm/utils/rpc/id.js"() {
    idCache = /* @__PURE__ */ createIdStore();
  }
});

// node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      const { body, fetchFn = options.fetchFn ?? fetch, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify5(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify5({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          const args = await onRequest?.(request, init) ?? { ...init, url };
          const response2 = await fetchFn(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (err2) {
            if (response.ok)
              throw err2;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify5(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err2) {
        if (err2 instanceof HttpRequestError)
          throw err2;
        if (err2 instanceof TimeoutError)
          throw err2;
        throw new HttpRequestError({
          body,
          cause: err2,
          url
        });
      }
    }
  };
}
var init_http = __esm({
  "node_modules/viem/_esm/utils/rpc/http.js"() {
    init_request();
    init_withTimeout();
    init_stringify();
    init_id();
  }
});

// node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, methods, name: name2, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid();
  return {
    config: {
      key,
      methods,
      name: name2,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),
    value
  };
}
var init_createTransport = __esm({
  "node_modules/viem/_esm/clients/transports/createTransport.js"() {
    init_buildRequest();
    init_uid();
  }
});

// node_modules/viem/_esm/clients/transports/fallback.js
function fallback(transports_, config = {}) {
  const { key = "fallback", name: name2 = "Fallback", rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay } = config;
  return ({ chain: chain3, pollingInterval = 4e3, timeout, ...rest }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key,
      name: name2,
      async request({ method, params }) {
        let includes;
        const fetch2 = async (i11 = 0) => {
          const transport2 = transports[i11]({
            ...rest,
            chain: chain3,
            retryCount: 0,
            timeout
          });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err2) {
            onResponse({
              error: err2,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (shouldThrow_(err2))
              throw err2;
            if (i11 === transports.length - 1)
              throw err2;
            includes ?? (includes = transports.slice(i11 + 1).some((transport3) => {
              const { include, exclude } = transport3({ chain: chain3 }).config.methods || {};
              if (include)
                return include.includes(method);
              if (exclude)
                return !exclude.includes(method);
              return true;
            }));
            if (!includes)
              throw err2;
            return fetch2(i11 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn3) => onResponse = fn3,
      transports: transports.map((fn3) => fn3({ chain: chain3, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain: chain3,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        ping: rankOptions.ping,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function shouldThrow(error2) {
  if ("code" in error2 && typeof error2.code === "number") {
    if (error2.code === TransactionRejectedRpcError.code || error2.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error2.message) || error2.code === 5e3)
      return true;
  }
  return false;
}
function rankTransports({ chain: chain3, interval = 4e3, onTransports, ping, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain: chain3, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_5, i11) => {
      const latencies = samples.map((sample2) => sample2[i11].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i11].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i11];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i11
      ];
    }).sort((a5, b7) => b7[0] - a5[0]);
    onTransports(scores.map(([, i11]) => transports[i11]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}
var init_fallback = __esm({
  "node_modules/viem/_esm/clients/transports/fallback.js"() {
    init_node();
    init_rpc();
    init_wait();
    init_createTransport();
  }
});

// node_modules/viem/_esm/errors/transport.js
var UrlRequiredError;
var init_transport = __esm({
  "node_modules/viem/_esm/errors/transport.js"() {
    init_base3();
    UrlRequiredError = class extends BaseError2 {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro",
          name: "UrlRequiredError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchFn, fetchOptions, key = "http", methods, name: name2 = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config;
  return ({ chain: chain3, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || chain3?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchFn,
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      methods,
      name: name2,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a5, b7) => a5.id - b7.id
        });
        const fn3 = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error: error2, result }] = await fn3(body);
        if (raw)
          return { error: error2, result };
        if (error2)
          throw new RpcRequestError({
            body,
            error: error2,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
var init_http2 = __esm({
  "node_modules/viem/_esm/clients/transports/http.js"() {
    init_request();
    init_transport();
    init_createBatchScheduler();
    init_http();
    init_createTransport();
  }
});

// node_modules/viem/_esm/index.js
var init_esm9 = __esm({
  "node_modules/viem/_esm/index.js"() {
    init_fallback();
    init_http2();
    init_toHex2();
    init_formatUnits();
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ERC7811Util.js
var ERC7811Utils;
var init_ERC7811Util = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/ERC7811Util.js"() {
    init_esm9();
    ERC7811Utils = {
      /**
       * Creates a Balance object from an ERC7811 Asset object
       * @param asset - Asset object to convert
       * @param chainId - Chain ID in CAIP-2 format
       * @returns Balance object
       */
      createBalance(asset, chainId) {
        const metadata = {
          name: asset.metadata["name"] || "",
          symbol: asset.metadata["symbol"] || "",
          decimals: asset.metadata["decimals"] || 0,
          value: asset.metadata["value"] || 0,
          price: asset.metadata["price"] || 0,
          iconUrl: asset.metadata["iconUrl"] || ""
        };
        return {
          name: metadata.name,
          symbol: metadata.symbol,
          chainId,
          address: asset.address === "native" ? void 0 : this.convertAddressToCAIP10Address(asset.address, chainId),
          value: metadata.value,
          price: metadata.price,
          quantity: {
            decimals: metadata.decimals.toString(),
            numeric: this.convertHexToBalance({
              hex: asset.balance,
              decimals: metadata.decimals
            })
          },
          iconUrl: metadata.iconUrl
        };
      },
      /**
       * Converts a hex string to a Balance object
       * @param hex - Hex string to convert
       * @param decimals - Number of decimals to use
       * @returns Balance object
       */
      convertHexToBalance({ hex, decimals }) {
        return formatUnits(BigInt(hex), decimals);
      },
      /**
       * Converts an address to a CAIP-10 address
       * @param address - Address to convert
       * @param chainId - Chain ID in CAIP-2 format
       * @returns CAIP-10 address
       */
      convertAddressToCAIP10Address(address2, chainId) {
        return `${chainId}:${address2}`;
      },
      /**
       *  Creates a CAIP-2 Chain ID from a chain ID and namespace
       * @param chainId  - Chain ID in hex format
       * @param namespace  - Chain namespace
       * @returns
       */
      createCAIP2ChainId(chainId, namespace) {
        return `${namespace}:${parseInt(chainId, 16)}`;
      },
      /**
       * Gets the chain ID in hex format from a CAIP-2 Chain ID
       * @param caip2ChainId - CAIP-2 Chain ID
       * @returns Chain ID in hex format
       */
      getChainIdHexFromCAIP2ChainId(caip2ChainId) {
        const parts = caip2ChainId.split(":");
        if (parts.length < 2 || !parts[1]) {
          return "0x0";
        }
        const chainPart = parts[1];
        const parsed = parseInt(chainPart, 10);
        return isNaN(parsed) ? "0x0" : `0x${parsed.toString(16)}`;
      },
      /**
       * Checks if a response is a valid WalletGetAssetsResponse
       * @param response - The response to check
       * @returns True if the response is a valid WalletGetAssetsResponse, false otherwise
       */
      isWalletGetAssetsResponse(response) {
        if (typeof response !== "object" || response === null) {
          return false;
        }
        return Object.values(response).every((value) => Array.isArray(value) && value.every((asset) => this.isValidAsset(asset)));
      },
      /**
       * Checks if an asset object is valid.
       * @param asset - The asset object to check.
       * @returns True if the asset is valid, false otherwise.
       */
      isValidAsset(asset) {
        return typeof asset === "object" && asset !== null && typeof asset.address === "string" && typeof asset.balance === "string" && (asset.type === "ERC20" || asset.type === "NATIVE") && typeof asset.metadata === "object" && asset.metadata !== null && typeof asset.metadata["name"] === "string" && typeof asset.metadata["symbol"] === "string" && typeof asset.metadata["decimals"] === "number" && typeof asset.metadata["price"] === "number" && typeof asset.metadata["iconUrl"] === "string";
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/BalanceUtil.js
var BalanceUtil;
var init_BalanceUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/BalanceUtil.js"() {
    init_esm8();
    init_AccountController();
    init_BlockchainApiController();
    init_ChainController();
    init_ConnectionController();
    init_ConnectorController();
    init_ERC7811Util();
    init_StorageUtil();
    BalanceUtil = {
      /**
       * Get the balances of the user's tokens. If user connected with Auth provider or and on the EIP155 network,
       * it'll use the `wallet_getAssets` and `wallet_getCapabilities` calls to fetch the balance rather than Blockchain API
       * @param forceUpdate - If true, the balances will be fetched from the server
       * @returns The balances of the user's tokens
       */
      async getMyTokensWithBalance(forceUpdate) {
        const address2 = AccountController.state.address;
        const caipNetwork = ChainController.state.activeCaipNetwork;
        const isAuthConnector = ConnectorController.getConnectorId("eip155") === ConstantsUtil.CONNECTOR_ID.AUTH;
        if (!address2 || !caipNetwork) {
          return [];
        }
        const caipAddress = `${caipNetwork.caipNetworkId}:${address2}`;
        const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);
        if (cachedBalance) {
          return cachedBalance.balances;
        }
        if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM && isAuthConnector) {
          const eip155Balances = await this.getEIP155Balances(address2, caipNetwork);
          if (eip155Balances) {
            return this.filterLowQualityTokens(eip155Balances);
          }
        }
        const response = await BlockchainApiController.getBalance(address2, caipNetwork.caipNetworkId, forceUpdate);
        return this.filterLowQualityTokens(response.balances);
      },
      /**
       * Get the balances of the user's tokens on the EIP155 network using native `wallet_getAssets` and `wallet_getCapabilities` calls
       * @param address - The address of the user
       * @param caipNetwork - The CAIP network
       * @returns The balances of the user's tokens on the EIP155 network
       */
      async getEIP155Balances(address2, caipNetwork) {
        try {
          const chainIdHex = ERC7811Utils.getChainIdHexFromCAIP2ChainId(caipNetwork.caipNetworkId);
          const walletCapabilities = await ConnectionController.getCapabilities(address2);
          if (!walletCapabilities?.[chainIdHex]?.["assetDiscovery"]?.supported) {
            return null;
          }
          const walletGetAssetsResponse = await ConnectionController.walletGetAssets({
            account: address2,
            chainFilter: [chainIdHex]
          });
          if (!ERC7811Utils.isWalletGetAssetsResponse(walletGetAssetsResponse)) {
            return null;
          }
          const assets = walletGetAssetsResponse[chainIdHex] || [];
          const filteredAssets = assets.map((asset) => ERC7811Utils.createBalance(asset, caipNetwork.caipNetworkId));
          StorageUtil.updateBalanceCache({
            caipAddress: `${caipNetwork.caipNetworkId}:${address2}`,
            balance: { balances: filteredAssets },
            timestamp: Date.now()
          });
          return filteredAssets;
        } catch (error2) {
          return null;
        }
      },
      /**
       * The 1Inch API includes many low-quality tokens in the balance response,
       * which appear inconsistently. This filter prevents them from being displayed.
       */
      filterLowQualityTokens(balances) {
        return balances.filter((balance) => balance.quantity.decimals !== "0");
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js
var state18, controller11, AccountController;
var init_AccountController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/AccountController.js"() {
    init_vanilla();
    init_BalanceUtil();
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    init_withErrorBoundary();
    init_ChainController();
    init_SnackController();
    state18 = proxy({
      currentTab: 0,
      tokenBalance: [],
      smartAccountDeployed: false,
      addressLabels: /* @__PURE__ */ new Map()
    });
    controller11 = {
      state: state18,
      replaceState(newState) {
        if (!newState) {
          return;
        }
        Object.assign(state18, ref(newState));
      },
      subscribe(callback) {
        return ChainController.subscribeChainProp("accountState", (accountState2) => {
          if (accountState2) {
            return callback(accountState2);
          }
          return void 0;
        });
      },
      subscribeKey(property, callback, chain3) {
        let prev = void 0;
        return ChainController.subscribeChainProp("accountState", (accountState2) => {
          if (accountState2) {
            const nextValue = accountState2[property];
            if (prev !== nextValue) {
              prev = nextValue;
              callback(nextValue);
            }
          }
        }, chain3);
      },
      setStatus(status, chain3) {
        ChainController.setAccountProp("status", status, chain3);
      },
      getCaipAddress(chain3) {
        if (!chain3) {
          return void 0;
        }
        return ChainController.state.chains.get(chain3)?.accountState?.caipAddress;
      },
      setCaipAddress(caipAddress, chain3) {
        const newAddress = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
        if (chain3 === ChainController.state.activeChain) {
          ChainController.state.activeCaipAddress = caipAddress;
        }
        ChainController.setAccountProp("caipAddress", caipAddress, chain3);
        ChainController.setAccountProp("address", newAddress, chain3);
      },
      setBalance(balance, balanceSymbol, chain3) {
        ChainController.setAccountProp("balance", balance, chain3);
        ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain3);
      },
      setProfileName(profileName, chain3) {
        ChainController.setAccountProp("profileName", profileName, chain3);
      },
      setProfileImage(profileImage, chain3) {
        ChainController.setAccountProp("profileImage", profileImage, chain3);
      },
      setUser(user, chain3) {
        ChainController.setAccountProp("user", user, chain3);
      },
      setAddressExplorerUrl(explorerUrl, chain3) {
        ChainController.setAccountProp("addressExplorerUrl", explorerUrl, chain3);
      },
      setSmartAccountDeployed(isDeployed, chain3) {
        ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain3);
      },
      setCurrentTab(currentTab) {
        ChainController.setAccountProp("currentTab", currentTab, ChainController.state.activeChain);
      },
      setTokenBalance(tokenBalance, chain3) {
        if (tokenBalance) {
          ChainController.setAccountProp("tokenBalance", tokenBalance, chain3);
        }
      },
      setShouldUpdateToAddress(address2, chain3) {
        ChainController.setAccountProp("shouldUpdateToAddress", address2, chain3);
      },
      addAddressLabel(address2, label, chain3) {
        if (!chain3) {
          return;
        }
        const map2 = ChainController.state.chains.get(chain3)?.accountState?.addressLabels || /* @__PURE__ */ new Map();
        map2.set(address2, label);
        ChainController.setAccountProp("addressLabels", map2, chain3);
      },
      removeAddressLabel(address2, chain3) {
        if (!chain3) {
          return;
        }
        const map2 = ChainController.state.chains.get(chain3)?.accountState?.addressLabels || /* @__PURE__ */ new Map();
        map2.delete(address2);
        ChainController.setAccountProp("addressLabels", map2, chain3);
      },
      setConnectedWalletInfo(connectedWalletInfo, chain3) {
        ChainController.setAccountProp("connectedWalletInfo", connectedWalletInfo, chain3, false);
      },
      setPreferredAccountType(preferredAccountType, chain3) {
        ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain3);
      },
      setSocialProvider(socialProvider, chain3) {
        if (socialProvider) {
          ChainController.setAccountProp("socialProvider", socialProvider, chain3);
        }
      },
      setSocialWindow(socialWindow, chain3) {
        ChainController.setAccountProp("socialWindow", socialWindow ? ref(socialWindow) : void 0, chain3);
      },
      setFarcasterUrl(farcasterUrl, chain3) {
        ChainController.setAccountProp("farcasterUrl", farcasterUrl, chain3);
      },
      async fetchTokenBalance(onError) {
        state18.balanceLoading = true;
        const chainId = ChainController.state.activeCaipNetwork?.caipNetworkId;
        const chain3 = ChainController.state.activeCaipNetwork?.chainNamespace;
        const caipAddress = ChainController.state.activeCaipAddress;
        const address2 = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
        if (state18.lastRetry && !CoreHelperUtil.isAllowedRetry(state18.lastRetry, 30 * ConstantsUtil2.ONE_SEC_MS)) {
          state18.balanceLoading = false;
          return [];
        }
        try {
          if (address2 && chainId && chain3) {
            const balance = await BalanceUtil.getMyTokensWithBalance();
            AccountController.setTokenBalance(balance, chain3);
            state18.lastRetry = void 0;
            state18.balanceLoading = false;
            return balance;
          }
        } catch (error2) {
          state18.lastRetry = Date.now();
          onError?.(error2);
          SnackController.showError("Token Balance Unavailable");
        } finally {
          state18.balanceLoading = false;
        }
        return [];
      },
      resetAccount(chain3) {
        ChainController.resetAccount(chain3);
      }
    };
    AccountController = withErrorBoundary(controller11);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/NetworkUtil.js
var NetworkUtil2;
var init_NetworkUtil2 = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/NetworkUtil.js"() {
    init_esm8();
    init_AccountController();
    init_ChainController();
    init_ConnectorController();
    init_RouterController();
    NetworkUtil2 = {
      /**
       * Function to handle the network switch.
       * This function has variety of conditions to handle the network switch depending on the connectors or namespace's connection states.
       * @param args.network - The network to switch to.
       * @param args.shouldConfirmSwitch - Whether to confirm the switch. If true, the user will be asked to confirm the switch if necessary.
       * @returns void
       */
      onSwitchNetwork({ network, ignoreSwitchConfirmation = false }) {
        const currentNetwork = ChainController.state.activeCaipNetwork;
        const routerData = RouterController.state.data;
        const isSameNetwork = network.id === currentNetwork?.id;
        if (isSameNetwork) {
          return;
        }
        const isCurrentNamespaceConnected = AccountController.getCaipAddress(ChainController.state.activeChain);
        const isDifferentNamespace = network.chainNamespace !== ChainController.state.activeChain;
        const isNextNamespaceConnected = AccountController.getCaipAddress(network.chainNamespace);
        const connectorId = ConnectorController.getConnectorId(ChainController.state.activeChain);
        const isConnectedWithAuth = connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        const isSupportedForAuthConnector = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((c12) => c12 === network.chainNamespace);
        if (ignoreSwitchConfirmation || isConnectedWithAuth && isSupportedForAuthConnector) {
          RouterController.push("SwitchNetwork", { ...routerData, network });
        } else if (
          /**
           * If user switching to a different namespace and next namespace is not connected, we need to show switch active chain view for confirmation first.
           */
          isCurrentNamespaceConnected && isDifferentNamespace && !isNextNamespaceConnected
        ) {
          RouterController.push("SwitchActiveChain", {
            switchToChain: network.chainNamespace,
            navigateTo: "Connect",
            navigateWithReplace: true,
            network
          });
        } else {
          RouterController.push("SwitchNetwork", { ...routerData, network });
        }
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js
var state19, controller12, ModalController;
var init_ModalController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/ModalController.js"() {
    init_vanilla();
    init_utils3();
    init_CoreHelperUtil();
    init_NetworkUtil2();
    init_withErrorBoundary();
    init_ApiController();
    init_ChainController();
    init_ConnectionController();
    init_ConnectorController();
    init_EventsController();
    init_OptionsController();
    init_PublicStateController();
    init_RouterController();
    state19 = proxy({
      loading: false,
      loadingNamespaceMap: /* @__PURE__ */ new Map(),
      open: false,
      shake: false,
      namespace: void 0
    });
    controller12 = {
      state: state19,
      subscribe(callback) {
        return subscribe(state19, () => callback(state19));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state19, key, callback);
      },
      async open(options) {
        const namespace = options?.namespace;
        const currentNamespace = ChainController.state.activeChain;
        const isSwitchingNamespace = namespace && namespace !== currentNamespace;
        const caipAddress = ChainController.getAccountData(options?.namespace)?.caipAddress;
        if (ConnectionController.state.wcBasic) {
          ApiController.prefetch({ fetchNetworkImages: false, fetchConnectorImages: false });
        } else {
          await ApiController.prefetch();
        }
        ConnectorController.setFilterByNamespace(options?.namespace);
        ModalController.setLoading(true, namespace);
        if (namespace && isSwitchingNamespace) {
          const namespaceNetwork = ChainController.getNetworkData(namespace)?.caipNetwork || ChainController.getRequestedCaipNetworks(namespace)[0];
          if (namespaceNetwork) {
            NetworkUtil2.onSwitchNetwork({ network: namespaceNetwork, ignoreSwitchConfirmation: true });
          }
        } else {
          const hasNoAdapters = ChainController.state.noAdapters;
          if (OptionsController.state.manualWCControl || hasNoAdapters && !caipAddress) {
            if (CoreHelperUtil.isMobile()) {
              RouterController.reset("AllWallets");
            } else {
              RouterController.reset("ConnectingWalletConnectBasic");
            }
          } else if (options?.view) {
            RouterController.reset(options.view, options.data);
          } else if (caipAddress) {
            RouterController.reset("Account");
          } else {
            RouterController.reset("Connect");
          }
        }
        state19.open = true;
        PublicStateController.set({ open: true });
        EventsController.sendEvent({
          type: "track",
          event: "MODAL_OPEN",
          properties: { connected: Boolean(caipAddress) }
        });
      },
      close() {
        const isEmbeddedEnabled = OptionsController.state.enableEmbedded;
        const isConnected = Boolean(ChainController.state.activeCaipAddress);
        if (state19.open) {
          EventsController.sendEvent({
            type: "track",
            event: "MODAL_CLOSE",
            properties: { connected: isConnected }
          });
        }
        state19.open = false;
        RouterController.reset("Connect");
        ModalController.clearLoading();
        if (isEmbeddedEnabled) {
          if (isConnected) {
            RouterController.replace("Account");
          } else {
            RouterController.push("Connect");
          }
        } else {
          PublicStateController.set({ open: false });
        }
        ConnectionController.resetUri();
      },
      setLoading(loading, namespace) {
        if (namespace) {
          state19.loadingNamespaceMap.set(namespace, loading);
        }
        state19.loading = loading;
        PublicStateController.set({ loading });
      },
      clearLoading() {
        state19.loadingNamespaceMap.clear();
        state19.loading = false;
        PublicStateController.set({ loading: false });
      },
      shake() {
        if (state19.shake) {
          return;
        }
        state19.shake = true;
        setTimeout(() => {
          state19.shake = false;
        }, 500);
      }
    };
    ModalController = withErrorBoundary(controller12);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OnRampController.js
var USDC_CURRENCY_DEFAULT, USD_CURRENCY_DEFAULT, defaultState, state20, controller13, OnRampController;
var init_OnRampController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/OnRampController.js"() {
    init_vanilla();
    init_utils3();
    init_esm8();
    init_ConstantsUtil2();
    init_withErrorBoundary();
    init_ApiController();
    init_BlockchainApiController();
    init_ChainController();
    init_OptionsController();
    USDC_CURRENCY_DEFAULT = {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    };
    USD_CURRENCY_DEFAULT = {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    };
    defaultState = {
      providers: ONRAMP_PROVIDERS,
      selectedProvider: null,
      error: null,
      purchaseCurrency: USDC_CURRENCY_DEFAULT,
      paymentCurrency: USD_CURRENCY_DEFAULT,
      purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
      paymentCurrencies: [],
      quotesLoading: false
    };
    state20 = proxy(defaultState);
    controller13 = {
      state: state20,
      subscribe(callback) {
        return subscribe(state20, () => callback(state20));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state20, key, callback);
      },
      setSelectedProvider(provider) {
        if (provider && provider.name === "meld") {
          const activeChain = ChainController.state.activeChain;
          const currency = activeChain === ConstantsUtil.CHAIN.SOLANA ? "SOL" : "USDC";
          const address2 = activeChain ? ChainController.state.chains.get(activeChain)?.accountState?.address ?? "" : "";
          const url = new URL(provider.url);
          url.searchParams.append("publicKey", MELD_PUBLIC_KEY);
          url.searchParams.append("destinationCurrencyCode", currency);
          url.searchParams.append("walletAddress", address2);
          url.searchParams.append("externalCustomerId", OptionsController.state.projectId);
          state20.selectedProvider = { ...provider, url: url.toString() };
        } else {
          state20.selectedProvider = provider;
        }
      },
      setOnrampProviders(providers) {
        if (Array.isArray(providers) && providers.every((item) => typeof item === "string")) {
          const validOnramp = providers;
          const newProviders = ONRAMP_PROVIDERS.filter((provider) => validOnramp.includes(provider.name));
          state20.providers = newProviders;
        } else {
          state20.providers = [];
        }
      },
      setPurchaseCurrency(currency) {
        state20.purchaseCurrency = currency;
      },
      setPaymentCurrency(currency) {
        state20.paymentCurrency = currency;
      },
      setPurchaseAmount(amount) {
        OnRampController.state.purchaseAmount = amount;
      },
      setPaymentAmount(amount) {
        OnRampController.state.paymentAmount = amount;
      },
      async getAvailableCurrencies() {
        const options = await BlockchainApiController.getOnrampOptions();
        state20.purchaseCurrencies = options.purchaseCurrencies;
        state20.paymentCurrencies = options.paymentCurrencies;
        state20.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
        state20.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
        await ApiController.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
        await ApiController.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
      },
      async getQuote() {
        state20.quotesLoading = true;
        try {
          const quote = await BlockchainApiController.getOnrampQuote({
            purchaseCurrency: state20.purchaseCurrency,
            paymentCurrency: state20.paymentCurrency,
            amount: state20.paymentAmount?.toString() || "0",
            network: state20.purchaseCurrency?.symbol
          });
          state20.quotesLoading = false;
          state20.purchaseAmount = Number(quote?.purchaseAmount.amount);
          return quote;
        } catch (error2) {
          state20.error = error2.message;
          state20.quotesLoading = false;
          return null;
        } finally {
          state20.quotesLoading = false;
        }
      },
      resetState() {
        state20.selectedProvider = null;
        state20.error = null;
        state20.purchaseCurrency = USDC_CURRENCY_DEFAULT;
        state20.paymentCurrency = USD_CURRENCY_DEFAULT;
        state20.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
        state20.paymentCurrencies = [];
        state20.paymentAmount = void 0;
        state20.purchaseAmount = void 0;
        state20.quotesLoading = false;
      }
    };
    OnRampController = withErrorBoundary(controller13);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TooltipController.js
var state21, controller14, TooltipController;
var init_TooltipController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/TooltipController.js"() {
    init_vanilla();
    init_utils3();
    init_withErrorBoundary();
    state21 = proxy({
      message: "",
      open: false,
      triggerRect: {
        width: 0,
        height: 0,
        top: 0,
        left: 0
      },
      variant: "shade"
    });
    controller14 = {
      state: state21,
      subscribe(callback) {
        return subscribe(state21, () => callback(state21));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state21, key, callback);
      },
      showTooltip({ message, triggerRect, variant }) {
        state21.open = true;
        state21.message = message;
        state21.triggerRect = triggerRect;
        state21.variant = variant;
      },
      hide() {
        state21.open = false;
        state21.message = "";
        state21.triggerRect = {
          width: 0,
          height: 0,
          top: 0,
          left: 0
        };
      }
    };
    TooltipController = withErrorBoundary(controller14);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js
var SLIP44_MSB, EnsUtil;
var init_EnsUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/EnsUtil.js"() {
    SLIP44_MSB = 2147483648;
    EnsUtil = {
      convertEVMChainIdToCoinType(chainId) {
        if (chainId >= SLIP44_MSB) {
          throw new Error("Invalid chainId");
        }
        return (SLIP44_MSB | chainId) >>> 0;
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js
var state22, controller15, EnsController;
var init_EnsController = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/controllers/EnsController.js"() {
    init_vanilla();
    init_utils3();
    init_EnsUtil();
    init_StorageUtil();
    init_withErrorBoundary();
    init_AccountController();
    init_BlockchainApiController();
    init_ChainController();
    init_ConnectionController();
    init_ConnectorController();
    init_RouterController();
    state22 = proxy({
      suggestions: [],
      loading: false
    });
    controller15 = {
      state: state22,
      subscribe(callback) {
        return subscribe(state22, () => callback(state22));
      },
      subscribeKey(key, callback) {
        return subscribeKey(state22, key, callback);
      },
      async resolveName(name2) {
        try {
          return await BlockchainApiController.lookupEnsName(name2);
        } catch (e10) {
          const error2 = e10;
          throw new Error(error2?.reasons?.[0]?.description || "Error resolving name");
        }
      },
      async isNameRegistered(name2) {
        try {
          await BlockchainApiController.lookupEnsName(name2);
          return true;
        } catch {
          return false;
        }
      },
      async getSuggestions(value) {
        try {
          state22.loading = true;
          state22.suggestions = [];
          const response = await BlockchainApiController.getEnsNameSuggestions(value);
          state22.suggestions = response.suggestions.map((suggestion) => ({
            ...suggestion,
            name: suggestion.name
          })) || [];
          return state22.suggestions;
        } catch (e10) {
          const errorMessage = EnsController.parseEnsApiError(e10, "Error fetching name suggestions");
          throw new Error(errorMessage);
        } finally {
          state22.loading = false;
        }
      },
      async getNamesForAddress(address2) {
        try {
          const network = ChainController.state.activeCaipNetwork;
          if (!network) {
            return [];
          }
          const cachedEns = StorageUtil.getEnsFromCacheForAddress(address2);
          if (cachedEns) {
            return cachedEns;
          }
          const response = await BlockchainApiController.reverseLookupEnsName({ address: address2 });
          StorageUtil.updateEnsCache({
            address: address2,
            ens: response,
            timestamp: Date.now()
          });
          return response;
        } catch (e10) {
          const errorMessage = EnsController.parseEnsApiError(e10, "Error fetching names for address");
          throw new Error(errorMessage);
        }
      },
      async registerName(name2) {
        const network = ChainController.state.activeCaipNetwork;
        const address2 = AccountController.state.address;
        const emailConnector = ConnectorController.getAuthConnector();
        if (!network) {
          throw new Error("Network not found");
        }
        if (!address2 || !emailConnector) {
          throw new Error("Address or auth connector not found");
        }
        state22.loading = true;
        try {
          const message = JSON.stringify({
            name: name2,
            attributes: {},
            // Unix timestamp
            timestamp: Math.floor(Date.now() / 1e3)
          });
          RouterController.pushTransactionStack({
            onCancel() {
              RouterController.replace("RegisterAccountName");
            }
          });
          const signature = await ConnectionController.signMessage(message);
          state22.loading = false;
          const networkId = network.id;
          if (!networkId) {
            throw new Error("Network not found");
          }
          const coinType = EnsUtil.convertEVMChainIdToCoinType(Number(networkId));
          await BlockchainApiController.registerEnsName({
            coinType,
            address: address2,
            signature,
            message
          });
          AccountController.setProfileName(name2, network.chainNamespace);
          RouterController.replace("RegisterAccountNameSuccess");
        } catch (e10) {
          const errorMessage = EnsController.parseEnsApiError(e10, `Error registering name ${name2}`);
          RouterController.replace("RegisterAccountName");
          throw new Error(errorMessage);
        } finally {
          state22.loading = false;
        }
      },
      validateName(name2) {
        return /^[a-zA-Z0-9-]{4,}$/u.test(name2);
      },
      parseEnsApiError(error2, defaultError) {
        const ensError = error2;
        return ensError?.reasons?.[0]?.description || defaultError;
      }
    };
    EnsController = withErrorBoundary(controller15);
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/SIWXUtil.js
var addEmbeddedWalletSessionPromise, SIWXUtil;
var init_SIWXUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/SIWXUtil.js"() {
    init_index_es14();
    init_esm8();
    init_utils4();
    init_AccountController();
    init_ChainController();
    init_ConnectionController();
    init_ConnectorController();
    init_EventsController();
    init_ModalController();
    init_OptionsController();
    init_RouterController();
    init_SnackController();
    init_ChainControllerUtil();
    init_CoreHelperUtil();
    addEmbeddedWalletSessionPromise = null;
    SIWXUtil = {
      getSIWX() {
        return OptionsController.state.siwx;
      },
      async initializeIfEnabled(caipAddress = ChainController.getActiveCaipAddress()) {
        const siwx = OptionsController.state.siwx;
        if (!(siwx && caipAddress)) {
          return;
        }
        const [namespace, chainId, address2] = caipAddress.split(":");
        if (!ChainController.checkIfSupportedNetwork(namespace, `${namespace}:${chainId}`)) {
          return;
        }
        try {
          if (OptionsController.state.remoteFeatures?.emailCapture) {
            const user = ChainController.getAccountData(namespace)?.user;
            await ModalController.open({
              view: "DataCapture",
              data: {
                email: user?.email ?? void 0
              }
            });
            return;
          }
          if (addEmbeddedWalletSessionPromise) {
            await addEmbeddedWalletSessionPromise;
          }
          const sessions = await siwx.getSessions(`${namespace}:${chainId}`, address2);
          if (sessions.length) {
            return;
          }
          await ModalController.open({
            view: "SIWXSignMessage"
          });
        } catch (error2) {
          console.error("SIWXUtil:initializeIfEnabled", error2);
          EventsController.sendEvent({
            type: "track",
            event: "SIWX_AUTH_ERROR",
            properties: this.getSIWXEventProperties()
          });
          await ConnectionController._getClient()?.disconnect().catch(console.error);
          RouterController.reset("Connect");
          SnackController.showError("A problem occurred while trying initialize authentication");
        }
      },
      async requestSignMessage() {
        const siwx = OptionsController.state.siwx;
        const address2 = CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress());
        const network = getActiveCaipNetwork();
        const client = ConnectionController._getClient();
        if (!siwx) {
          throw new Error("SIWX is not enabled");
        }
        if (!address2) {
          throw new Error("No ActiveCaipAddress found");
        }
        if (!network) {
          throw new Error("No ActiveCaipNetwork or client found");
        }
        if (!client) {
          throw new Error("No ConnectionController client found");
        }
        try {
          const siwxMessage = await siwx.createMessage({
            chainId: network.caipNetworkId,
            accountAddress: address2
          });
          const message = siwxMessage.toString();
          const connectorId = ConnectorController.getConnectorId(network.chainNamespace);
          if (connectorId === ConstantsUtil.CONNECTOR_ID.AUTH) {
            RouterController.pushTransactionStack({});
          }
          const signature = await client.signMessage(message);
          await siwx.addSession({
            data: siwxMessage,
            message,
            signature
          });
          ChainController.setLastConnectedSIWECaipNetwork(network);
          ModalController.close();
          EventsController.sendEvent({
            type: "track",
            event: "SIWX_AUTH_SUCCESS",
            properties: this.getSIWXEventProperties()
          });
        } catch (error2) {
          const properties = this.getSIWXEventProperties();
          if (!ModalController.state.open || RouterController.state.view === "ApproveTransaction") {
            await ModalController.open({
              view: "SIWXSignMessage"
            });
          }
          SnackController.showError("Error signing message");
          EventsController.sendEvent({
            type: "track",
            event: "SIWX_AUTH_ERROR",
            properties
          });
          console.error("SWIXUtil:requestSignMessage", error2);
        }
      },
      async cancelSignMessage() {
        try {
          const siwx = this.getSIWX();
          const isRequired = siwx?.getRequired?.();
          if (isRequired) {
            const lastNetwork = ChainController.getLastConnectedSIWECaipNetwork();
            if (lastNetwork) {
              const sessions = await siwx?.getSessions(lastNetwork?.caipNetworkId, CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress()) || "");
              if (sessions && sessions.length > 0) {
                await ChainController.switchActiveNetwork(lastNetwork);
              } else {
                await ConnectionController.disconnect();
              }
            } else {
              await ConnectionController.disconnect();
            }
          } else {
            ModalController.close();
          }
          ModalController.close();
          EventsController.sendEvent({
            event: "CLICK_CANCEL_SIWX",
            type: "track",
            properties: this.getSIWXEventProperties()
          });
        } catch (error2) {
          console.error("SIWXUtil:cancelSignMessage", error2);
        }
      },
      async getAllSessions() {
        const siwx = this.getSIWX();
        const allRequestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
        const sessions = [];
        await Promise.all(allRequestedCaipNetworks.map(async (caipNetwork) => {
          const session = await siwx?.getSessions(caipNetwork.caipNetworkId, CoreHelperUtil.getPlainAddress(ChainController.getActiveCaipAddress()) || "");
          if (session) {
            sessions.push(...session);
          }
        }));
        return sessions;
      },
      async getSessions(args) {
        const siwx = OptionsController.state.siwx;
        let address2 = args?.address;
        if (!address2) {
          const activeCaipAddress = ChainController.getActiveCaipAddress();
          address2 = CoreHelperUtil.getPlainAddress(activeCaipAddress);
        }
        let network = args?.caipNetworkId;
        if (!network) {
          const activeCaipNetwork = ChainController.getActiveCaipNetwork();
          network = activeCaipNetwork?.caipNetworkId;
        }
        if (!(siwx && address2 && network)) {
          return [];
        }
        return siwx.getSessions(network, address2);
      },
      async isSIWXCloseDisabled() {
        const siwx = this.getSIWX();
        if (siwx) {
          const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
          const isSiwxSignMessage = RouterController.state.view === "SIWXSignMessage";
          if (isApproveSignScreen || isSiwxSignMessage) {
            return siwx.getRequired?.() && (await this.getSessions()).length === 0;
          }
        }
        return false;
      },
      async authConnectorAuthenticate({ authConnector, chainId, socialUri, preferredAccountType, chainNamespace }) {
        const siwx = SIWXUtil.getSIWX();
        if (!siwx || !chainNamespace.includes(ConstantsUtil.CHAIN.EVM) || // Request to input email and sign message when email capture is enabled
        OptionsController.state.remoteFeatures?.emailCapture) {
          const result2 = await authConnector.connect({
            chainId,
            socialUri,
            preferredAccountType
          });
          return {
            address: result2.address,
            chainId: result2.chainId,
            accounts: result2.accounts
          };
        }
        const caipNetwork = `${chainNamespace}:${chainId}`;
        const siwxMessage = await siwx.createMessage({
          chainId: caipNetwork,
          accountAddress: "<<AccountAddress>>"
        });
        const siwxMessageData = {
          accountAddress: siwxMessage.accountAddress,
          chainId: siwxMessage.chainId,
          domain: siwxMessage.domain,
          uri: siwxMessage.uri,
          version: siwxMessage.version,
          nonce: siwxMessage.nonce,
          notBefore: siwxMessage.notBefore,
          statement: siwxMessage.statement,
          resources: siwxMessage.resources,
          requestId: siwxMessage.requestId,
          issuedAt: siwxMessage.issuedAt,
          expirationTime: siwxMessage.expirationTime,
          serializedMessage: siwxMessage.toString()
        };
        const result = await authConnector.connect({
          chainId,
          socialUri,
          siwxMessage: siwxMessageData,
          preferredAccountType
        });
        siwxMessageData.accountAddress = result.address;
        siwxMessageData.serializedMessage = result.message || "";
        if (result.signature && result.message) {
          const promise = SIWXUtil.addEmbeddedWalletSession(siwxMessageData, result.message, result.signature);
          await promise;
        }
        return {
          address: result.address,
          chainId: result.chainId,
          accounts: result.accounts
        };
      },
      async addEmbeddedWalletSession(siwxMessageData, message, signature) {
        if (addEmbeddedWalletSessionPromise) {
          return addEmbeddedWalletSessionPromise;
        }
        const siwx = SIWXUtil.getSIWX();
        if (!siwx) {
          return Promise.resolve();
        }
        addEmbeddedWalletSessionPromise = siwx.addSession({
          data: siwxMessageData,
          message,
          signature
        }).finally(() => {
          addEmbeddedWalletSessionPromise = null;
        });
        return addEmbeddedWalletSessionPromise;
      },
      async universalProviderAuthenticate({ universalProvider, chains, methods }) {
        const siwx = SIWXUtil.getSIWX();
        const namespaces = new Set(chains.map((chain3) => chain3.split(":")[0]));
        if (!siwx || namespaces.size !== 1 || !namespaces.has("eip155")) {
          return false;
        }
        const siwxMessage = await siwx.createMessage({
          chainId: getActiveCaipNetwork()?.caipNetworkId || "",
          accountAddress: ""
        });
        const result = await universalProvider.authenticate({
          nonce: siwxMessage.nonce,
          domain: siwxMessage.domain,
          uri: siwxMessage.uri,
          exp: siwxMessage.expirationTime,
          iat: siwxMessage.issuedAt,
          nbf: siwxMessage.notBefore,
          requestId: siwxMessage.requestId,
          version: siwxMessage.version,
          resources: siwxMessage.resources,
          statement: siwxMessage.statement,
          chainId: siwxMessage.chainId,
          methods,
          // The first chainId is what is used for universal provider to build the message
          chains: [siwxMessage.chainId, ...chains.filter((chain3) => chain3 !== siwxMessage.chainId)]
        });
        SnackController.showLoading("Authenticating...", { autoClose: false });
        AccountController.setConnectedWalletInfo({
          ...result.session.peer.metadata,
          name: result.session.peer.metadata.name,
          icon: result.session.peer.metadata.icons?.[0],
          type: "WALLET_CONNECT"
        }, Array.from(namespaces)[0]);
        if (result?.auths?.length) {
          const sessions = result.auths.map((cacao) => {
            const message = universalProvider.client.formatAuthMessage({
              request: cacao.p,
              iss: cacao.p.iss
            });
            return {
              data: {
                ...cacao.p,
                accountAddress: cacao.p.iss.split(":").slice(-1).join(""),
                chainId: cacao.p.iss.split(":").slice(2, 4).join(":"),
                uri: cacao.p.aud,
                version: cacao.p.version || siwxMessage.version,
                expirationTime: cacao.p.exp,
                issuedAt: cacao.p.iat,
                notBefore: cacao.p.nbf
              },
              message,
              signature: cacao.s.s,
              cacao
            };
          });
          try {
            await siwx.setSessions(sessions);
            EventsController.sendEvent({
              type: "track",
              event: "SIWX_AUTH_SUCCESS",
              properties: SIWXUtil.getSIWXEventProperties()
            });
          } catch (error2) {
            console.error("SIWX:universalProviderAuth - failed to set sessions", error2);
            EventsController.sendEvent({
              type: "track",
              event: "SIWX_AUTH_ERROR",
              properties: SIWXUtil.getSIWXEventProperties()
            });
            await universalProvider.disconnect().catch(console.error);
            throw error2;
          } finally {
            SnackController.hide();
          }
        }
        return true;
      },
      getSIWXEventProperties() {
        const namespace = ChainController.state.activeChain;
        if (!namespace) {
          throw new Error("SIWXUtil:getSIWXEventProperties - namespace is required");
        }
        return {
          network: ChainController.state.activeCaipNetwork?.caipNetworkId || "",
          isSmartAccount: getPreferredAccountType(namespace) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        };
      },
      async clearSessions() {
        const siwx = this.getSIWX();
        if (siwx) {
          await siwx.setSessions([]);
        }
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/src/utils/ModalUtil.js
var ModalUtil;
var init_ModalUtil = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/src/utils/ModalUtil.js"() {
    init_ConnectionController();
    init_ModalController();
    init_RouterController();
    init_SIWXUtil();
    ModalUtil = {
      isUnsupportedChainView() {
        return RouterController.state.view === "UnsupportedChain" || RouterController.state.view === "SwitchNetwork" && RouterController.state.history.includes("UnsupportedChain");
      },
      async safeClose() {
        if (this.isUnsupportedChainView()) {
          ModalController.shake();
          return;
        }
        const isSIWXCloseDisabled = await SIWXUtil.isSIWXCloseDisabled();
        if (isSIWXCloseDisabled) {
          ModalController.shake();
          return;
        }
        if (RouterController.state.view === "DataCapture" || RouterController.state.view === "DataCaptureOtpConfirm") {
          ConnectionController.disconnect();
        }
        ModalController.close();
      }
    };
  }
});

// node_modules/@reown/appkit-controllers/dist/esm/exports/index.js
var init_exports = __esm({
  "node_modules/@reown/appkit-controllers/dist/esm/exports/index.js"() {
    init_ModalController();
    init_RouterController();
    init_AccountController();
    init_ChainController();
    init_OnRampController();
    init_ConnectionController();
    init_ConnectionControllerUtil();
    init_ConnectorController();
    init_SnackController();
    init_ApiController();
    init_AssetController();
    init_ThemeController();
    init_OptionsController();
    init_BlockchainApiController();
    init_PublicStateController();
    init_EventsController();
    init_SendController();
    init_TooltipController();
    init_EnsController();
    init_AlertController();
    init_AssetUtil();
    init_ConstantsUtil2();
    init_CoreHelperUtil();
    init_StorageUtil();
    init_SIWXUtil();
    init_ModalUtil();
    init_ChainControllerUtil();
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/ConstantsUtil.js
var ConstantsUtil3;
var init_ConstantsUtil3 = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/ConstantsUtil.js"() {
    init_esm8();
    ConstantsUtil3 = {
      METMASK_CONNECTOR_NAME: "MetaMask",
      TRUST_CONNECTOR_NAME: "Trust Wallet",
      SOLFLARE_CONNECTOR_NAME: "Solflare",
      PHANTOM_CONNECTOR_NAME: "Phantom",
      COIN98_CONNECTOR_NAME: "Coin98",
      MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
      BACKPACK_CONNECTOR_NAME: "Backpack",
      BITGET_CONNECTOR_NAME: "Bitget Wallet",
      FRONTIER_CONNECTOR_NAME: "Frontier",
      XVERSE_CONNECTOR_NAME: "Xverse Wallet",
      LEATHER_CONNECTOR_NAME: "Leather",
      EIP155: ConstantsUtil.CHAIN.EVM,
      ADD_CHAIN_METHOD: "wallet_addEthereumChain",
      EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
      EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
      CONNECTOR_RDNS_MAP: {
        coinbaseWallet: "com.coinbase.wallet",
        coinbaseWalletSDK: "com.coinbase.wallet"
      },
      CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
      CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
      CONNECTOR_TYPE_INJECTED: "INJECTED",
      CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
      CONNECTOR_TYPE_AUTH: "AUTH",
      CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
      CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH"
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js
var PresetsUtil;
var init_PresetsUtil = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js"() {
    init_esm8();
    init_ConstantsUtil3();
    PresetsUtil = {
      ConnectorExplorerIds: {
        [ConstantsUtil.CONNECTOR_ID.COINBASE]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
        [ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
        [ConstantsUtil.CONNECTOR_ID.SAFE]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
        [ConstantsUtil.CONNECTOR_ID.LEDGER]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
        [ConstantsUtil.CONNECTOR_ID.OKX]: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
        [ConstantsUtil3.METMASK_CONNECTOR_NAME]: "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
        [ConstantsUtil3.TRUST_CONNECTOR_NAME]: "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
        [ConstantsUtil3.SOLFLARE_CONNECTOR_NAME]: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
        [ConstantsUtil3.PHANTOM_CONNECTOR_NAME]: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
        [ConstantsUtil3.COIN98_CONNECTOR_NAME]: "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
        [ConstantsUtil3.MAGIC_EDEN_CONNECTOR_NAME]: "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
        [ConstantsUtil3.BACKPACK_CONNECTOR_NAME]: "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
        [ConstantsUtil3.BITGET_CONNECTOR_NAME]: "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
        [ConstantsUtil3.FRONTIER_CONNECTOR_NAME]: "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
        [ConstantsUtil3.XVERSE_CONNECTOR_NAME]: "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
        [ConstantsUtil3.LEATHER_CONNECTOR_NAME]: "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13"
      },
      NetworkImageIds: {
        1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
        42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
        43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
        56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
        250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
        10: "ab9c186a-c52f-464b-2906-ca59d760a400",
        137: "41d04d42-da3b-4453-8506-668cc0727900",
        5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
        295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
        11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
        84532: "a18a7ecd-e307-4360-4746-283182228e00",
        1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
        130: "2257980a-3463-48c6-cbac-a42d2a956e00",
        10143: "0a728e83-bacb-46db-7844-948f05434900",
        100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
        9001: "f926ff41-260d-4028-635e-91913fc28e00",
        324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
        314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
        4689: "34e68754-e536-40da-c153-6ef2e7188a00",
        1088: "3897a66d-40b9-4833-162f-a2c90531c900",
        1284: "161038da-44ae-4ec7-1208-0ea569454b00",
        1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
        7777777: "845c60df-d429-4991-e687-91ae45791600",
        42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
        8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
        1313161554: "3ff73439-a619-4894-9262-4470c773a100",
        2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
        2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
        80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
        2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
        "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
        "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
        EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
        "000000000019d6689c085ae165831e93": "0b4838db-0161-4ffe-022d-532bf03dba00",
        "000000000933ea01ad0ee984209779ba": "39354064-d79b-420b-065d-f980c4b78200"
      },
      ConnectorImageIds: {
        [ConstantsUtil.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
        [ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
        [ConstantsUtil.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
        [ConstantsUtil.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
        [ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
        [ConstantsUtil.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
      },
      ConnectorNamesMap: {
        [ConstantsUtil.CONNECTOR_ID.INJECTED]: "Browser Wallet",
        [ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
        [ConstantsUtil.CONNECTOR_ID.COINBASE]: "Coinbase",
        [ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
        [ConstantsUtil.CONNECTOR_ID.LEDGER]: "Ledger",
        [ConstantsUtil.CONNECTOR_ID.SAFE]: "Safe"
      },
      ConnectorTypesMap: {
        [ConstantsUtil.CONNECTOR_ID.INJECTED]: "INJECTED",
        [ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
        [ConstantsUtil.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
        [ConstantsUtil.CONNECTOR_ID.AUTH]: "AUTH",
        [ConstantsUtil3.CONNECTOR_TYPE_AUTH]: "AUTH"
      },
      WalletConnectRpcChainIds: [
        1,
        5,
        11155111,
        10,
        420,
        42161,
        421613,
        137,
        80001,
        42220,
        1313161554,
        1313161555,
        56,
        97,
        43114,
        43113,
        100,
        8453,
        84531,
        7777777,
        999,
        324,
        280
      ]
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/HelpersUtil.js
var HelpersUtil;
var init_HelpersUtil = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/HelpersUtil.js"() {
    init_esm8();
    init_exports();
    init_ConstantsUtil3();
    HelpersUtil = {
      getCaipTokens(tokens) {
        if (!tokens) {
          return void 0;
        }
        const caipTokens = {};
        Object.entries(tokens).forEach(([id, token]) => {
          caipTokens[`${ConstantsUtil3.EIP155}:${id}`] = token;
        });
        return caipTokens;
      },
      isLowerCaseMatch(str1, str2) {
        return str1?.toLowerCase() === str2?.toLowerCase();
      },
      getActiveNamespaceConnectedToAuth() {
        const activeChain = ChainController.state.activeChain;
        return ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((chain3) => ConnectorController.getConnectorId(chain3) === ConstantsUtil.CONNECTOR_ID.AUTH && chain3 === activeChain);
      },
      withRetry({ conditionFn, intervalMs, maxRetries }) {
        let attempts = 0;
        return new Promise((resolve) => {
          async function tryCheck() {
            attempts += 1;
            const result = await conditionFn();
            if (result) {
              return resolve(true);
            }
            if (attempts >= maxRetries) {
              return resolve(false);
            }
            setTimeout(tryCheck, intervalMs);
            return null;
          }
          tryCheck();
        });
      }
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/ErrorUtil.js
var abortController, ErrorUtil;
var init_ErrorUtil = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/ErrorUtil.js"() {
    init_esm8();
    abortController = new AbortController();
    ErrorUtil = {
      EmbeddedWalletAbortController: abortController,
      UniversalProviderErrors: {
        UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
          message: "Unauthorized: origin not allowed",
          alertErrorKey: "ORIGIN_NOT_ALLOWED"
        },
        JWT_VALIDATION_ERROR: {
          message: "JWT validation error: JWT Token is not yet valid",
          alertErrorKey: "JWT_TOKEN_NOT_VALID"
        },
        INVALID_KEY: {
          message: "Unauthorized: invalid key",
          alertErrorKey: "INVALID_PROJECT_ID"
        }
      },
      ALERT_ERRORS: {
        SWITCH_NETWORK_NOT_FOUND: {
          code: "APKT001",
          displayMessage: "Network Not Found",
          debugMessage: "The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration."
        },
        ORIGIN_NOT_ALLOWED: {
          code: "APKT002",
          displayMessage: "Invalid App Configuration",
          debugMessage: () => `The origin ${isSafe() ? window.origin : "unknown"} is not in your allow list. Please update your allowed domains at https://dashboard.reown.com.`
        },
        IFRAME_LOAD_FAILED: {
          code: "APKT003",
          displayMessage: "Network Error: Wallet Load Failed",
          debugMessage: () => "Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists."
        },
        IFRAME_REQUEST_TIMEOUT: {
          code: "APKT004",
          displayMessage: "Wallet Request Timeout",
          debugMessage: () => "The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists."
        },
        UNVERIFIED_DOMAIN: {
          code: "APKT005",
          displayMessage: "Unverified Domain",
          debugMessage: () => "Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com."
        },
        JWT_TOKEN_NOT_VALID: {
          code: "APKT006",
          displayMessage: "Session Expired",
          debugMessage: "Your session is invalid or expired. Please check your system\u2019s date and time settings, then reconnect."
        },
        INVALID_PROJECT_ID: {
          code: "APKT007",
          displayMessage: "Invalid Project ID",
          debugMessage: "The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID."
        },
        PROJECT_ID_NOT_CONFIGURED: {
          code: "APKT008",
          displayMessage: "Project ID Missing",
          debugMessage: "No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com."
        },
        SERVER_ERROR_APP_CONFIGURATION: {
          code: "APKT009",
          displayMessage: "Server Error",
          debugMessage: (errorMessage) => `Unable to fetch App Configuration. ${errorMessage}. Please check your network connection and try again shortly. Contact support if the issue persists.`
        },
        RATE_LIMITED_APP_CONFIGURATION: {
          code: "APKT010",
          displayMessage: "Rate Limited",
          debugMessage: "You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists."
        }
      },
      ALERT_WARNINGS: {
        LOCAL_CONFIGURATION_IGNORED: {
          debugMessage: (warningMessage) => `[Reown Config Notice] ${warningMessage}`
        }
      }
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/LoggerUtil.js
var LoggerUtil;
var init_LoggerUtil = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/LoggerUtil.js"() {
    init_index_es3();
    LoggerUtil = {
      createLogger(onError, level = "error") {
        const loggerOptions = k2({
          level
        });
        const { logger } = A({
          opts: loggerOptions
        });
        logger.error = (...args) => {
          for (const arg of args) {
            if (arg instanceof Error) {
              onError(arg, ...args);
              return;
            }
          }
          onError(void 0, ...args);
        };
        return logger;
      }
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/CaipNetworkUtil.js
function getBlockchainApiRpcUrl(caipNetworkId, projectId) {
  const url = new URL("https://rpc.walletconnect.org/v1/");
  url.searchParams.set("chainId", caipNetworkId);
  url.searchParams.set("projectId", projectId);
  return url.toString();
}
var RPC_URL_HOST, WC_HTTP_RPC_SUPPORTED_CHAINS, CaipNetworksUtil;
var init_CaipNetworkUtil = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/CaipNetworkUtil.js"() {
    init_esm9();
    init_esm8();
    init_exports();
    init_PresetsUtil();
    RPC_URL_HOST = "rpc.walletconnect.org";
    WC_HTTP_RPC_SUPPORTED_CHAINS = [
      "near:mainnet",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "eip155:1101",
      "eip155:56",
      "eip155:42161",
      "eip155:7777777",
      "eip155:59144",
      "eip155:324",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
      "eip155:5000",
      "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
      "eip155:80084",
      "eip155:5003",
      "eip155:100",
      "eip155:8453",
      "eip155:42220",
      "eip155:1313161555",
      "eip155:17000",
      "eip155:1",
      "eip155:300",
      "eip155:1313161554",
      "eip155:1329",
      "eip155:84532",
      "eip155:421614",
      "eip155:11155111",
      "eip155:8217",
      "eip155:43114",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "eip155:999999999",
      "eip155:11155420",
      "eip155:80002",
      "eip155:97",
      "eip155:43113",
      "eip155:137",
      "eip155:10",
      "eip155:1301",
      "bip122:000000000019d6689c085ae165831e93",
      "bip122:000000000933ea01ad0ee984209779ba"
    ];
    CaipNetworksUtil = {
      extendRpcUrlWithProjectId(rpcUrl, projectId) {
        let isReownUrl = false;
        try {
          const url = new URL(rpcUrl);
          isReownUrl = url.host === RPC_URL_HOST;
        } catch (e10) {
          isReownUrl = false;
        }
        if (isReownUrl) {
          const url = new URL(rpcUrl);
          if (!url.searchParams.has("projectId")) {
            url.searchParams.set("projectId", projectId);
          }
          return url.toString();
        }
        return rpcUrl;
      },
      isCaipNetwork(network) {
        return "chainNamespace" in network && "caipNetworkId" in network;
      },
      getChainNamespace(network) {
        if (this.isCaipNetwork(network)) {
          return network.chainNamespace;
        }
        return ConstantsUtil.CHAIN.EVM;
      },
      getCaipNetworkId(network) {
        if (this.isCaipNetwork(network)) {
          return network.caipNetworkId;
        }
        return `${ConstantsUtil.CHAIN.EVM}:${network.id}`;
      },
      getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId) {
        const defaultRpcUrl = caipNetwork.rpcUrls?.default?.http?.[0];
        if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetworkId)) {
          return getBlockchainApiRpcUrl(caipNetworkId, projectId);
        }
        return defaultRpcUrl || "";
      },
      extendCaipNetwork(caipNetwork, { customNetworkImageUrls, projectId, customRpcUrls }) {
        const chainNamespace = this.getChainNamespace(caipNetwork);
        const caipNetworkId = this.getCaipNetworkId(caipNetwork);
        const networkDefaultRpcUrl = caipNetwork.rpcUrls?.default?.http?.[0];
        const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId);
        const chainDefaultRpcUrl = caipNetwork?.rpcUrls?.["chainDefault"]?.http?.[0] || networkDefaultRpcUrl;
        const customRpcUrlsOfNetwork = customRpcUrls?.[caipNetworkId]?.map((i11) => i11.url) || [];
        const rpcUrls = [...customRpcUrlsOfNetwork, ...reownRpcUrl ? [reownRpcUrl] : []];
        const rpcUrlsWithoutReown = [...customRpcUrlsOfNetwork];
        if (chainDefaultRpcUrl && !rpcUrlsWithoutReown.includes(chainDefaultRpcUrl)) {
          rpcUrlsWithoutReown.push(chainDefaultRpcUrl);
        }
        return {
          ...caipNetwork,
          chainNamespace,
          caipNetworkId,
          assets: {
            imageId: PresetsUtil.NetworkImageIds[caipNetwork.id],
            imageUrl: customNetworkImageUrls?.[caipNetwork.id]
          },
          rpcUrls: {
            ...caipNetwork.rpcUrls,
            default: {
              http: rpcUrls
            },
            chainDefault: {
              http: rpcUrlsWithoutReown
            }
          }
        };
      },
      extendCaipNetworks(caipNetworks, { customNetworkImageUrls, projectId, customRpcUrls }) {
        return caipNetworks.map((caipNetwork) => CaipNetworksUtil.extendCaipNetwork(caipNetwork, {
          customNetworkImageUrls,
          customRpcUrls,
          projectId
        }));
      },
      getViemTransport(caipNetwork, projectId, customRpcUrls) {
        const transports = [];
        customRpcUrls?.forEach((rpcUrl) => {
          transports.push(http(rpcUrl.url, rpcUrl.config));
        });
        if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
          transports.push(http(getBlockchainApiRpcUrl(caipNetwork.caipNetworkId, projectId), {
            fetchOptions: {
              headers: {
                "Content-Type": "text/plain"
              }
            }
          }));
        }
        caipNetwork?.rpcUrls?.default?.http?.forEach((rpcUrl) => {
          transports.push(http(rpcUrl));
        });
        return fallback(transports);
      },
      extendWagmiTransports(caipNetwork, projectId, transport) {
        if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
          const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetwork.caipNetworkId, projectId);
          return fallback([transport, http(reownRpcUrl)]);
        }
        return transport;
      },
      getUnsupportedNetwork(caipNetworkId) {
        return {
          id: caipNetworkId.split(":")[1],
          caipNetworkId,
          name: ConstantsUtil.UNSUPPORTED_NETWORK_NAME,
          chainNamespace: caipNetworkId.split(":")[0],
          nativeCurrency: {
            name: "",
            decimals: 0,
            symbol: ""
          },
          rpcUrls: {
            default: {
              http: []
            }
          }
        };
      },
      getCaipNetworkFromStorage(defaultCaipNetwork) {
        const caipNetworkIdFromStorage = StorageUtil.getActiveCaipNetworkId();
        const caipNetworks = ChainController.getAllRequestedCaipNetworks();
        const availableNamespaces = Array.from(ChainController.state.chains?.keys() || []);
        const namespace = caipNetworkIdFromStorage?.split(":")[0];
        const isNamespaceAvailable = namespace ? availableNamespaces.includes(namespace) : false;
        const caipNetwork = caipNetworks?.find((cn3) => cn3.caipNetworkId === caipNetworkIdFromStorage);
        const isUnsupportedNetwork = isNamespaceAvailable && !caipNetwork && caipNetworkIdFromStorage;
        if (isUnsupportedNetwork) {
          return this.getUnsupportedNetwork(caipNetworkIdFromStorage);
        }
        if (caipNetwork) {
          return caipNetwork;
        }
        if (defaultCaipNetwork) {
          return defaultCaipNetwork;
        }
        return caipNetworks?.[0];
      }
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/src/ProviderUtil.js
var CLEAN_PROVIDERS_STATE, state23, ProviderUtil;
var init_ProviderUtil = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/src/ProviderUtil.js"() {
    init_vanilla();
    init_utils3();
    CLEAN_PROVIDERS_STATE = {
      eip155: void 0,
      solana: void 0,
      polkadot: void 0,
      bip122: void 0,
      cosmos: void 0,
      sui: void 0,
      stacks: void 0
    };
    state23 = proxy({
      providers: { ...CLEAN_PROVIDERS_STATE },
      providerIds: { ...CLEAN_PROVIDERS_STATE }
    });
    ProviderUtil = {
      state: state23,
      subscribeKey(key, callback) {
        return subscribeKey(state23, key, callback);
      },
      subscribe(callback) {
        return subscribe(state23, () => {
          callback(state23);
        });
      },
      subscribeProviders(callback) {
        return subscribe(state23.providers, () => callback(state23.providers));
      },
      setProvider(chainNamespace, provider) {
        if (chainNamespace && provider) {
          state23.providers[chainNamespace] = ref(provider);
        }
      },
      getProvider(chainNamespace) {
        if (!chainNamespace) {
          return void 0;
        }
        return state23.providers[chainNamespace];
      },
      setProviderId(chainNamespace, providerId) {
        if (providerId) {
          state23.providerIds[chainNamespace] = providerId;
        }
      },
      getProviderId(chainNamespace) {
        if (!chainNamespace) {
          return void 0;
        }
        return state23.providerIds[chainNamespace];
      },
      reset() {
        state23.providers = { ...CLEAN_PROVIDERS_STATE };
        state23.providerIds = { ...CLEAN_PROVIDERS_STATE };
      },
      resetChain(chainNamespace) {
        state23.providers[chainNamespace] = void 0;
        state23.providerIds[chainNamespace] = void 0;
      }
    };
  }
});

// node_modules/@reown/appkit-utils/dist/esm/exports/index.js
var init_exports2 = __esm({
  "node_modules/@reown/appkit-utils/dist/esm/exports/index.js"() {
    init_ConstantsUtil3();
    init_PresetsUtil();
    init_HelpersUtil();
    init_ErrorUtil();
    init_LoggerUtil();
    init_CaipNetworkUtil();
    init_ProviderUtil();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil4;
var init_ConstantsUtil4 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js"() {
    ConstantsUtil4 = {
      ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
      SECURE_SITE_ORIGIN: (typeof process !== "undefined" && typeof process.env !== "undefined" ? process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] : void 0) || "https://secure.walletconnect.org",
      VIEW_DIRECTION: {
        Next: "next",
        Prev: "prev"
      },
      DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
      ANIMATION_DURATIONS: {
        HeaderText: 120,
        ModalHeight: 150,
        ViewTransition: 150
      }
    };
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/WalletUtil.js
var WalletUtil;
var init_WalletUtil = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/WalletUtil.js"() {
    init_exports();
    init_exports2();
    init_ConnectorUtil();
    init_ConstantsUtil4();
    WalletUtil = {
      filterOutDuplicatesByRDNS(wallets) {
        const connectors = OptionsController.state.enableEIP6963 ? ConnectorController.state.connectors : [];
        const recent = StorageUtil.getRecentWallets();
        const connectorRDNSs = connectors.map((connector) => connector.info?.rdns).filter(Boolean);
        const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
        const allRDNSs = connectorRDNSs.concat(recentRDNSs);
        if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
          const index2 = allRDNSs.indexOf("io.metamask.mobile");
          allRDNSs[index2] = "io.metamask";
        }
        const filtered = wallets.filter((wallet) => {
          if (wallet?.rdns && allRDNSs.includes(String(wallet.rdns))) {
            return false;
          }
          if (!wallet?.rdns) {
            const hasMatchingConnectorName = connectors.some((connector) => connector.name === wallet.name);
            if (hasMatchingConnectorName) {
              return false;
            }
          }
          return true;
        });
        return filtered;
      },
      filterOutDuplicatesByIds(wallets) {
        const connectors = ConnectorController.state.connectors.filter((connector) => connector.type === "ANNOUNCED" || connector.type === "INJECTED");
        const recent = StorageUtil.getRecentWallets();
        const connectorIds = connectors.map((connector) => connector.explorerId);
        const recentIds = recent.map((wallet) => wallet.id);
        const allIds = connectorIds.concat(recentIds);
        const filtered = wallets.filter((wallet) => !allIds.includes(wallet?.id));
        return filtered;
      },
      filterOutDuplicateWallets(wallets) {
        const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
        const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
        return uniqueWallets;
      },
      markWalletsAsInstalled(wallets) {
        const { connectors } = ConnectorController.state;
        const { featuredWalletIds } = OptionsController.state;
        const installedWalletRdnsMap = connectors.filter((connector) => connector.type === "ANNOUNCED").reduce((rdnsMap, connector) => {
          if (!connector.info?.rdns) {
            return rdnsMap;
          }
          rdnsMap[connector.info.rdns] = true;
          return rdnsMap;
        }, {});
        const walletsWithInstallationStatus = wallets.map((wallet) => ({
          ...wallet,
          installed: Boolean(wallet.rdns) && Boolean(installedWalletRdnsMap[wallet.rdns ?? ""])
        }));
        const sortedWallets = walletsWithInstallationStatus.sort((walletA, walletB) => {
          const installationComparison = Number(walletB.installed) - Number(walletA.installed);
          if (installationComparison !== 0) {
            return installationComparison;
          }
          if (featuredWalletIds?.length) {
            const walletAFeaturedIndex = featuredWalletIds.indexOf(walletA.id);
            const walletBFeaturedIndex = featuredWalletIds.indexOf(walletB.id);
            if (walletAFeaturedIndex !== -1 && walletBFeaturedIndex !== -1) {
              return walletAFeaturedIndex - walletBFeaturedIndex;
            }
            if (walletAFeaturedIndex !== -1) {
              return -1;
            }
            if (walletBFeaturedIndex !== -1) {
              return 1;
            }
          }
          return 0;
        });
        return sortedWallets;
      },
      getConnectOrderMethod(_features, _connectors) {
        const connectMethodOrder = _features?.connectMethodsOrder || OptionsController.state.features?.connectMethodsOrder;
        const connectors = _connectors || ConnectorController.state.connectors;
        if (connectMethodOrder) {
          return connectMethodOrder;
        }
        const { injected, announced } = ConnectorUtil.getConnectorsByType(connectors, ApiController.state.recommended, ApiController.state.featured);
        const shownInjected = injected.filter(ConnectorUtil.showConnector);
        const shownAnnounced = announced.filter(ConnectorUtil.showConnector);
        if (shownInjected.length || shownAnnounced.length) {
          return ["wallet", "email", "social"];
        }
        return ConstantsUtil4.DEFAULT_CONNECT_METHOD_ORDER;
      },
      isExcluded(wallet) {
        const isRDNSExcluded = Boolean(wallet.rdns) && ApiController.state.excludedWallets.some((w6) => w6.rdns === wallet.rdns);
        const isNameExcluded = Boolean(wallet.name) && ApiController.state.excludedWallets.some((w6) => HelpersUtil.isLowerCaseMatch(w6.name, wallet.name));
        return isRDNSExcluded || isNameExcluded;
      },
      markWalletsWithDisplayIndex(wallets) {
        return wallets.map((w6, index2) => ({ ...w6, display_index: index2 }));
      }
    };
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConnectorUtil.js
var ConnectorUtil;
var init_ConnectorUtil = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConnectorUtil.js"() {
    init_esm8();
    init_exports();
    init_exports2();
    init_WalletUtil();
    ConnectorUtil = {
      getConnectorsByType(connectors, recommended, featured) {
        const { customWallets } = OptionsController.state;
        const recent = StorageUtil.getRecentWallets();
        const filteredRecommended = WalletUtil.filterOutDuplicateWallets(recommended);
        const filteredFeatured = WalletUtil.filterOutDuplicateWallets(featured);
        const multiChain = connectors.filter((connector) => connector.type === "MULTI_CHAIN");
        const announced = connectors.filter((connector) => connector.type === "ANNOUNCED");
        const injected = connectors.filter((connector) => connector.type === "INJECTED");
        const external = connectors.filter((connector) => connector.type === "EXTERNAL");
        return {
          custom: customWallets,
          recent,
          external,
          multiChain,
          announced,
          injected,
          recommended: filteredRecommended,
          featured: filteredFeatured
        };
      },
      showConnector(connector) {
        const rdns = connector.info?.rdns;
        const isRDNSExcluded = Boolean(rdns) && ApiController.state.excludedWallets.some((wallet) => Boolean(wallet.rdns) && wallet.rdns === rdns);
        const isNameExcluded = Boolean(connector.name) && ApiController.state.excludedWallets.some((wallet) => HelpersUtil.isLowerCaseMatch(wallet.name, connector.name));
        if (connector.type === "INJECTED") {
          const isBrowserWallet = connector.name === "Browser Wallet";
          if (isBrowserWallet) {
            if (!CoreHelperUtil.isMobile()) {
              return false;
            }
            if (CoreHelperUtil.isMobile() && !rdns && !ConnectionController.checkInstalled()) {
              return false;
            }
          }
          if (isRDNSExcluded || isNameExcluded) {
            return false;
          }
        }
        if ((connector.type === "ANNOUNCED" || connector.type === "EXTERNAL") && (isRDNSExcluded || isNameExcluded)) {
          return false;
        }
        return true;
      },
      getIsConnectedWithWC() {
        const chains = Array.from(ChainController.state.chains.values());
        const isConnectedWithWC = chains.some((chain3) => {
          const connectorId = ConnectorController.getConnectorId(chain3.namespace);
          return connectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
        });
        return isConnectedWithWC;
      },
      getConnectorTypeOrder({ recommended, featured, custom, recent, announced, injected, multiChain, external, overriddenConnectors = OptionsController.state.features?.connectorTypeOrder ?? [] }) {
        const isWCEnabled = OptionsController.state.enableWalletConnect;
        const allConnectors = [
          { type: "walletConnect", isEnabled: isWCEnabled },
          { type: "recent", isEnabled: recent.length > 0 },
          { type: "injected", isEnabled: [...injected, ...announced, ...multiChain].length > 0 },
          { type: "featured", isEnabled: featured.length > 0 },
          { type: "custom", isEnabled: custom && custom.length > 0 },
          { type: "external", isEnabled: external.length > 0 },
          { type: "recommended", isEnabled: recommended.length > 0 }
        ];
        const enabledConnectors = allConnectors.filter((option) => option.isEnabled);
        const enabledConnectorTypes = new Set(enabledConnectors.map((option) => option.type));
        const prioritizedConnectors = overriddenConnectors.filter((type) => enabledConnectorTypes.has(type)).map((type) => ({ type, isEnabled: true }));
        const remainingConnectors = enabledConnectors.filter(({ type: enabledConnectorType }) => {
          const hasPrioritizedConnector = prioritizedConnectors.some(({ type: prioritizedConnectorType }) => prioritizedConnectorType === enabledConnectorType);
          return !hasPrioritizedConnector;
        });
        return Array.from(new Set([...prioritizedConnectors, ...remainingConnectors].map(({ type }) => type)));
      },
      getAuthName({ email, socialUsername, socialProvider }) {
        if (socialUsername) {
          if (socialProvider && socialProvider === "discord" && socialUsername.endsWith("0")) {
            return socialUsername.slice(0, -1);
          }
          return socialUsername;
        }
        return email.length > 30 ? `${email.slice(0, -3)}...` : email;
      },
      async fetchProviderData(connector) {
        try {
          if (connector.name === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
            return { accounts: [], chainId: void 0 };
          }
          if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
            return { accounts: [], chainId: void 0 };
          }
          const [accounts, chainId] = await Promise.all([
            connector.provider?.request({ method: "eth_accounts" }),
            connector.provider?.request({ method: "eth_chainId" }).then((hexChainId) => Number(hexChainId))
          ]);
          return { accounts, chainId };
        } catch (err2) {
          console.warn(`Failed to fetch provider data for ${connector.name}`, err2);
          return { accounts: [], chainId: void 0 };
        }
      }
    };
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/MathUtil.js
var init_MathUtil = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/MathUtil.js"() {
  }
});

// node_modules/@lit/reactive-element/css-tag.js
var t, e2, s3, o5, n5, r3, i4, S5, c7;
var init_css_tag = __esm({
  "node_modules/@lit/reactive-element/css-tag.js"() {
    t = globalThis;
    e2 = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
    s3 = Symbol();
    o5 = /* @__PURE__ */ new WeakMap();
    n5 = class {
      constructor(t5, e10, o13) {
        if (this._$cssResult$ = true, o13 !== s3) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t5, this.t = e10;
      }
      get styleSheet() {
        let t5 = this.o;
        const s8 = this.t;
        if (e2 && void 0 === t5) {
          const e10 = void 0 !== s8 && 1 === s8.length;
          e10 && (t5 = o5.get(s8)), void 0 === t5 && ((this.o = t5 = new CSSStyleSheet()).replaceSync(this.cssText), e10 && o5.set(s8, t5));
        }
        return t5;
      }
      toString() {
        return this.cssText;
      }
    };
    r3 = (t5) => new n5("string" == typeof t5 ? t5 : t5 + "", void 0, s3);
    i4 = (t5, ...e10) => {
      const o13 = 1 === t5.length ? t5[0] : e10.reduce((e11, s8, o14) => e11 + ((t6) => {
        if (true === t6._$cssResult$) return t6.cssText;
        if ("number" == typeof t6) return t6;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + t6 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
      })(s8) + t5[o14 + 1], t5[0]);
      return new n5(o13, t5, s3);
    };
    S5 = (s8, o13) => {
      if (e2) s8.adoptedStyleSheets = o13.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet);
      else for (const e10 of o13) {
        const o14 = document.createElement("style"), n12 = t.litNonce;
        void 0 !== n12 && o14.setAttribute("nonce", n12), o14.textContent = e10.cssText, s8.appendChild(o14);
      }
    };
    c7 = e2 ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
      let e10 = "";
      for (const s8 of t6.cssRules) e10 += s8.cssText;
      return r3(e10);
    })(t5) : t5;
  }
});

// node_modules/@lit/reactive-element/reactive-element.js
var i5, e3, h7, r4, o6, n6, a3, c8, l8, p5, d5, u3, f9, b5, y6;
var init_reactive_element = __esm({
  "node_modules/@lit/reactive-element/reactive-element.js"() {
    init_css_tag();
    init_css_tag();
    ({ is: i5, defineProperty: e3, getOwnPropertyDescriptor: h7, getOwnPropertyNames: r4, getOwnPropertySymbols: o6, getPrototypeOf: n6 } = Object);
    a3 = globalThis;
    c8 = a3.trustedTypes;
    l8 = c8 ? c8.emptyScript : "";
    p5 = a3.reactiveElementPolyfillSupport;
    d5 = (t5, s8) => t5;
    u3 = { toAttribute(t5, s8) {
      switch (s8) {
        case Boolean:
          t5 = t5 ? l8 : null;
          break;
        case Object:
        case Array:
          t5 = null == t5 ? t5 : JSON.stringify(t5);
      }
      return t5;
    }, fromAttribute(t5, s8) {
      let i11 = t5;
      switch (s8) {
        case Boolean:
          i11 = null !== t5;
          break;
        case Number:
          i11 = null === t5 ? null : Number(t5);
          break;
        case Object:
        case Array:
          try {
            i11 = JSON.parse(t5);
          } catch (t6) {
            i11 = null;
          }
      }
      return i11;
    } };
    f9 = (t5, s8) => !i5(t5, s8);
    b5 = { attribute: true, type: String, converter: u3, reflect: false, useDefault: false, hasChanged: f9 };
    Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a3.litPropertyMetadata ?? (a3.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
    y6 = class extends HTMLElement {
      static addInitializer(t5) {
        this._$Ei(), (this.l ?? (this.l = [])).push(t5);
      }
      static get observedAttributes() {
        return this.finalize(), this._$Eh && [...this._$Eh.keys()];
      }
      static createProperty(t5, s8 = b5) {
        if (s8.state && (s8.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t5) && ((s8 = Object.create(s8)).wrapped = true), this.elementProperties.set(t5, s8), !s8.noAccessor) {
          const i11 = Symbol(), h12 = this.getPropertyDescriptor(t5, i11, s8);
          void 0 !== h12 && e3(this.prototype, t5, h12);
        }
      }
      static getPropertyDescriptor(t5, s8, i11) {
        const { get: e10, set: r9 } = h7(this.prototype, t5) ?? { get() {
          return this[s8];
        }, set(t6) {
          this[s8] = t6;
        } };
        return { get: e10, set(s9) {
          const h12 = e10?.call(this);
          r9?.call(this, s9), this.requestUpdate(t5, h12, i11);
        }, configurable: true, enumerable: true };
      }
      static getPropertyOptions(t5) {
        return this.elementProperties.get(t5) ?? b5;
      }
      static _$Ei() {
        if (this.hasOwnProperty(d5("elementProperties"))) return;
        const t5 = n6(this);
        t5.finalize(), void 0 !== t5.l && (this.l = [...t5.l]), this.elementProperties = new Map(t5.elementProperties);
      }
      static finalize() {
        if (this.hasOwnProperty(d5("finalized"))) return;
        if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d5("properties"))) {
          const t6 = this.properties, s8 = [...r4(t6), ...o6(t6)];
          for (const i11 of s8) this.createProperty(i11, t6[i11]);
        }
        const t5 = this[Symbol.metadata];
        if (null !== t5) {
          const s8 = litPropertyMetadata.get(t5);
          if (void 0 !== s8) for (const [t6, i11] of s8) this.elementProperties.set(t6, i11);
        }
        this._$Eh = /* @__PURE__ */ new Map();
        for (const [t6, s8] of this.elementProperties) {
          const i11 = this._$Eu(t6, s8);
          void 0 !== i11 && this._$Eh.set(i11, t6);
        }
        this.elementStyles = this.finalizeStyles(this.styles);
      }
      static finalizeStyles(s8) {
        const i11 = [];
        if (Array.isArray(s8)) {
          const e10 = new Set(s8.flat(1 / 0).reverse());
          for (const s9 of e10) i11.unshift(c7(s9));
        } else void 0 !== s8 && i11.push(c7(s8));
        return i11;
      }
      static _$Eu(t5, s8) {
        const i11 = s8.attribute;
        return false === i11 ? void 0 : "string" == typeof i11 ? i11 : "string" == typeof t5 ? t5.toLowerCase() : void 0;
      }
      constructor() {
        super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
      }
      _$Ev() {
        this._$ES = new Promise((t5) => this.enableUpdating = t5), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t5) => t5(this));
      }
      addController(t5) {
        (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t5), void 0 !== this.renderRoot && this.isConnected && t5.hostConnected?.();
      }
      removeController(t5) {
        this._$EO?.delete(t5);
      }
      _$E_() {
        const t5 = /* @__PURE__ */ new Map(), s8 = this.constructor.elementProperties;
        for (const i11 of s8.keys()) this.hasOwnProperty(i11) && (t5.set(i11, this[i11]), delete this[i11]);
        t5.size > 0 && (this._$Ep = t5);
      }
      createRenderRoot() {
        const t5 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S5(t5, this.constructor.elementStyles), t5;
      }
      connectedCallback() {
        this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$EO?.forEach((t5) => t5.hostConnected?.());
      }
      enableUpdating(t5) {
      }
      disconnectedCallback() {
        this._$EO?.forEach((t5) => t5.hostDisconnected?.());
      }
      attributeChangedCallback(t5, s8, i11) {
        this._$AK(t5, i11);
      }
      _$ET(t5, s8) {
        const i11 = this.constructor.elementProperties.get(t5), e10 = this.constructor._$Eu(t5, i11);
        if (void 0 !== e10 && true === i11.reflect) {
          const h12 = (void 0 !== i11.converter?.toAttribute ? i11.converter : u3).toAttribute(s8, i11.type);
          this._$Em = t5, null == h12 ? this.removeAttribute(e10) : this.setAttribute(e10, h12), this._$Em = null;
        }
      }
      _$AK(t5, s8) {
        const i11 = this.constructor, e10 = i11._$Eh.get(t5);
        if (void 0 !== e10 && this._$Em !== e10) {
          const t6 = i11.getPropertyOptions(e10), h12 = "function" == typeof t6.converter ? { fromAttribute: t6.converter } : void 0 !== t6.converter?.fromAttribute ? t6.converter : u3;
          this._$Em = e10;
          const r9 = h12.fromAttribute(s8, t6.type);
          this[e10] = r9 ?? this._$Ej?.get(e10) ?? r9, this._$Em = null;
        }
      }
      requestUpdate(t5, s8, i11) {
        if (void 0 !== t5) {
          const e10 = this.constructor, h12 = this[t5];
          if (i11 ?? (i11 = e10.getPropertyOptions(t5)), !((i11.hasChanged ?? f9)(h12, s8) || i11.useDefault && i11.reflect && h12 === this._$Ej?.get(t5) && !this.hasAttribute(e10._$Eu(t5, i11)))) return;
          this.C(t5, s8, i11);
        }
        false === this.isUpdatePending && (this._$ES = this._$EP());
      }
      C(t5, s8, { useDefault: i11, reflect: e10, wrapped: h12 }, r9) {
        i11 && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t5) && (this._$Ej.set(t5, r9 ?? s8 ?? this[t5]), true !== h12 || void 0 !== r9) || (this._$AL.has(t5) || (this.hasUpdated || i11 || (s8 = void 0), this._$AL.set(t5, s8)), true === e10 && this._$Em !== t5 && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t5));
      }
      async _$EP() {
        this.isUpdatePending = true;
        try {
          await this._$ES;
        } catch (t6) {
          Promise.reject(t6);
        }
        const t5 = this.scheduleUpdate();
        return null != t5 && await t5, !this.isUpdatePending;
      }
      scheduleUpdate() {
        return this.performUpdate();
      }
      performUpdate() {
        if (!this.isUpdatePending) return;
        if (!this.hasUpdated) {
          if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
            for (const [t7, s9] of this._$Ep) this[t7] = s9;
            this._$Ep = void 0;
          }
          const t6 = this.constructor.elementProperties;
          if (t6.size > 0) for (const [s9, i11] of t6) {
            const { wrapped: t7 } = i11, e10 = this[s9];
            true !== t7 || this._$AL.has(s9) || void 0 === e10 || this.C(s9, void 0, i11, e10);
          }
        }
        let t5 = false;
        const s8 = this._$AL;
        try {
          t5 = this.shouldUpdate(s8), t5 ? (this.willUpdate(s8), this._$EO?.forEach((t6) => t6.hostUpdate?.()), this.update(s8)) : this._$EM();
        } catch (s9) {
          throw t5 = false, this._$EM(), s9;
        }
        t5 && this._$AE(s8);
      }
      willUpdate(t5) {
      }
      _$AE(t5) {
        this._$EO?.forEach((t6) => t6.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
      }
      _$EM() {
        this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
      }
      get updateComplete() {
        return this.getUpdateComplete();
      }
      getUpdateComplete() {
        return this._$ES;
      }
      shouldUpdate(t5) {
        return true;
      }
      update(t5) {
        this._$Eq && (this._$Eq = this._$Eq.forEach((t6) => this._$ET(t6, this[t6]))), this._$EM();
      }
      updated(t5) {
      }
      firstUpdated(t5) {
      }
    };
    y6.elementStyles = [], y6.shadowRootOptions = { mode: "open" }, y6[d5("elementProperties")] = /* @__PURE__ */ new Map(), y6[d5("finalized")] = /* @__PURE__ */ new Map(), p5?.({ ReactiveElement: y6 }), (a3.reactiveElementVersions ?? (a3.reactiveElementVersions = [])).push("2.1.1");
  }
});

// node_modules/lit-html/lit-html.js
function P6(t5, i11) {
  if (!a4(t5) || !t5.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s4 ? s4.createHTML(i11) : i11;
}
function S6(t5, i11, s8 = t5, e10) {
  if (i11 === T5) return i11;
  let h12 = void 0 !== e10 ? s8._$Co?.[e10] : s8._$Cl;
  const o13 = c9(i11) ? void 0 : i11._$litDirective$;
  return h12?.constructor !== o13 && (h12?._$AO?.(false), void 0 === o13 ? h12 = void 0 : (h12 = new o13(t5), h12._$AT(t5, s8, e10)), void 0 !== e10 ? (s8._$Co ?? (s8._$Co = []))[e10] = h12 : s8._$Cl = h12), void 0 !== h12 && (i11 = S6(t5, h12._$AS(t5, i11.values), h12, e10)), i11;
}
var t2, i6, s4, e4, h8, o7, n7, r5, l9, c9, a4, u4, d6, f10, v6, _3, m4, p6, g4, $4, y7, x6, b6, w5, T5, E6, A5, C5, V4, N13, M5, R4, k6, H3, I5, L5, z4, Z3, j5, B4;
var init_lit_html = __esm({
  "node_modules/lit-html/lit-html.js"() {
    t2 = globalThis;
    i6 = t2.trustedTypes;
    s4 = i6 ? i6.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
    e4 = "$lit$";
    h8 = `lit$${Math.random().toFixed(9).slice(2)}$`;
    o7 = "?" + h8;
    n7 = `<${o7}>`;
    r5 = document;
    l9 = () => r5.createComment("");
    c9 = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
    a4 = Array.isArray;
    u4 = (t5) => a4(t5) || "function" == typeof t5?.[Symbol.iterator];
    d6 = "[ 	\n\f\r]";
    f10 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
    v6 = /-->/g;
    _3 = />/g;
    m4 = RegExp(`>|${d6}(?:([^\\s"'>=/]+)(${d6}*=${d6}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
    p6 = /'/g;
    g4 = /"/g;
    $4 = /^(?:script|style|textarea|title)$/i;
    y7 = (t5) => (i11, ...s8) => ({ _$litType$: t5, strings: i11, values: s8 });
    x6 = y7(1);
    b6 = y7(2);
    w5 = y7(3);
    T5 = Symbol.for("lit-noChange");
    E6 = Symbol.for("lit-nothing");
    A5 = /* @__PURE__ */ new WeakMap();
    C5 = r5.createTreeWalker(r5, 129);
    V4 = (t5, i11) => {
      const s8 = t5.length - 1, o13 = [];
      let r9, l10 = 2 === i11 ? "<svg>" : 3 === i11 ? "<math>" : "", c12 = f10;
      for (let i12 = 0; i12 < s8; i12++) {
        const s9 = t5[i12];
        let a5, u6, d7 = -1, y9 = 0;
        for (; y9 < s9.length && (c12.lastIndex = y9, u6 = c12.exec(s9), null !== u6); ) y9 = c12.lastIndex, c12 === f10 ? "!--" === u6[1] ? c12 = v6 : void 0 !== u6[1] ? c12 = _3 : void 0 !== u6[2] ? ($4.test(u6[2]) && (r9 = RegExp("</" + u6[2], "g")), c12 = m4) : void 0 !== u6[3] && (c12 = m4) : c12 === m4 ? ">" === u6[0] ? (c12 = r9 ?? f10, d7 = -1) : void 0 === u6[1] ? d7 = -2 : (d7 = c12.lastIndex - u6[2].length, a5 = u6[1], c12 = void 0 === u6[3] ? m4 : '"' === u6[3] ? g4 : p6) : c12 === g4 || c12 === p6 ? c12 = m4 : c12 === v6 || c12 === _3 ? c12 = f10 : (c12 = m4, r9 = void 0);
        const x7 = c12 === m4 && t5[i12 + 1].startsWith("/>") ? " " : "";
        l10 += c12 === f10 ? s9 + n7 : d7 >= 0 ? (o13.push(a5), s9.slice(0, d7) + e4 + s9.slice(d7) + h8 + x7) : s9 + h8 + (-2 === d7 ? i12 : x7);
      }
      return [P6(t5, l10 + (t5[s8] || "<?>") + (2 === i11 ? "</svg>" : 3 === i11 ? "</math>" : "")), o13];
    };
    N13 = class _N {
      constructor({ strings: t5, _$litType$: s8 }, n12) {
        let r9;
        this.parts = [];
        let c12 = 0, a5 = 0;
        const u6 = t5.length - 1, d7 = this.parts, [f13, v8] = V4(t5, s8);
        if (this.el = _N.createElement(f13, n12), C5.currentNode = this.el.content, 2 === s8 || 3 === s8) {
          const t6 = this.el.content.firstChild;
          t6.replaceWith(...t6.childNodes);
        }
        for (; null !== (r9 = C5.nextNode()) && d7.length < u6; ) {
          if (1 === r9.nodeType) {
            if (r9.hasAttributes()) for (const t6 of r9.getAttributeNames()) if (t6.endsWith(e4)) {
              const i11 = v8[a5++], s9 = r9.getAttribute(t6).split(h8), e10 = /([.?@])?(.*)/.exec(i11);
              d7.push({ type: 1, index: c12, name: e10[2], strings: s9, ctor: "." === e10[1] ? H3 : "?" === e10[1] ? I5 : "@" === e10[1] ? L5 : k6 }), r9.removeAttribute(t6);
            } else t6.startsWith(h8) && (d7.push({ type: 6, index: c12 }), r9.removeAttribute(t6));
            if ($4.test(r9.tagName)) {
              const t6 = r9.textContent.split(h8), s9 = t6.length - 1;
              if (s9 > 0) {
                r9.textContent = i6 ? i6.emptyScript : "";
                for (let i11 = 0; i11 < s9; i11++) r9.append(t6[i11], l9()), C5.nextNode(), d7.push({ type: 2, index: ++c12 });
                r9.append(t6[s9], l9());
              }
            }
          } else if (8 === r9.nodeType) if (r9.data === o7) d7.push({ type: 2, index: c12 });
          else {
            let t6 = -1;
            for (; -1 !== (t6 = r9.data.indexOf(h8, t6 + 1)); ) d7.push({ type: 7, index: c12 }), t6 += h8.length - 1;
          }
          c12++;
        }
      }
      static createElement(t5, i11) {
        const s8 = r5.createElement("template");
        return s8.innerHTML = t5, s8;
      }
    };
    M5 = class {
      constructor(t5, i11) {
        this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i11;
      }
      get parentNode() {
        return this._$AM.parentNode;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      u(t5) {
        const { el: { content: i11 }, parts: s8 } = this._$AD, e10 = (t5?.creationScope ?? r5).importNode(i11, true);
        C5.currentNode = e10;
        let h12 = C5.nextNode(), o13 = 0, n12 = 0, l10 = s8[0];
        for (; void 0 !== l10; ) {
          if (o13 === l10.index) {
            let i12;
            2 === l10.type ? i12 = new R4(h12, h12.nextSibling, this, t5) : 1 === l10.type ? i12 = new l10.ctor(h12, l10.name, l10.strings, this, t5) : 6 === l10.type && (i12 = new z4(h12, this, t5)), this._$AV.push(i12), l10 = s8[++n12];
          }
          o13 !== l10?.index && (h12 = C5.nextNode(), o13++);
        }
        return C5.currentNode = r5, e10;
      }
      p(t5) {
        let i11 = 0;
        for (const s8 of this._$AV) void 0 !== s8 && (void 0 !== s8.strings ? (s8._$AI(t5, s8, i11), i11 += s8.strings.length - 2) : s8._$AI(t5[i11])), i11++;
      }
    };
    R4 = class _R {
      get _$AU() {
        return this._$AM?._$AU ?? this._$Cv;
      }
      constructor(t5, i11, s8, e10) {
        this.type = 2, this._$AH = E6, this._$AN = void 0, this._$AA = t5, this._$AB = i11, this._$AM = s8, this.options = e10, this._$Cv = e10?.isConnected ?? true;
      }
      get parentNode() {
        let t5 = this._$AA.parentNode;
        const i11 = this._$AM;
        return void 0 !== i11 && 11 === t5?.nodeType && (t5 = i11.parentNode), t5;
      }
      get startNode() {
        return this._$AA;
      }
      get endNode() {
        return this._$AB;
      }
      _$AI(t5, i11 = this) {
        t5 = S6(this, t5, i11), c9(t5) ? t5 === E6 || null == t5 || "" === t5 ? (this._$AH !== E6 && this._$AR(), this._$AH = E6) : t5 !== this._$AH && t5 !== T5 && this._(t5) : void 0 !== t5._$litType$ ? this.$(t5) : void 0 !== t5.nodeType ? this.T(t5) : u4(t5) ? this.k(t5) : this._(t5);
      }
      O(t5) {
        return this._$AA.parentNode.insertBefore(t5, this._$AB);
      }
      T(t5) {
        this._$AH !== t5 && (this._$AR(), this._$AH = this.O(t5));
      }
      _(t5) {
        this._$AH !== E6 && c9(this._$AH) ? this._$AA.nextSibling.data = t5 : this.T(r5.createTextNode(t5)), this._$AH = t5;
      }
      $(t5) {
        const { values: i11, _$litType$: s8 } = t5, e10 = "number" == typeof s8 ? this._$AC(t5) : (void 0 === s8.el && (s8.el = N13.createElement(P6(s8.h, s8.h[0]), this.options)), s8);
        if (this._$AH?._$AD === e10) this._$AH.p(i11);
        else {
          const t6 = new M5(e10, this), s9 = t6.u(this.options);
          t6.p(i11), this.T(s9), this._$AH = t6;
        }
      }
      _$AC(t5) {
        let i11 = A5.get(t5.strings);
        return void 0 === i11 && A5.set(t5.strings, i11 = new N13(t5)), i11;
      }
      k(t5) {
        a4(this._$AH) || (this._$AH = [], this._$AR());
        const i11 = this._$AH;
        let s8, e10 = 0;
        for (const h12 of t5) e10 === i11.length ? i11.push(s8 = new _R(this.O(l9()), this.O(l9()), this, this.options)) : s8 = i11[e10], s8._$AI(h12), e10++;
        e10 < i11.length && (this._$AR(s8 && s8._$AB.nextSibling, e10), i11.length = e10);
      }
      _$AR(t5 = this._$AA.nextSibling, i11) {
        for (this._$AP?.(false, true, i11); t5 !== this._$AB; ) {
          const i12 = t5.nextSibling;
          t5.remove(), t5 = i12;
        }
      }
      setConnected(t5) {
        void 0 === this._$AM && (this._$Cv = t5, this._$AP?.(t5));
      }
    };
    k6 = class {
      get tagName() {
        return this.element.tagName;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      constructor(t5, i11, s8, e10, h12) {
        this.type = 1, this._$AH = E6, this._$AN = void 0, this.element = t5, this.name = i11, this._$AM = e10, this.options = h12, s8.length > 2 || "" !== s8[0] || "" !== s8[1] ? (this._$AH = Array(s8.length - 1).fill(new String()), this.strings = s8) : this._$AH = E6;
      }
      _$AI(t5, i11 = this, s8, e10) {
        const h12 = this.strings;
        let o13 = false;
        if (void 0 === h12) t5 = S6(this, t5, i11, 0), o13 = !c9(t5) || t5 !== this._$AH && t5 !== T5, o13 && (this._$AH = t5);
        else {
          const e11 = t5;
          let n12, r9;
          for (t5 = h12[0], n12 = 0; n12 < h12.length - 1; n12++) r9 = S6(this, e11[s8 + n12], i11, n12), r9 === T5 && (r9 = this._$AH[n12]), o13 || (o13 = !c9(r9) || r9 !== this._$AH[n12]), r9 === E6 ? t5 = E6 : t5 !== E6 && (t5 += (r9 ?? "") + h12[n12 + 1]), this._$AH[n12] = r9;
        }
        o13 && !e10 && this.j(t5);
      }
      j(t5) {
        t5 === E6 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 ?? "");
      }
    };
    H3 = class extends k6 {
      constructor() {
        super(...arguments), this.type = 3;
      }
      j(t5) {
        this.element[this.name] = t5 === E6 ? void 0 : t5;
      }
    };
    I5 = class extends k6 {
      constructor() {
        super(...arguments), this.type = 4;
      }
      j(t5) {
        this.element.toggleAttribute(this.name, !!t5 && t5 !== E6);
      }
    };
    L5 = class extends k6 {
      constructor(t5, i11, s8, e10, h12) {
        super(t5, i11, s8, e10, h12), this.type = 5;
      }
      _$AI(t5, i11 = this) {
        if ((t5 = S6(this, t5, i11, 0) ?? E6) === T5) return;
        const s8 = this._$AH, e10 = t5 === E6 && s8 !== E6 || t5.capture !== s8.capture || t5.once !== s8.once || t5.passive !== s8.passive, h12 = t5 !== E6 && (s8 === E6 || e10);
        e10 && this.element.removeEventListener(this.name, this, s8), h12 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
      }
      handleEvent(t5) {
        "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t5) : this._$AH.handleEvent(t5);
      }
    };
    z4 = class {
      constructor(t5, i11, s8) {
        this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i11, this.options = s8;
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AI(t5) {
        S6(this, t5);
      }
    };
    Z3 = { M: e4, P: h8, A: o7, C: 1, L: V4, R: M5, D: u4, V: S6, I: R4, H: k6, N: I5, U: L5, B: H3, F: z4 };
    j5 = t2.litHtmlPolyfillSupport;
    j5?.(N13, R4), (t2.litHtmlVersions ?? (t2.litHtmlVersions = [])).push("3.3.1");
    B4 = (t5, i11, s8) => {
      const e10 = s8?.renderBefore ?? i11;
      let h12 = e10._$litPart$;
      if (void 0 === h12) {
        const t6 = s8?.renderBefore ?? null;
        e10._$litPart$ = h12 = new R4(i11.insertBefore(l9(), t6), t6, void 0, s8 ?? {});
      }
      return h12._$AI(t5), h12;
    };
  }
});

// node_modules/lit-element/lit-element.js
var s5, i7, o8;
var init_lit_element = __esm({
  "node_modules/lit-element/lit-element.js"() {
    init_reactive_element();
    init_reactive_element();
    init_lit_html();
    init_lit_html();
    s5 = globalThis;
    i7 = class extends y6 {
      constructor() {
        super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
      }
      createRenderRoot() {
        var _a2;
        const t5 = super.createRenderRoot();
        return (_a2 = this.renderOptions).renderBefore ?? (_a2.renderBefore = t5.firstChild), t5;
      }
      update(t5) {
        const r9 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this._$Do = B4(r9, this.renderRoot, this.renderOptions);
      }
      connectedCallback() {
        super.connectedCallback(), this._$Do?.setConnected(true);
      }
      disconnectedCallback() {
        super.disconnectedCallback(), this._$Do?.setConnected(false);
      }
      render() {
        return T5;
      }
    };
    i7._$litElement$ = true, i7["finalized"] = true, s5.litElementHydrateSupport?.({ LitElement: i7 });
    o8 = s5.litElementPolyfillSupport;
    o8?.({ LitElement: i7 });
    (s5.litElementVersions ?? (s5.litElementVersions = [])).push("4.2.1");
  }
});

// node_modules/lit-html/is-server.js
var init_is_server = __esm({
  "node_modules/lit-html/is-server.js"() {
  }
});

// node_modules/lit/index.js
var init_lit = __esm({
  "node_modules/lit/index.js"() {
    init_reactive_element();
    init_lit_html();
    init_lit_element();
    init_is_server();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeUtil.js
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(themeVariables) {
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  }
}
function createRootStyles(themeVariables) {
  return {
    core: i4`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${r3(themeVariables?.["--w3m-color-mix-strength"] ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r3(themeVariables?.["--w3m-font-family"] || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r3(themeVariables?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${r3(themeVariables?.["--w3m-border-radius-master"] || "4px")};
        --w3m-z-index: ${r3(themeVariables?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: i4`
      :root {
        --w3m-color-mix: ${r3(themeVariables?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${r3(getW3mThemeVariables(themeVariables, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${r3(getW3mThemeVariables(themeVariables, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: i4`
      :root {
        --w3m-color-mix: ${r3(themeVariables?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${r3(getW3mThemeVariables(themeVariables, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${r3(getW3mThemeVariables(themeVariables, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `
  };
}
var themeTag, darkModeTag, lightModeTag, resetStyles, elementStyles, colorStyles;
var init_ThemeUtil2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/ThemeUtil.js"() {
    init_lit();
    init_esm8();
    themeTag = void 0;
    darkModeTag = void 0;
    lightModeTag = void 0;
    resetStyles = i4`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
    elementStyles = i4`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
    colorStyles = i4`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/UiHelperUtil.js
var UiHelperUtil;
var init_UiHelperUtil = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/UiHelperUtil.js"() {
    UiHelperUtil = {
      getSpacingStyles(spacing, index2) {
        if (Array.isArray(spacing)) {
          return spacing[index2] ? `var(--wui-spacing-${spacing[index2]})` : void 0;
        } else if (typeof spacing === "string") {
          return `var(--wui-spacing-${spacing})`;
        }
        return void 0;
      },
      getFormattedDate(date) {
        return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
      },
      getHostName(url) {
        try {
          const newUrl = new URL(url);
          return newUrl.hostname;
        } catch (error2) {
          return "";
        }
      },
      getTruncateString({ string: string2, charsStart, charsEnd, truncate }) {
        if (string2.length <= charsStart + charsEnd) {
          return string2;
        }
        if (truncate === "end") {
          return `${string2.substring(0, charsStart)}...`;
        } else if (truncate === "start") {
          return `...${string2.substring(string2.length - charsEnd)}`;
        }
        return `${string2.substring(0, Math.floor(charsStart))}...${string2.substring(string2.length - Math.floor(charsEnd))}`;
      },
      generateAvatarColors(address2) {
        const hash2 = address2.toLowerCase().replace(/^0x/iu, "").replace(/[^a-f0-9]/gu, "");
        const baseColor = hash2.substring(0, 6).padEnd(6, "0");
        const rgbColor = this.hexToRgb(baseColor);
        const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
        const radius = Number(masterBorderRadius?.replace("px", ""));
        const edge = 100 - 3 * radius;
        const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
        const colors = [];
        for (let i11 = 0; i11 < 5; i11 += 1) {
          const tintedColor = this.tintColor(rgbColor, 0.15 * i11);
          colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
        }
        return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
      },
      hexToRgb(hex) {
        const bigint = parseInt(hex, 16);
        const r9 = bigint >> 16 & 255;
        const g5 = bigint >> 8 & 255;
        const b7 = bigint & 255;
        return [r9, g5, b7];
      },
      tintColor(rgb, tint) {
        const [r9, g5, b7] = rgb;
        const tintedR = Math.round(r9 + (255 - r9) * tint);
        const tintedG = Math.round(g5 + (255 - g5) * tint);
        const tintedB = Math.round(b7 + (255 - b7) * tint);
        return [tintedR, tintedG, tintedB];
      },
      isNumber(character) {
        const regex2 = {
          number: /^[0-9]+$/u
        };
        return regex2.number.test(character);
      },
      getColorTheme(theme) {
        if (theme) {
          return theme;
        } else if (typeof window !== "undefined" && window.matchMedia && typeof window.matchMedia === "function") {
          if (window.matchMedia("(prefers-color-scheme: dark)")?.matches) {
            return "dark";
          }
          return "light";
        }
        return "dark";
      },
      splitBalance(input) {
        const parts = input.split(".");
        if (parts.length === 2) {
          return [parts[0], parts[1]];
        }
        return ["0", "00"];
      },
      roundNumber(number2, threshold, fixed) {
        const roundedNumber = number2.toString().length >= threshold ? Number(number2).toFixed(fixed) : number2;
        return roundedNumber;
      },
      formatNumberToLocalString(value, decimals = 2) {
        if (value === void 0) {
          return "0.00";
        }
        if (typeof value === "number") {
          return value.toLocaleString("en-US", {
            maximumFractionDigits: decimals,
            minimumFractionDigits: decimals
          });
        }
        return parseFloat(value).toLocaleString("en-US", {
          maximumFractionDigits: decimals,
          minimumFractionDigits: decimals
        });
      }
    };
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/TransactionUtil.js
var init_TransactionUtil = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/TransactionUtil.js"() {
    init_UiHelperUtil();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/WebComponentsUtil.js
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create2(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}
var init_WebComponentsUtil = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/WebComponentsUtil.js"() {
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/index.js
var init_exports3 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/index.js"() {
    init_MathUtil();
    init_ThemeUtil2();
    init_UiHelperUtil();
    init_TransactionUtil();
    init_WebComponentsUtil();
  }
});

// node_modules/@lit/reactive-element/decorators/custom-element.js
var init_custom_element = __esm({
  "node_modules/@lit/reactive-element/decorators/custom-element.js"() {
  }
});

// node_modules/@lit/reactive-element/decorators/property.js
function n8(t5) {
  return (e10, o13) => "object" == typeof o13 ? r6(t5, e10, o13) : ((t6, e11, o14) => {
    const r9 = e11.hasOwnProperty(o14);
    return e11.constructor.createProperty(o14, t6), r9 ? Object.getOwnPropertyDescriptor(e11, o14) : void 0;
  })(t5, e10, o13);
}
var o9, r6;
var init_property = __esm({
  "node_modules/@lit/reactive-element/decorators/property.js"() {
    init_reactive_element();
    o9 = { attribute: true, type: String, converter: u3, reflect: false, hasChanged: f9 };
    r6 = (t5 = o9, e10, r9) => {
      const { kind: n12, metadata: i11 } = r9;
      let s8 = globalThis.litPropertyMetadata.get(i11);
      if (void 0 === s8 && globalThis.litPropertyMetadata.set(i11, s8 = /* @__PURE__ */ new Map()), "setter" === n12 && ((t5 = Object.create(t5)).wrapped = true), s8.set(r9.name, t5), "accessor" === n12) {
        const { name: o13 } = r9;
        return { set(r10) {
          const n13 = e10.get.call(this);
          e10.set.call(this, r10), this.requestUpdate(o13, n13, t5);
        }, init(e11) {
          return void 0 !== e11 && this.C(o13, void 0, t5, e11), e11;
        } };
      }
      if ("setter" === n12) {
        const { name: o13 } = r9;
        return function(r10) {
          const n13 = this[o13];
          e10.call(this, r10), this.requestUpdate(o13, n13, t5);
        };
      }
      throw Error("Unsupported decorator location: " + n12);
    };
  }
});

// node_modules/@lit/reactive-element/decorators/state.js
function r7(r9) {
  return n8({ ...r9, state: true, attribute: false });
}
var init_state = __esm({
  "node_modules/@lit/reactive-element/decorators/state.js"() {
    init_property();
  }
});

// node_modules/@lit/reactive-element/decorators/event-options.js
var init_event_options = __esm({
  "node_modules/@lit/reactive-element/decorators/event-options.js"() {
  }
});

// node_modules/@lit/reactive-element/decorators/base.js
var init_base4 = __esm({
  "node_modules/@lit/reactive-element/decorators/base.js"() {
  }
});

// node_modules/@lit/reactive-element/decorators/query.js
var init_query = __esm({
  "node_modules/@lit/reactive-element/decorators/query.js"() {
    init_base4();
  }
});

// node_modules/@lit/reactive-element/decorators/query-all.js
var init_query_all = __esm({
  "node_modules/@lit/reactive-element/decorators/query-all.js"() {
    init_base4();
  }
});

// node_modules/@lit/reactive-element/decorators/query-async.js
var init_query_async = __esm({
  "node_modules/@lit/reactive-element/decorators/query-async.js"() {
    init_base4();
  }
});

// node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
var init_query_assigned_elements = __esm({
  "node_modules/@lit/reactive-element/decorators/query-assigned-elements.js"() {
    init_base4();
  }
});

// node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js
var init_query_assigned_nodes = __esm({
  "node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js"() {
    init_base4();
  }
});

// node_modules/lit/decorators.js
var init_decorators = __esm({
  "node_modules/lit/decorators.js"() {
    init_custom_element();
    init_property();
    init_state();
    init_event_options();
    init_query();
    init_query_all();
    init_query_async();
    init_query_assigned_elements();
    init_query_assigned_nodes();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-flex/styles.js
var styles_default;
var init_styles = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-flex/styles.js"() {
    init_lit();
    styles_default = i4`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-flex/index.js
var __decorate2, WuiFlex;
var init_wui_flex = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-flex/index.js"() {
    init_lit();
    init_decorators();
    init_ThemeUtil2();
    init_UiHelperUtil();
    init_WebComponentsUtil();
    init_styles();
    __decorate2 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiFlex = class WuiFlex2 extends i7 {
      render() {
        this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
        return x6`<slot></slot>`;
      }
    };
    WuiFlex.styles = [resetStyles, styles_default];
    __decorate2([
      n8()
    ], WuiFlex.prototype, "flexDirection", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "flexWrap", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "flexBasis", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "flexGrow", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "flexShrink", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "alignItems", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "justifyContent", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "columnGap", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "rowGap", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "gap", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "padding", void 0);
    __decorate2([
      n8()
    ], WuiFlex.prototype, "margin", void 0);
    WuiFlex = __decorate2([
      customElement("wui-flex")
    ], WuiFlex);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-flex.js
var init_wui_flex2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-flex.js"() {
    init_wui_flex();
  }
});

// node_modules/lit-html/directives/if-defined.js
var o10;
var init_if_defined = __esm({
  "node_modules/lit-html/directives/if-defined.js"() {
    init_lit_html();
    o10 = (o13) => o13 ?? E6;
  }
});

// node_modules/lit/directives/if-defined.js
var init_if_defined2 = __esm({
  "node_modules/lit/directives/if-defined.js"() {
    init_if_defined();
  }
});

// node_modules/lit-html/directive-helpers.js
var t3, i8, f11;
var init_directive_helpers = __esm({
  "node_modules/lit-html/directive-helpers.js"() {
    init_lit_html();
    ({ I: t3 } = Z3);
    i8 = (o13) => null === o13 || "object" != typeof o13 && "function" != typeof o13;
    f11 = (o13) => void 0 === o13.strings;
  }
});

// node_modules/lit-html/directive.js
var t4, e6, i9;
var init_directive = __esm({
  "node_modules/lit-html/directive.js"() {
    t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
    e6 = (t5) => (...e10) => ({ _$litDirective$: t5, values: e10 });
    i9 = class {
      constructor(t5) {
      }
      get _$AU() {
        return this._$AM._$AU;
      }
      _$AT(t5, e10, i11) {
        this._$Ct = t5, this._$AM = e10, this._$Ci = i11;
      }
      _$AS(t5, e10) {
        return this.update(t5, e10);
      }
      update(t5, e10) {
        return this.render(...e10);
      }
    };
  }
});

// node_modules/lit-html/async-directive.js
function h9(i11) {
  void 0 !== this._$AN ? (o11(this), this._$AM = i11, r8(this)) : this._$AM = i11;
}
function n9(i11, t5 = false, e10 = 0) {
  const r9 = this._$AH, h12 = this._$AN;
  if (void 0 !== h12 && 0 !== h12.size) if (t5) if (Array.isArray(r9)) for (let i12 = e10; i12 < r9.length; i12++) s6(r9[i12], false), o11(r9[i12]);
  else null != r9 && (s6(r9, false), o11(r9));
  else s6(this, i11);
}
var s6, o11, r8, c10, f12;
var init_async_directive = __esm({
  "node_modules/lit-html/async-directive.js"() {
    init_directive_helpers();
    init_directive();
    init_directive();
    s6 = (i11, t5) => {
      const e10 = i11._$AN;
      if (void 0 === e10) return false;
      for (const i12 of e10) i12._$AO?.(t5, false), s6(i12, t5);
      return true;
    };
    o11 = (i11) => {
      let t5, e10;
      do {
        if (void 0 === (t5 = i11._$AM)) break;
        e10 = t5._$AN, e10.delete(i11), i11 = t5;
      } while (0 === e10?.size);
    };
    r8 = (i11) => {
      for (let t5; t5 = i11._$AM; i11 = t5) {
        let e10 = t5._$AN;
        if (void 0 === e10) t5._$AN = e10 = /* @__PURE__ */ new Set();
        else if (e10.has(i11)) break;
        e10.add(i11), c10(t5);
      }
    };
    c10 = (i11) => {
      i11.type == t4.CHILD && (i11._$AP ?? (i11._$AP = n9), i11._$AQ ?? (i11._$AQ = h9));
    };
    f12 = class extends i9 {
      constructor() {
        super(...arguments), this._$AN = void 0;
      }
      _$AT(i11, t5, e10) {
        super._$AT(i11, t5, e10), r8(this), this.isConnected = i11._$AU;
      }
      _$AO(i11, t5 = true) {
        i11 !== this.isConnected && (this.isConnected = i11, i11 ? this.reconnected?.() : this.disconnected?.()), t5 && (s6(this, i11), o11(this));
      }
      setValue(t5) {
        if (f11(this._$Ct)) this._$Ct._$AI(t5, this);
        else {
          const i11 = [...this._$Ct._$AH];
          i11[this._$Ci] = t5, this._$Ct._$AI(i11, this, 0);
        }
      }
      disconnected() {
      }
      reconnected() {
      }
    };
  }
});

// node_modules/lit-html/directives/private-async-helpers.js
var s7, i10;
var init_private_async_helpers = __esm({
  "node_modules/lit-html/directives/private-async-helpers.js"() {
    s7 = class {
      constructor(t5) {
        this.G = t5;
      }
      disconnect() {
        this.G = void 0;
      }
      reconnect(t5) {
        this.G = t5;
      }
      deref() {
        return this.G;
      }
    };
    i10 = class {
      constructor() {
        this.Y = void 0, this.Z = void 0;
      }
      get() {
        return this.Y;
      }
      pause() {
        this.Y ?? (this.Y = new Promise((t5) => this.Z = t5));
      }
      resume() {
        this.Z?.(), this.Y = this.Z = void 0;
      }
    };
  }
});

// node_modules/lit-html/directives/until.js
var n10, h10, c11, m5;
var init_until = __esm({
  "node_modules/lit-html/directives/until.js"() {
    init_lit_html();
    init_directive_helpers();
    init_async_directive();
    init_private_async_helpers();
    init_directive();
    n10 = (t5) => !i8(t5) && "function" == typeof t5.then;
    h10 = 1073741823;
    c11 = class extends f12 {
      constructor() {
        super(...arguments), this._$Cwt = h10, this._$Cbt = [], this._$CK = new s7(this), this._$CX = new i10();
      }
      render(...s8) {
        return s8.find((t5) => !n10(t5)) ?? T5;
      }
      update(s8, i11) {
        const e10 = this._$Cbt;
        let r9 = e10.length;
        this._$Cbt = i11;
        const o13 = this._$CK, c12 = this._$CX;
        this.isConnected || this.disconnected();
        for (let t5 = 0; t5 < i11.length && !(t5 > this._$Cwt); t5++) {
          const s9 = i11[t5];
          if (!n10(s9)) return this._$Cwt = t5, s9;
          t5 < r9 && s9 === e10[t5] || (this._$Cwt = h10, r9 = 0, Promise.resolve(s9).then(async (t6) => {
            for (; c12.get(); ) await c12.get();
            const i12 = o13.deref();
            if (void 0 !== i12) {
              const e11 = i12._$Cbt.indexOf(s9);
              e11 > -1 && e11 < i12._$Cwt && (i12._$Cwt = e11, i12.setValue(t6));
            }
          }));
        }
        return T5;
      }
      disconnected() {
        this._$CK.disconnect(), this._$CX.pause();
      }
      reconnected() {
        this._$CK.reconnect(this), this._$CX.resume();
      }
    };
    m5 = e6(c11);
  }
});

// node_modules/lit/directives/until.js
var init_until2 = __esm({
  "node_modules/lit/directives/until.js"() {
    init_until();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/CacheUtil.js
var CacheUtil, globalSvgCache;
var init_CacheUtil = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/CacheUtil.js"() {
    CacheUtil = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      set(key, value) {
        this.cache.set(key, value);
      }
      get(key) {
        return this.cache.get(key);
      }
      has(key) {
        return this.cache.has(key);
      }
      delete(key) {
        this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
      }
    };
    globalSvgCache = new CacheUtil();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-icon/styles.js
var styles_default2;
var init_styles2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-icon/styles.js"() {
    init_lit();
    styles_default2 = i4`
  :host {
    display: flex;
    aspect-ratio: var(--local-aspect-ratio);
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }

  .fallback {
    width: var(--local-width);
    height: var(--local-height);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/add.js
var add_exports = {};
__export(add_exports, {
  addSvg: () => addSvg
});
var addSvg;
var init_add = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/add.js"() {
    init_lit();
    addSvg = b6`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#667dff"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/all-wallets.js
var all_wallets_exports = {};
__export(all_wallets_exports, {
  allWalletsSvg: () => allWalletsSvg
});
var allWalletsSvg;
var init_all_wallets = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/all-wallets.js"() {
    init_lit();
    allWalletsSvg = b6`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-bottom-circle.js
var arrow_bottom_circle_exports = {};
__export(arrow_bottom_circle_exports, {
  arrowBottomCircleSvg: () => arrowBottomCircleSvg
});
var arrowBottomCircleSvg;
var init_arrow_bottom_circle = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-bottom-circle.js"() {
    init_lit();
    arrowBottomCircleSvg = b6`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/app-store.js
var app_store_exports = {};
__export(app_store_exports, {
  appStoreSvg: () => appStoreSvg
});
var appStoreSvg;
var init_app_store = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/app-store.js"() {
    init_lit();
    appStoreSvg = b6`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/apple.js
var apple_exports = {};
__export(apple_exports, {
  appleSvg: () => appleSvg
});
var appleSvg;
var init_apple = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/apple.js"() {
    init_lit();
    appleSvg = b6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-bottom.js
var arrow_bottom_exports = {};
__export(arrow_bottom_exports, {
  arrowBottomSvg: () => arrowBottomSvg
});
var arrowBottomSvg;
var init_arrow_bottom = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-bottom.js"() {
    init_lit();
    arrowBottomSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-left.js
var arrow_left_exports = {};
__export(arrow_left_exports, {
  arrowLeftSvg: () => arrowLeftSvg
});
var arrowLeftSvg;
var init_arrow_left = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-left.js"() {
    init_lit();
    arrowLeftSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-right.js
var arrow_right_exports = {};
__export(arrow_right_exports, {
  arrowRightSvg: () => arrowRightSvg
});
var arrowRightSvg;
var init_arrow_right = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-right.js"() {
    init_lit();
    arrowRightSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-top.js
var arrow_top_exports = {};
__export(arrow_top_exports, {
  arrowTopSvg: () => arrowTopSvg
});
var arrowTopSvg;
var init_arrow_top = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/arrow-top.js"() {
    init_lit();
    arrowTopSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/bank.js
var bank_exports = {};
__export(bank_exports, {
  bankSvg: () => bankSvg
});
var bankSvg;
var init_bank = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/bank.js"() {
    init_lit();
    bankSvg = b6`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/browser.js
var browser_exports = {};
__export(browser_exports, {
  browserSvg: () => browserSvg
});
var browserSvg;
var init_browser = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/browser.js"() {
    init_lit();
    browserSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/bin.js
var bin_exports = {};
__export(bin_exports, {
  binSvg: () => binSvg
});
var binSvg;
var init_bin = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/bin.js"() {
    init_lit();
    binSvg = b6`<svg viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.90029 1.71429C4.09883 0.736183 4.96358 0 6.00028 0C7.03698 0 7.90173 0.736183 8.10027 1.71429H9.41533C9.42361 1.71417 9.4319 1.71417 9.44022 1.71429H10.286C10.7594 1.71429 11.1431 2.09804 11.1431 2.57143C11.1431 3.04482 10.7594 3.42857 10.286 3.42857H10.1855L9.73675 7.01877C9.6785 7.48493 9.6279 7.88983 9.55601 8.22075C9.47948 8.57304 9.36472 8.91574 9.13613 9.22925C8.91553 9.53181 8.63151 9.78254 8.30392 9.96392C7.96448 10.1519 7.61019 10.2232 7.25112 10.2555C6.91385 10.2858 6.50581 10.2857 6.03603 10.2857H5.96453C5.49475 10.2857 5.08671 10.2858 4.74944 10.2555C4.39037 10.2232 4.03608 10.1519 3.69664 9.96392C3.36905 9.78254 3.08503 9.53181 2.86442 9.22925C2.63583 8.91574 2.52108 8.57304 2.44455 8.22075C2.37266 7.88984 2.32206 7.48496 2.26382 7.0188L1.81504 3.42857H1.71456C1.24118 3.42857 0.857422 3.04482 0.857422 2.57143C0.857422 2.09804 1.24118 1.71429 1.71456 1.71429H2.56034C2.56866 1.71417 2.57695 1.71417 2.58522 1.71429H3.90029ZM3.54266 3.42857L3.96043 6.77068C4.02441 7.2825 4.06617 7.61016 4.11976 7.85681C4.17051 8.09045 4.21726 8.17492 4.2496 8.21928C4.32314 8.32013 4.41781 8.4037 4.52701 8.46416C4.57504 8.49076 4.66465 8.52666 4.90278 8.54805C5.15417 8.57063 5.48448 8.57143 6.00028 8.57143C6.51608 8.57143 6.84638 8.57063 7.09778 8.54805C7.33591 8.52666 7.42552 8.49076 7.47355 8.46416C7.58275 8.4037 7.67742 8.32013 7.75096 8.21928C7.7833 8.17491 7.83005 8.09045 7.8808 7.85681C7.93439 7.61016 7.97615 7.2825 8.04013 6.77068L8.4579 3.42857H3.54266Z" fill="currentColor"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/bitcoin.js
var bitcoin_exports = {};
__export(bitcoin_exports, {
  bitcoinSvg: () => bitcoinSvg
});
var bitcoinSvg;
var init_bitcoin = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/bitcoin.js"() {
    init_lit();
    bitcoinSvg = b6`
<svg width="13" height="12" viewBox="0 0 13 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_24458_3947)">
<path d="M12.6542 7.45143C11.8528 10.6657 8.59691 12.6219 5.38191 11.8204C2.16827 11.019 0.211924 7.76324 1.01369 4.54918C1.81476 1.33451 5.07063 -0.621803 8.28463 0.17954C11.4994 0.980884 13.4556 4.23702 12.6541 7.45149L12.6542 7.45143H12.6542Z" fill="var(--wui-color-gray-glass-005)"/>
<path d="M9.48002 5.14517C9.59946 4.3467 8.9915 3.91749 8.16017 3.63117L8.42986 2.54957L7.7714 2.38551L7.50886 3.43863C7.33576 3.39546 7.15799 3.35479 6.9813 3.31446L7.24574 2.25439L6.58769 2.09033L6.31786 3.17158C6.17461 3.13896 6.03391 3.10673 5.89741 3.07277L5.89817 3.06937L4.99014 2.84264L4.81498 3.54585C4.81498 3.54585 5.3035 3.65783 5.29321 3.66472C5.55985 3.73126 5.60807 3.90775 5.60006 4.04765L5.29286 5.27984C5.31122 5.2845 5.33503 5.29125 5.36131 5.3018C5.33935 5.29635 5.31597 5.2904 5.29171 5.28459L4.86112 7.01072C4.82853 7.09172 4.74582 7.21328 4.5594 7.16712C4.566 7.17668 4.08082 7.0477 4.08082 7.0477L3.75391 7.80135L4.61079 8.01495C4.77019 8.05492 4.92641 8.09674 5.08024 8.13607L4.80777 9.23007L5.46547 9.39413L5.7353 8.31174C5.91498 8.36051 6.08935 8.4055 6.26005 8.44791L5.99112 9.52519L6.64961 9.68925L6.92206 8.5973C8.04487 8.80978 8.88914 8.72411 9.2445 7.70862C9.53085 6.89103 9.23025 6.41944 8.63954 6.11192C9.06978 6.0127 9.39385 5.72975 9.48026 5.14525L9.48005 5.14511L9.48002 5.14517ZM7.9756 7.25457C7.7721 8.07216 6.39541 7.6302 5.94906 7.51937L6.31064 6.07001C6.75696 6.18142 8.18827 6.40191 7.97562 7.25457H7.9756ZM8.17923 5.13332C7.9936 5.877 6.84776 5.49918 6.47606 5.40653L6.80389 4.09205C7.17559 4.18469 8.37261 4.35761 8.17929 5.13332H8.17923Z" fill="var(--wui-color-gray-glass-090)"/>
</g>
<defs>
<clipPath id="clip0_24458_3947">
<rect width="11.9997" height="12" fill="white" transform="translate(0.833984)"/>
</clipPath>
</defs>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/card.js
var card_exports = {};
__export(card_exports, {
  cardSvg: () => cardSvg
});
var cardSvg;
var init_card = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/card.js"() {
    init_lit();
    cardSvg = b6`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/checkmark.js
var checkmark_exports = {};
__export(checkmark_exports, {
  checkmarkSvg: () => checkmarkSvg
});
var checkmarkSvg;
var init_checkmark = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/checkmark.js"() {
    init_lit();
    checkmarkSvg = b6`<svg
  width="28"
  height="28"
  viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M25.5297 4.92733C26.1221 5.4242 26.1996 6.30724 25.7027 6.89966L12.2836 22.8997C12.0316 23.2001 11.6652 23.3811 11.2735 23.3986C10.8817 23.4161 10.5006 23.2686 10.2228 22.9919L2.38218 15.1815C1.83439 14.6358 1.83268 13.7494 2.37835 13.2016C2.92403 12.6538 3.81046 12.6521 4.35825 13.1978L11.1183 19.9317L23.5573 5.10036C24.0542 4.50794 24.9372 4.43047 25.5297 4.92733Z"
    fill="currentColor"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/checkmark-bold.js
var checkmark_bold_exports = {};
__export(checkmark_bold_exports, {
  checkmarkBoldSvg: () => checkmarkBoldSvg
});
var checkmarkBoldSvg;
var init_checkmark_bold = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/checkmark-bold.js"() {
    init_lit();
    checkmarkBoldSvg = b6`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.9576 2.23383C13.3807 2.58873 13.4361 3.21947 13.0812 3.64263L6.37159 11.6426C6.19161 11.8572 5.92989 11.9865 5.65009 11.999C5.3703 12.0115 5.09808 11.9062 4.89965 11.7085L0.979321 7.80331C0.588042 7.41354 0.586817 6.78038 0.976585 6.3891C1.36635 5.99782 1.99952 5.99659 2.3908 6.38636L5.53928 9.52268L11.5488 2.35742C11.9037 1.93426 12.5344 1.87893 12.9576 2.23383Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-bottom.js
var chevron_bottom_exports = {};
__export(chevron_bottom_exports, {
  chevronBottomSvg: () => chevronBottomSvg
});
var chevronBottomSvg;
var init_chevron_bottom = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-bottom.js"() {
    init_lit();
    chevronBottomSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-left.js
var chevron_left_exports = {};
__export(chevron_left_exports, {
  chevronLeftSvg: () => chevronLeftSvg
});
var chevronLeftSvg;
var init_chevron_left = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-left.js"() {
    init_lit();
    chevronLeftSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-right.js
var chevron_right_exports = {};
__export(chevron_right_exports, {
  chevronRightSvg: () => chevronRightSvg
});
var chevronRightSvg;
var init_chevron_right = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-right.js"() {
    init_lit();
    chevronRightSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-top.js
var chevron_top_exports = {};
__export(chevron_top_exports, {
  chevronTopSvg: () => chevronTopSvg
});
var chevronTopSvg;
var init_chevron_top = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chevron-top.js"() {
    init_lit();
    chevronTopSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chrome-store.js
var chrome_store_exports = {};
__export(chrome_store_exports, {
  chromeStoreSvg: () => chromeStoreSvg
});
var chromeStoreSvg;
var init_chrome_store = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/chrome-store.js"() {
    init_lit();
    chromeStoreSvg = b6`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/clock.js
var clock_exports = {};
__export(clock_exports, {
  clockSvg: () => clockSvg
});
var clockSvg;
var init_clock = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/clock.js"() {
    init_lit();
    clockSvg = b6`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path 
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M7.00235 2C4.24 2 2.00067 4.23858 2.00067 7C2.00067 9.76142 4.24 12 7.00235 12C9.7647 12 12.004 9.76142 12.004 7C12.004 4.23858 9.7647 2 7.00235 2ZM0 7C0 3.13401 3.13506 0 7.00235 0C10.8696 0 14.0047 3.13401 14.0047 7C14.0047 10.866 10.8696 14 7.00235 14C3.13506 14 0 10.866 0 7ZM7.00235 3C7.55482 3 8.00269 3.44771 8.00269 4V6.58579L9.85327 8.43575C10.2439 8.82627 10.2439 9.45944 9.85327 9.84996C9.46262 10.2405 8.82924 10.2405 8.43858 9.84996L6.29501 7.70711C6.10741 7.51957 6.00201 7.26522 6.00201 7V4C6.00201 3.44771 6.44988 3 7.00235 3Z" 
    fill="currentColor"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/close.js
var close_exports = {};
__export(close_exports, {
  closeSvg: () => closeSvg
});
var closeSvg;
var init_close = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/close.js"() {
    init_lit();
    closeSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/compass.js
var compass_exports = {};
__export(compass_exports, {
  compassSvg: () => compassSvg
});
var compassSvg;
var init_compass = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/compass.js"() {
    init_lit();
    compassSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/coinPlaceholder.js
var coinPlaceholder_exports = {};
__export(coinPlaceholder_exports, {
  coinPlaceholderSvg: () => coinPlaceholderSvg
});
var coinPlaceholderSvg;
var init_coinPlaceholder = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/coinPlaceholder.js"() {
    init_lit();
    coinPlaceholderSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/copy.js
var copy_exports = {};
__export(copy_exports, {
  copySvg: () => copySvg
});
var copySvg;
var init_copy = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/copy.js"() {
    init_lit();
    copySvg = b6`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/cursor.js
var cursor_exports = {};
__export(cursor_exports, {
  cursorSvg: () => cursorSvg
});
var cursorSvg;
var init_cursor = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/cursor.js"() {
    init_lit();
    cursorSvg = b6` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/cursor-transparent.js
var cursor_transparent_exports = {};
__export(cursor_transparent_exports, {
  cursorTransparentSvg: () => cursorTransparentSvg
});
var cursorTransparentSvg;
var init_cursor_transparent = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/cursor-transparent.js"() {
    init_lit();
    cursorTransparentSvg = b6`<svg fill="none" viewBox="0 0 14 6">
  <path style="fill: var(--wui-color-bg-150);" d="M0 1h14L9.21 5.12a3.31 3.31 0 0 1-4.49 0L0 1Z" />
  <path
    style="stroke: var(--wui-color-inverse-100);"
    stroke-opacity=".05"
    d="M1.33 1.5h11.32L8.88 4.75l-.01.01a2.81 2.81 0 0 1-3.8 0l-.02-.01L1.33 1.5Z"
  />
  <path
    style="fill: var(--wui-color-bg-150);"
    d="M1.25.71h11.5L9.21 3.88a3.31 3.31 0 0 1-4.49 0L1.25.71Z"
  />
</svg> `;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/circle.js
var circle_exports = {};
__export(circle_exports, {
  circleSvg: () => circleSvg
});
var circleSvg;
var init_circle = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/circle.js"() {
    init_lit();
    circleSvg = b6`<svg width="4" height="4" viewBox="0 0 4 4" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="2" cy="2" r="2" fill="white" fill-opacity="0.2"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/desktop.js
var desktop_exports = {};
__export(desktop_exports, {
  desktopSvg: () => desktopSvg
});
var desktopSvg;
var init_desktop = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/desktop.js"() {
    init_lit();
    desktopSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/disconnect.js
var disconnect_exports = {};
__export(disconnect_exports, {
  disconnectSvg: () => disconnectSvg
});
var disconnectSvg;
var init_disconnect = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/disconnect.js"() {
    init_lit();
    disconnectSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/discord.js
var discord_exports = {};
__export(discord_exports, {
  discordSvg: () => discordSvg
});
var discordSvg;
var init_discord = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/discord.js"() {
    init_lit();
    discordSvg = b6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/ethereum.js
var ethereum_exports = {};
__export(ethereum_exports, {
  ethereumSvg: () => ethereumSvg
});
var ethereumSvg;
var init_ethereum = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/ethereum.js"() {
    init_lit();
    ethereumSvg = b6`<svg width="13" height="12" viewBox="0 0 13 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.66686 12C9.9805 12 12.6667 9.31371 12.6667 6C12.6667 2.68629 9.9805 0 6.66686 0C3.35323 0 0.666992 2.68629 0.666992 6C0.666992 9.31371 3.35323 12 6.66686 12Z" fill="var(--wui-color-gray-glass-005)"/>
<path d="M6.6658 1.50098V4.82739L9.47712 6.08381L6.6658 1.50098Z" fill="var(--wui-color-gray-glass-060)"/>
<path d="M6.6658 1.50098L3.85449 6.08381L6.6658 4.82739V1.50098Z" fill="var(--wui-color-gray-glass-090)"/>
<path d="M6.6658 8.23909V10.4993L9.47876 6.60705L6.6658 8.23909Z" fill="var(--wui-color-gray-glass-060)"/>
<path d="M6.6658 10.4993V8.23909L3.85449 6.60705L6.6658 10.4993Z" fill="var(--wui-color-gray-glass-090)"/>
<path d="M6.6658 7.71585L9.47712 6.08381L6.6658 4.82739V7.71585Z" fill="var(--wui-color-gray-glass-020)"/>
<path d="M3.85449 6.08381L6.6658 7.71585V4.82739L3.85449 6.08381Z" fill="var(--wui-color-gray-glass-060)"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/etherscan.js
var etherscan_exports = {};
__export(etherscan_exports, {
  etherscanSvg: () => etherscanSvg
});
var etherscanSvg;
var init_etherscan = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/etherscan.js"() {
    init_lit();
    etherscanSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/extension.js
var extension_exports = {};
__export(extension_exports, {
  extensionSvg: () => extensionSvg
});
var extensionSvg;
var init_extension = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/extension.js"() {
    init_lit();
    extensionSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/external-link.js
var external_link_exports = {};
__export(external_link_exports, {
  externalLinkSvg: () => externalLinkSvg
});
var externalLinkSvg;
var init_external_link = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/external-link.js"() {
    init_lit();
    externalLinkSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/facebook.js
var facebook_exports = {};
__export(facebook_exports, {
  facebookSvg: () => facebookSvg
});
var facebookSvg;
var init_facebook = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/facebook.js"() {
    init_lit();
    facebookSvg = b6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/farcaster.js
var farcaster_exports = {};
__export(farcaster_exports, {
  farcasterSvg: () => farcasterSvg
});
var farcasterSvg;
var init_farcaster = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/farcaster.js"() {
    init_lit();
    farcasterSvg = b6`<svg style="border-radius: 9999px; overflow: hidden;"  fill="none" viewBox="0 0 1000 1000">
  <rect width="1000" height="1000" rx="9999" ry="9999" fill="#855DCD"/>
  <path fill="#855DCD" d="M0 0h1000v1000H0V0Z" />
  <path
    fill="#fff"
    d="M320 248h354v504h-51.96V521.13h-.5c-5.76-63.8-59.31-113.81-124.54-113.81s-118.78 50-124.53 113.81h-.5V752H320V248Z"
  />
  <path
    fill="#fff"
    d="m225 320 21.16 71.46h17.9v289.09a16.29 16.29 0 0 0-16.28 16.24v19.49h-3.25a16.3 16.3 0 0 0-16.28 16.24V752h182.26v-19.48a16.22 16.22 0 0 0-16.28-16.24h-3.25v-19.5a16.22 16.22 0 0 0-16.28-16.23h-19.52V320H225Zm400.3 360.55a16.3 16.3 0 0 0-15.04 10.02 16.2 16.2 0 0 0-1.24 6.22v19.49h-3.25a16.29 16.29 0 0 0-16.27 16.24V752h182.24v-19.48a16.23 16.23 0 0 0-16.27-16.24h-3.25v-19.5a16.2 16.2 0 0 0-10.04-15 16.3 16.3 0 0 0-6.23-1.23v-289.1h17.9L775 320H644.82v360.55H625.3Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/filters.js
var filters_exports = {};
__export(filters_exports, {
  filtersSvg: () => filtersSvg
});
var filtersSvg;
var init_filters = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/filters.js"() {
    init_lit();
    filtersSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/github.js
var github_exports = {};
__export(github_exports, {
  githubSvg: () => githubSvg
});
var githubSvg;
var init_github = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/github.js"() {
    init_lit();
    githubSvg = b6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/google.js
var google_exports = {};
__export(google_exports, {
  googleSvg: () => googleSvg
});
var googleSvg;
var init_google = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/google.js"() {
    init_lit();
    googleSvg = b6`<svg fill="none" viewBox="0 0 40 40">
  <path
    fill="#4285F4"
    d="M32.74 20.3c0-.93-.08-1.81-.24-2.66H20.26v5.03h7a6 6 0 0 1-2.62 3.91v3.28h4.22c2.46-2.27 3.88-5.6 3.88-9.56Z"
  />
  <path
    fill="#34A853"
    d="M20.26 33a12.4 12.4 0 0 0 8.6-3.14l-4.22-3.28a7.74 7.74 0 0 1-4.38 1.26 7.76 7.76 0 0 1-7.28-5.36H8.65v3.36A12.99 12.99 0 0 0 20.26 33Z"
  />
  <path
    fill="#FBBC05"
    d="M12.98 22.47a7.79 7.79 0 0 1 0-4.94v-3.36H8.65a12.84 12.84 0 0 0 0 11.66l3.37-2.63.96-.73Z"
  />
  <path
    fill="#EA4335"
    d="M20.26 12.18a7.1 7.1 0 0 1 4.98 1.93l3.72-3.72A12.47 12.47 0 0 0 20.26 7c-5.08 0-9.47 2.92-11.6 7.17l4.32 3.36a7.76 7.76 0 0 1 7.28-5.35Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/help-circle.js
var help_circle_exports = {};
__export(help_circle_exports, {
  helpCircleSvg: () => helpCircleSvg
});
var helpCircleSvg;
var init_help_circle = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/help-circle.js"() {
    init_lit();
    helpCircleSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/image.js
var image_exports = {};
__export(image_exports, {
  imageSvg: () => imageSvg
});
var imageSvg;
var init_image = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/image.js"() {
    init_lit();
    imageSvg = b6`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path d="M4.98926 3.73932C4.2989 3.73932 3.73926 4.29896 3.73926 4.98932C3.73926 5.67968 4.2989 6.23932 4.98926 6.23932C5.67962 6.23932 6.23926 5.67968 6.23926 4.98932C6.23926 4.29896 5.67962 3.73932 4.98926 3.73932Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.60497 0.500001H6.39504C5.41068 0.499977 4.59185 0.499958 3.93178 0.571471C3.24075 0.64634 2.60613 0.809093 2.04581 1.21619C1.72745 1.44749 1.44749 1.72745 1.21619 2.04581C0.809093 2.60613 0.64634 3.24075 0.571471 3.93178C0.499958 4.59185 0.499977 5.41065 0.500001 6.39501V7.57815C0.499998 8.37476 0.499995 9.05726 0.534869 9.62725C0.570123 10.2034 0.644114 10.7419 0.828442 11.2302C0.925651 11.4877 1.05235 11.7287 1.21619 11.9542C1.44749 12.2726 1.72745 12.5525 2.04581 12.7838C2.60613 13.1909 3.24075 13.3537 3.93178 13.4285C4.59185 13.5001 5.41066 13.5 6.39503 13.5H7.60496C8.58933 13.5 9.40815 13.5001 10.0682 13.4285C10.7593 13.3537 11.3939 13.1909 11.9542 12.7838C12.2726 12.5525 12.5525 12.2726 12.7838 11.9542C13.1909 11.3939 13.3537 10.7593 13.4285 10.0682C13.5 9.40816 13.5 8.58935 13.5 7.60497V6.39505C13.5 5.41068 13.5 4.59185 13.4285 3.93178C13.3537 3.24075 13.1909 2.60613 12.7838 2.04581C12.5525 1.72745 12.2726 1.44749 11.9542 1.21619C11.3939 0.809093 10.7593 0.64634 10.0682 0.571471C9.40816 0.499958 8.58933 0.499977 7.60497 0.500001ZM3.22138 2.83422C3.38394 2.71612 3.62634 2.61627 4.14721 2.55984C4.68679 2.50138 5.39655 2.5 6.45 2.5H7.55C8.60345 2.5 9.31322 2.50138 9.8528 2.55984C10.3737 2.61627 10.6161 2.71612 10.7786 2.83422C10.9272 2.94216 11.0578 3.07281 11.1658 3.22138C11.2839 3.38394 11.3837 3.62634 11.4402 4.14721C11.4986 4.68679 11.5 5.39655 11.5 6.45V6.49703C10.9674 6.11617 10.386 5.84936 9.74213 5.81948C8.40536 5.75745 7.3556 6.73051 6.40509 7.84229C6.33236 7.92737 6.27406 7.98735 6.22971 8.02911L6.1919 8.00514L6.17483 7.99427C6.09523 7.94353 5.98115 7.87083 5.85596 7.80302C5.56887 7.64752 5.18012 7.4921 4.68105 7.4921C4.66697 7.4921 4.6529 7.49239 4.63884 7.49299C3.79163 7.52878 3.09922 8.1106 2.62901 8.55472C2.58751 8.59392 2.54594 8.6339 2.50435 8.6745C2.50011 8.34653 2.5 7.97569 2.5 7.55V6.45C2.5 5.39655 2.50138 4.68679 2.55984 4.14721C2.61627 3.62634 2.71612 3.38394 2.83422 3.22138C2.94216 3.07281 3.07281 2.94216 3.22138 2.83422ZM10.3703 8.14825C10.6798 8.37526 11.043 8.71839 11.4832 9.20889C11.4744 9.44992 11.4608 9.662 11.4402 9.8528C11.3837 10.3737 11.2839 10.6161 11.1658 10.7786C11.0578 10.9272 10.9272 11.0578 10.7786 11.1658C10.6161 11.2839 10.3737 11.3837 9.8528 11.4402C9.31322 11.4986 8.60345 11.5 7.55 11.5H6.45C5.39655 11.5 4.68679 11.4986 4.14721 11.4402C3.62634 11.3837 3.38394 11.2839 3.22138 11.1658C3.15484 11.1174 3.0919 11.0645 3.03298 11.0075C3.10126 10.9356 3.16806 10.8649 3.23317 10.7959L3.29772 10.7276C3.55763 10.4525 3.78639 10.2126 4.00232 10.0087C4.22016 9.80294 4.39412 9.66364 4.53524 9.57742C4.63352 9.51738 4.69022 9.49897 4.71275 9.49345C4.76387 9.49804 4.81803 9.51537 4.90343 9.56162C4.96409 9.59447 5.02355 9.63225 5.11802 9.69238L5.12363 9.69595C5.20522 9.74789 5.32771 9.82587 5.46078 9.89278C5.76529 10.0459 6.21427 10.186 6.74977 10.0158C7.21485 9.86796 7.59367 9.52979 7.92525 9.14195C8.91377 7.98571 9.38267 7.80495 9.64941 7.81733C9.7858 7.82366 10.0101 7.884 10.3703 8.14825Z" fill="currentColor"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/id.js
var id_exports = {};
__export(id_exports, {
  idSvg: () => idSvg
});
var idSvg;
var init_id2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/id.js"() {
    init_lit();
    idSvg = b6`<svg
 xmlns="http://www.w3.org/2000/svg"
 width="28"
 height="28"
 viewBox="0 0 28 28"
 fill="none">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7.974 2.975h12.052c1.248 0 2.296 0 3.143.092.89.096 1.723.307 2.461.844a4.9 4.9 0 0 1 1.084 1.084c.537.738.748 1.57.844 2.461.092.847.092 1.895.092 3.143v6.802c0 1.248 0 2.296-.092 3.143-.096.89-.307 1.723-.844 2.461a4.9 4.9 0 0 1-1.084 1.084c-.738.537-1.57.748-2.461.844-.847.092-1.895.092-3.143.092H7.974c-1.247 0-2.296 0-3.143-.092-.89-.096-1.723-.307-2.461-.844a4.901 4.901 0 0 1-1.084-1.084c-.537-.738-.748-1.571-.844-2.461C.35 19.697.35 18.649.35 17.4v-6.802c0-1.248 0-2.296.092-3.143.096-.89.307-1.723.844-2.461A4.9 4.9 0 0 1 2.37 3.91c.738-.537 1.571-.748 2.461-.844.847-.092 1.895-.092 3.143-.092ZM5.133 5.85c-.652.071-.936.194-1.117.326a2.1 2.1 0 0 0-.465.465c-.132.181-.255.465-.325 1.117-.074.678-.076 1.573-.076 2.917v6.65c0 1.344.002 2.239.076 2.917.07.652.193.936.325 1.117a2.1 2.1 0 0 0 .465.465c.181.132.465.255 1.117.326.678.073 1.574.075 2.917.075h11.9c1.344 0 2.239-.002 2.917-.075.652-.071.936-.194 1.117-.326.179-.13.335-.286.465-.465.132-.181.255-.465.326-1.117.073-.678.075-1.573.075-2.917v-6.65c0-1.344-.002-2.239-.075-2.917-.071-.652-.194-.936-.326-1.117a2.1 2.1 0 0 0-.465-.465c-.181-.132-.465-.255-1.117-.326-.678-.073-1.573-.075-2.917-.075H8.05c-1.343 0-2.239.002-2.917.075Zm.467 7.275a3.15 3.15 0 1 1 6.3 0 3.15 3.15 0 0 1-6.3 0Zm8.75-1.75a1.4 1.4 0 0 1 1.4-1.4h3.5a1.4 1.4 0 0 1 0 2.8h-3.5a1.4 1.4 0 0 1-1.4-1.4Zm0 5.25a1.4 1.4 0 0 1 1.4-1.4H21a1.4 1.4 0 1 1 0 2.8h-5.25a1.4 1.4 0 0 1-1.4-1.4Z"
    clip-rule="evenodd"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/info-circle.js
var info_circle_exports = {};
__export(info_circle_exports, {
  infoCircleSvg: () => infoCircleSvg
});
var infoCircleSvg;
var init_info_circle = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/info-circle.js"() {
    init_lit();
    infoCircleSvg = b6`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/lightbulb.js
var lightbulb_exports = {};
__export(lightbulb_exports, {
  lightbulbSvg: () => lightbulbSvg
});
var lightbulbSvg;
var init_lightbulb = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/lightbulb.js"() {
    init_lit();
    lightbulbSvg = b6`<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.00177 1.78569C3.8179 1.78569 2.85819 2.74508 2.85819 3.92855C2.85819 4.52287 3.09928 5.05956 3.49077 5.4485L3.5005 5.45817C3.64381 5.60054 3.76515 5.72108 3.85631 5.81845C3.93747 5.90512 4.05255 6.03218 4.12889 6.1805C4.16999 6.26034 4.19 6.30843 4.21768 6.39385C4.22145 6.40546 4.22499 6.41703 4.22833 6.42855H5.77521C5.77854 6.41703 5.78208 6.40547 5.78585 6.39385C5.81353 6.30843 5.83354 6.26034 5.87464 6.1805C5.95098 6.03218 6.06606 5.90512 6.14722 5.81845C6.23839 5.72108 6.35973 5.60053 6.50304 5.45816L6.51276 5.4485C6.90425 5.05956 7.14534 4.52287 7.14534 3.92855C7.14534 2.74508 6.18563 1.78569 5.00177 1.78569ZM5.71629 7.85712H4.28724C4.28724 8.21403 4.28876 8.40985 4.30703 8.54571C4.30727 8.54748 4.30751 8.54921 4.30774 8.55091C4.30944 8.55115 4.31118 8.55138 4.31295 8.55162C4.44884 8.56989 4.64474 8.5714 5.00177 8.5714C5.3588 8.5714 5.55469 8.56989 5.69059 8.55162C5.69236 8.55138 5.69409 8.55115 5.69579 8.55091C5.69603 8.54921 5.69627 8.54748 5.6965 8.54571C5.71477 8.40985 5.71629 8.21403 5.71629 7.85712ZM2.85819 7.14283C2.85819 6.9948 2.85796 6.91114 2.8548 6.85032C2.85461 6.84656 2.85441 6.84309 2.85421 6.83988C2.84393 6.8282 2.83047 6.81334 2.81301 6.79469C2.74172 6.71856 2.63908 6.61643 2.48342 6.46178C1.83307 5.81566 1.42914 4.91859 1.42914 3.92855C1.42914 1.9561 3.02866 0.357117 5.00177 0.357117C6.97487 0.357117 8.57439 1.9561 8.57439 3.92855C8.57439 4.91859 8.17047 5.81566 7.52012 6.46178C7.36445 6.61643 7.26182 6.71856 7.19053 6.79469C7.17306 6.81334 7.1596 6.8282 7.14932 6.83988C7.14912 6.84309 7.14892 6.84656 7.14873 6.85032C7.14557 6.91114 7.14534 6.9948 7.14534 7.14283V7.85712C7.14534 7.87009 7.14535 7.88304 7.14535 7.89598C7.14541 8.19889 7.14547 8.49326 7.11281 8.73606C7.076 9.00978 6.98631 9.32212 6.72678 9.58156C6.46726 9.841 6.15481 9.93065 5.881 9.96745C5.63813 10.0001 5.34365 10 5.04064 9.99998C5.0277 9.99998 5.01474 9.99998 5.00177 9.99998C4.98879 9.99998 4.97583 9.99998 4.96289 9.99998C4.65988 10 4.36541 10.0001 4.12253 9.96745C3.84872 9.93065 3.53628 9.841 3.27675 9.58156C3.01722 9.32212 2.92753 9.00978 2.89072 8.73606C2.85807 8.49326 2.85812 8.19889 2.85818 7.89598C2.85819 7.88304 2.85819 7.87008 2.85819 7.85712V7.14283ZM7.1243 6.86977C7.12366 6.87069 7.1233 6.87116 7.12327 6.87119C7.12323 6.87123 7.12356 6.87076 7.1243 6.86977ZM2.88027 6.8712C2.88025 6.87119 2.87988 6.8707 2.87921 6.86975C2.87995 6.87072 2.88028 6.8712 2.88027 6.8712Z" fill="#949E9E"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/mail.js
var mail_exports = {};
__export(mail_exports, {
  mailSvg: () => mailSvg
});
var mailSvg;
var init_mail = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/mail.js"() {
    init_lit();
    mailSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/mobile.js
var mobile_exports = {};
__export(mobile_exports, {
  mobileSvg: () => mobileSvg
});
var mobileSvg;
var init_mobile = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/mobile.js"() {
    init_lit();
    mobileSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/more.js
var more_exports = {};
__export(more_exports, {
  moreSvg: () => moreSvg
});
var moreSvg;
var init_more = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/more.js"() {
    init_lit();
    moreSvg = b6`<svg fill="none" viewBox="0 0 41 40">
  <path
    style="fill: var(--wui-color-fg-100);"
    fill-opacity=".05"
    d="M.6 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z"
  />
  <path
    fill="#949E9E"
    d="M15.6 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM23.1 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM28.1 22.81a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/network-placeholder.js
var network_placeholder_exports = {};
__export(network_placeholder_exports, {
  networkPlaceholderSvg: () => networkPlaceholderSvg
});
var networkPlaceholderSvg;
var init_network_placeholder = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/network-placeholder.js"() {
    init_lit();
    networkPlaceholderSvg = b6`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/nftPlaceholder.js
var nftPlaceholder_exports = {};
__export(nftPlaceholder_exports, {
  nftPlaceholderSvg: () => nftPlaceholderSvg
});
var nftPlaceholderSvg;
var init_nftPlaceholder = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/nftPlaceholder.js"() {
    init_lit();
    nftPlaceholderSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/off.js
var off_exports = {};
__export(off_exports, {
  offSvg: () => offSvg
});
var offSvg;
var init_off = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/off.js"() {
    init_lit();
    offSvg = b6`<svg viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M7.99792 0C8.6291 0 9.14077 0.511675 9.14077 1.14286V6.41758C9.14077 7.04877 8.6291 7.56044 7.99792 7.56044C7.36673 7.56044 6.85506 7.04877 6.85506 6.41758V1.14286C6.85506 0.511675 7.36673 0 7.99792 0ZM5.44952 2.61998C5.79899 3.14558 5.6562 3.85497 5.1306 4.20444C3.73012 5.1356 2.8111 6.72446 2.8111 8.52747C2.8111 11.3921 5.13332 13.7143 7.99792 13.7143C10.8625 13.7143 13.1847 11.3921 13.1847 8.52747C13.1847 6.72446 12.2657 5.1356 10.8652 4.20444C10.3396 3.85497 10.1968 3.14558 10.5463 2.61998C10.8958 2.09437 11.6052 1.95158 12.1308 2.30105C14.1414 3.63786 15.4704 5.92721 15.4704 8.52747C15.4704 12.6544 12.1249 16 7.99792 16C3.87095 16 0.525391 12.6544 0.525391 8.52747C0.525391 5.92721 1.85448 3.63786 3.86506 2.30105C4.39066 1.95158 5.10005 2.09437 5.44952 2.61998Z" fill="currentColor"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/play-store.js
var play_store_exports = {};
__export(play_store_exports, {
  playStoreSvg: () => playStoreSvg
});
var playStoreSvg;
var init_play_store = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/play-store.js"() {
    init_lit();
    playStoreSvg = b6` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/plus.js
var plus_exports = {};
__export(plus_exports, {
  plusSvg: () => plusSvg
});
var plusSvg;
var init_plus = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/plus.js"() {
    init_lit();
    plusSvg = b6`<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/qr-code.js
var qr_code_exports = {};
__export(qr_code_exports, {
  qrCodeIcon: () => qrCodeIcon
});
var qrCodeIcon;
var init_qr_code = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/qr-code.js"() {
    init_lit();
    qrCodeIcon = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/recycle-horizontal.js
var recycle_horizontal_exports = {};
__export(recycle_horizontal_exports, {
  recycleHorizontalSvg: () => recycleHorizontalSvg
});
var recycleHorizontalSvg;
var init_recycle_horizontal = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/recycle-horizontal.js"() {
    init_lit();
    recycleHorizontalSvg = b6`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/refresh.js
var refresh_exports = {};
__export(refresh_exports, {
  refreshSvg: () => refreshSvg
});
var refreshSvg;
var init_refresh = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/refresh.js"() {
    init_lit();
    refreshSvg = b6`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/search.js
var search_exports = {};
__export(search_exports, {
  searchSvg: () => searchSvg
});
var searchSvg;
var init_search = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/search.js"() {
    init_lit();
    searchSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/send.js
var send_exports = {};
__export(send_exports, {
  sendSvg: () => sendSvg
});
var sendSvg;
var init_send = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/send.js"() {
    init_lit();
    sendSvg = b6`<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontal.js
var swapHorizontal_exports = {};
__export(swapHorizontal_exports, {
  swapHorizontalSvg: () => swapHorizontalSvg
});
var swapHorizontalSvg;
var init_swapHorizontal = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontal.js"() {
    init_lit();
    swapHorizontalSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontalMedium.js
var swapHorizontalMedium_exports = {};
__export(swapHorizontalMedium_exports, {
  swapHorizontalMediumSvg: () => swapHorizontalMediumSvg
});
var swapHorizontalMediumSvg;
var init_swapHorizontalMedium = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontalMedium.js"() {
    init_lit();
    swapHorizontalMediumSvg = b6`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontalBold.js
var swapHorizontalBold_exports = {};
__export(swapHorizontalBold_exports, {
  swapHorizontalBoldSvg: () => swapHorizontalBoldSvg
});
var swapHorizontalBoldSvg;
var init_swapHorizontalBold = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontalBold.js"() {
    init_lit();
    swapHorizontalBoldSvg = b6`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontalRoundedBold.js
var swapHorizontalRoundedBold_exports = {};
__export(swapHorizontalRoundedBold_exports, {
  swapHorizontalRoundedBoldSvg: () => swapHorizontalRoundedBoldSvg
});
var swapHorizontalRoundedBoldSvg;
var init_swapHorizontalRoundedBold = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapHorizontalRoundedBold.js"() {
    init_lit();
    swapHorizontalRoundedBoldSvg = b6`<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
  <path 
    fill="currentColor"
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M8.3071 0.292893C8.69763 0.683417 8.69763 1.31658 8.3071 1.70711L6.41421 3.6H11.3404C13.8368 3.6 16.0533 5.1975 16.8427 7.56588L16.9487 7.88377C17.1233 8.40772 16.8402 8.97404 16.3162 9.14868C15.7923 9.32333 15.226 9.04017 15.0513 8.51623L14.9453 8.19834C14.4281 6.64664 12.976 5.6 11.3404 5.6H6.41421L8.3071 7.49289C8.69763 7.88342 8.69763 8.51658 8.3071 8.90711C7.91658 9.29763 7.28341 9.29763 6.89289 8.90711L3.29289 5.30711C2.90236 4.91658 2.90236 4.28342 3.29289 3.89289L6.89289 0.292893C7.28341 -0.0976311 7.91658 -0.0976311 8.3071 0.292893ZM3.68377 10.8513C4.20771 10.6767 4.77403 10.9598 4.94868 11.4838L5.05464 11.8017C5.57188 13.3534 7.024 14.4 8.65964 14.4L13.5858 14.4L11.6929 12.5071C11.3024 12.1166 11.3024 11.4834 11.6929 11.0929C12.0834 10.7024 12.7166 10.7024 13.1071 11.0929L16.7071 14.6929C17.0976 15.0834 17.0976 15.7166 16.7071 16.1071L13.1071 19.7071C12.7166 20.0976 12.0834 20.0976 11.6929 19.7071C11.3024 19.3166 11.3024 18.6834 11.6929 18.2929L13.5858 16.4L8.65964 16.4C6.16314 16.4 3.94674 14.8025 3.15728 12.4341L3.05131 12.1162C2.87667 11.5923 3.15983 11.026 3.68377 10.8513Z" 
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapVertical.js
var swapVertical_exports = {};
__export(swapVertical_exports, {
  swapVerticalSvg: () => swapVerticalSvg
});
var swapVerticalSvg;
var init_swapVertical = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/swapVertical.js"() {
    init_lit();
    swapVerticalSvg = b6`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/solana.js
var solana_exports = {};
__export(solana_exports, {
  solanaSvg: () => solanaSvg
});
var solanaSvg;
var init_solana = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/solana.js"() {
    init_lit();
    solanaSvg = b6`
<svg width="13" height="12" viewBox="0 0 13 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_24458_3940)">
<path d="M6.49987 12C9.81351 12 12.4997 9.31371 12.4997 6C12.4997 2.68629 9.81351 0 6.49987 0C3.18623 0 0.5 2.68629 0.5 6C0.5 9.31371 3.18623 12 6.49987 12Z" fill="var(--wui-color-gray-glass-005)"/>
<path d="M9.89298 7.73057L8.76102 8.91828C8.73642 8.94408 8.70664 8.96465 8.67356 8.97871C8.64047 8.99277 8.60478 9.00002 8.56872 9H3.2027C3.1771 9 3.15205 8.99268 3.13064 8.97895C3.10923 8.96521 3.09239 8.94565 3.08218 8.92268C3.07197 8.8997 3.06885 8.87431 3.07319 8.84963C3.07753 8.82494 3.08915 8.80203 3.10662 8.78371L4.23943 7.596C4.26397 7.57027 4.29365 7.54974 4.32662 7.53569C4.3596 7.52163 4.39518 7.51435 4.43115 7.51428H9.79688C9.82248 7.51428 9.84752 7.52161 9.86895 7.53534C9.89033 7.54908 9.90717 7.56864 9.91742 7.59161C9.92761 7.61459 9.93073 7.63997 9.92638 7.66466C9.92204 7.68935 9.91043 7.71226 9.89298 7.73057ZM8.76102 5.33885C8.73642 5.31305 8.70664 5.29248 8.67356 5.27843C8.64047 5.26437 8.60478 5.25713 8.56872 5.25715H3.2027C3.1771 5.25715 3.15205 5.26446 3.13064 5.2782C3.10923 5.29194 3.09239 5.31149 3.08218 5.33446C3.07197 5.35744 3.06885 5.38283 3.07319 5.40752C3.07753 5.4322 3.08915 5.45511 3.10662 5.47343L4.23943 6.66115C4.26397 6.68688 4.29365 6.7074 4.32662 6.72146C4.3596 6.73551 4.39518 6.7428 4.43115 6.74285H9.79688C9.82248 6.74285 9.84752 6.73554 9.86895 6.7218C9.89033 6.70806 9.90717 6.68851 9.91742 6.66554C9.92761 6.64256 9.93073 6.61717 9.92638 6.59248C9.92204 6.5678 9.91043 6.54489 9.89298 6.52657L8.76102 5.33885ZM3.2027 4.48572H8.56872C8.60478 4.48573 8.64047 4.47849 8.67356 4.46443C8.70664 4.45037 8.73642 4.4298 8.76102 4.404L9.89298 3.21629C9.91043 3.19797 9.92204 3.17506 9.92638 3.15037C9.93073 3.12569 9.92761 3.1003 9.91742 3.07732C9.90717 3.05435 9.89033 3.03479 9.86895 3.02106C9.84752 3.00732 9.82248 3 9.79688 3H4.43115C4.39518 3.00006 4.3596 3.00734 4.32662 3.0214C4.29365 3.03545 4.26397 3.05598 4.23943 3.08171L3.10691 4.26943C3.08946 4.28772 3.07785 4.31061 3.0735 4.33527C3.06914 4.35993 3.07224 4.3853 3.08241 4.40826C3.09258 4.43122 3.10938 4.45078 3.13075 4.46454C3.15212 4.4783 3.17712 4.48565 3.2027 4.48572Z" fill="var(--wui-color-gray-glass-090)"/>
</g>
<defs>
<clipPath id="clip0_24458_3940">
<rect width="11.9997" height="12" fill="white" transform="translate(0.5)"/>
</clipPath>
</defs>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/telegram.js
var telegram_exports = {};
__export(telegram_exports, {
  telegramSvg: () => telegramSvg
});
var telegramSvg;
var init_telegram = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/telegram.js"() {
    init_lit();
    telegramSvg = b6`<svg width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M0 0h32v32H0z"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.034 15.252c4.975-2.167 8.293-3.596 9.953-4.287 4.74-1.971 5.725-2.314 6.366-2.325.142-.002.457.033.662.198.172.14.22.33.243.463.022.132.05.435.028.671-.257 2.7-1.368 9.248-1.933 12.27-.24 1.28-.71 1.708-1.167 1.75-.99.091-1.743-.655-2.703-1.284-1.502-.985-2.351-1.598-3.81-2.558-1.684-1.11-.592-1.721.368-2.718.252-.261 4.619-4.233 4.703-4.594.01-.045.02-.213-.08-.301-.1-.09-.246-.059-.353-.035-.15.034-2.55 1.62-7.198 4.758-.682.468-1.298.696-1.851.684-.61-.013-1.782-.344-2.653-.628-1.069-.347-1.918-.53-1.845-1.12.039-.308.462-.623 1.27-.944Z" fill="#fff"/>
  </g>
  <path d="M.5 16C.5 7.44 7.44.5 16 .5 24.56.5 31.5 7.44 31.5 16c0 8.56-6.94 15.5-15.5 15.5C7.44 31.5.5 24.56.5 16Z" stroke="#141414" stroke-opacity=".05"/>
  <defs>
    <linearGradient id="b" x1="1600" y1="0" x2="1600" y2="3176.27" gradientUnits="userSpaceOnUse">
      <stop stop-color="#2AABEE"/>
      <stop offset="1" stop-color="#229ED9"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16S0 24.837 0 16Z" fill="#fff"/>
    </clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/three-dots.js
var three_dots_exports = {};
__export(three_dots_exports, {
  threeDotsSvg: () => threeDotsSvg
});
var threeDotsSvg;
var init_three_dots = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/three-dots.js"() {
    init_lit();
    threeDotsSvg = b6`<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7 3.71875C6.0335 3.71875 5.25 2.93525 5.25 1.96875C5.25 1.00225 6.0335 0.21875 7 0.21875C7.9665 0.21875 8.75 1.00225 8.75 1.96875C8.75 2.93525 7.9665 3.71875 7 3.71875Z" fill="#949E9E"/>
  <path d="M7 8.96875C6.0335 8.96875 5.25 8.18525 5.25 7.21875C5.25 6.25225 6.0335 5.46875 7 5.46875C7.9665 5.46875 8.75 6.25225 8.75 7.21875C8.75 8.18525 7.9665 8.96875 7 8.96875Z" fill="#949E9E"/>
  <path d="M5.25 12.4688C5.25 13.4352 6.0335 14.2187 7 14.2187C7.9665 14.2187 8.75 13.4352 8.75 12.4688C8.75 11.5023 7.9665 10.7188 7 10.7188C6.0335 10.7188 5.25 11.5023 5.25 12.4688Z" fill="#949E9E"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/twitch.js
var twitch_exports = {};
__export(twitch_exports, {
  twitchSvg: () => twitchSvg
});
var twitchSvg;
var init_twitch = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/twitch.js"() {
    init_lit();
    twitchSvg = b6`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/x.js
var x_exports = {};
__export(x_exports, {
  xSvg: () => xSvg
});
var xSvg;
var init_x = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/x.js"() {
    init_lit();
    xSvg = b6`<svg fill="none" viewBox="0 0 41 40">
  <g clip-path="url(#a)">
    <path fill="#000" d="M.8 0h40v40H.8z" />
    <path
      fill="#fff"
      d="m22.63 18.46 7.14-8.3h-1.69l-6.2 7.2-4.96-7.2H11.2l7.5 10.9-7.5 8.71h1.7l6.55-7.61 5.23 7.61h5.72l-7.77-11.31Zm-9.13-7.03h2.6l11.98 17.13h-2.6L13.5 11.43Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M.8 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z" /></clipPath>
  </defs>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/twitterIcon.js
var twitterIcon_exports = {};
__export(twitterIcon_exports, {
  twitterIconSvg: () => twitterIconSvg
});
var twitterIconSvg;
var init_twitterIcon = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/twitterIcon.js"() {
    init_lit();
    twitterIconSvg = b6`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/user.js
var user_exports = {};
__export(user_exports, {
  userSvg: () => userSvg
});
var userSvg;
var init_user = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/user.js"() {
    init_lit();
    userSvg = b6`<svg viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M13.9998 3.5C12.3085 3.5 10.9373 4.87113 10.9373 6.5625C10.9373 8.25387 12.3085 9.625 13.9998 9.625C15.6912 9.625 17.0623 8.25387 17.0623 6.5625C17.0623 4.87113 15.6912 3.5 13.9998 3.5ZM7.43735 6.5625C7.43735 2.93813 10.3755 0 13.9998 0C17.6242 0 20.5623 2.93813 20.5623 6.5625C20.5623 10.1869 17.6242 13.125 13.9998 13.125C10.3755 13.125 7.43735 10.1869 7.43735 6.5625ZM13.9998 17.8675C11.126 17.8675 8.58879 19.3111 7.07434 21.5207C6.78205 21.9471 6.56997 22.2579 6.4061 22.534C6.24539 22.8047 6.1769 22.9681 6.14674 23.0736C6.12281 23.1573 6.1203 23.2121 6.13052 23.2804C6.14324 23.3656 6.18621 23.5318 6.33646 23.8169C6.5167 24.1589 6.66134 24.2632 7.0307 24.3543C7.59943 24.4944 8.4222 24.5064 9.94429 24.5064H18.0554C19.5775 24.5064 20.4003 24.4944 20.969 24.3543C21.3384 24.2632 21.483 24.1589 21.6632 23.8169C21.8135 23.5318 21.8565 23.3656 21.8692 23.2804C21.8794 23.2121 21.8769 23.1573 21.853 23.0736C21.8228 22.9681 21.7543 22.8047 21.5936 22.534C21.4297 22.2579 21.2176 21.9471 20.9254 21.5207C19.4109 19.3111 16.8737 17.8675 13.9998 17.8675ZM4.18736 19.542C6.32648 16.421 9.92314 14.3675 13.9998 14.3675C18.0766 14.3675 21.6732 16.421 23.8123 19.542C23.8409 19.5836 23.8699 19.6258 23.8991 19.6684C24.3886 20.3805 24.9617 21.2145 25.2181 22.1115C25.5476 23.2638 25.3418 24.3438 24.7596 25.4485C24.0843 26.7302 23.0844 27.4377 21.8064 27.7526C20.7724 28.0074 19.5099 28.0069 18.2225 28.0064C18.1669 28.0064 18.1111 28.0064 18.0554 28.0064H9.94429C9.88855 28.0064 9.83284 28.0064 9.77717 28.0064C8.48981 28.0069 7.22727 28.0074 6.19332 27.7526C4.9153 27.4377 3.91541 26.7302 3.24005 25.4485C2.65792 24.3438 2.45214 23.2638 2.78156 22.1115C3.03802 21.2145 3.61113 20.3805 4.10056 19.6684C4.12982 19.6258 4.15878 19.5836 4.18736 19.542Z"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/verify.js
var verify_exports = {};
__export(verify_exports, {
  verifySvg: () => verifySvg
});
var verifySvg;
var init_verify = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/verify.js"() {
    init_lit();
    verifySvg = b6`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/verify-filled.js
var verify_filled_exports = {};
__export(verify_filled_exports, {
  verifyFilledSvg: () => verifyFilledSvg
});
var verifyFilledSvg;
var init_verify_filled = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/verify-filled.js"() {
    init_lit();
    verifyFilledSvg = b6`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/wallet.js
var wallet_exports = {};
__export(wallet_exports, {
  walletSvg: () => walletSvg
});
var walletSvg;
var init_wallet = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/wallet.js"() {
    init_lit();
    walletSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/walletconnect.js
var walletconnect_exports = {};
__export(walletconnect_exports, {
  walletConnectBrownSvg: () => walletConnectBrownSvg,
  walletConnectLightBrownSvg: () => walletConnectLightBrownSvg,
  walletConnectSvg: () => walletConnectSvg
});
var walletConnectSvg, walletConnectLightBrownSvg, walletConnectBrownSvg;
var init_walletconnect = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/walletconnect.js"() {
    init_lit();
    walletConnectSvg = b6`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;
    walletConnectLightBrownSvg = b6`
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_22274_4692)">
<path d="M0 6.64C0 4.17295 0 2.93942 0.525474 2.01817C0.880399 1.39592 1.39592 0.880399 2.01817 0.525474C2.93942 0 4.17295 0 6.64 0H9.36C11.8271 0 13.0606 0 13.9818 0.525474C14.6041 0.880399 15.1196 1.39592 15.4745 2.01817C16 2.93942 16 4.17295 16 6.64V9.36C16 11.8271 16 13.0606 15.4745 13.9818C15.1196 14.6041 14.6041 15.1196 13.9818 15.4745C13.0606 16 11.8271 16 9.36 16H6.64C4.17295 16 2.93942 16 2.01817 15.4745C1.39592 15.1196 0.880399 14.6041 0.525474 13.9818C0 13.0606 0 11.8271 0 9.36V6.64Z" fill="#C7B994"/>
<path d="M4.49038 5.76609C6.42869 3.86833 9.5713 3.86833 11.5096 5.76609L11.7429 5.99449C11.8398 6.08938 11.8398 6.24323 11.7429 6.33811L10.9449 7.11942C10.8964 7.16686 10.8179 7.16686 10.7694 7.11942L10.4484 6.80512C9.09617 5.48119 6.90381 5.48119 5.5516 6.80512L5.20782 7.14171C5.15936 7.18915 5.08079 7.18915 5.03234 7.14171L4.23434 6.3604C4.13742 6.26552 4.13742 6.11167 4.23434 6.01678L4.49038 5.76609ZM13.1599 7.38192L13.8702 8.07729C13.9671 8.17217 13.9671 8.32602 13.8702 8.4209L10.6677 11.5564C10.5708 11.6513 10.4137 11.6513 10.3168 11.5564L8.04388 9.33105C8.01965 9.30733 7.98037 9.30733 7.95614 9.33105L5.6833 11.5564C5.58638 11.6513 5.42925 11.6513 5.33234 11.5564L2.12982 8.42087C2.0329 8.32598 2.0329 8.17213 2.12982 8.07724L2.84004 7.38188C2.93695 7.28699 3.09408 7.28699 3.191 7.38188L5.46392 9.60726C5.48815 9.63098 5.52743 9.63098 5.55166 9.60726L7.82447 7.38188C7.92138 7.28699 8.07851 7.28699 8.17543 7.38187L10.4484 9.60726C10.4726 9.63098 10.5119 9.63098 10.5361 9.60726L12.809 7.38192C12.9059 7.28703 13.063 7.28703 13.1599 7.38192Z" fill="#202020"/>
</g>
<defs>
<clipPath id="clip0_22274_4692">
<path d="M0 8C0 3.58172 3.58172 0 8 0C12.4183 0 16 3.58172 16 8C16 12.4183 12.4183 16 8 16C3.58172 16 0 12.4183 0 8Z" fill="white"/>
</clipPath>
</defs>
</svg>
`;
    walletConnectBrownSvg = b6`
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="11" cy="11" r="11" transform="matrix(-1 0 0 1 23 1)" fill="#202020"/>
<circle cx="11" cy="11" r="11.5" transform="matrix(-1 0 0 1 23 1)" stroke="#C7B994" stroke-opacity="0.7"/>
<path d="M15.4523 11.0686L16.7472 9.78167C13.8205 6.87297 10.1838 6.87297 7.25708 9.78167L8.55201 11.0686C10.7779 8.85645 13.2279 8.85645 15.4538 11.0686H15.4523Z" fill="#C7B994"/>
<path d="M15.0199 14.067L12 11.0656L8.98 14.067L5.96004 11.0656L4.66663 12.3511L8.98 16.6393L12 13.638L15.0199 16.6393L19.3333 12.3511L18.0399 11.0656L15.0199 14.067Z" fill="#C7B994"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/wallet-placeholder.js
var wallet_placeholder_exports = {};
__export(wallet_placeholder_exports, {
  walletPlaceholderSvg: () => walletPlaceholderSvg
});
var walletPlaceholderSvg;
var init_wallet_placeholder = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/wallet-placeholder.js"() {
    init_lit();
    walletPlaceholderSvg = b6`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/warning-circle.js
var warning_circle_exports = {};
__export(warning_circle_exports, {
  warningCircleSvg: () => warningCircleSvg
});
var warningCircleSvg;
var init_warning_circle = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/warning-circle.js"() {
    init_lit();
    warningCircleSvg = b6`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/info.js
var info_exports = {};
__export(info_exports, {
  infoSvg: () => infoSvg
});
var infoSvg;
var init_info = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/info.js"() {
    init_lit();
    infoSvg = b6`<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.125 6.875C9.125 6.57833 9.21298 6.28832 9.3778 6.04165C9.54262 5.79497 9.77689 5.60271 10.051 5.48918C10.3251 5.37565 10.6267 5.34594 10.9176 5.40382C11.2086 5.4617 11.4759 5.60456 11.6857 5.81434C11.8954 6.02412 12.0383 6.29139 12.0962 6.58236C12.1541 6.87334 12.1244 7.17494 12.0108 7.44903C11.8973 7.72311 11.705 7.95738 11.4584 8.1222C11.2117 8.28703 10.9217 8.375 10.625 8.375C10.2272 8.375 9.84565 8.21696 9.56434 7.93566C9.28304 7.65436 9.125 7.27282 9.125 6.875ZM21.125 11C21.125 13.0025 20.5312 14.9601 19.4186 16.6251C18.3061 18.2902 16.7248 19.5879 14.8747 20.3543C13.0246 21.1206 10.9888 21.3211 9.02471 20.9305C7.06066 20.5398 5.25656 19.5755 3.84055 18.1595C2.42454 16.7435 1.46023 14.9393 1.06955 12.9753C0.678878 11.0112 0.879387 8.97543 1.64572 7.12533C2.41206 5.27523 3.70981 3.69392 5.37486 2.58137C7.0399 1.46882 8.99747 0.875 11 0.875C13.6844 0.877978 16.258 1.94567 18.1562 3.84383C20.0543 5.74199 21.122 8.3156 21.125 11ZM18.875 11C18.875 9.44247 18.4131 7.91992 17.5478 6.62488C16.6825 5.32985 15.4526 4.32049 14.0136 3.72445C12.5747 3.12841 10.9913 2.97246 9.46367 3.27632C7.93607 3.58017 6.53288 4.3302 5.43154 5.43153C4.3302 6.53287 3.58018 7.93606 3.27632 9.46366C2.97246 10.9913 3.12841 12.5747 3.72445 14.0136C4.32049 15.4526 5.32985 16.6825 6.62489 17.5478C7.91993 18.4131 9.44248 18.875 11 18.875C13.0879 18.8728 15.0896 18.0424 16.566 16.566C18.0424 15.0896 18.8728 13.0879 18.875 11ZM12.125 14.4387V11.375C12.125 10.8777 11.9275 10.4008 11.5758 10.0492C11.2242 9.69754 10.7473 9.5 10.25 9.5C9.98433 9.4996 9.72708 9.59325 9.52383 9.76435C9.32058 9.93544 9.18444 10.173 9.13952 10.4348C9.09461 10.6967 9.14381 10.966 9.27843 11.195C9.41304 11.4241 9.62438 11.5981 9.875 11.6863V14.75C9.875 15.2473 10.0725 15.7242 10.4242 16.0758C10.7758 16.4275 11.2527 16.625 11.75 16.625C12.0157 16.6254 12.2729 16.5318 12.4762 16.3607C12.6794 16.1896 12.8156 15.952 12.8605 15.6902C12.9054 15.4283 12.8562 15.159 12.7216 14.93C12.587 14.7009 12.3756 14.5269 12.125 14.4387Z" fill="currentColor"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/exclamation-triangle.js
var exclamation_triangle_exports = {};
__export(exclamation_triangle_exports, {
  exclamationTriangleSvg: () => exclamationTriangleSvg
});
var exclamationTriangleSvg;
var init_exclamation_triangle = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/exclamation-triangle.js"() {
    init_lit();
    exclamationTriangleSvg = b6`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.0162 11.6312L9.55059 2.13937C9.39228 1.86862 9.16584 1.64405 8.8938 1.48798C8.62176 1.33192 8.3136 1.2498 7.99997 1.2498C7.68634 1.2498 7.37817 1.33192 7.10613 1.48798C6.83409 1.64405 6.60765 1.86862 6.44934 2.13937L0.983716 11.6312C0.830104 11.894 0.749146 12.1928 0.749146 12.4972C0.749146 12.8015 0.830104 13.1004 0.983716 13.3631C1.14027 13.6352 1.3664 13.8608 1.63889 14.0166C1.91139 14.1725 2.22044 14.253 2.53434 14.25H13.4656C13.7793 14.2528 14.0881 14.1721 14.3603 14.0163C14.6326 13.8604 14.8585 13.635 15.015 13.3631C15.1688 13.1005 15.2499 12.8017 15.2502 12.4973C15.2504 12.193 15.1696 11.8941 15.0162 11.6312ZM13.7162 12.6125C13.6908 12.6558 13.6541 12.6914 13.6101 12.7157C13.5661 12.7399 13.5164 12.7517 13.4662 12.75H2.53434C2.48415 12.7517 2.43442 12.7399 2.39042 12.7157C2.34641 12.6914 2.30976 12.6558 2.28434 12.6125C2.26278 12.5774 2.25137 12.5371 2.25137 12.4959C2.25137 12.4548 2.26278 12.4144 2.28434 12.3794L7.74997 2.88749C7.77703 2.84583 7.81408 2.8116 7.85774 2.7879C7.9014 2.7642 7.95029 2.75178 7.99997 2.75178C8.04964 2.75178 8.09854 2.7642 8.1422 2.7879C8.18586 2.8116 8.2229 2.84583 8.24997 2.88749L13.715 12.3794C13.7367 12.4143 13.7483 12.4546 13.7486 12.4958C13.7488 12.5369 13.7376 12.5773 13.7162 12.6125ZM7.24997 8.49999V6.49999C7.24997 6.30108 7.32898 6.11031 7.46964 5.96966C7.61029 5.82901 7.80105 5.74999 7.99997 5.74999C8.19888 5.74999 8.38964 5.82901 8.5303 5.96966C8.67095 6.11031 8.74997 6.30108 8.74997 6.49999V8.49999C8.74997 8.6989 8.67095 8.88967 8.5303 9.03032C8.38964 9.17097 8.19888 9.24999 7.99997 9.24999C7.80105 9.24999 7.61029 9.17097 7.46964 9.03032C7.32898 8.88967 7.24997 8.6989 7.24997 8.49999ZM8.99997 11C8.99997 11.1978 8.94132 11.3911 8.83144 11.5556C8.72155 11.72 8.56538 11.8482 8.38265 11.9239C8.19992 11.9996 7.99886 12.0194 7.80488 11.9808C7.6109 11.9422 7.43271 11.847 7.29286 11.7071C7.15301 11.5672 7.05777 11.3891 7.01918 11.1951C6.9806 11.0011 7.0004 10.8 7.07609 10.6173C7.15177 10.4346 7.27995 10.2784 7.4444 10.1685C7.60885 10.0586 7.80219 9.99999 7.99997 9.99999C8.26518 9.99999 8.51954 10.1053 8.70707 10.2929C8.89461 10.4804 8.99997 10.7348 8.99997 11Z" fill="currentColor"/>
</svg>
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/reown-logo.js
var reown_logo_exports = {};
__export(reown_logo_exports, {
  reownSvg: () => reownSvg
});
var reownSvg;
var init_reown_logo = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/reown-logo.js"() {
    init_lit();
    reownSvg = b6`<svg width="60" height="16" viewBox="0 0 60 16" fill="none"">
  <path d="M9.3335 4.66667C9.3335 2.08934 11.4229 0 14.0002 0H20.6669C23.2442 0 25.3335 2.08934 25.3335 4.66667V11.3333C25.3335 13.9106 23.2442 16 20.6669 16H14.0002C11.4229 16 9.3335 13.9106 9.3335 11.3333V4.66667Z" fill="#363636"/>
  <path d="M15.6055 11.0003L17.9448 4.66699H18.6316L16.2923 11.0003H15.6055Z" fill="#F6F6F6"/>
  <path d="M0 4.33333C0 1.9401 1.9401 0 4.33333 0C6.72657 0 8.66669 1.9401 8.66669 4.33333V11.6667C8.66669 14.0599 6.72657 16 4.33333 16C1.9401 16 0 14.0599 0 11.6667V4.33333Z" fill="#363636"/>
  <path d="M3.9165 9.99934V9.16602H4.74983V9.99934H3.9165Z" fill="#F6F6F6"/>
  <path d="M26 8C26 3.58172 29.3517 0 33.4863 0H52.5137C56.6483 0 60 3.58172 60 8C60 12.4183 56.6483 16 52.5137 16H33.4863C29.3517 16 26 12.4183 26 8Z" fill="#363636"/>
  <path d="M49.3687 9.95834V6.26232H50.0213V6.81966C50.256 6.40899 50.7326 6.16699 51.2606 6.16699C52.0599 6.16699 52.6173 6.67299 52.6173 7.65566V9.95834H51.972V7.69234C51.972 7.04696 51.6053 6.70966 51.07 6.70966C50.4906 6.70966 50.0213 7.17168 50.0213 7.82433V9.95834H49.3687Z" fill="#F6F6F6"/>
  <path d="M45.2538 9.95773L44.5718 6.26172H45.1877L45.6717 9.31242L46.3098 7.30306H46.9184L47.5491 9.29041L48.0404 6.26172H48.6564L47.9744 9.95773H47.2411L46.6178 8.03641L45.9871 9.95773H45.2538Z" fill="#F6F6F6"/>
  <path d="M42.3709 10.0536C41.2489 10.0536 40.5889 9.21765 40.5889 8.1103C40.5889 7.01035 41.2489 6.16699 42.3709 6.16699C43.4929 6.16699 44.1529 7.01035 44.1529 8.1103C44.1529 9.21765 43.4929 10.0536 42.3709 10.0536ZM42.3709 9.51096C43.1775 9.51096 43.4856 8.82164 43.4856 8.10296C43.4856 7.39163 43.1775 6.70966 42.3709 6.70966C41.5642 6.70966 41.2562 7.39163 41.2562 8.10296C41.2562 8.82164 41.5642 9.51096 42.3709 9.51096Z" fill="#F6F6F6"/>
  <path d="M38.2805 10.0536C37.1952 10.0536 36.5132 9.22499 36.5132 8.1103C36.5132 7.00302 37.1952 6.16699 38.2805 6.16699C39.1972 6.16699 40.0038 6.68766 39.9159 8.27896H37.1805C37.2319 8.96103 37.5472 9.5183 38.2805 9.5183C38.7718 9.5183 39.0945 9.21765 39.2045 8.87299H39.8499C39.7472 9.48903 39.1679 10.0536 38.2805 10.0536ZM37.1952 7.78765H39.2852C39.2338 7.04696 38.8892 6.70232 38.2805 6.70232C37.6132 6.70232 37.2832 7.18635 37.1952 7.78765Z" fill="#F6F6F6"/>
  <path d="M33.3828 9.95773V6.26172H34.0501V6.88506C34.2848 6.47439 34.6882 6.26172 35.1061 6.26172H35.9935V6.88506H35.0548C34.4682 6.88506 34.0501 7.26638 34.0501 8.00706V9.95773H33.3828Z" fill="#F6F6F6"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/x-mark.js
var x_mark_exports = {};
__export(x_mark_exports, {
  xMarkSvg: () => xMarkSvg
});
var xMarkSvg;
var init_x_mark = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/x-mark.js"() {
    init_lit();
    xMarkSvg = b6`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M1.9659 1.96541C2.30063 1.63067 2.84334 1.63067 3.17808 1.96541L6.00056 4.78789L8.82304 1.96541C9.15777 1.63067 9.70049 1.63067 10.0352 1.96541C10.37 2.30014 10.37 2.84285 10.0352 3.17759L7.21274 6.00007L10.0352 8.82255C10.37 9.15729 10.37 9.7 10.0352 10.0347C9.70049 10.3695 9.15777 10.3695 8.82304 10.0347L6.00056 7.21225L3.17808 10.0347C2.84334 10.3695 2.30063 10.3695 1.9659 10.0347C1.63116 9.7 1.63116 9.15729 1.9659 8.82255L4.78837 6.00007L1.9659 3.17759C1.63116 2.84285 1.63116 2.30014 1.9659 1.96541Z" fill="currentColor"/>
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-icon/index.js
async function getSvg(name2) {
  if (globalSvgCache.has(name2)) {
    return globalSvgCache.get(name2);
  }
  const importFn = ICONS[name2] ?? ICONS.copy;
  const svgPromise = importFn();
  globalSvgCache.set(name2, svgPromise);
  return svgPromise;
}
var __decorate3, ICONS, WuiIcon;
var init_wui_icon = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-icon/index.js"() {
    init_lit();
    init_decorators();
    init_until2();
    init_CacheUtil();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles2();
    __decorate3 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    ICONS = {
      add: async () => (await Promise.resolve().then(() => (init_add(), add_exports))).addSvg,
      allWallets: async () => (await Promise.resolve().then(() => (init_all_wallets(), all_wallets_exports))).allWalletsSvg,
      arrowBottomCircle: async () => (await Promise.resolve().then(() => (init_arrow_bottom_circle(), arrow_bottom_circle_exports))).arrowBottomCircleSvg,
      appStore: async () => (await Promise.resolve().then(() => (init_app_store(), app_store_exports))).appStoreSvg,
      apple: async () => (await Promise.resolve().then(() => (init_apple(), apple_exports))).appleSvg,
      arrowBottom: async () => (await Promise.resolve().then(() => (init_arrow_bottom(), arrow_bottom_exports))).arrowBottomSvg,
      arrowLeft: async () => (await Promise.resolve().then(() => (init_arrow_left(), arrow_left_exports))).arrowLeftSvg,
      arrowRight: async () => (await Promise.resolve().then(() => (init_arrow_right(), arrow_right_exports))).arrowRightSvg,
      arrowTop: async () => (await Promise.resolve().then(() => (init_arrow_top(), arrow_top_exports))).arrowTopSvg,
      bank: async () => (await Promise.resolve().then(() => (init_bank(), bank_exports))).bankSvg,
      browser: async () => (await Promise.resolve().then(() => (init_browser(), browser_exports))).browserSvg,
      bin: async () => (await Promise.resolve().then(() => (init_bin(), bin_exports))).binSvg,
      bitcoin: async () => (await Promise.resolve().then(() => (init_bitcoin(), bitcoin_exports))).bitcoinSvg,
      card: async () => (await Promise.resolve().then(() => (init_card(), card_exports))).cardSvg,
      checkmark: async () => (await Promise.resolve().then(() => (init_checkmark(), checkmark_exports))).checkmarkSvg,
      checkmarkBold: async () => (await Promise.resolve().then(() => (init_checkmark_bold(), checkmark_bold_exports))).checkmarkBoldSvg,
      chevronBottom: async () => (await Promise.resolve().then(() => (init_chevron_bottom(), chevron_bottom_exports))).chevronBottomSvg,
      chevronLeft: async () => (await Promise.resolve().then(() => (init_chevron_left(), chevron_left_exports))).chevronLeftSvg,
      chevronRight: async () => (await Promise.resolve().then(() => (init_chevron_right(), chevron_right_exports))).chevronRightSvg,
      chevronTop: async () => (await Promise.resolve().then(() => (init_chevron_top(), chevron_top_exports))).chevronTopSvg,
      chromeStore: async () => (await Promise.resolve().then(() => (init_chrome_store(), chrome_store_exports))).chromeStoreSvg,
      clock: async () => (await Promise.resolve().then(() => (init_clock(), clock_exports))).clockSvg,
      close: async () => (await Promise.resolve().then(() => (init_close(), close_exports))).closeSvg,
      compass: async () => (await Promise.resolve().then(() => (init_compass(), compass_exports))).compassSvg,
      coinPlaceholder: async () => (await Promise.resolve().then(() => (init_coinPlaceholder(), coinPlaceholder_exports))).coinPlaceholderSvg,
      copy: async () => (await Promise.resolve().then(() => (init_copy(), copy_exports))).copySvg,
      cursor: async () => (await Promise.resolve().then(() => (init_cursor(), cursor_exports))).cursorSvg,
      cursorTransparent: async () => (await Promise.resolve().then(() => (init_cursor_transparent(), cursor_transparent_exports))).cursorTransparentSvg,
      circle: async () => (await Promise.resolve().then(() => (init_circle(), circle_exports))).circleSvg,
      desktop: async () => (await Promise.resolve().then(() => (init_desktop(), desktop_exports))).desktopSvg,
      disconnect: async () => (await Promise.resolve().then(() => (init_disconnect(), disconnect_exports))).disconnectSvg,
      discord: async () => (await Promise.resolve().then(() => (init_discord(), discord_exports))).discordSvg,
      ethereum: async () => (await Promise.resolve().then(() => (init_ethereum(), ethereum_exports))).ethereumSvg,
      etherscan: async () => (await Promise.resolve().then(() => (init_etherscan(), etherscan_exports))).etherscanSvg,
      extension: async () => (await Promise.resolve().then(() => (init_extension(), extension_exports))).extensionSvg,
      externalLink: async () => (await Promise.resolve().then(() => (init_external_link(), external_link_exports))).externalLinkSvg,
      facebook: async () => (await Promise.resolve().then(() => (init_facebook(), facebook_exports))).facebookSvg,
      farcaster: async () => (await Promise.resolve().then(() => (init_farcaster(), farcaster_exports))).farcasterSvg,
      filters: async () => (await Promise.resolve().then(() => (init_filters(), filters_exports))).filtersSvg,
      github: async () => (await Promise.resolve().then(() => (init_github(), github_exports))).githubSvg,
      google: async () => (await Promise.resolve().then(() => (init_google(), google_exports))).googleSvg,
      helpCircle: async () => (await Promise.resolve().then(() => (init_help_circle(), help_circle_exports))).helpCircleSvg,
      image: async () => (await Promise.resolve().then(() => (init_image(), image_exports))).imageSvg,
      id: async () => (await Promise.resolve().then(() => (init_id2(), id_exports))).idSvg,
      infoCircle: async () => (await Promise.resolve().then(() => (init_info_circle(), info_circle_exports))).infoCircleSvg,
      lightbulb: async () => (await Promise.resolve().then(() => (init_lightbulb(), lightbulb_exports))).lightbulbSvg,
      mail: async () => (await Promise.resolve().then(() => (init_mail(), mail_exports))).mailSvg,
      mobile: async () => (await Promise.resolve().then(() => (init_mobile(), mobile_exports))).mobileSvg,
      more: async () => (await Promise.resolve().then(() => (init_more(), more_exports))).moreSvg,
      networkPlaceholder: async () => (await Promise.resolve().then(() => (init_network_placeholder(), network_placeholder_exports))).networkPlaceholderSvg,
      nftPlaceholder: async () => (await Promise.resolve().then(() => (init_nftPlaceholder(), nftPlaceholder_exports))).nftPlaceholderSvg,
      off: async () => (await Promise.resolve().then(() => (init_off(), off_exports))).offSvg,
      playStore: async () => (await Promise.resolve().then(() => (init_play_store(), play_store_exports))).playStoreSvg,
      plus: async () => (await Promise.resolve().then(() => (init_plus(), plus_exports))).plusSvg,
      qrCode: async () => (await Promise.resolve().then(() => (init_qr_code(), qr_code_exports))).qrCodeIcon,
      recycleHorizontal: async () => (await Promise.resolve().then(() => (init_recycle_horizontal(), recycle_horizontal_exports))).recycleHorizontalSvg,
      refresh: async () => (await Promise.resolve().then(() => (init_refresh(), refresh_exports))).refreshSvg,
      search: async () => (await Promise.resolve().then(() => (init_search(), search_exports))).searchSvg,
      send: async () => (await Promise.resolve().then(() => (init_send(), send_exports))).sendSvg,
      swapHorizontal: async () => (await Promise.resolve().then(() => (init_swapHorizontal(), swapHorizontal_exports))).swapHorizontalSvg,
      swapHorizontalMedium: async () => (await Promise.resolve().then(() => (init_swapHorizontalMedium(), swapHorizontalMedium_exports))).swapHorizontalMediumSvg,
      swapHorizontalBold: async () => (await Promise.resolve().then(() => (init_swapHorizontalBold(), swapHorizontalBold_exports))).swapHorizontalBoldSvg,
      swapHorizontalRoundedBold: async () => (await Promise.resolve().then(() => (init_swapHorizontalRoundedBold(), swapHorizontalRoundedBold_exports))).swapHorizontalRoundedBoldSvg,
      swapVertical: async () => (await Promise.resolve().then(() => (init_swapVertical(), swapVertical_exports))).swapVerticalSvg,
      solana: async () => (await Promise.resolve().then(() => (init_solana(), solana_exports))).solanaSvg,
      telegram: async () => (await Promise.resolve().then(() => (init_telegram(), telegram_exports))).telegramSvg,
      threeDots: async () => (await Promise.resolve().then(() => (init_three_dots(), three_dots_exports))).threeDotsSvg,
      twitch: async () => (await Promise.resolve().then(() => (init_twitch(), twitch_exports))).twitchSvg,
      twitter: async () => (await Promise.resolve().then(() => (init_x(), x_exports))).xSvg,
      twitterIcon: async () => (await Promise.resolve().then(() => (init_twitterIcon(), twitterIcon_exports))).twitterIconSvg,
      user: async () => (await Promise.resolve().then(() => (init_user(), user_exports))).userSvg,
      verify: async () => (await Promise.resolve().then(() => (init_verify(), verify_exports))).verifySvg,
      verifyFilled: async () => (await Promise.resolve().then(() => (init_verify_filled(), verify_filled_exports))).verifyFilledSvg,
      wallet: async () => (await Promise.resolve().then(() => (init_wallet(), wallet_exports))).walletSvg,
      walletConnect: async () => (await Promise.resolve().then(() => (init_walletconnect(), walletconnect_exports))).walletConnectSvg,
      walletConnectLightBrown: async () => (await Promise.resolve().then(() => (init_walletconnect(), walletconnect_exports))).walletConnectLightBrownSvg,
      walletConnectBrown: async () => (await Promise.resolve().then(() => (init_walletconnect(), walletconnect_exports))).walletConnectBrownSvg,
      walletPlaceholder: async () => (await Promise.resolve().then(() => (init_wallet_placeholder(), wallet_placeholder_exports))).walletPlaceholderSvg,
      warningCircle: async () => (await Promise.resolve().then(() => (init_warning_circle(), warning_circle_exports))).warningCircleSvg,
      x: async () => (await Promise.resolve().then(() => (init_x(), x_exports))).xSvg,
      info: async () => (await Promise.resolve().then(() => (init_info(), info_exports))).infoSvg,
      exclamationTriangle: async () => (await Promise.resolve().then(() => (init_exclamation_triangle(), exclamation_triangle_exports))).exclamationTriangleSvg,
      reown: async () => (await Promise.resolve().then(() => (init_reown_logo(), reown_logo_exports))).reownSvg,
      "x-mark": async () => (await Promise.resolve().then(() => (init_x_mark(), x_mark_exports))).xMarkSvg
    };
    WuiIcon = class WuiIcon2 extends i7 {
      constructor() {
        super(...arguments);
        this.size = "md";
        this.name = "copy";
        this.color = "fg-300";
        this.aspectRatio = "1 / 1";
      }
      render() {
        this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
      --local-aspect-ratio: ${this.aspectRatio}
    `;
        return x6`${m5(getSvg(this.name), x6`<div class="fallback"></div>`)}`;
      }
    };
    WuiIcon.styles = [resetStyles, colorStyles, styles_default2];
    __decorate3([
      n8()
    ], WuiIcon.prototype, "size", void 0);
    __decorate3([
      n8()
    ], WuiIcon.prototype, "name", void 0);
    __decorate3([
      n8()
    ], WuiIcon.prototype, "color", void 0);
    __decorate3([
      n8()
    ], WuiIcon.prototype, "aspectRatio", void 0);
    WuiIcon = __decorate3([
      customElement("wui-icon")
    ], WuiIcon);
  }
});

// node_modules/lit-html/directives/class-map.js
var e7;
var init_class_map = __esm({
  "node_modules/lit-html/directives/class-map.js"() {
    init_lit_html();
    init_directive();
    e7 = e6(class extends i9 {
      constructor(t5) {
        if (super(t5), t5.type !== t4.ATTRIBUTE || "class" !== t5.name || t5.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
      }
      render(t5) {
        return " " + Object.keys(t5).filter((s8) => t5[s8]).join(" ") + " ";
      }
      update(s8, [i11]) {
        if (void 0 === this.st) {
          this.st = /* @__PURE__ */ new Set(), void 0 !== s8.strings && (this.nt = new Set(s8.strings.join(" ").split(/\s/).filter((t5) => "" !== t5)));
          for (const t5 in i11) i11[t5] && !this.nt?.has(t5) && this.st.add(t5);
          return this.render(i11);
        }
        const r9 = s8.element.classList;
        for (const t5 of this.st) t5 in i11 || (r9.remove(t5), this.st.delete(t5));
        for (const t5 in i11) {
          const s9 = !!i11[t5];
          s9 === this.st.has(t5) || this.nt?.has(t5) || (s9 ? (r9.add(t5), this.st.add(t5)) : (r9.remove(t5), this.st.delete(t5)));
        }
        return T5;
      }
    });
  }
});

// node_modules/lit/directives/class-map.js
var init_class_map2 = __esm({
  "node_modules/lit/directives/class-map.js"() {
    init_class_map();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-text/styles.js
var styles_default3;
var init_styles3 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-text/styles.js"() {
    init_lit();
    styles_default3 = i4`
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .wui-line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  .wui-font-medium-400 {
    font-size: var(--wui-font-size-medium);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-600 {
    font-size: var(--wui-font-size-medium);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-title-600 {
    font-size: var(--wui-font-size-title);
    letter-spacing: var(--wui-letter-spacing-title);
  }

  .wui-font-title-6-600 {
    font-size: var(--wui-font-size-title-6);
    letter-spacing: var(--wui-letter-spacing-title-6);
  }

  .wui-font-mini-700 {
    font-size: var(--wui-font-size-mini);
    letter-spacing: var(--wui-letter-spacing-mini);
    text-transform: uppercase;
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-400,
  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600,
  .wui-font-micro-500 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-medium-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700,
  .wui-font-mini-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-600,
  .wui-font-medium-title-600,
  .wui-font-title-6-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }

  :host([disabled]) {
    opacity: 0.4;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-text/index.js
var __decorate4, WuiText;
var init_wui_text = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-text/index.js"() {
    init_lit();
    init_decorators();
    init_class_map2();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles3();
    __decorate4 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiText = class WuiText2 extends i7 {
      constructor() {
        super(...arguments);
        this.variant = "paragraph-500";
        this.color = "fg-300";
        this.align = "left";
        this.lineClamp = void 0;
      }
      render() {
        const classes = {
          [`wui-font-${this.variant}`]: true,
          [`wui-color-${this.color}`]: true,
          [`wui-line-clamp-${this.lineClamp}`]: this.lineClamp ? true : false
        };
        this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
        return x6`<slot class=${e7(classes)}></slot>`;
      }
    };
    WuiText.styles = [resetStyles, styles_default3];
    __decorate4([
      n8()
    ], WuiText.prototype, "variant", void 0);
    __decorate4([
      n8()
    ], WuiText.prototype, "color", void 0);
    __decorate4([
      n8()
    ], WuiText.prototype, "align", void 0);
    __decorate4([
      n8()
    ], WuiText.prototype, "lineClamp", void 0);
    WuiText = __decorate4([
      customElement("wui-text")
    ], WuiText);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-box/styles.js
var styles_default4;
var init_styles4 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-box/styles.js"() {
    init_lit();
    styles_default4 = i4`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-color-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-box/index.js
var __decorate5, WuiIconBox;
var init_wui_icon_box = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-box/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles4();
    __decorate5 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiIconBox = class WuiIconBox2 extends i7 {
      constructor() {
        super(...arguments);
        this.size = "md";
        this.backgroundColor = "accent-100";
        this.iconColor = "accent-100";
        this.background = "transparent";
        this.border = false;
        this.borderColor = "wui-color-bg-125";
        this.icon = "copy";
      }
      render() {
        const iconSize = this.iconSize || this.size;
        const isLg = this.size === "lg";
        const isXl = this.size === "xl";
        const bgMix = isLg ? "12%" : "16%";
        const borderRadius = isLg ? "xxs" : isXl ? "s" : "3xl";
        const isGray = this.background === "gray";
        const isOpaque = this.background === "opaque";
        const isColorChange = this.backgroundColor === "accent-100" && isOpaque || this.backgroundColor === "success-100" && isOpaque || this.backgroundColor === "error-100" && isOpaque || this.backgroundColor === "inverse-100" && isOpaque;
        let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
        if (isColorChange) {
          bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
        } else if (isGray) {
          bgValueVariable = `var(--wui-color-gray-${this.backgroundColor})`;
        }
        this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
        return x6` <wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></wui-icon> `;
      }
    };
    WuiIconBox.styles = [resetStyles, elementStyles, styles_default4];
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "size", void 0);
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "backgroundColor", void 0);
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "iconColor", void 0);
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "iconSize", void 0);
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "background", void 0);
    __decorate5([
      n8({ type: Boolean })
    ], WuiIconBox.prototype, "border", void 0);
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "borderColor", void 0);
    __decorate5([
      n8()
    ], WuiIconBox.prototype, "icon", void 0);
    WuiIconBox = __decorate5([
      customElement("wui-icon-box")
    ], WuiIconBox);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-image/styles.js
var styles_default5;
var init_styles5 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-image/styles.js"() {
    init_lit();
    styles_default5 = i4`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
  }

  :host([data-object-fit='cover']) img {
    object-fit: cover;
    object-position: center center;
  }

  :host([data-object-fit='contain']) img {
    object-fit: contain;
    object-position: center center;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-image/index.js
var __decorate6, WuiImage;
var init_wui_image = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-image/index.js"() {
    init_lit();
    init_decorators();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles5();
    __decorate6 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiImage = class WuiImage2 extends i7 {
      constructor() {
        super(...arguments);
        this.src = "./path/to/image.jpg";
        this.alt = "Image";
        this.size = void 0;
        this.objectFit = "cover";
      }
      render() {
        if (this.objectFit) {
          this.dataset["objectFit"] = this.objectFit;
        }
        this.style.cssText = `
      --local-width: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      --local-height: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      `;
        return x6`<img src=${this.src} alt=${this.alt} @error=${this.handleImageError} />`;
      }
      handleImageError() {
        this.dispatchEvent(new CustomEvent("onLoadError", { bubbles: true, composed: true }));
      }
    };
    WuiImage.styles = [resetStyles, colorStyles, styles_default5];
    __decorate6([
      n8()
    ], WuiImage.prototype, "src", void 0);
    __decorate6([
      n8()
    ], WuiImage.prototype, "alt", void 0);
    __decorate6([
      n8()
    ], WuiImage.prototype, "size", void 0);
    __decorate6([
      n8()
    ], WuiImage.prototype, "objectFit", void 0);
    WuiImage = __decorate6([
      customElement("wui-image")
    ], WuiImage);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-wallet-image/styles.js
var styles_default6;
var init_styles6 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-wallet-image/styles.js"() {
    init_lit();
    styles_default6 = i4`
  :host {
    position: relative;
    background-color: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-150, #1e1f1f);
    padding: 1px;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-wallet-image/index.js
var __decorate7, WuiWalletImage;
var init_wui_wallet_image = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-wallet-image/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_wui_image();
    init_wui_flex();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_icon_box();
    init_styles6();
    __decorate7 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiWalletImage = class WuiWalletImage2 extends i7 {
      constructor() {
        super(...arguments);
        this.size = "md";
        this.name = "";
        this.installed = false;
        this.badgeSize = "xs";
      }
      render() {
        let borderRadius = "xxs";
        if (this.size === "lg") {
          borderRadius = "m";
        } else if (this.size === "md") {
          borderRadius = "xs";
        } else {
          borderRadius = "xxs";
        }
        this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
        if (this.walletIcon) {
          this.dataset["walletIcon"] = this.walletIcon;
        }
        return x6`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
      }
      templateVisual() {
        if (this.imageSrc) {
          return x6`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
        } else if (this.walletIcon) {
          return x6`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`;
        }
        return x6`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
      }
    };
    WuiWalletImage.styles = [elementStyles, resetStyles, styles_default6];
    __decorate7([
      n8()
    ], WuiWalletImage.prototype, "size", void 0);
    __decorate7([
      n8()
    ], WuiWalletImage.prototype, "name", void 0);
    __decorate7([
      n8()
    ], WuiWalletImage.prototype, "imageSrc", void 0);
    __decorate7([
      n8()
    ], WuiWalletImage.prototype, "walletIcon", void 0);
    __decorate7([
      n8({ type: Boolean })
    ], WuiWalletImage.prototype, "installed", void 0);
    __decorate7([
      n8()
    ], WuiWalletImage.prototype, "badgeSize", void 0);
    WuiWalletImage = __decorate7([
      customElement("wui-wallet-image")
    ], WuiWalletImage);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-all-wallets-image/styles.js
var styles_default7;
var init_styles7 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-all-wallets-image/styles.js"() {
    init_lit();
    styles_default7 = i4`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-all-wallets-image/index.js
var __decorate8, TOTAL_IMAGES, WuiAllWalletsImage;
var init_wui_all_wallets_image = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-all-wallets-image/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_wui_flex();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_icon_box();
    init_wui_wallet_image();
    init_styles7();
    __decorate8 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    TOTAL_IMAGES = 4;
    WuiAllWalletsImage = class WuiAllWalletsImage2 extends i7 {
      constructor() {
        super(...arguments);
        this.walletImages = [];
      }
      render() {
        const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
        return x6`${this.walletImages.slice(0, TOTAL_IMAGES).map(({ src: src2, walletName }) => x6`
            <wui-wallet-image
              size="inherit"
              imageSrc=${src2}
              name=${o10(walletName)}
            ></wui-wallet-image>
          `)}
      ${isPlaceholders ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => x6` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
      }
    };
    WuiAllWalletsImage.styles = [resetStyles, styles_default7];
    __decorate8([
      n8({ type: Array })
    ], WuiAllWalletsImage.prototype, "walletImages", void 0);
    WuiAllWalletsImage = __decorate8([
      customElement("wui-all-wallets-image")
    ], WuiAllWalletsImage);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tag/styles.js
var styles_default8;
var init_styles8 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tag/styles.js"() {
    init_lit();
    styles_default8 = i4`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    height: var(--wui-spacing-m);
    padding: 0 var(--wui-spacing-3xs) !important;
    border-radius: var(--wui-border-radius-5xs);
    transition:
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius, background-color;
  }

  :host > wui-text {
    transform: translateY(5%);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-color-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }

  :host([data-size='lg']) {
    padding: 11px 5px !important;
  }

  :host([data-size='lg']) > wui-text {
    transform: translateY(2%);
  }

  :host([data-size='xs']) {
    height: var(--wui-spacing-2l);
    padding: 0 var(--wui-spacing-3xs) !important;
  }

  :host([data-size='xs']) > wui-text {
    transform: translateY(2%);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tag/index.js
var __decorate9, WuiTag;
var init_wui_tag = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tag/index.js"() {
    init_lit();
    init_decorators();
    init_wui_text();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles8();
    __decorate9 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiTag = class WuiTag2 extends i7 {
      constructor() {
        super(...arguments);
        this.variant = "main";
        this.size = "lg";
      }
      render() {
        this.dataset["variant"] = this.variant;
        this.dataset["size"] = this.size;
        const textVariant = this.size === "md" || this.size === "xs" ? "mini-700" : "micro-700";
        return x6`
      <wui-text data-variant=${this.variant} variant=${textVariant} color="inherit">
        <slot></slot>
      </wui-text>
    `;
      }
    };
    WuiTag.styles = [resetStyles, styles_default8];
    __decorate9([
      n8()
    ], WuiTag.prototype, "variant", void 0);
    __decorate9([
      n8()
    ], WuiTag.prototype, "size", void 0);
    WuiTag = __decorate9([
      customElement("wui-tag")
    ], WuiTag);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-wallet/styles.js
var styles_default9;
var init_styles9 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-wallet/styles.js"() {
    init_lit();
    styles_default9 = i4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-wallet/index.js
var __decorate10, WuiListWallet;
var init_wui_list_wallet = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-wallet/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_wui_icon();
    init_wui_text();
    init_wui_icon_box();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_all_wallets_image();
    init_wui_tag();
    init_wui_wallet_image();
    init_styles9();
    __decorate10 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiListWallet = class WuiListWallet2 extends i7 {
      constructor() {
        super(...arguments);
        this.walletImages = [];
        this.imageSrc = "";
        this.name = "";
        this.tabIdx = void 0;
        this.installed = false;
        this.disabled = false;
        this.showAllWallets = false;
        this.loading = false;
        this.loadingSpinnerColor = "accent-100";
      }
      render() {
        return x6`
      <button ?disabled=${this.disabled} tabindex=${o10(this.tabIdx)}>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
      }
      templateAllWallets() {
        if (this.showAllWallets && this.imageSrc) {
          return x6` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `;
        } else if (this.showAllWallets && this.walletIcon) {
          return x6` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `;
        }
        return null;
      }
      templateWalletImage() {
        if (!this.showAllWallets && this.imageSrc) {
          return x6`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`;
        } else if (!this.showAllWallets && !this.imageSrc) {
          return x6`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
        }
        return null;
      }
      templateStatus() {
        if (this.loading) {
          return x6`<wui-loading-spinner
        size="lg"
        color=${this.loadingSpinnerColor}
      ></wui-loading-spinner>`;
        } else if (this.tagLabel && this.tagVariant) {
          return x6`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`;
        } else if (this.icon) {
          return x6`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`;
        }
        return null;
      }
    };
    WuiListWallet.styles = [resetStyles, elementStyles, styles_default9];
    __decorate10([
      n8({ type: Array })
    ], WuiListWallet.prototype, "walletImages", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "imageSrc", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "name", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "tagLabel", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "tagVariant", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "icon", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "walletIcon", void 0);
    __decorate10([
      n8()
    ], WuiListWallet.prototype, "tabIdx", void 0);
    __decorate10([
      n8({ type: Boolean })
    ], WuiListWallet.prototype, "installed", void 0);
    __decorate10([
      n8({ type: Boolean })
    ], WuiListWallet.prototype, "disabled", void 0);
    __decorate10([
      n8({ type: Boolean })
    ], WuiListWallet.prototype, "showAllWallets", void 0);
    __decorate10([
      n8({ type: Boolean })
    ], WuiListWallet.prototype, "loading", void 0);
    __decorate10([
      n8({ type: String })
    ], WuiListWallet.prototype, "loadingSpinnerColor", void 0);
    WuiListWallet = __decorate10([
      customElement("wui-list-wallet")
    ], WuiListWallet);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-list-wallet.js
var init_wui_list_wallet2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-list-wallet.js"() {
    init_wui_list_wallet();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-widget/index.js
var __decorate11, W3mAllWalletsWidget;
var init_w3m_all_wallets_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_list_wallet2();
    __decorate11 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mAllWalletsWidget = class W3mAllWalletsWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.count = ApiController.state.count;
        this.filteredCount = ApiController.state.filteredWallets.length;
        this.isFetchingRecommendedWallets = ApiController.state.isFetchingRecommendedWallets;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController.subscribeKey("count", (val) => this.count = val), ApiController.subscribeKey("filteredWallets", (val) => this.filteredCount = val.length), ApiController.subscribeKey("isFetchingRecommendedWallets", (val) => this.isFetchingRecommendedWallets = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const wcConnector = this.connectors.find((c12) => c12.id === "walletConnect");
        const { allWallets } = OptionsController.state;
        if (!wcConnector || allWallets === "HIDE") {
          return null;
        }
        if (allWallets === "ONLY_MOBILE" && !CoreHelperUtil.isMobile()) {
          return null;
        }
        const featuredCount = ApiController.state.featured.length;
        const rawCount = this.count + featuredCount;
        const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
        const count = this.filteredCount > 0 ? this.filteredCount : roundedCount;
        let tagLabel = `${count}`;
        if (this.filteredCount > 0) {
          tagLabel = `${this.filteredCount}`;
        } else if (count < rawCount) {
          tagLabel = `${count}+`;
        }
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
        tabIdx=${o10(this.tabIdx)}
        .loading=${this.isFetchingRecommendedWallets}
        loadingSpinnerColor=${this.isFetchingRecommendedWallets ? "fg-300" : "accent-100"}
        ?disabled=${hasWcConnection}
      ></wui-list-wallet>
    `;
      }
      onAllWallets() {
        EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
        RouterController.push("AllWallets");
      }
    };
    __decorate11([
      n8()
    ], W3mAllWalletsWidget.prototype, "tabIdx", void 0);
    __decorate11([
      r7()
    ], W3mAllWalletsWidget.prototype, "connectors", void 0);
    __decorate11([
      r7()
    ], W3mAllWalletsWidget.prototype, "count", void 0);
    __decorate11([
      r7()
    ], W3mAllWalletsWidget.prototype, "filteredCount", void 0);
    __decorate11([
      r7()
    ], W3mAllWalletsWidget.prototype, "isFetchingRecommendedWallets", void 0);
    W3mAllWalletsWidget = __decorate11([
      customElement("w3m-all-wallets-widget")
    ], W3mAllWalletsWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-announced-widget/index.js
var __decorate12, W3mConnectAnnouncedWidget;
var init_w3m_connect_announced_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-announced-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    init_exports2();
    init_ConnectorUtil();
    __decorate12 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectAnnouncedWidget = class W3mConnectAnnouncedWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.connections = ConnectionController.state.connections;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ConnectionController.subscribeKey("connections", (val) => this.connections = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const announcedConnectors = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
        if (!announcedConnectors?.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${announcedConnectors.filter(ConnectorUtil.showConnector).map((connector) => {
          const connectionsByNamespace = this.connections.get(connector.chain) ?? [];
          const isAlreadyConnected = connectionsByNamespace.some((c12) => HelpersUtil.isLowerCaseMatch(c12.connectorId, connector.id));
          return x6`
            <wui-list-wallet
              imageSrc=${o10(AssetUtil.getConnectorImage(connector))}
              name=${connector.name ?? "Unknown"}
              @click=${() => this.onConnector(connector)}
              tagVariant=${isAlreadyConnected ? "shade" : "success"}
              tagLabel=${isAlreadyConnected ? "connected" : "installed"}
              data-testid=${`wallet-selector-${connector.id}`}
              .installed=${true}
              tabIdx=${o10(this.tabIdx)}
            >
            </wui-list-wallet>
          `;
        })}
      </wui-flex>
    `;
      }
      onConnector(connector) {
        if (connector.id === "walletConnect") {
          if (CoreHelperUtil.isMobile()) {
            RouterController.push("AllWallets");
          } else {
            RouterController.push("ConnectingWalletConnect");
          }
        } else {
          RouterController.push("ConnectingExternal", { connector });
        }
      }
    };
    __decorate12([
      n8()
    ], W3mConnectAnnouncedWidget.prototype, "tabIdx", void 0);
    __decorate12([
      r7()
    ], W3mConnectAnnouncedWidget.prototype, "connectors", void 0);
    __decorate12([
      r7()
    ], W3mConnectAnnouncedWidget.prototype, "connections", void 0);
    W3mConnectAnnouncedWidget = __decorate12([
      customElement("w3m-connect-announced-widget")
    ], W3mConnectAnnouncedWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-custom-widget/index.js
var __decorate13, W3mConnectCustomWidget;
var init_w3m_connect_custom_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-custom-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    __decorate13 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectCustomWidget = class W3mConnectCustomWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.loading = false;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
        if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
          this.loading = !ConnectionController.state.wcUri;
          this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", (val) => this.loading = !val));
        }
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const { customWallets } = OptionsController.state;
        if (!customWallets?.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        const wallets = this.filterOutDuplicateWallets(customWallets);
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`<wui-flex flexDirection="column" gap="xs">
      ${wallets.map((wallet) => x6`
          <wui-list-wallet
            imageSrc=${o10(AssetUtil.getWalletImage(wallet))}
            name=${wallet.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(wallet)}
            data-testid=${`wallet-selector-${wallet.id}`}
            tabIdx=${o10(this.tabIdx)}
            ?loading=${this.loading}
            ?disabled=${hasWcConnection}
          >
          </wui-list-wallet>
        `)}
    </wui-flex>`;
      }
      filterOutDuplicateWallets(wallets) {
        const recent = StorageUtil.getRecentWallets();
        const connectorRDNSs = this.connectors.map((connector) => connector.info?.rdns).filter(Boolean);
        const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
        const allRDNSs = connectorRDNSs.concat(recentRDNSs);
        if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
          const index2 = allRDNSs.indexOf("io.metamask.mobile");
          allRDNSs[index2] = "io.metamask";
        }
        const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet?.rdns)));
        return filtered;
      }
      onConnectWallet(wallet) {
        if (this.loading) {
          return;
        }
        RouterController.push("ConnectingWalletConnect", { wallet });
      }
    };
    __decorate13([
      n8()
    ], W3mConnectCustomWidget.prototype, "tabIdx", void 0);
    __decorate13([
      r7()
    ], W3mConnectCustomWidget.prototype, "connectors", void 0);
    __decorate13([
      r7()
    ], W3mConnectCustomWidget.prototype, "loading", void 0);
    W3mConnectCustomWidget = __decorate13([
      customElement("w3m-connect-custom-widget")
    ], W3mConnectCustomWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-external-widget/index.js
var __decorate14, W3mConnectExternalWidget;
var init_w3m_connect_external_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-external-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    init_ConnectorUtil();
    __decorate14 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectExternalWidget = class W3mConnectExternalWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const externalConnectors = this.connectors.filter((connector) => connector.type === "EXTERNAL");
        const filteredOutExcludedConnectors = externalConnectors.filter(ConnectorUtil.showConnector);
        const filteredOutCoinbaseConnectors = filteredOutExcludedConnectors.filter((connector) => connector.id !== ConstantsUtil.CONNECTOR_ID.COINBASE_SDK);
        if (!filteredOutCoinbaseConnectors?.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${filteredOutCoinbaseConnectors.map((connector) => x6`
            <wui-list-wallet
              imageSrc=${o10(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${o10(this.tabIdx)}
              ?disabled=${hasWcConnection}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
      }
      onConnector(connector) {
        RouterController.push("ConnectingExternal", { connector });
      }
    };
    __decorate14([
      n8()
    ], W3mConnectExternalWidget.prototype, "tabIdx", void 0);
    __decorate14([
      r7()
    ], W3mConnectExternalWidget.prototype, "connectors", void 0);
    W3mConnectExternalWidget = __decorate14([
      customElement("w3m-connect-external-widget")
    ], W3mConnectExternalWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-featured-widget/index.js
var __decorate15, W3mConnectFeaturedWidget;
var init_w3m_connect_featured_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-featured-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    __decorate15 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectFeaturedWidget = class W3mConnectFeaturedWidget2 extends i7 {
      constructor() {
        super(...arguments);
        this.tabIdx = void 0;
        this.wallets = [];
      }
      render() {
        if (!this.wallets.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${this.wallets.map((wallet) => x6`
            <wui-list-wallet
              data-testid=${`wallet-selector-featured-${wallet.id}`}
              imageSrc=${o10(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tabIdx=${o10(this.tabIdx)}
              ?disabled=${hasWcConnection}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
      }
      onConnectWallet(wallet) {
        ConnectorController.selectWalletConnector(wallet);
      }
    };
    __decorate15([
      n8()
    ], W3mConnectFeaturedWidget.prototype, "tabIdx", void 0);
    __decorate15([
      n8()
    ], W3mConnectFeaturedWidget.prototype, "wallets", void 0);
    W3mConnectFeaturedWidget = __decorate15([
      customElement("w3m-connect-featured-widget")
    ], W3mConnectFeaturedWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-injected-widget/index.js
var __decorate16, W3mConnectInjectedWidget;
var init_w3m_connect_injected_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-injected-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    init_exports2();
    init_ConnectorUtil();
    __decorate16 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectInjectedWidget = class W3mConnectInjectedWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = [];
        this.connections = ConnectionController.state.connections;
        this.unsubscribe.push(ConnectionController.subscribeKey("connections", (val) => this.connections = val));
      }
      render() {
        const injectedConnectors = this.connectors.filter(ConnectorUtil.showConnector);
        if (injectedConnectors.length === 0) {
          this.style.cssText = `display: none`;
          return null;
        }
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${injectedConnectors.map((connector) => {
          const connectionsByNamespace = this.connections.get(connector.chain) ?? [];
          const isAlreadyConnected = connectionsByNamespace.some((c12) => HelpersUtil.isLowerCaseMatch(c12.connectorId, connector.id));
          return x6`
            <wui-list-wallet
              imageSrc=${o10(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant=${isAlreadyConnected ? "shade" : "success"}
              tagLabel=${isAlreadyConnected ? "connected" : "installed"}
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${o10(this.tabIdx)}
            >
            </wui-list-wallet>
          `;
        })}
      </wui-flex>
    `;
      }
      onConnector(connector) {
        ConnectorController.setActiveConnector(connector);
        RouterController.push("ConnectingExternal", { connector });
      }
    };
    __decorate16([
      n8()
    ], W3mConnectInjectedWidget.prototype, "tabIdx", void 0);
    __decorate16([
      n8()
    ], W3mConnectInjectedWidget.prototype, "connectors", void 0);
    __decorate16([
      r7()
    ], W3mConnectInjectedWidget.prototype, "connections", void 0);
    W3mConnectInjectedWidget = __decorate16([
      customElement("w3m-connect-injected-widget")
    ], W3mConnectInjectedWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-multi-chain-widget/index.js
var __decorate17, W3mConnectMultiChainWidget;
var init_w3m_connect_multi_chain_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-multi-chain-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    __decorate17 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectMultiChainWidget = class W3mConnectMultiChainWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const multiChainConnectors = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN" && connector.name !== "WalletConnect");
        if (!multiChainConnectors?.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${multiChainConnectors.map((connector) => x6`
            <wui-list-wallet
              imageSrc=${o10(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="shade"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
              tabIdx=${o10(this.tabIdx)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
      }
      onConnector(connector) {
        ConnectorController.setActiveConnector(connector);
        RouterController.push("ConnectingMultiChain");
      }
    };
    __decorate17([
      n8()
    ], W3mConnectMultiChainWidget.prototype, "tabIdx", void 0);
    __decorate17([
      r7()
    ], W3mConnectMultiChainWidget.prototype, "connectors", void 0);
    W3mConnectMultiChainWidget = __decorate17([
      customElement("w3m-connect-multi-chain-widget")
    ], W3mConnectMultiChainWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recent-widget/index.js
var __decorate18, W3mConnectRecentWidget;
var init_w3m_connect_recent_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recent-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    init_WalletUtil();
    __decorate18 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectRecentWidget = class W3mConnectRecentWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.loading = false;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
        if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
          this.loading = !ConnectionController.state.wcUri;
          this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", (val) => this.loading = !val));
        }
      }
      render() {
        const recentWallets = StorageUtil.getRecentWallets();
        const filteredRecentWallets = recentWallets.filter((wallet) => !WalletUtil.isExcluded(wallet)).filter((wallet) => !this.hasWalletConnector(wallet)).filter((wallet) => this.isWalletCompatibleWithCurrentChain(wallet));
        if (!filteredRecentWallets.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${filteredRecentWallets.map((wallet) => x6`
            <wui-list-wallet
              imageSrc=${o10(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tagLabel="recent"
              tagVariant="shade"
              tabIdx=${o10(this.tabIdx)}
              ?loading=${this.loading}
              ?disabled=${hasWcConnection}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
      }
      onConnectWallet(wallet) {
        if (this.loading) {
          return;
        }
        ConnectorController.selectWalletConnector(wallet);
      }
      hasWalletConnector(wallet) {
        return this.connectors.some((connector) => connector.id === wallet.id || connector.name === wallet.name);
      }
      isWalletCompatibleWithCurrentChain(wallet) {
        const currentNamespace = ChainController.state.activeChain;
        if (currentNamespace && wallet.chains) {
          return wallet.chains.some((c12) => {
            const chainNamespace = c12.split(":")[0];
            return currentNamespace === chainNamespace;
          });
        }
        return true;
      }
    };
    __decorate18([
      n8()
    ], W3mConnectRecentWidget.prototype, "tabIdx", void 0);
    __decorate18([
      r7()
    ], W3mConnectRecentWidget.prototype, "connectors", void 0);
    __decorate18([
      r7()
    ], W3mConnectRecentWidget.prototype, "loading", void 0);
    W3mConnectRecentWidget = __decorate18([
      customElement("w3m-connect-recent-widget")
    ], W3mConnectRecentWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recommended-widget/index.js
var __decorate19, W3mConnectRecommendedWidget;
var init_w3m_connect_recommended_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recommended-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_wallet2();
    init_WalletUtil();
    __decorate19 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectRecommendedWidget = class W3mConnectRecommendedWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.wallets = [];
        this.loading = false;
        if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
          this.loading = !ConnectionController.state.wcUri;
          this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", (val) => this.loading = !val));
        }
      }
      render() {
        const { connectors } = ConnectorController.state;
        const { customWallets, featuredWalletIds } = OptionsController.state;
        const recentWallets = StorageUtil.getRecentWallets();
        const wcConnector = connectors.find((c12) => c12.id === "walletConnect");
        const injectedConnectors = connectors.filter((c12) => c12.type === "INJECTED" || c12.type === "ANNOUNCED" || c12.type === "MULTI_CHAIN");
        const injectedWallets = injectedConnectors.filter((i11) => i11.name !== "Browser Wallet");
        if (!wcConnector) {
          return null;
        }
        if (featuredWalletIds || customWallets || !this.wallets.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        const overrideLength = injectedWallets.length + recentWallets.length;
        const maxRecommended = Math.max(0, 2 - overrideLength);
        const wallets = WalletUtil.filterOutDuplicateWallets(this.wallets).slice(0, maxRecommended);
        if (!wallets.length) {
          this.style.cssText = `display: none`;
          return null;
        }
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => x6`
            <wui-list-wallet
              imageSrc=${o10(AssetUtil.getWalletImage(wallet))}
              name=${wallet?.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tabIdx=${o10(this.tabIdx)}
              ?loading=${this.loading}
              ?disabled=${hasWcConnection}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
      }
      onConnectWallet(wallet) {
        if (this.loading) {
          return;
        }
        const connector = ConnectorController.getConnector({
          id: wallet.id,
          rdns: wallet.rdns
        });
        if (connector) {
          RouterController.push("ConnectingExternal", { connector });
        } else {
          RouterController.push("ConnectingWalletConnect", { wallet });
        }
      }
    };
    __decorate19([
      n8()
    ], W3mConnectRecommendedWidget.prototype, "tabIdx", void 0);
    __decorate19([
      n8()
    ], W3mConnectRecommendedWidget.prototype, "wallets", void 0);
    __decorate19([
      r7()
    ], W3mConnectRecommendedWidget.prototype, "loading", void 0);
    W3mConnectRecommendedWidget = __decorate19([
      customElement("w3m-connect-recommended-widget")
    ], W3mConnectRecommendedWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-walletconnect-widget/index.js
var __decorate20, W3mConnectWalletConnectWidget;
var init_w3m_connect_walletconnect_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-walletconnect-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_list_wallet2();
    __decorate20 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectWalletConnectWidget = class W3mConnectWalletConnectWidget2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.connectorImages = AssetController.state.connectorImages;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), AssetController.subscribeKey("connectorImages", (val) => this.connectorImages = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        if (CoreHelperUtil.isMobile()) {
          this.style.cssText = `display: none`;
          return null;
        }
        const connector = this.connectors.find((c12) => c12.id === "walletConnect");
        if (!connector) {
          this.style.cssText = `display: none`;
          return null;
        }
        const connectorImage = connector.imageUrl || this.connectorImages[connector?.imageId ?? ""];
        const hasWcConnection = ConnectionController.hasAnyConnection(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        return x6`
      <wui-list-wallet
        imageSrc=${o10(connectorImage)}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        tabIdx=${o10(this.tabIdx)}
        data-testid="wallet-selector-walletconnect"
        ?disabled=${hasWcConnection}
      >
      </wui-list-wallet>
    `;
      }
      onConnector(connector) {
        ConnectorController.setActiveConnector(connector);
        RouterController.push("ConnectingWalletConnect");
      }
    };
    __decorate20([
      n8()
    ], W3mConnectWalletConnectWidget.prototype, "tabIdx", void 0);
    __decorate20([
      r7()
    ], W3mConnectWalletConnectWidget.prototype, "connectors", void 0);
    __decorate20([
      r7()
    ], W3mConnectWalletConnectWidget.prototype, "connectorImages", void 0);
    W3mConnectWalletConnectWidget = __decorate20([
      customElement("w3m-connect-walletconnect-widget")
    ], W3mConnectWalletConnectWidget);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/styles.js
var styles_default10;
var init_styles10 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/styles.js"() {
    init_lit();
    styles_default10 = i4`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/index.js
var __decorate21, W3mConnectorList;
var init_w3m_connector_list = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_w3m_connect_announced_widget();
    init_w3m_connect_custom_widget();
    init_w3m_connect_external_widget();
    init_w3m_connect_featured_widget();
    init_w3m_connect_injected_widget();
    init_w3m_connect_multi_chain_widget();
    init_w3m_connect_recent_widget();
    init_w3m_connect_recommended_widget();
    init_w3m_connect_walletconnect_widget();
    init_ConnectorUtil();
    init_styles10();
    __decorate21 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectorList = class W3mConnectorList2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.tabIdx = void 0;
        this.connectors = ConnectorController.state.connectors;
        this.recommended = ApiController.state.recommended;
        this.featured = ApiController.state.featured;
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController.subscribeKey("recommended", (val) => this.recommended = val), ApiController.subscribeKey("featured", (val) => this.featured = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        return x6`
      <wui-flex flexDirection="column" gap="xs"> ${this.connectorListTemplate()} </wui-flex>
    `;
      }
      connectorListTemplate() {
        const { custom, recent, announced, injected, multiChain, recommended, featured, external } = ConnectorUtil.getConnectorsByType(this.connectors, this.recommended, this.featured);
        const connectorTypeOrder = ConnectorUtil.getConnectorTypeOrder({
          custom,
          recent,
          announced,
          injected,
          multiChain,
          recommended,
          featured,
          external
        });
        return connectorTypeOrder.map((type) => {
          switch (type) {
            case "injected":
              return x6`
            ${multiChain.length ? x6`<w3m-connect-multi-chain-widget
                  tabIdx=${o10(this.tabIdx)}
                ></w3m-connect-multi-chain-widget>` : null}
            ${announced.length ? x6`<w3m-connect-announced-widget
                  tabIdx=${o10(this.tabIdx)}
                ></w3m-connect-announced-widget>` : null}
            ${injected.length ? x6`<w3m-connect-injected-widget
                  .connectors=${injected}
                  tabIdx=${o10(this.tabIdx)}
                ></w3m-connect-injected-widget>` : null}
          `;
            case "walletConnect":
              return x6`<w3m-connect-walletconnect-widget
            tabIdx=${o10(this.tabIdx)}
          ></w3m-connect-walletconnect-widget>`;
            case "recent":
              return x6`<w3m-connect-recent-widget
            tabIdx=${o10(this.tabIdx)}
          ></w3m-connect-recent-widget>`;
            case "featured":
              return x6`<w3m-connect-featured-widget
            .wallets=${featured}
            tabIdx=${o10(this.tabIdx)}
          ></w3m-connect-featured-widget>`;
            case "custom":
              return x6`<w3m-connect-custom-widget
            tabIdx=${o10(this.tabIdx)}
          ></w3m-connect-custom-widget>`;
            case "external":
              return x6`<w3m-connect-external-widget
            tabIdx=${o10(this.tabIdx)}
          ></w3m-connect-external-widget>`;
            case "recommended":
              return x6`<w3m-connect-recommended-widget
            .wallets=${recommended}
            tabIdx=${o10(this.tabIdx)}
          ></w3m-connect-recommended-widget>`;
            default:
              console.warn(`Unknown connector type: ${type}`);
              return null;
          }
        });
      }
    };
    W3mConnectorList.styles = styles_default10;
    __decorate21([
      n8()
    ], W3mConnectorList.prototype, "tabIdx", void 0);
    __decorate21([
      r7()
    ], W3mConnectorList.prototype, "connectors", void 0);
    __decorate21([
      r7()
    ], W3mConnectorList.prototype, "recommended", void 0);
    __decorate21([
      r7()
    ], W3mConnectorList.prototype, "featured", void 0);
    W3mConnectorList = __decorate21([
      customElement("w3m-connector-list")
    ], W3mConnectorList);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tabs/styles.js
var styles_default11;
var init_styles11 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tabs/styles.js"() {
    init_lit();
    styles_default11 = i4`
  :host {
    display: inline-flex;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    min-height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: color var(--wui-e ase-out-power-1) var(--wui-duration-md);
    will-change: color;
  }

  button {
    width: var(--local-tab-width);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tabs/index.js
var __decorate22, WuiTabs;
var init_wui_tabs = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-tabs/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_wui_text();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles11();
    __decorate22 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiTabs = class WuiTabs2 extends i7 {
      constructor() {
        super(...arguments);
        this.tabs = [];
        this.onTabChange = () => null;
        this.buttons = [];
        this.disabled = false;
        this.localTabWidth = "100px";
        this.activeTab = 0;
        this.isDense = false;
      }
      render() {
        this.isDense = this.tabs.length > 3;
        this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
        this.dataset["type"] = this.isDense ? "flex" : "block";
        return this.tabs.map((tab, index2) => {
          const isActive = index2 === this.activeTab;
          return x6`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index2)}
          data-active=${isActive}
          data-testid="tab-${tab.label?.toLowerCase()}"
        >
          ${this.iconTemplate(tab)}
          <wui-text variant="small-600" color="inherit"> ${tab.label} </wui-text>
        </button>
      `;
        });
      }
      firstUpdated() {
        if (this.shadowRoot && this.isDense) {
          this.buttons = [...this.shadowRoot.querySelectorAll("button")];
          setTimeout(() => {
            this.animateTabs(0, true);
          }, 0);
        }
      }
      iconTemplate(tab) {
        if (tab.icon) {
          return x6`<wui-icon size="xs" color="inherit" name=${tab.icon}></wui-icon>`;
        }
        return null;
      }
      onTabClick(index2) {
        if (this.buttons) {
          this.animateTabs(index2, false);
        }
        this.activeTab = index2;
        this.onTabChange(index2);
      }
      animateTabs(index2, initialAnimation) {
        const passiveBtn = this.buttons[this.activeTab];
        const activeBtn = this.buttons[index2];
        const passiveBtnText = passiveBtn?.querySelector("wui-text");
        const activeBtnText = activeBtn?.querySelector("wui-text");
        const activeBtnBounds = activeBtn?.getBoundingClientRect();
        const activeBtnTextBounds = activeBtnText?.getBoundingClientRect();
        if (passiveBtn && passiveBtnText && !initialAnimation && index2 !== this.activeTab) {
          passiveBtnText.animate([{ opacity: 0 }], {
            duration: 50,
            easing: "ease",
            fill: "forwards"
          });
          passiveBtn.animate([{ width: `34px` }], {
            duration: 500,
            easing: "ease",
            fill: "forwards"
          });
        }
        if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
          if (index2 !== this.activeTab || initialAnimation) {
            this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
            activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
              duration: initialAnimation ? 0 : 500,
              fill: "forwards",
              easing: "ease"
            });
            activeBtnText.animate([{ opacity: 1 }], {
              duration: initialAnimation ? 0 : 125,
              delay: initialAnimation ? 0 : 200,
              fill: "forwards",
              easing: "ease"
            });
          }
        }
      }
    };
    WuiTabs.styles = [resetStyles, elementStyles, styles_default11];
    __decorate22([
      n8({ type: Array })
    ], WuiTabs.prototype, "tabs", void 0);
    __decorate22([
      n8()
    ], WuiTabs.prototype, "onTabChange", void 0);
    __decorate22([
      n8({ type: Array })
    ], WuiTabs.prototype, "buttons", void 0);
    __decorate22([
      n8({ type: Boolean })
    ], WuiTabs.prototype, "disabled", void 0);
    __decorate22([
      n8()
    ], WuiTabs.prototype, "localTabWidth", void 0);
    __decorate22([
      r7()
    ], WuiTabs.prototype, "activeTab", void 0);
    __decorate22([
      r7()
    ], WuiTabs.prototype, "isDense", void 0);
    WuiTabs = __decorate22([
      customElement("wui-tabs")
    ], WuiTabs);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-tabs.js
var init_wui_tabs2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-tabs.js"() {
    init_wui_tabs();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-header/index.js
var __decorate23, W3mConnectingHeader;
var init_w3m_connecting_header = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-header/index.js"() {
    init_lit();
    init_decorators();
    init_exports3();
    init_wui_flex2();
    init_wui_tabs2();
    __decorate23 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingHeader = class W3mConnectingHeader2 extends i7 {
      constructor() {
        super(...arguments);
        this.platformTabs = [];
        this.unsubscribe = [];
        this.platforms = [];
        this.onSelectPlatfrom = void 0;
      }
      disconnectCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const tabs = this.generateTabs();
        return x6`
      <wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <wui-tabs .tabs=${tabs} .onTabChange=${this.onTabChange.bind(this)}></wui-tabs>
      </wui-flex>
    `;
      }
      generateTabs() {
        const tabs = this.platforms.map((platform) => {
          if (platform === "browser") {
            return { label: "Browser", icon: "extension", platform: "browser" };
          } else if (platform === "mobile") {
            return { label: "Mobile", icon: "mobile", platform: "mobile" };
          } else if (platform === "qrcode") {
            return { label: "Mobile", icon: "mobile", platform: "qrcode" };
          } else if (platform === "web") {
            return { label: "Webapp", icon: "browser", platform: "web" };
          } else if (platform === "desktop") {
            return { label: "Desktop", icon: "desktop", platform: "desktop" };
          }
          return { label: "Browser", icon: "extension", platform: "unsupported" };
        });
        this.platformTabs = tabs.map(({ platform }) => platform);
        return tabs;
      }
      onTabChange(index2) {
        const tab = this.platformTabs[index2];
        if (tab) {
          this.onSelectPlatfrom?.(tab);
        }
      }
    };
    __decorate23([
      n8({ type: Array })
    ], W3mConnectingHeader.prototype, "platforms", void 0);
    __decorate23([
      n8()
    ], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
    W3mConnectingHeader = __decorate23([
      customElement("w3m-connecting-header")
    ], W3mConnectingHeader);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-spinner/styles.js
var styles_default12;
var init_styles12 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-spinner/styles.js"() {
    init_lit();
    styles_default12 = i4`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-spinner/index.js
var __decorate24, WuiLoadingSpinner;
var init_wui_loading_spinner = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-spinner/index.js"() {
    init_lit();
    init_decorators();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles12();
    __decorate24 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiLoadingSpinner = class WuiLoadingSpinner2 extends i7 {
      constructor() {
        super(...arguments);
        this.color = "accent-100";
        this.size = "lg";
      }
      render() {
        this.style.cssText = `--local-color: ${this.color === "inherit" ? "inherit" : `var(--wui-color-${this.color})`}`;
        this.dataset["size"] = this.size;
        return x6`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
      }
    };
    WuiLoadingSpinner.styles = [resetStyles, styles_default12];
    __decorate24([
      n8()
    ], WuiLoadingSpinner.prototype, "color", void 0);
    __decorate24([
      n8()
    ], WuiLoadingSpinner.prototype, "size", void 0);
    WuiLoadingSpinner = __decorate24([
      customElement("wui-loading-spinner")
    ], WuiLoadingSpinner);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-button/styles.js
var styles_default13;
var init_styles13 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-button/styles.js"() {
    init_lit();
    styles_default13 = i4`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: none;
    border-radius: var(--local-border-radius);
    width: var(--local-width);
    white-space: nowrap;
  }

  /* -- Sizes --------------------------------------------------- */
  button[data-size='xs'] {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-s) var(--wui-spacing-3xs) var(--wui-spacing-s);
    height: 24px;
  }

  button[data-size='xs'][data-icon-left='true'][data-icon-right='false'] {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-s) var(--wui-spacing-3xs) var(--wui-spacing-s);
  }

  button[data-size='xs'][data-icon-right='true'][data-icon-left='false'] {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-s) var(--wui-spacing-3xs) var(--wui-spacing-s);
  }

  button[data-size='sm'] {
    padding: 7.2px var(--wui-spacing-s) 7.2px var(--wui-spacing-s);
    height: 32px;
  }

  button[data-size='sm'][data-icon-left='true'][data-icon-right='false'] {
    padding: 7.2px var(--wui-spacing-s) 7.2px var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-right='true'][data-icon-left='false'] {
    padding: 7.2px var(--wui-spacing-s) 7.2px var(--wui-spacing-s);
  }

  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
    height: 36px;
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
    height: 48px;
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='inverse'] {
    background-color: var(--wui-color-inverse-100);
    color: var(--wui-color-inverse-000);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='accent-error'] {
    background: var(--wui-color-error-glass-015);
    color: var(--wui-color-error-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-error-glass-010);
  }

  button[data-variant='accent-success'] {
    background: var(--wui-color-success-glass-015);
    color: var(--wui-color-success-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-success-glass-010);
  }

  button[data-variant='neutral'] {
    background: transparent;
    color: var(--wui-color-fg-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  /* -- Focus states --------------------------------------------------- */
  button[data-variant='main']:focus-visible:enabled {
    background-color: var(--wui-color-accent-090);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='inverse']:focus-visible:enabled {
    background-color: var(--wui-color-inverse-100);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent']:focus-visible:enabled {
    background-color: var(--wui-color-accent-glass-010);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent-error']:focus-visible:enabled {
    background: var(--wui-color-error-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-error-100),
      0 0 0 4px var(--wui-color-error-glass-020);
  }
  button[data-variant='accent-success']:focus-visible:enabled {
    background: var(--wui-color-success-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-success-100),
      0 0 0 4px var(--wui-color-success-glass-020);
  }
  button[data-variant='neutral']:focus-visible:enabled {
    background: var(--wui-color-gray-glass-005);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-gray-glass-002);
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='accent-error']:hover:enabled {
      background: var(--wui-color-error-glass-020);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-error']:active:enabled {
      background: var(--wui-color-error-glass-030);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-success']:hover:enabled {
      background: var(--wui-color-success-glass-020);
      color: var(--wui-color-success-100);
    }

    button[data-variant='accent-success']:active:enabled {
      background: var(--wui-color-success-glass-030);
      color: var(--wui-color-success-100);
    }

    button[data-variant='neutral']:hover:enabled {
      background: var(--wui-color-gray-glass-002);
    }

    button[data-variant='neutral']:active:enabled {
      background: var(--wui-color-gray-glass-005);
    }

    button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
      padding-left: var(--wui-spacing-m);
    }

    button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
      padding-right: var(--wui-spacing-m);
    }
  }

  /* -- Disabled state --------------------------------------------------- */
  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    color: var(--wui-color-gray-glass-020);
    cursor: not-allowed;
  }

  button > wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-button/index.js
var __decorate25, SPINNER_COLOR_BY_VARIANT, TEXT_VARIANT_BY_SIZE, SPINNER_SIZE_BY_SIZE, WuiButton;
var init_wui_button = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-button/index.js"() {
    init_lit();
    init_decorators();
    init_wui_loading_spinner();
    init_wui_text();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles13();
    __decorate25 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    SPINNER_COLOR_BY_VARIANT = {
      main: "inverse-100",
      inverse: "inverse-000",
      accent: "accent-100",
      "accent-error": "error-100",
      "accent-success": "success-100",
      neutral: "fg-100",
      disabled: "gray-glass-020"
    };
    TEXT_VARIANT_BY_SIZE = {
      lg: "paragraph-600",
      md: "small-600",
      sm: "small-600",
      xs: "tiny-600"
    };
    SPINNER_SIZE_BY_SIZE = {
      lg: "md",
      md: "md",
      sm: "sm",
      xs: "sm"
    };
    WuiButton = class WuiButton2 extends i7 {
      constructor() {
        super(...arguments);
        this.size = "lg";
        this.disabled = false;
        this.fullWidth = false;
        this.loading = false;
        this.variant = "main";
        this.hasIconLeft = false;
        this.hasIconRight = false;
        this.borderRadius = "m";
      }
      render() {
        this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
        const textVariant = this.textVariant ?? TEXT_VARIANT_BY_SIZE[this.size];
        return x6`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled}
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
      }
      handleSlotLeftChange() {
        this.hasIconLeft = true;
      }
      handleSlotRightChange() {
        this.hasIconRight = true;
      }
      loadingTemplate() {
        if (this.loading) {
          const size4 = SPINNER_SIZE_BY_SIZE[this.size];
          const color = this.disabled ? SPINNER_COLOR_BY_VARIANT["disabled"] : SPINNER_COLOR_BY_VARIANT[this.variant];
          return x6`<wui-loading-spinner color=${color} size=${size4}></wui-loading-spinner>`;
        }
        return x6``;
      }
    };
    WuiButton.styles = [resetStyles, elementStyles, styles_default13];
    __decorate25([
      n8()
    ], WuiButton.prototype, "size", void 0);
    __decorate25([
      n8({ type: Boolean })
    ], WuiButton.prototype, "disabled", void 0);
    __decorate25([
      n8({ type: Boolean })
    ], WuiButton.prototype, "fullWidth", void 0);
    __decorate25([
      n8({ type: Boolean })
    ], WuiButton.prototype, "loading", void 0);
    __decorate25([
      n8()
    ], WuiButton.prototype, "variant", void 0);
    __decorate25([
      n8({ type: Boolean })
    ], WuiButton.prototype, "hasIconLeft", void 0);
    __decorate25([
      n8({ type: Boolean })
    ], WuiButton.prototype, "hasIconRight", void 0);
    __decorate25([
      n8()
    ], WuiButton.prototype, "borderRadius", void 0);
    __decorate25([
      n8()
    ], WuiButton.prototype, "textVariant", void 0);
    WuiButton = __decorate25([
      customElement("wui-button")
    ], WuiButton);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-button.js
var init_wui_button2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-button.js"() {
    init_wui_button();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-icon.js
var init_wui_icon2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-icon.js"() {
    init_wui_icon();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-icon-box.js
var init_wui_icon_box2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-icon-box.js"() {
    init_wui_icon_box();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-link/styles.js
var styles_default14;
var init_styles14 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-link/styles.js"() {
    init_lit();
    styles_default14 = i4`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-color-gray-glass-015);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-link/index.js
var __decorate26, WuiLink;
var init_wui_link = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-link/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_wui_text();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles14();
    __decorate26 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiLink = class WuiLink2 extends i7 {
      constructor() {
        super(...arguments);
        this.tabIdx = void 0;
        this.disabled = false;
        this.color = "inherit";
      }
      render() {
        return x6`
      <button ?disabled=${this.disabled} tabindex=${o10(this.tabIdx)}>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
      }
    };
    WuiLink.styles = [resetStyles, elementStyles, styles_default14];
    __decorate26([
      n8()
    ], WuiLink.prototype, "tabIdx", void 0);
    __decorate26([
      n8({ type: Boolean })
    ], WuiLink.prototype, "disabled", void 0);
    __decorate26([
      n8()
    ], WuiLink.prototype, "color", void 0);
    WuiLink = __decorate26([
      customElement("wui-link")
    ], WuiLink);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-link.js
var init_wui_link2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-link.js"() {
    init_wui_link();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-thumbnail/styles.js
var styles_default15;
var init_styles15 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-thumbnail/styles.js"() {
    init_lit();
    styles_default15 = i4`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-thumbnail/index.js
var __decorate27, WuiLoadingThumbnail;
var init_wui_loading_thumbnail = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-loading-thumbnail/index.js"() {
    init_lit();
    init_decorators();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles15();
    __decorate27 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiLoadingThumbnail = class WuiLoadingThumbnail2 extends i7 {
      constructor() {
        super(...arguments);
        this.radius = 36;
      }
      render() {
        return this.svgLoaderTemplate();
      }
      svgLoaderTemplate() {
        const radius = this.radius > 50 ? 50 : this.radius;
        const standardValue = 36;
        const radiusFactor = standardValue - radius;
        const dashArrayStart = 116 + radiusFactor;
        const dashArrayEnd = 245 + radiusFactor;
        const dashOffset = 360 + radiusFactor * 1.75;
        return x6`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
      }
    };
    WuiLoadingThumbnail.styles = [resetStyles, styles_default15];
    __decorate27([
      n8({ type: Number })
    ], WuiLoadingThumbnail.prototype, "radius", void 0);
    WuiLoadingThumbnail = __decorate27([
      customElement("wui-loading-thumbnail")
    ], WuiLoadingThumbnail);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-loading-thumbnail.js
var init_wui_loading_thumbnail2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-loading-thumbnail.js"() {
    init_wui_loading_thumbnail();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-text.js
var init_wui_text2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-text.js"() {
    init_wui_text();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-wallet-image.js
var init_wui_wallet_image2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-wallet-image.js"() {
    init_wui_wallet_image();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-chip-button/styles.js
var styles_default16;
var init_styles16 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-chip-button/styles.js"() {
    init_lit();
    styles_default16 = i4`
  button {
    border: none;
    border-radius: var(--wui-border-radius-3xl);
  }

  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='gray'] {
    background-color: transparent;
    color: var(--wui-color-fg-200);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='shade'] {
    background-color: transparent;
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-size='sm'] {
    height: 32px;
    padding: 0 var(--wui-spacing-s);
  }

  button[data-size='md'] {
    height: 40px;
    padding: 0 var(--wui-spacing-l);
  }

  button[data-size='sm'] > wui-image {
    width: 16px;
    height: 16px;
  }

  button[data-size='md'] > wui-image {
    width: 24px;
    height: 24px;
  }

  button[data-size='sm'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-size='md'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  button.disabled > wui-icon,
  button.disabled > wui-image {
    filter: grayscale(1);
  }

  button[data-variant='main'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  button[data-variant='shade'] > wui-image,
  button[data-variant='gray'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:focus-visible {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='shade']:focus-visible,
    button[data-variant='gray']:focus-visible,
    button[data-variant='shade']:hover,
    button[data-variant='gray']:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    button[data-variant='gray']:active,
    button[data-variant='shade']:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  button.disabled {
    color: var(--wui-color-gray-glass-020);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    pointer-events: none;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-chip-button/index.js
var __decorate28, WuiChipButton;
var init_wui_chip_button = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-chip-button/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_wui_image();
    init_wui_text();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles16();
    __decorate28 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiChipButton = class WuiChipButton2 extends i7 {
      constructor() {
        super(...arguments);
        this.variant = "accent";
        this.imageSrc = "";
        this.disabled = false;
        this.icon = "externalLink";
        this.size = "md";
        this.text = "";
      }
      render() {
        const textVariant = this.size === "sm" ? "small-600" : "paragraph-600";
        return x6`
      <button
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
        data-size=${this.size}
      >
        ${this.imageSrc ? x6`<wui-image src=${this.imageSrc}></wui-image>` : null}
        <wui-text variant=${textVariant} color="inherit"> ${this.text} </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </button>
    `;
      }
    };
    WuiChipButton.styles = [resetStyles, elementStyles, styles_default16];
    __decorate28([
      n8()
    ], WuiChipButton.prototype, "variant", void 0);
    __decorate28([
      n8()
    ], WuiChipButton.prototype, "imageSrc", void 0);
    __decorate28([
      n8({ type: Boolean })
    ], WuiChipButton.prototype, "disabled", void 0);
    __decorate28([
      n8()
    ], WuiChipButton.prototype, "icon", void 0);
    __decorate28([
      n8()
    ], WuiChipButton.prototype, "size", void 0);
    __decorate28([
      n8()
    ], WuiChipButton.prototype, "text", void 0);
    WuiChipButton = __decorate28([
      customElement("wui-chip-button")
    ], WuiChipButton);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-cta-button/styles.js
var styles_default17;
var init_styles17 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-cta-button/styles.js"() {
    init_lit();
    styles_default17 = i4`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-cta-button/index.js
var __decorate29, WuiCtaButton;
var init_wui_cta_button = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-cta-button/index.js"() {
    init_lit();
    init_decorators();
    init_wui_text();
    init_wui_chip_button();
    init_wui_flex();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles17();
    __decorate29 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiCtaButton = class WuiCtaButton2 extends i7 {
      constructor() {
        super(...arguments);
        this.disabled = false;
        this.label = "";
        this.buttonLabel = "";
      }
      render() {
        return x6`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-chip-button size="sm" variant="shade" text=${this.buttonLabel} icon="chevronRight">
        </wui-chip-button>
      </wui-flex>
    `;
      }
    };
    WuiCtaButton.styles = [resetStyles, elementStyles, styles_default17];
    __decorate29([
      n8({ type: Boolean })
    ], WuiCtaButton.prototype, "disabled", void 0);
    __decorate29([
      n8()
    ], WuiCtaButton.prototype, "label", void 0);
    __decorate29([
      n8()
    ], WuiCtaButton.prototype, "buttonLabel", void 0);
    WuiCtaButton = __decorate29([
      customElement("wui-cta-button")
    ], WuiCtaButton);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-cta-button.js
var init_wui_cta_button2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-cta-button.js"() {
    init_wui_cta_button();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/styles.js
var styles_default18;
var init_styles18 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/styles.js"() {
    init_lit();
    styles_default18 = i4`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/index.js
var __decorate30, W3mMobileDownloadLinks;
var init_w3m_mobile_download_links = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_wui_cta_button2();
    init_styles18();
    __decorate30 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends i7 {
      constructor() {
        super(...arguments);
        this.wallet = void 0;
      }
      render() {
        if (!this.wallet) {
          this.style.display = "none";
          return null;
        }
        const { name: name2, app_store, play_store, chrome_store, homepage } = this.wallet;
        const isMobile = CoreHelperUtil.isMobile();
        const isIos = CoreHelperUtil.isIos();
        const isAndroid = CoreHelperUtil.isAndroid();
        const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
        const shortName = UiHelperUtil.getTruncateString({
          string: name2,
          charsStart: 12,
          charsEnd: 0,
          truncate: "end"
        });
        if (isMultiple && !isMobile) {
          return x6`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
        }
        if (!isMultiple && homepage) {
          return x6`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
        }
        if (app_store && isIos) {
          return x6`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
        }
        if (play_store && isAndroid) {
          return x6`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
        }
        this.style.display = "none";
        return null;
      }
      onAppStore() {
        if (this.wallet?.app_store) {
          CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
        }
      }
      onPlayStore() {
        if (this.wallet?.play_store) {
          CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
        }
      }
      onHomePage() {
        if (this.wallet?.homepage) {
          CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
        }
      }
    };
    W3mMobileDownloadLinks.styles = [styles_default18];
    __decorate30([
      n8({ type: Object })
    ], W3mMobileDownloadLinks.prototype, "wallet", void 0);
    W3mMobileDownloadLinks = __decorate30([
      customElement("w3m-mobile-download-links")
    ], W3mMobileDownloadLinks);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/styles.js
var styles_default19;
var init_styles19 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/styles.js"() {
    init_lit();
    styles_default19 = i4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/index.js
var __decorate31, W3mConnectingWidget;
var init_w3m_connecting_widget = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_wui_button2();
    init_wui_flex2();
    init_wui_icon2();
    init_wui_icon_box2();
    init_wui_link2();
    init_wui_loading_thumbnail2();
    init_wui_text2();
    init_wui_wallet_image2();
    init_w3m_mobile_download_links();
    init_styles19();
    __decorate31 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWidget = class extends i7 {
      constructor() {
        super();
        this.wallet = RouterController.state.data?.wallet;
        this.connector = RouterController.state.data?.connector;
        this.timeout = void 0;
        this.secondaryBtnIcon = "refresh";
        this.onConnect = void 0;
        this.onRender = void 0;
        this.onAutoConnect = void 0;
        this.isWalletConnect = true;
        this.unsubscribe = [];
        this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
        this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet";
        this.isRetrying = false;
        this.uri = ConnectionController.state.wcUri;
        this.error = ConnectionController.state.wcError;
        this.ready = false;
        this.showRetry = false;
        this.label = void 0;
        this.secondaryBtnLabel = "Try again";
        this.secondaryLabel = "Accept connection request in the wallet";
        this.isLoading = false;
        this.isMobile = false;
        this.onRetry = void 0;
        this.unsubscribe.push(...[
          ConnectionController.subscribeKey("wcUri", (val) => {
            this.uri = val;
            if (this.isRetrying && this.onRetry) {
              this.isRetrying = false;
              this.onConnect?.();
            }
          }),
          ConnectionController.subscribeKey("wcError", (val) => this.error = val)
        ]);
        if ((CoreHelperUtil.isTelegram() || CoreHelperUtil.isSafari()) && CoreHelperUtil.isIos() && ConnectionController.state.wcUri) {
          this.onConnect?.();
        }
      }
      firstUpdated() {
        this.onAutoConnect?.();
        this.showRetry = !this.onAutoConnect;
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
        ConnectionController.setWcError(false);
        clearTimeout(this.timeout);
      }
      render() {
        this.onRender?.();
        this.onShowRetry();
        const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
        let label = "";
        if (this.label) {
          label = this.label;
        } else {
          label = `Continue in ${this.name}`;
          if (this.error) {
            label = "Connection declined";
          }
        }
        return x6`
      <wui-flex
        data-error=${o10(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o10(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text
            align="center"
            variant="paragraph-500"
            color=${this.error ? "error-100" : "fg-100"}
          >
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.secondaryBtnLabel ? x6`
              <wui-button
                variant="accent"
                size="md"
                ?disabled=${this.isRetrying || this.isLoading}
                @click=${this.onTryAgain.bind(this)}
                data-testid="w3m-connecting-widget-secondary-button"
              >
                <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
                ${this.secondaryBtnLabel}
              </wui-button>
            ` : null}
      </wui-flex>

      ${this.isWalletConnect ? x6`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200" data-testid="wui-link-copy">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
      }
      onShowRetry() {
        if (this.error && !this.showRetry) {
          this.showRetry = true;
          const retryButton = this.shadowRoot?.querySelector("wui-button");
          retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
            fill: "forwards",
            easing: "ease"
          });
        }
      }
      onTryAgain() {
        ConnectionController.setWcError(false);
        if (this.onRetry) {
          this.isRetrying = true;
          this.onRetry?.();
        } else {
          this.onConnect?.();
        }
      }
      loaderTemplate() {
        const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
        const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
        return x6`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
      }
      onCopyUri() {
        try {
          if (this.uri) {
            CoreHelperUtil.copyToClopboard(this.uri);
            SnackController.showSuccess("Link copied");
          }
        } catch {
          SnackController.showError("Failed to copy");
        }
      }
    };
    W3mConnectingWidget.styles = styles_default19;
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "isRetrying", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "uri", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "error", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "ready", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "showRetry", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "label", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "secondaryBtnLabel", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "secondaryLabel", void 0);
    __decorate31([
      r7()
    ], W3mConnectingWidget.prototype, "isLoading", void 0);
    __decorate31([
      n8({ type: Boolean })
    ], W3mConnectingWidget.prototype, "isMobile", void 0);
    __decorate31([
      n8()
    ], W3mConnectingWidget.prototype, "onRetry", void 0);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-browser/index.js
var __decorate32, W3mConnectingWcBrowser;
var init_w3m_connecting_wc_browser = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-browser/index.js"() {
    init_exports();
    init_exports3();
    init_w3m_connecting_widget();
    __decorate32 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
      constructor() {
        super();
        if (!this.wallet) {
          throw new Error("w3m-connecting-wc-browser: No wallet provided");
        }
        this.onConnect = this.onConnectProxy.bind(this);
        this.onAutoConnect = this.onConnectProxy.bind(this);
        EventsController.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet.name,
            platform: "browser",
            displayIndex: this.wallet?.display_index
          }
        });
      }
      async onConnectProxy() {
        try {
          this.error = false;
          const { connectors } = ConnectorController.state;
          const connector = connectors.find((c12) => c12.type === "ANNOUNCED" && c12.info?.rdns === this.wallet?.rdns || c12.type === "INJECTED" || c12.name === this.wallet?.name);
          if (connector) {
            await ConnectionController.connectExternal(connector, connector.chain);
          } else {
            throw new Error("w3m-connecting-wc-browser: No connector found");
          }
          ModalController.close();
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: {
              method: "browser",
              name: this.wallet?.name || "Unknown",
              caipNetworkId: ChainController.getActiveCaipNetwork()?.caipNetworkId
            }
          });
        } catch (error2) {
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_ERROR",
            properties: { message: error2?.message ?? "Unknown" }
          });
          this.error = true;
        }
      }
    };
    W3mConnectingWcBrowser = __decorate32([
      customElement("w3m-connecting-wc-browser")
    ], W3mConnectingWcBrowser);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-desktop/index.js
var __decorate33, W3mConnectingWcDesktop;
var init_w3m_connecting_wc_desktop = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-desktop/index.js"() {
    init_exports();
    init_exports3();
    init_w3m_connecting_widget();
    __decorate33 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
      constructor() {
        super();
        if (!this.wallet) {
          throw new Error("w3m-connecting-wc-desktop: No wallet provided");
        }
        this.onConnect = this.onConnectProxy.bind(this);
        this.onRender = this.onRenderProxy.bind(this);
        EventsController.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet.name,
            platform: "desktop",
            displayIndex: this.wallet?.display_index
          }
        });
      }
      onRenderProxy() {
        if (!this.ready && this.uri) {
          this.ready = true;
          this.onConnect?.();
        }
      }
      onConnectProxy() {
        if (this.wallet?.desktop_link && this.uri) {
          try {
            this.error = false;
            const { desktop_link, name: name2 } = this.wallet;
            const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
            ConnectionController.setWcLinking({ name: name2, href });
            ConnectionController.setRecentWallet(this.wallet);
            CoreHelperUtil.openHref(redirect, "_blank");
          } catch {
            this.error = true;
          }
        }
      }
    };
    W3mConnectingWcDesktop = __decorate33([
      customElement("w3m-connecting-wc-desktop")
    ], W3mConnectingWcDesktop);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-mobile/index.js
var __decorate34, W3mConnectingWcMobile;
var init_w3m_connecting_wc_mobile = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-mobile/index.js"() {
    init_decorators();
    init_exports();
    init_exports3();
    init_w3m_connecting_widget();
    __decorate34 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
      constructor() {
        super();
        this.btnLabelTimeout = void 0;
        this.redirectDeeplink = void 0;
        this.redirectUniversalLink = void 0;
        this.target = void 0;
        this.preferUniversalLinks = OptionsController.state.experimental_preferUniversalLinks;
        this.isLoading = true;
        this.onConnect = () => {
          if (this.wallet?.mobile_link && this.uri) {
            try {
              this.error = false;
              const { mobile_link, link_mode, name: name2 } = this.wallet;
              const { redirect, redirectUniversalLink, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri, link_mode);
              this.redirectDeeplink = redirect;
              this.redirectUniversalLink = redirectUniversalLink;
              this.target = CoreHelperUtil.isIframe() ? "_top" : "_self";
              ConnectionController.setWcLinking({ name: name2, href });
              ConnectionController.setRecentWallet(this.wallet);
              if (this.preferUniversalLinks && this.redirectUniversalLink) {
                CoreHelperUtil.openHref(this.redirectUniversalLink, this.target);
              } else {
                CoreHelperUtil.openHref(this.redirectDeeplink, this.target);
              }
            } catch (e10) {
              EventsController.sendEvent({
                type: "track",
                event: "CONNECT_PROXY_ERROR",
                properties: {
                  message: e10 instanceof Error ? e10.message : "Error parsing the deeplink",
                  uri: this.uri,
                  mobile_link: this.wallet.mobile_link,
                  name: this.wallet.name
                }
              });
              this.error = true;
            }
          }
        };
        if (!this.wallet) {
          throw new Error("w3m-connecting-wc-mobile: No wallet provided");
        }
        this.secondaryBtnLabel = "Open";
        this.secondaryLabel = ConstantsUtil2.CONNECT_LABELS.MOBILE;
        this.secondaryBtnIcon = "externalLink";
        this.onHandleURI();
        this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", () => {
          this.onHandleURI();
        }));
        EventsController.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet.name,
            platform: "mobile",
            displayIndex: this.wallet?.display_index
          }
        });
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        clearTimeout(this.btnLabelTimeout);
      }
      onHandleURI() {
        this.isLoading = !this.uri;
        if (!this.ready && this.uri) {
          this.ready = true;
          this.onConnect?.();
        }
      }
      onTryAgain() {
        ConnectionController.setWcError(false);
        this.onConnect?.();
      }
    };
    __decorate34([
      r7()
    ], W3mConnectingWcMobile.prototype, "redirectDeeplink", void 0);
    __decorate34([
      r7()
    ], W3mConnectingWcMobile.prototype, "redirectUniversalLink", void 0);
    __decorate34([
      r7()
    ], W3mConnectingWcMobile.prototype, "target", void 0);
    __decorate34([
      r7()
    ], W3mConnectingWcMobile.prototype, "preferUniversalLinks", void 0);
    __decorate34([
      r7()
    ], W3mConnectingWcMobile.prototype, "isLoading", void 0);
    W3mConnectingWcMobile = __decorate34([
      customElement("w3m-connecting-wc-mobile")
    ], W3mConnectingWcMobile);
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/utils.js
var require_utils3 = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version4) {
      if (!version4) throw new Error('"version" cannot be null or undefined');
      if (version4 < 1 || version4 > 40) throw new Error('"version" should be in range from 1 to 40');
      return version4 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version4) {
      return CODEWORDS_COUNT[version4];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f13) {
      if (typeof f13 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f13;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string2);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e10) {
        return defaultValue;
      }
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index2) {
        const bufIndex = Math.floor(index2 / 8);
        return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
      },
      put: function(num2, length2) {
        for (let i11 = 0; i11 < length2; i11++) {
          this.putBit((num2 >>> length2 - i11 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size4) {
      if (!size4 || size4 < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size4;
      this.data = new Uint8Array(size4 * size4);
      this.reservedBit = new Uint8Array(size4 * size4);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index2 = row * this.size + col;
      this.data[index2] = value;
      if (reserved) this.reservedBit[index2] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils3().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version4) {
      if (version4 === 1) return [];
      const posCount = Math.floor(version4 / 7) + 2;
      const size4 = getSymbolSize(version4);
      const intervals = size4 === 145 ? 26 : Math.ceil((size4 - 13) / (2 * posCount - 2)) * 2;
      const positions = [size4 - 7];
      for (let i11 = 1; i11 < posCount - 1; i11++) {
        positions[i11] = positions[i11 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version4) {
      const coords = [];
      const pos = exports.getRowColCoords(version4);
      const posLength = pos.length;
      for (let i11 = 0; i11 < posLength; i11++) {
        for (let j7 = 0; j7 < posLength; j7++) {
          if (i11 === 0 && j7 === 0 || // top-left
          i11 === 0 && j7 === posLength - 1 || // bottom-left
          i11 === posLength - 1 && j7 === 0) {
            continue;
          }
          coords.push([pos[i11], pos[j7]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils3().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version4) {
      const size4 = getSymbolSize(version4);
      return [
        // top-left
        [0, 0],
        // top-right
        [size4 - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size4 - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from3(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size4 = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size4; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size4; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size4 = data.size;
      let points = 0;
      for (let row = 0; row < size4 - 1; row++) {
        for (let col = 0; col < size4 - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size4 = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size4; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size4; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i11 = 0; i11 < modulesCount; i11++) darkCount += data.data[i11];
      const k7 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k7 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i11, j7) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i11 + j7) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i11 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j7 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i11 + j7) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i11 / 2) + Math.floor(j7 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i11 * j7 % 2 + i11 * j7 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i11 * j7 % 2 + i11 * j7 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i11 * j7 % 3 + (i11 + j7) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size4 = data.size;
      for (let col = 0; col < size4; col++) {
        for (let row = 0; row < size4; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p8 = 0; p8 < numPatterns; p8++) {
        setupFormatFunc(p8);
        exports.applyMask(p8, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p8, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p8;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version4, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version4 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version4 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version4 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version4 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version4, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version4 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version4 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version4 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version4 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x7 = 1;
      for (let i11 = 0; i11 < 255; i11++) {
        EXP_TABLE[i11] = x7;
        LOG_TABLE[x7] = i11;
        x7 <<= 1;
        if (x7 & 256) {
          x7 ^= 285;
        }
      }
      for (let i11 = 255; i11 < 512; i11++) {
        EXP_TABLE[i11] = EXP_TABLE[i11 - 255];
      }
    })();
    exports.log = function log(n12) {
      if (n12 < 1) throw new Error("log(" + n12 + ")");
      return LOG_TABLE[n12];
    };
    exports.exp = function exp(n12) {
      return EXP_TABLE[n12];
    };
    exports.mul = function mul(x7, y9) {
      if (x7 === 0 || y9 === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x7] + LOG_TABLE[y9]];
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p22) {
      const coeff = new Uint8Array(p1.length + p22.length - 1);
      for (let i11 = 0; i11 < p1.length; i11++) {
        for (let j7 = 0; j7 < p22.length; j7++) {
          coeff[i11 + j7] ^= GF.mul(p1[i11], p22[j7]);
        }
      }
      return coeff;
    };
    exports.mod = function mod3(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i11 = 0; i11 < divisor.length; i11++) {
          result[i11] ^= GF.mul(divisor[i11], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i11 = 0; i11 < degree; i11++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i11)]));
      }
      return poly;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode6(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version4) {
      return !isNaN(version4) && version4 >= 1 && version4 <= 40;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version4) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version4)) {
        throw new Error("Invalid version: " + version4);
      }
      if (version4 >= 1 && version4 < 10) return mode.ccBits[0];
      else if (version4 < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString3(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString3(string2) {
      if (typeof string2 !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string2.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string2);
      }
    }
    exports.from = function from3(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString3(value);
      } catch (e10) {
        return defaultValue;
      }
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils3();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version4) {
      return Mode.getCharCountIndicator(mode, version4) + 4;
    }
    function getTotalBitsFromDataArray(segments, version4) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version4);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from3(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version4, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version4)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version4);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version4, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version4);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version4) {
      if (!VersionCheck.isValid(version4) || version4 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d7 = version4 << 12;
      while (Utils.getBCHDigit(d7) - G18_BCH >= 0) {
        d7 ^= G18 << Utils.getBCHDigit(d7) - G18_BCH;
      }
      return version4 << 12 | d7;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils3();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d7 = data << 10;
      while (Utils.getBCHDigit(d7) - G15_BCH >= 0) {
        d7 ^= G15 << Utils.getBCHDigit(d7) - G15_BCH;
      }
      return (data << 10 | d7) ^ G15_MASK;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i11, group, value;
      for (i11 = 0; i11 + 3 <= this.data.length; i11 += 3) {
        group = this.data.substr(i11, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i11;
      if (remainingNum > 0) {
        group = this.data.substr(i11);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i11;
      for (i11 = 0; i11 + 2 <= this.data.length; i11 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i11]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i11 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i11]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports, module) {
    "use strict";
    module.exports = function encodeUtf8(input) {
      var result = [];
      var size4 = input.length;
      for (var index2 = 0; index2 < size4; index2++) {
        var point = input.charCodeAt(index2);
        if (point >= 55296 && point <= 56319 && size4 > index2 + 1) {
          var second = input.charCodeAt(index2 + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index2 += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        }
        if (point < 55296 || point >= 57344 && point < 65536) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        data = encodeUtf8(data);
      }
      this.data = new Uint8Array(data);
    }
    ByteData.getBitsLength = function getBitsLength(length2) {
      return length2 * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i11 = 0, l10 = this.data.length; i11 < l10; i11++) {
        bitBuffer.put(this.data[i11], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils3();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length2) {
      return length2 * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i11;
      for (i11 = 0; i11 < this.data.length; i11++) {
        let value = Utils.toSJIS(this.data[i11]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i11] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s8, d7) {
        var predecessors = {};
        var costs = {};
        costs[s8] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s8, 0);
        var closest, u6, v8, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u6 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u6] || {};
          for (v8 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v8)) {
              cost_of_e = adjacent_nodes[v8];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v8];
              first_visit = typeof costs[v8] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v8] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v8, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v8] = u6;
              }
            }
          }
        }
        if (typeof d7 !== "undefined" && typeof costs[d7] === "undefined") {
          var msg = ["Could not find a path from ", s8, " to ", d7, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d7) {
        var nodes = [];
        var u6 = d7;
        var predecessor;
        while (u6) {
          nodes.push(u6);
          predecessor = predecessors[u6];
          u6 = predecessors[u6];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s8, d7) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s8, d7);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d7
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T6 = dijkstra.PriorityQueue, t5 = {}, key;
          opts = opts || {};
          for (key in T6) {
            if (T6.hasOwnProperty(key)) {
              t5[key] = T6[key];
            }
          }
          t5.queue = [];
          t5.sorter = opts.sorter || T6.default_sorter;
          return t5;
        },
        default_sorter: function(a5, b7) {
          return a5.cost - b7.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils3();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode, str) {
      const segments = [];
      let result;
      while ((result = regex2.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s22) {
        return s1.index - s22.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i11 = 0; i11 < segs.length; i11++) {
        const seg = segs[i11];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version4) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i11 = 0; i11 < nodes.length; i11++) {
        const nodeGroup = nodes[i11];
        const currentNodeIds = [];
        for (let j7 = 0; j7 < nodeGroup.length; j7++) {
          const node = nodeGroup[j7];
          const key = "" + i11 + j7;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n12 = 0; n12 < prevNodeIds.length; n12++) {
            const prevNodeId = prevNodeIds[n12];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version4);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n12 = 0; n12 < prevNodeIds.length; n12++) {
        graph[prevNodeIds[n12]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString3(data, version4) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version4);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i11 = 1; i11 < path.length - 1; i11++) {
        optimizedSegs.push(graph.table[path[i11]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils3();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version4) {
      const size4 = matrix.size;
      const pos = FinderPattern.getPositions(version4);
      for (let i11 = 0; i11 < pos.length; i11++) {
        const row = pos[i11][0];
        const col = pos[i11][1];
        for (let r9 = -1; r9 <= 7; r9++) {
          if (row + r9 <= -1 || size4 <= row + r9) continue;
          for (let c12 = -1; c12 <= 7; c12++) {
            if (col + c12 <= -1 || size4 <= col + c12) continue;
            if (r9 >= 0 && r9 <= 6 && (c12 === 0 || c12 === 6) || c12 >= 0 && c12 <= 6 && (r9 === 0 || r9 === 6) || r9 >= 2 && r9 <= 4 && c12 >= 2 && c12 <= 4) {
              matrix.set(row + r9, col + c12, true, true);
            } else {
              matrix.set(row + r9, col + c12, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size4 = matrix.size;
      for (let r9 = 8; r9 < size4 - 8; r9++) {
        const value = r9 % 2 === 0;
        matrix.set(r9, 6, value, true);
        matrix.set(6, r9, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version4) {
      const pos = AlignmentPattern.getPositions(version4);
      for (let i11 = 0; i11 < pos.length; i11++) {
        const row = pos[i11][0];
        const col = pos[i11][1];
        for (let r9 = -2; r9 <= 2; r9++) {
          for (let c12 = -2; c12 <= 2; c12++) {
            if (r9 === -2 || r9 === 2 || c12 === -2 || c12 === 2 || r9 === 0 && c12 === 0) {
              matrix.set(row + r9, col + c12, true, true);
            } else {
              matrix.set(row + r9, col + c12, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version4) {
      const size4 = matrix.size;
      const bits = Version.getEncodedBits(version4);
      let row, col, mod3;
      for (let i11 = 0; i11 < 18; i11++) {
        row = Math.floor(i11 / 3);
        col = i11 % 3 + size4 - 8 - 3;
        mod3 = (bits >> i11 & 1) === 1;
        matrix.set(row, col, mod3, true);
        matrix.set(col, row, mod3, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size4 = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i11, mod3;
      for (i11 = 0; i11 < 15; i11++) {
        mod3 = (bits >> i11 & 1) === 1;
        if (i11 < 6) {
          matrix.set(i11, 8, mod3, true);
        } else if (i11 < 8) {
          matrix.set(i11 + 1, 8, mod3, true);
        } else {
          matrix.set(size4 - 15 + i11, 8, mod3, true);
        }
        if (i11 < 8) {
          matrix.set(8, size4 - i11 - 1, mod3, true);
        } else if (i11 < 9) {
          matrix.set(8, 15 - i11 - 1 + 1, mod3, true);
        } else {
          matrix.set(8, 15 - i11 - 1, mod3, true);
        }
      }
      matrix.set(size4 - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size4 = matrix.size;
      let inc = -1;
      let row = size4 - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size4 - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c12 = 0; c12 < 2; c12++) {
            if (!matrix.isReserved(row, col - c12)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c12, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size4 <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version4, errorCorrectionLevel, segments) {
      const buffer3 = new BitBuffer();
      segments.forEach(function(data) {
        buffer3.put(data.mode.bit, 4);
        buffer3.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version4));
        data.write(buffer3);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version4);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version4, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer3.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer3.put(0, 4);
      }
      while (buffer3.getLengthInBits() % 8 !== 0) {
        buffer3.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer3.getLengthInBits()) / 8;
      for (let i11 = 0; i11 < remainingByte; i11++) {
        buffer3.put(i11 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer3, version4, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version4, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version4);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version4, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version4, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs3 = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer3 = new Uint8Array(bitBuffer.buffer);
      for (let b7 = 0; b7 < ecTotalBlocks; b7++) {
        const dataSize = b7 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b7] = buffer3.slice(offset, offset + dataSize);
        ecData[b7] = rs3.encode(dcData[b7]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index2 = 0;
      let i11, r9;
      for (i11 = 0; i11 < maxDataSize; i11++) {
        for (r9 = 0; r9 < ecTotalBlocks; r9++) {
          if (i11 < dcData[r9].length) {
            data[index2++] = dcData[r9][i11];
          }
        }
      }
      for (i11 = 0; i11 < ecCount; i11++) {
        for (r9 = 0; r9 < ecTotalBlocks; r9++) {
          data[index2++] = ecData[r9][i11];
        }
      }
      return data;
    }
    function createSymbol(data, version4, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version4;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version4) {
        version4 = bestVersion;
      } else if (version4 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version4, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version4);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version4);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version4);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version4 >= 7) {
        setupVersionInfo(modules, version4);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version4,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create2(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version4;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version4 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version4, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/renderer/utils.js
var require_utils4 = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c12) {
          return [c12, c12];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr4, opts) {
      const size4 = qr4.modules.size;
      const data = qr4.modules.data;
      const scale = exports.getScale(size4, opts);
      const symbolSize = Math.floor((size4 + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i11 = 0; i11 < symbolSize; i11++) {
        for (let j7 = 0; j7 < symbolSize; j7++) {
          let posDst = (i11 * symbolSize + j7) * 4;
          let pxColor = opts.color.light;
          if (i11 >= scaledMargin && j7 >= scaledMargin && i11 < symbolSize - scaledMargin && j7 < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i11 - scaledMargin) / scale);
            const jSrc = Math.floor((j7 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size4 + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils4();
    function clearCanvas(ctx, canvas, size4) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size4;
      canvas.width = size4;
      canvas.style.height = size4 + "px";
      canvas.style.width = size4 + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e10) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size4 = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size4, size4);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size4);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils4();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x7, y9) {
      let str = cmd + x7;
      if (typeof y9 !== "undefined") str += " " + y9;
      return str;
    }
    function qrToPath(data, size4, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i11 = 0; i11 < data.length; i11++) {
        const col = Math.floor(i11 % size4);
        const row = Math.floor(i11 / size4);
        if (!col && !newRow) newRow = true;
        if (data[i11]) {
          lineLength++;
          if (!(i11 > 0 && col > 0 && data[i11 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size4 && data[i11 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size4 = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size4 + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size4, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/@reown/appkit-ui/node_modules/qrcode/lib/browser.js
var require_browser3 = __commonJS({
  "node_modules/@reown/appkit-ui/node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e10) {
            reject(e10);
          }
        });
      }
      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e10) {
        cb(e10);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _5, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/QrCode.js
function isAdjecentDots(cy, otherCy, cellSize) {
  if (cy === otherCy) {
    return false;
  }
  const diff = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
  return diff <= cellSize + CONNECTING_ERROR_MARGIN;
}
function getMatrix(value, errorCorrectionLevel) {
  const arr = Array.prototype.slice.call(import_qrcode.default.create(value, { errorCorrectionLevel }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key, index2) => (index2 % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows, []);
}
var import_qrcode, CONNECTING_ERROR_MARGIN, CIRCLE_SIZE_MODIFIER, QRCODE_MATRIX_MARGIN, QrCodeUtil;
var init_QrCode = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/QrCode.js"() {
    import_qrcode = __toESM(require_browser3(), 1);
    init_lit();
    CONNECTING_ERROR_MARGIN = 0.1;
    CIRCLE_SIZE_MODIFIER = 2.5;
    QRCODE_MATRIX_MARGIN = 7;
    QrCodeUtil = {
      generate({ uri, size: size4, logoSize, dotColor = "#141414" }) {
        const edgeColor = "transparent";
        const strokeWidth = 5;
        const dots = [];
        const matrix = getMatrix(uri, "Q");
        const cellSize = size4 / matrix.length;
        const qrList = [
          { x: 0, y: 0 },
          { x: 1, y: 0 },
          { x: 0, y: 1 }
        ];
        qrList.forEach(({ x: x7, y: y9 }) => {
          const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x7;
          const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y9;
          const borderRadius = 0.45;
          for (let i11 = 0; i11 < qrList.length; i11 += 1) {
            const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i11 * 2);
            dots.push(b6`
            <rect
              fill=${i11 === 2 ? dotColor : edgeColor}
              width=${i11 === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i11 === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              ry= ${i11 === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              stroke=${dotColor}
              stroke-width=${i11 === 0 ? strokeWidth : 0}
              height=${i11 === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i11 === 0 ? y1 + cellSize * i11 + strokeWidth / 2 : y1 + cellSize * i11}
              y= ${i11 === 0 ? x1 + cellSize * i11 + strokeWidth / 2 : x1 + cellSize * i11}
            />
          `);
          }
        });
        const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
        const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
        const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
        const circles = [];
        matrix.forEach((row, i11) => {
          row.forEach((_5, j7) => {
            if (matrix[i11][j7]) {
              if (!(i11 < QRCODE_MATRIX_MARGIN && j7 < QRCODE_MATRIX_MARGIN || i11 > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j7 < QRCODE_MATRIX_MARGIN || i11 < QRCODE_MATRIX_MARGIN && j7 > matrix.length - (QRCODE_MATRIX_MARGIN + 1))) {
                if (!(i11 > matrixMiddleStart && i11 < matrixMiddleEnd && j7 > matrixMiddleStart && j7 < matrixMiddleEnd)) {
                  const cx = i11 * cellSize + cellSize / 2;
                  const cy = j7 * cellSize + cellSize / 2;
                  circles.push([cx, cy]);
                }
              }
            }
          });
        });
        const circlesToConnect = {};
        circles.forEach(([cx, cy]) => {
          if (circlesToConnect[cx]) {
            circlesToConnect[cx]?.push(cy);
          } else {
            circlesToConnect[cx] = [cy];
          }
        });
        Object.entries(circlesToConnect).map(([cx, cys]) => {
          const newCys = cys.filter((cy) => cys.every((otherCy) => !isAdjecentDots(cy, otherCy, cellSize)));
          return [Number(cx), newCys];
        }).forEach(([cx, cys]) => {
          cys.forEach((cy) => {
            dots.push(b6`<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
          });
        });
        Object.entries(circlesToConnect).filter(([_5, cys]) => cys.length > 1).map(([cx, cys]) => {
          const newCys = cys.filter((cy) => cys.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
          return [Number(cx), newCys];
        }).map(([cx, cys]) => {
          cys.sort((a5, b7) => a5 < b7 ? -1 : 1);
          const groups = [];
          for (const cy of cys) {
            const group = groups.find((item) => item.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
            if (group) {
              group.push(cy);
            } else {
              groups.push([cy]);
            }
          }
          return [cx, groups.map((item) => [item[0], item[item.length - 1]])];
        }).forEach(([cx, groups]) => {
          groups.forEach(([y1, y22]) => {
            dots.push(b6`
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y22}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
          });
        });
        return dots;
      }
    };
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-qr-code/styles.js
var styles_default20;
var init_styles20 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-qr-code/styles.js"() {
    init_lit();
    styles_default20 = i4`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  :host([data-clear='true']) > wui-icon {
    display: none;
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: var(--local-icon-color) !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-qr-code/index.js
var __decorate35, DEFAULT_ICON_COLOR, WuiQrCode;
var init_wui_qr_code = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-qr-code/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_wui_image();
    init_QrCode();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles20();
    __decorate35 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    DEFAULT_ICON_COLOR = "#3396ff";
    WuiQrCode = class WuiQrCode2 extends i7 {
      constructor() {
        super(...arguments);
        this.uri = "";
        this.size = 0;
        this.theme = "dark";
        this.imageSrc = void 0;
        this.alt = void 0;
        this.arenaClear = void 0;
        this.farcaster = void 0;
      }
      render() {
        this.dataset["theme"] = this.theme;
        this.dataset["clear"] = String(this.arenaClear);
        this.style.cssText = `
     --local-size: ${this.size}px;
     --local-icon-color: ${this.color ?? DEFAULT_ICON_COLOR}
    `;
        return x6`${this.templateVisual()} ${this.templateSvg()}`;
      }
      templateSvg() {
        const size4 = this.theme === "light" ? this.size : this.size - 16 * 2;
        return b6`
      <svg height=${size4} width=${size4}>
        ${QrCodeUtil.generate({
          uri: this.uri,
          size: size4,
          logoSize: this.arenaClear ? 0 : size4 / 4,
          dotColor: this.color
        })}
      </svg>
    `;
      }
      templateVisual() {
        if (this.imageSrc) {
          return x6`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>`;
        }
        if (this.farcaster) {
          return x6`<wui-icon
        class="farcaster"
        size="inherit"
        color="inherit"
        name="farcaster"
      ></wui-icon>`;
        }
        return x6`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
      }
    };
    WuiQrCode.styles = [resetStyles, styles_default20];
    __decorate35([
      n8()
    ], WuiQrCode.prototype, "uri", void 0);
    __decorate35([
      n8({ type: Number })
    ], WuiQrCode.prototype, "size", void 0);
    __decorate35([
      n8()
    ], WuiQrCode.prototype, "theme", void 0);
    __decorate35([
      n8()
    ], WuiQrCode.prototype, "imageSrc", void 0);
    __decorate35([
      n8()
    ], WuiQrCode.prototype, "alt", void 0);
    __decorate35([
      n8()
    ], WuiQrCode.prototype, "color", void 0);
    __decorate35([
      n8({ type: Boolean })
    ], WuiQrCode.prototype, "arenaClear", void 0);
    __decorate35([
      n8({ type: Boolean })
    ], WuiQrCode.prototype, "farcaster", void 0);
    WuiQrCode = __decorate35([
      customElement("wui-qr-code")
    ], WuiQrCode);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-qr-code.js
var init_wui_qr_code2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-qr-code.js"() {
    init_wui_qr_code();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-shimmer/styles.js
var styles_default21;
var init_styles21 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-shimmer/styles.js"() {
    init_lit();
    styles_default21 = i4`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  :host([variant='light']) {
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-150) 5%,
      var(--wui-color-bg-150) 48%,
      var(--wui-color-bg-200) 55%,
      var(--wui-color-bg-200) 60%,
      var(--wui-color-bg-200) calc(60% + 10px),
      var(--wui-color-bg-150) calc(60% + 12px),
      var(--wui-color-bg-150) 100%
    );
    background-size: 250%;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-shimmer/index.js
var __decorate36, WuiShimmer;
var init_wui_shimmer = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-shimmer/index.js"() {
    init_lit();
    init_decorators();
    init_WebComponentsUtil();
    init_styles21();
    __decorate36 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiShimmer = class WuiShimmer2 extends i7 {
      constructor() {
        super(...arguments);
        this.width = "";
        this.height = "";
        this.borderRadius = "m";
        this.variant = "default";
      }
      render() {
        this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
        return x6`<slot></slot>`;
      }
    };
    WuiShimmer.styles = [styles_default21];
    __decorate36([
      n8()
    ], WuiShimmer.prototype, "width", void 0);
    __decorate36([
      n8()
    ], WuiShimmer.prototype, "height", void 0);
    __decorate36([
      n8()
    ], WuiShimmer.prototype, "borderRadius", void 0);
    __decorate36([
      n8()
    ], WuiShimmer.prototype, "variant", void 0);
    WuiShimmer = __decorate36([
      customElement("wui-shimmer")
    ], WuiShimmer);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-shimmer.js
var init_wui_shimmer2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-shimmer.js"() {
    init_wui_shimmer();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/utils/ConstantsUtil.js
var REOWN_URL;
var init_ConstantsUtil5 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/utils/ConstantsUtil.js"() {
    REOWN_URL = "https://reown.com";
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-ux-by-reown/styles.js
var styles_default22;
var init_styles22 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-ux-by-reown/styles.js"() {
    init_lit();
    styles_default22 = i4`
  .reown-logo {
    height: var(--wui-spacing-xxl);
  }

  a {
    text-decoration: none;
    cursor: pointer;
  }

  a:hover {
    opacity: 0.9;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-ux-by-reown/index.js
var __decorate37, WuiUxByReown;
var init_wui_ux_by_reown = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-ux-by-reown/index.js"() {
    init_lit();
    init_wui_icon();
    init_wui_text();
    init_wui_flex();
    init_ConstantsUtil5();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles22();
    __decorate37 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiUxByReown = class WuiUxByReown2 extends i7 {
      render() {
        return x6`
      <a
        data-testid="ux-branding-reown"
        href=${REOWN_URL}
        rel="noreferrer"
        target="_blank"
        style="text-decoration: none;"
      >
        <wui-flex
          justifyContent="center"
          alignItems="center"
          gap="xs"
          .padding=${["0", "0", "l", "0"]}
        >
          <wui-text variant="small-500" color="fg-100"> UX by </wui-text>
          <wui-icon name="reown" size="xxxl" class="reown-logo"></wui-icon>
        </wui-flex>
      </a>
    `;
      }
    };
    WuiUxByReown.styles = [resetStyles, elementStyles, styles_default22];
    WuiUxByReown = __decorate37([
      customElement("wui-ux-by-reown")
    ], WuiUxByReown);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-ux-by-reown.js
var init_wui_ux_by_reown2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-ux-by-reown.js"() {
    init_wui_ux_by_reown();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/styles.js
var styles_default23;
var init_styles23 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/styles.js"() {
    init_lit();
    styles_default23 = i4`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/index.js
var __decorate38, W3mConnectingWcQrcode;
var init_w3m_connecting_wc_qrcode = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/index.js"() {
    init_lit();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_icon2();
    init_wui_link2();
    init_wui_qr_code2();
    init_wui_shimmer2();
    init_wui_text2();
    init_wui_ux_by_reown2();
    init_w3m_connecting_widget();
    init_w3m_mobile_download_links();
    init_styles23();
    __decorate38 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
      constructor() {
        super();
        this.forceUpdate = () => {
          this.requestUpdate();
        };
        window.addEventListener("resize", this.forceUpdate);
        EventsController.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet?.name ?? "WalletConnect",
            platform: "qrcode",
            displayIndex: this.wallet?.display_index
          }
        });
      }
      disconnectedCallback() {
        super.disconnectedCallback();
        this.unsubscribe?.forEach((unsub) => unsub());
        window.removeEventListener("resize", this.forceUpdate);
      }
      render() {
        this.onRenderProxy();
        return x6`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>
      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
      }
      onRenderProxy() {
        if (!this.ready && this.uri) {
          this.timeout = setTimeout(() => {
            this.ready = true;
          }, 200);
        }
      }
      qrCodeTemplate() {
        if (!this.uri || !this.ready) {
          return null;
        }
        const size4 = this.getBoundingClientRect().width - 40;
        const alt = this.wallet ? this.wallet.name : void 0;
        ConnectionController.setWcLinking(void 0);
        ConnectionController.setRecentWallet(this.wallet);
        return x6` <wui-qr-code
      size=${size4}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o10(AssetUtil.getWalletImage(this.wallet))}
      color=${o10(ThemeController.state.themeVariables["--w3m-qr-color"])}
      alt=${o10(alt)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
      }
      copyTemplate() {
        const inactive = !this.uri || !this.ready;
        return x6`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
      }
    };
    W3mConnectingWcQrcode.styles = styles_default23;
    W3mConnectingWcQrcode = __decorate38([
      customElement("w3m-connecting-wc-qrcode")
    ], W3mConnectingWcQrcode);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-unsupported/index.js
var __decorate39, W3mConnectingWcUnsupported;
var init_w3m_connecting_wc_unsupported = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-unsupported/index.js"() {
    init_lit();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_text2();
    init_wui_wallet_image2();
    init_w3m_mobile_download_links();
    __decorate39 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends i7 {
      constructor() {
        super();
        this.wallet = RouterController.state.data?.wallet;
        if (!this.wallet) {
          throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
        }
        EventsController.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet.name,
            platform: "browser",
            displayIndex: this.wallet?.display_index
          }
        });
      }
      render() {
        return x6`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o10(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
      }
    };
    W3mConnectingWcUnsupported = __decorate39([
      customElement("w3m-connecting-wc-unsupported")
    ], W3mConnectingWcUnsupported);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-web/index.js
var __decorate40, W3mConnectingWcWeb;
var init_w3m_connecting_wc_web = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-web/index.js"() {
    init_decorators();
    init_exports();
    init_exports3();
    init_w3m_connecting_widget();
    __decorate40 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
      constructor() {
        super();
        this.isLoading = true;
        if (!this.wallet) {
          throw new Error("w3m-connecting-wc-web: No wallet provided");
        }
        this.onConnect = this.onConnectProxy.bind(this);
        this.secondaryBtnLabel = "Open";
        this.secondaryLabel = ConstantsUtil2.CONNECT_LABELS.MOBILE;
        this.secondaryBtnIcon = "externalLink";
        this.updateLoadingState();
        this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", () => {
          this.updateLoadingState();
        }));
        EventsController.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet.name,
            platform: "web",
            displayIndex: this.wallet?.display_index
          }
        });
      }
      updateLoadingState() {
        this.isLoading = !this.uri;
      }
      onConnectProxy() {
        if (this.wallet?.webapp_link && this.uri) {
          try {
            this.error = false;
            const { webapp_link, name: name2 } = this.wallet;
            const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
            ConnectionController.setWcLinking({ name: name2, href });
            ConnectionController.setRecentWallet(this.wallet);
            CoreHelperUtil.openHref(redirect, "_blank");
          } catch {
            this.error = true;
          }
        }
      }
    };
    __decorate40([
      r7()
    ], W3mConnectingWcWeb.prototype, "isLoading", void 0);
    W3mConnectingWcWeb = __decorate40([
      customElement("w3m-connecting-wc-web")
    ], W3mConnectingWcWeb);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-wc-view/index.js
var __decorate41, W3mConnectingWcView;
var init_w3m_connecting_wc_view = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-wc-view/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_exports2();
    init_w3m_connecting_header();
    init_w3m_connecting_wc_browser();
    init_w3m_connecting_wc_desktop();
    init_w3m_connecting_wc_mobile();
    init_w3m_connecting_wc_qrcode();
    init_w3m_connecting_wc_unsupported();
    init_w3m_connecting_wc_web();
    __decorate41 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcView = class W3mConnectingWcView2 extends i7 {
      constructor() {
        super();
        this.wallet = RouterController.state.data?.wallet;
        this.unsubscribe = [];
        this.platform = void 0;
        this.platforms = [];
        this.isSiwxEnabled = Boolean(OptionsController.state.siwx);
        this.remoteFeatures = OptionsController.state.remoteFeatures;
        this.determinePlatforms();
        this.initializeConnection();
        this.unsubscribe.push(OptionsController.subscribeKey("remoteFeatures", (val) => this.remoteFeatures = val));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        return x6`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
      ${this.reownBrandingTemplate()}
    `;
      }
      reownBrandingTemplate() {
        if (!this.remoteFeatures?.reownBranding) {
          return null;
        }
        return x6`<wui-ux-by-reown></wui-ux-by-reown>`;
      }
      async initializeConnection(retry = false) {
        if (this.platform === "browser" || OptionsController.state.manualWCControl && !retry) {
          return;
        }
        try {
          const { wcPairingExpiry, status } = ConnectionController.state;
          if (retry || OptionsController.state.enableEmbedded || CoreHelperUtil.isPairingExpired(wcPairingExpiry) || status === "connecting") {
            const connectionsByNamespace = ConnectionController.getConnections(ChainController.state.activeChain);
            const isMultiWalletEnabled = this.remoteFeatures?.multiWallet;
            const hasConnections = connectionsByNamespace.length > 0;
            await ConnectionController.connectWalletConnect();
            if (!this.isSiwxEnabled) {
              if (hasConnections && isMultiWalletEnabled) {
                RouterController.replace("ProfileWallets");
                SnackController.showSuccess("New Wallet Added");
              } else {
                ModalController.close();
              }
            }
          }
        } catch (error2) {
          if (error2 instanceof Error && error2.message.includes("An error occurred when attempting to switch chain") && !OptionsController.state.enableNetworkSwitch) {
            if (ChainController.state.activeChain) {
              ChainController.setActiveCaipNetwork(CaipNetworksUtil.getUnsupportedNetwork(`${ChainController.state.activeChain}:${ChainController.state.activeCaipNetwork?.id}`));
              ChainController.showUnsupportedChainUI();
              return;
            }
          }
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_ERROR",
            properties: { message: error2?.message ?? "Unknown" }
          });
          ConnectionController.setWcError(true);
          SnackController.showError(error2.message ?? "Connection error");
          ConnectionController.resetWcConnection();
          RouterController.goBack();
        }
      }
      determinePlatforms() {
        if (!this.wallet) {
          this.platforms.push("qrcode");
          this.platform = "qrcode";
          return;
        }
        if (this.platform) {
          return;
        }
        const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
        const injectedIds = injected?.map(({ injected_id }) => injected_id).filter(Boolean);
        const browserIds = [...rdns ? [rdns] : injectedIds ?? []];
        const isBrowser = OptionsController.state.isUniversalProvider ? false : browserIds.length;
        const hasMobileWCLink = mobile_link;
        const isWebWc = webapp_link;
        const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
        const isBrowserWc = isBrowser && isBrowserInstalled;
        const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
        if (isBrowserWc && !ChainController.state.noAdapters) {
          this.platforms.push("browser");
        }
        if (hasMobileWCLink) {
          this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
        }
        if (isWebWc) {
          this.platforms.push("web");
        }
        if (isDesktopWc) {
          this.platforms.push("desktop");
        }
        if (!isBrowserWc && isBrowser && !ChainController.state.noAdapters) {
          this.platforms.push("unsupported");
        }
        this.platform = this.platforms[0];
      }
      platformTemplate() {
        switch (this.platform) {
          case "browser":
            return x6`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
          case "web":
            return x6`<w3m-connecting-wc-web></w3m-connecting-wc-web>`;
          case "desktop":
            return x6`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
          case "mobile":
            return x6`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
          case "qrcode":
            return x6`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
          default:
            return x6`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
        }
      }
      headerTemplate() {
        const multiPlatform = this.platforms.length > 1;
        if (!multiPlatform) {
          return null;
        }
        return x6`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
      }
      async onSelectPlatform(platform) {
        const container = this.shadowRoot?.querySelector("div");
        if (container) {
          await container.animate([{ opacity: 1 }, { opacity: 0 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }).finished;
          this.platform = platform;
          container.animate([{ opacity: 0 }, { opacity: 1 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          });
        }
      }
    };
    __decorate41([
      r7()
    ], W3mConnectingWcView.prototype, "platform", void 0);
    __decorate41([
      r7()
    ], W3mConnectingWcView.prototype, "platforms", void 0);
    __decorate41([
      r7()
    ], W3mConnectingWcView.prototype, "isSiwxEnabled", void 0);
    __decorate41([
      r7()
    ], W3mConnectingWcView.prototype, "remoteFeatures", void 0);
    W3mConnectingWcView = __decorate41([
      customElement("w3m-connecting-wc-view")
    ], W3mConnectingWcView);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-wc-basic-view/index.js
var __decorate42, W3mConnectingWcBasicView;
var init_w3m_connecting_wc_basic_view = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-wc-basic-view/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_w3m_all_wallets_widget();
    init_w3m_connector_list();
    init_w3m_connecting_wc_view();
    __decorate42 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mConnectingWcBasicView = class W3mConnectingWcBasicView2 extends i7 {
      constructor() {
        super(...arguments);
        this.isMobile = CoreHelperUtil.isMobile();
      }
      render() {
        if (this.isMobile) {
          const { featured, recommended } = ApiController.state;
          const { customWallets } = OptionsController.state;
          const recent = StorageUtil.getRecentWallets();
          const showConnectors = featured.length || recommended.length || customWallets?.length || recent.length;
          return x6`<wui-flex
        flexDirection="column"
        gap="xs"
        .margin=${["3xs", "s", "s", "s"]}
      >
        ${showConnectors ? x6`<w3m-connector-list></w3m-connector-list>` : null}
        <w3m-all-wallets-widget></w3m-all-wallets-widget>
      </wui-flex>`;
        }
        return x6`<wui-flex flexDirection="column" .padding=${["0", "0", "l", "0"]}>
      <w3m-connecting-wc-view></w3m-connecting-wc-view>
      <wui-flex flexDirection="column" .padding=${["0", "m", "0", "m"]}>
        <w3m-all-wallets-widget></w3m-all-wallets-widget> </wui-flex
    ></wui-flex>`;
      }
    };
    __decorate42([
      r7()
    ], W3mConnectingWcBasicView.prototype, "isMobile", void 0);
    W3mConnectingWcBasicView = __decorate42([
      customElement("w3m-connecting-wc-basic-view")
    ], W3mConnectingWcBasicView);
  }
});

// node_modules/lit-html/directives/ref.js
var e8, h11, o12, n11;
var init_ref = __esm({
  "node_modules/lit-html/directives/ref.js"() {
    init_lit_html();
    init_async_directive();
    init_directive();
    e8 = () => new h11();
    h11 = class {
    };
    o12 = /* @__PURE__ */ new WeakMap();
    n11 = e6(class extends f12 {
      render(i11) {
        return E6;
      }
      update(i11, [s8]) {
        const e10 = s8 !== this.G;
        return e10 && void 0 !== this.G && this.rt(void 0), (e10 || this.lt !== this.ct) && (this.G = s8, this.ht = i11.options?.host, this.rt(this.ct = i11.element)), E6;
      }
      rt(t5) {
        if (this.isConnected || (t5 = void 0), "function" == typeof this.G) {
          const i11 = this.ht ?? globalThis;
          let s8 = o12.get(i11);
          void 0 === s8 && (s8 = /* @__PURE__ */ new WeakMap(), o12.set(i11, s8)), void 0 !== s8.get(this.G) && this.G.call(this.ht, void 0), s8.set(this.G, t5), void 0 !== t5 && this.G.call(this.ht, t5);
        } else this.G.value = t5;
      }
      get lt() {
        return "function" == typeof this.G ? o12.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
      }
      disconnected() {
        this.lt === this.ct && this.rt(void 0);
      }
      reconnected() {
        this.rt(this.ct);
      }
    });
  }
});

// node_modules/lit/directives/ref.js
var init_ref2 = __esm({
  "node_modules/lit/directives/ref.js"() {
    init_ref();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-switch/styles.js
var styles_default24;
var init_styles24 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-switch/styles.js"() {
    init_lit();
    styles_default24 = i4`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  label {
    position: relative;
    display: inline-block;
    width: 32px;
    height: 22px;
  }

  input {
    width: 0;
    height: 0;
    opacity: 0;
  }

  span {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--wui-color-blue-100);
    border-width: 1px;
    border-style: solid;
    border-color: var(--wui-color-gray-glass-002);
    border-radius: 999px;
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color;
  }

  span:before {
    position: absolute;
    content: '';
    height: 16px;
    width: 16px;
    left: 3px;
    top: 2px;
    background-color: var(--wui-color-inverse-100);
    transition: transform var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    will-change: transform;
    border-radius: 50%;
  }

  input:checked + span {
    border-color: var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-blue-100);
  }

  input:not(:checked) + span {
    background-color: var(--wui-color-gray-glass-010);
  }

  input:checked + span:before {
    transform: translateX(calc(100% - 7px));
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-switch/index.js
var __decorate43, WuiSwitch;
var init_wui_switch = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-switch/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_ref2();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles24();
    __decorate43 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiSwitch = class WuiSwitch2 extends i7 {
      constructor() {
        super(...arguments);
        this.inputElementRef = e8();
        this.checked = void 0;
      }
      render() {
        return x6`
      <label>
        <input
          ${n11(this.inputElementRef)}
          type="checkbox"
          ?checked=${o10(this.checked)}
          @change=${this.dispatchChangeEvent.bind(this)}
        />
        <span></span>
      </label>
    `;
      }
      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent("switchChange", {
          detail: this.inputElementRef.value?.checked,
          bubbles: true,
          composed: true
        }));
      }
    };
    WuiSwitch.styles = [resetStyles, elementStyles, colorStyles, styles_default24];
    __decorate43([
      n8({ type: Boolean })
    ], WuiSwitch.prototype, "checked", void 0);
    WuiSwitch = __decorate43([
      customElement("wui-switch")
    ], WuiSwitch);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-certified-switch/styles.js
var styles_default25;
var init_styles25 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-certified-switch/styles.js"() {
    init_lit();
    styles_default25 = i4`
  :host {
    height: 100%;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: center;
    column-gap: var(--wui-spacing-1xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
    cursor: pointer;
  }

  wui-switch {
    pointer-events: none;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-certified-switch/index.js
var __decorate44, WuiCertifiedSwitch;
var init_wui_certified_switch = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-certified-switch/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_wui_icon();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_switch();
    init_styles25();
    __decorate44 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiCertifiedSwitch = class WuiCertifiedSwitch2 extends i7 {
      constructor() {
        super(...arguments);
        this.checked = void 0;
      }
      render() {
        return x6`
      <button>
        <wui-icon size="xl" name="walletConnectBrown"></wui-icon>
        <wui-switch ?checked=${o10(this.checked)}></wui-switch>
      </button>
    `;
      }
    };
    WuiCertifiedSwitch.styles = [resetStyles, elementStyles, styles_default25];
    __decorate44([
      n8({ type: Boolean })
    ], WuiCertifiedSwitch.prototype, "checked", void 0);
    WuiCertifiedSwitch = __decorate44([
      customElement("wui-certified-switch")
    ], WuiCertifiedSwitch);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-certified-switch.js
var init_wui_certified_switch2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-certified-switch.js"() {
    init_wui_certified_switch();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-element/styles.js
var styles_default26;
var init_styles26 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-element/styles.js"() {
    init_lit();
    styles_default26 = i4`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }

    button:active:enabled {
      background-color: var(--wui-color-fg-225);
    }
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-element/index.js
var __decorate45, WuiInputElement;
var init_wui_input_element = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-element/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles26();
    __decorate45 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiInputElement = class WuiInputElement2 extends i7 {
      constructor() {
        super(...arguments);
        this.icon = "copy";
      }
      render() {
        return x6`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
      }
    };
    WuiInputElement.styles = [resetStyles, elementStyles, styles_default26];
    __decorate45([
      n8()
    ], WuiInputElement.prototype, "icon", void 0);
    WuiInputElement = __decorate45([
      customElement("wui-input-element")
    ], WuiInputElement);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-text/styles.js
var styles_default27;
var init_styles27 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-text/styles.js"() {
    init_lit();
    styles_default27 = i4`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px var(--wui-spacing-3xl);
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  .wui-padding-right-xs {
    padding-right: var(--wui-spacing-xs);
  }

  .wui-padding-right-s {
    padding-right: var(--wui-spacing-s);
  }

  .wui-padding-right-m {
    padding-right: var(--wui-spacing-m);
  }

  .wui-padding-right-l {
    padding-right: var(--wui-spacing-l);
  }

  .wui-padding-right-xl {
    padding-right: var(--wui-spacing-xl);
  }

  .wui-padding-right-2xl {
    padding-right: var(--wui-spacing-2xl);
  }

  .wui-padding-right-3xl {
    padding-right: var(--wui-spacing-3xl);
  }

  .wui-padding-right-4xl {
    padding-right: var(--wui-spacing-4xl);
  }

  .wui-padding-right-5xl {
    padding-right: var(--wui-spacing-5xl);
  }

  wui-icon + .wui-size-lg,
  wui-loading-spinner + .wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-m) 17.25px var(--wui-spacing-m);
  }
  wui-icon + .wui-size-mdl,
  wui-loading-spinner + .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-3xl) 17.25px 40px;
  }
  wui-icon[data-input='mdl'] {
    left: var(--wui-spacing-m);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-text/index.js
var __decorate46, WuiInputText;
var init_wui_input_text = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-input-text/index.js"() {
    init_lit();
    init_decorators();
    init_class_map2();
    init_if_defined2();
    init_ref2();
    init_wui_icon();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles27();
    __decorate46 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiInputText = class WuiInputText2 extends i7 {
      constructor() {
        super(...arguments);
        this.inputElementRef = e8();
        this.size = "md";
        this.disabled = false;
        this.placeholder = "";
        this.type = "text";
        this.value = "";
      }
      render() {
        const inputClass = `wui-padding-right-${this.inputRightPadding}`;
        const sizeClass = `wui-size-${this.size}`;
        const classes = {
          [sizeClass]: true,
          [inputClass]: Boolean(this.inputRightPadding)
        };
        return x6`${this.templateIcon()}
      <input
        data-testid="wui-input-text"
        ${n11(this.inputElementRef)}
        class=${e7(classes)}
        type=${this.type}
        enterkeyhint=${o10(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        .value=${this.value || ""}
        tabindex=${o10(this.tabIdx)}
      />
      <slot></slot>`;
      }
      templateIcon() {
        if (this.icon) {
          return x6`<wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>`;
        }
        return null;
      }
      dispatchInputChangeEvent() {
        this.dispatchEvent(new CustomEvent("inputChange", {
          detail: this.inputElementRef.value?.value,
          bubbles: true,
          composed: true
        }));
      }
    };
    WuiInputText.styles = [resetStyles, elementStyles, styles_default27];
    __decorate46([
      n8()
    ], WuiInputText.prototype, "size", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "icon", void 0);
    __decorate46([
      n8({ type: Boolean })
    ], WuiInputText.prototype, "disabled", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "placeholder", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "type", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "keyHint", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "value", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "inputRightPadding", void 0);
    __decorate46([
      n8()
    ], WuiInputText.prototype, "tabIdx", void 0);
    WuiInputText = __decorate46([
      customElement("wui-input-text")
    ], WuiInputText);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-search-bar/styles.js
var styles_default28;
var init_styles28 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-search-bar/styles.js"() {
    init_lit();
    styles_default28 = i4`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-search-bar/index.js
var __decorate47, WuiSearchBar;
var init_wui_search_bar = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-search-bar/index.js"() {
    init_lit();
    init_ref2();
    init_wui_input_element();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_input_text();
    init_styles28();
    __decorate47 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiSearchBar = class WuiSearchBar2 extends i7 {
      constructor() {
        super(...arguments);
        this.inputComponentRef = e8();
      }
      render() {
        return x6`
      <wui-input-text
        ${n11(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
      }
      clearValue() {
        const inputComponent = this.inputComponentRef.value;
        const inputElement = inputComponent?.inputElementRef.value;
        if (inputElement) {
          inputElement.value = "";
          inputElement.focus();
          inputElement.dispatchEvent(new Event("input"));
        }
      }
    };
    WuiSearchBar.styles = [resetStyles, styles_default28];
    WuiSearchBar = __decorate47([
      customElement("wui-search-bar")
    ], WuiSearchBar);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-search-bar.js
var init_wui_search_bar2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-search-bar.js"() {
    init_wui_search_bar();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/networkMd.js
var networkSvgMd;
var init_networkMd = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/assets/svg/networkMd.js"() {
    init_lit();
    networkSvgMd = b6`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-card-select-loader/styles.js
var styles_default29;
var init_styles29 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-card-select-loader/styles.js"() {
    init_lit();
    styles_default29 = i4`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-color-gray-glass-010);
    stroke-width: 1px;
  }

  @media (max-width: 350px) {
    :host {
      width: 100%;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-card-select-loader/index.js
var __decorate48, WuiCardSelectLoader;
var init_wui_card_select_loader = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-card-select-loader/index.js"() {
    init_lit();
    init_decorators();
    init_networkMd();
    init_wui_shimmer();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles29();
    __decorate48 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiCardSelectLoader = class WuiCardSelectLoader2 extends i7 {
      constructor() {
        super(...arguments);
        this.type = "wallet";
      }
      render() {
        return x6`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
      }
      shimmerTemplate() {
        if (this.type === "network") {
          return x6` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvgMd}`;
        }
        return x6`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
      }
    };
    WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles_default29];
    __decorate48([
      n8()
    ], WuiCardSelectLoader.prototype, "type", void 0);
    WuiCardSelectLoader = __decorate48([
      customElement("wui-card-select-loader")
    ], WuiCardSelectLoader);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-card-select-loader.js
var init_wui_card_select_loader2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-card-select-loader.js"() {
    init_wui_card_select_loader();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-grid/styles.js
var styles_default30;
var init_styles30 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-grid/styles.js"() {
    init_lit();
    styles_default30 = i4`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-grid/index.js
var __decorate49, WuiGrid;
var init_wui_grid = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/layout/wui-grid/index.js"() {
    init_lit();
    init_decorators();
    init_ThemeUtil2();
    init_UiHelperUtil();
    init_WebComponentsUtil();
    init_styles30();
    __decorate49 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiGrid = class WuiGrid2 extends i7 {
      render() {
        this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
        return x6`<slot></slot>`;
      }
    };
    WuiGrid.styles = [resetStyles, styles_default30];
    __decorate49([
      n8()
    ], WuiGrid.prototype, "gridTemplateRows", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "gridTemplateColumns", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "justifyItems", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "alignItems", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "justifyContent", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "alignContent", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "columnGap", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "rowGap", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "gap", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "padding", void 0);
    __decorate49([
      n8()
    ], WuiGrid.prototype, "margin", void 0);
    WuiGrid = __decorate49([
      customElement("wui-grid")
    ], WuiGrid);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-grid.js
var init_wui_grid2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-grid.js"() {
    init_wui_grid();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/styles.js
var styles_default31;
var init_styles31 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/styles.js"() {
    init_lit();
    styles_default31 = i4`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    width: 104px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-s) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border-radius;
    outline: none;
    border: none;
  }

  button > wui-flex > wui-text {
    color: var(--wui-color-fg-100);
    max-width: 86px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button > wui-flex > wui-text.certified {
    max-width: 66px;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }

  @media (max-width: 350px) {
    button {
      width: 100%;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/index.js
var __decorate50, W3mAllWalletsListItem;
var init_w3m_all_wallets_list_item = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_icon2();
    init_wui_shimmer2();
    init_wui_text2();
    init_wui_wallet_image2();
    init_styles31();
    __decorate50 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mAllWalletsListItem = class W3mAllWalletsListItem2 extends i7 {
      constructor() {
        super();
        this.observer = new IntersectionObserver(() => void 0);
        this.visible = false;
        this.imageSrc = void 0;
        this.imageLoading = false;
        this.wallet = void 0;
        this.observer = new IntersectionObserver((entries2) => {
          entries2.forEach((entry) => {
            if (entry.isIntersecting) {
              this.visible = true;
              this.fetchImageSrc();
            } else {
              this.visible = false;
            }
          });
        }, { threshold: 0.01 });
      }
      firstUpdated() {
        this.observer.observe(this);
      }
      disconnectedCallback() {
        this.observer.disconnect();
      }
      render() {
        const certified = this.wallet?.badge_type === "certified";
        return x6`
      <button>
        ${this.imageTemplate()}
        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="3xs">
          <wui-text
            variant="tiny-500"
            color="inherit"
            class=${o10(certified ? "certified" : void 0)}
            >${this.wallet?.name}</wui-text
          >
          ${certified ? x6`<wui-icon size="sm" name="walletConnectBrown"></wui-icon>` : null}
        </wui-flex>
      </button>
    `;
      }
      imageTemplate() {
        if (!this.visible && !this.imageSrc || this.imageLoading) {
          return this.shimmerTemplate();
        }
        return x6`
      <wui-wallet-image
        size="md"
        imageSrc=${o10(this.imageSrc)}
        name=${this.wallet?.name}
        .installed=${this.wallet?.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
      }
      shimmerTemplate() {
        return x6`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
      }
      async fetchImageSrc() {
        if (!this.wallet) {
          return;
        }
        this.imageSrc = AssetUtil.getWalletImage(this.wallet);
        if (this.imageSrc) {
          return;
        }
        this.imageLoading = true;
        this.imageSrc = await AssetUtil.fetchWalletImage(this.wallet.image_id);
        this.imageLoading = false;
      }
    };
    W3mAllWalletsListItem.styles = styles_default31;
    __decorate50([
      r7()
    ], W3mAllWalletsListItem.prototype, "visible", void 0);
    __decorate50([
      r7()
    ], W3mAllWalletsListItem.prototype, "imageSrc", void 0);
    __decorate50([
      r7()
    ], W3mAllWalletsListItem.prototype, "imageLoading", void 0);
    __decorate50([
      n8()
    ], W3mAllWalletsListItem.prototype, "wallet", void 0);
    W3mAllWalletsListItem = __decorate50([
      customElement("w3m-all-wallets-list-item")
    ], W3mAllWalletsListItem);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/styles.js
var styles_default32;
var init_styles32 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/styles.js"() {
    init_lit();
    styles_default32 = i4`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/index.js
var __decorate51, PAGINATOR_ID, W3mAllWalletsList;
var init_w3m_all_wallets_list = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_card_select_loader2();
    init_wui_grid2();
    init_WalletUtil();
    init_w3m_all_wallets_list_item();
    init_styles32();
    __decorate51 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    PAGINATOR_ID = "local-paginator";
    W3mAllWalletsList = class W3mAllWalletsList2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.paginationObserver = void 0;
        this.loading = !ApiController.state.wallets.length;
        this.wallets = ApiController.state.wallets;
        this.recommended = ApiController.state.recommended;
        this.featured = ApiController.state.featured;
        this.filteredWallets = ApiController.state.filteredWallets;
        this.unsubscribe.push(...[
          ApiController.subscribeKey("wallets", (val) => this.wallets = val),
          ApiController.subscribeKey("recommended", (val) => this.recommended = val),
          ApiController.subscribeKey("featured", (val) => this.featured = val),
          ApiController.subscribeKey("filteredWallets", (val) => this.filteredWallets = val)
        ]);
      }
      firstUpdated() {
        this.initialFetch();
        this.createPaginationObserver();
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
        this.paginationObserver?.disconnect();
      }
      render() {
        return x6`
      <wui-grid
        data-scroll=${!this.loading}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.loading ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
      }
      async initialFetch() {
        this.loading = true;
        const gridEl = this.shadowRoot?.querySelector("wui-grid");
        if (gridEl) {
          await ApiController.fetchWalletsByPage({ page: 1 });
          await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }).finished;
          this.loading = false;
          gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          });
        }
      }
      shimmerTemplate(items, id) {
        return [...Array(items)].map(() => x6`
        <wui-card-select-loader type="wallet" id=${o10(id)}></wui-card-select-loader>
      `);
      }
      getWallets() {
        const wallets = [...this.featured, ...this.recommended];
        if (this.filteredWallets?.length > 0) {
          wallets.push(...this.filteredWallets);
        } else {
          wallets.push(...this.wallets);
        }
        const uniqueWallets = CoreHelperUtil.uniqueBy(wallets, "id");
        const walletsWithInstalled = WalletUtil.markWalletsAsInstalled(uniqueWallets);
        return WalletUtil.markWalletsWithDisplayIndex(walletsWithInstalled);
      }
      walletsTemplate() {
        const wallets = this.getWallets();
        return wallets.map((wallet) => x6`
        <w3m-all-wallets-list-item
          @click=${() => this.onConnectWallet(wallet)}
          .wallet=${wallet}
        ></w3m-all-wallets-list-item>
      `);
      }
      paginationLoaderTemplate() {
        const { wallets, recommended, featured, count } = ApiController.state;
        const columns = window.innerWidth < 352 ? 3 : 4;
        const currentWallets = wallets.length + recommended.length;
        const minimumRows = Math.ceil(currentWallets / columns);
        let shimmerCount = minimumRows * columns - currentWallets + columns;
        shimmerCount -= wallets.length ? featured.length % columns : 0;
        if (count === 0 && featured.length > 0) {
          return null;
        }
        if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
          return this.shimmerTemplate(shimmerCount, PAGINATOR_ID);
        }
        return null;
      }
      createPaginationObserver() {
        const loaderEl = this.shadowRoot?.querySelector(`#${PAGINATOR_ID}`);
        if (loaderEl) {
          this.paginationObserver = new IntersectionObserver(([element]) => {
            if (element?.isIntersecting && !this.loading) {
              const { page, count, wallets } = ApiController.state;
              if (wallets.length < count) {
                ApiController.fetchWalletsByPage({ page: page + 1 });
              }
            }
          });
          this.paginationObserver.observe(loaderEl);
        }
      }
      onConnectWallet(wallet) {
        ConnectorController.selectWalletConnector(wallet);
      }
    };
    W3mAllWalletsList.styles = styles_default32;
    __decorate51([
      r7()
    ], W3mAllWalletsList.prototype, "loading", void 0);
    __decorate51([
      r7()
    ], W3mAllWalletsList.prototype, "wallets", void 0);
    __decorate51([
      r7()
    ], W3mAllWalletsList.prototype, "recommended", void 0);
    __decorate51([
      r7()
    ], W3mAllWalletsList.prototype, "featured", void 0);
    __decorate51([
      r7()
    ], W3mAllWalletsList.prototype, "filteredWallets", void 0);
    W3mAllWalletsList = __decorate51([
      customElement("w3m-all-wallets-list")
    ], W3mAllWalletsList);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-loading-spinner.js
var init_wui_loading_spinner2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-loading-spinner.js"() {
    init_wui_loading_spinner();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/styles.js
var styles_default33;
var init_styles33 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/styles.js"() {
    init_lit();
    styles_default33 = i4`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 104px);
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }

  @media (max-width: 350px) {
    wui-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/index.js
var __decorate52, W3mAllWalletsSearch;
var init_w3m_all_wallets_search = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_grid2();
    init_wui_icon_box2();
    init_wui_loading_spinner2();
    init_wui_text2();
    init_WalletUtil();
    init_w3m_all_wallets_list_item();
    init_styles33();
    __decorate52 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends i7 {
      constructor() {
        super(...arguments);
        this.prevQuery = "";
        this.prevBadge = void 0;
        this.loading = true;
        this.query = "";
      }
      render() {
        this.onSearch();
        return this.loading ? x6`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
      }
      async onSearch() {
        if (this.query.trim() !== this.prevQuery.trim() || this.badge !== this.prevBadge) {
          this.prevQuery = this.query;
          this.prevBadge = this.badge;
          this.loading = true;
          await ApiController.searchWallet({ search: this.query, badge: this.badge });
          this.loading = false;
        }
      }
      walletsTemplate() {
        const { search } = ApiController.state;
        const wallets = WalletUtil.markWalletsAsInstalled(search);
        if (!search.length) {
          return x6`
        <wui-flex
          data-testid="no-wallet-found"
          justifyContent="center"
          alignItems="center"
          gap="s"
          flexDirection="column"
        >
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text data-testid="no-wallet-found-text" color="fg-200" variant="paragraph-500">
            No Wallet found
          </wui-text>
        </wui-flex>
      `;
        }
        return x6`
      <wui-grid
        data-testid="wallet-list"
        .padding=${["0", "s", "s", "s"]}
        rowGap="l"
        columnGap="xs"
        justifyContent="space-between"
      >
        ${wallets.map((wallet) => x6`
            <w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(wallet)}
              .wallet=${wallet}
              data-testid="wallet-search-item-${wallet.id}"
            ></w3m-all-wallets-list-item>
          `)}
      </wui-grid>
    `;
      }
      onConnectWallet(wallet) {
        ConnectorController.selectWalletConnector(wallet);
      }
    };
    W3mAllWalletsSearch.styles = styles_default33;
    __decorate52([
      r7()
    ], W3mAllWalletsSearch.prototype, "loading", void 0);
    __decorate52([
      n8()
    ], W3mAllWalletsSearch.prototype, "query", void 0);
    __decorate52([
      n8()
    ], W3mAllWalletsSearch.prototype, "badge", void 0);
    W3mAllWalletsSearch = __decorate52([
      customElement("w3m-all-wallets-search")
    ], W3mAllWalletsSearch);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-all-wallets-view/index.js
var __decorate53, W3mAllWalletsView;
var init_w3m_all_wallets_view = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-all-wallets-view/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_certified_switch2();
    init_wui_flex2();
    init_wui_icon_box2();
    init_wui_search_bar2();
    init_w3m_all_wallets_list();
    init_w3m_all_wallets_search();
    __decorate53 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mAllWalletsView = class W3mAllWalletsView2 extends i7 {
      constructor() {
        super(...arguments);
        this.search = "";
        this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
          this.search = value;
        });
      }
      render() {
        const isSearch = this.search.length >= 2;
        return x6`
      <wui-flex .padding=${["0", "s", "s", "s"]} gap="xs">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        <wui-certified-switch
          ?checked=${this.badge}
          @click=${this.onClick.bind(this)}
          data-testid="wui-certified-switch"
        ></wui-certified-switch>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch || this.badge ? x6`<w3m-all-wallets-search
            query=${this.search}
            badge=${o10(this.badge)}
          ></w3m-all-wallets-search>` : x6`<w3m-all-wallets-list badge=${o10(this.badge)}></w3m-all-wallets-list>`}
    `;
      }
      onInputChange(event) {
        this.onDebouncedSearch(event.detail);
      }
      onClick() {
        if (this.badge === "certified") {
          this.badge = void 0;
          return;
        }
        this.badge = "certified";
        SnackController.showSvg("Only WalletConnect certified", {
          icon: "walletConnectBrown",
          iconColor: "accent-100"
        });
      }
      qrButtonTemplate() {
        if (CoreHelperUtil.isMobile()) {
          return x6`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
        }
        return null;
      }
      onWalletConnectQr() {
        RouterController.push("ConnectingWalletConnect");
      }
    };
    __decorate53([
      r7()
    ], W3mAllWalletsView.prototype, "search", void 0);
    __decorate53([
      r7()
    ], W3mAllWalletsView.prototype, "badge", void 0);
    W3mAllWalletsView = __decorate53([
      customElement("w3m-all-wallets-view")
    ], W3mAllWalletsView);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-item/styles.js
var styles_default34;
var init_styles34 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-item/styles.js"() {
    init_lit();
    styles_default34 = i4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      color var(--wui-ease-out-power-1) var(--wui-duration-md),
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: color, background-color;
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    color: var(--wui-color-gray-glass-020);
  }

  button[data-loading='true'] > wui-icon {
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-item/index.js
var __decorate54, WuiListItem;
var init_wui_list_item = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-list-item/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_wui_icon();
    init_wui_image();
    init_wui_loading_spinner();
    init_wui_text();
    init_wui_flex();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_icon_box();
    init_styles34();
    __decorate54 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiListItem = class WuiListItem2 extends i7 {
      constructor() {
        super(...arguments);
        this.tabIdx = void 0;
        this.variant = "icon";
        this.disabled = false;
        this.imageSrc = void 0;
        this.alt = void 0;
        this.chevron = false;
        this.loading = false;
      }
      render() {
        return x6`
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${o10(this.iconVariant)}
        tabindex=${o10(this.tabIdx)}
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
      }
      visualTemplate() {
        if (this.variant === "image" && this.imageSrc) {
          return x6`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
        }
        if (this.iconVariant === "square" && this.icon && this.variant === "icon") {
          return x6`<wui-icon name=${this.icon}></wui-icon>`;
        }
        if (this.variant === "icon" && this.icon && this.iconVariant) {
          const color = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200";
          const size4 = this.iconVariant === "square-blue" ? "mdl" : "md";
          const iconSize = this.iconSize ? this.iconSize : size4;
          return x6`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color}
          backgroundColor=${color}
          size=${size4}
        ></wui-icon-box>
      `;
        }
        return null;
      }
      loadingTemplate() {
        if (this.loading) {
          return x6`<wui-loading-spinner
        data-testid="wui-list-item-loading-spinner"
        color="fg-300"
      ></wui-loading-spinner>`;
        }
        return x6``;
      }
      chevronTemplate() {
        if (this.chevron) {
          return x6`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`;
        }
        return null;
      }
    };
    WuiListItem.styles = [resetStyles, elementStyles, styles_default34];
    __decorate54([
      n8()
    ], WuiListItem.prototype, "icon", void 0);
    __decorate54([
      n8()
    ], WuiListItem.prototype, "iconSize", void 0);
    __decorate54([
      n8()
    ], WuiListItem.prototype, "tabIdx", void 0);
    __decorate54([
      n8()
    ], WuiListItem.prototype, "variant", void 0);
    __decorate54([
      n8()
    ], WuiListItem.prototype, "iconVariant", void 0);
    __decorate54([
      n8({ type: Boolean })
    ], WuiListItem.prototype, "disabled", void 0);
    __decorate54([
      n8()
    ], WuiListItem.prototype, "imageSrc", void 0);
    __decorate54([
      n8()
    ], WuiListItem.prototype, "alt", void 0);
    __decorate54([
      n8({ type: Boolean })
    ], WuiListItem.prototype, "chevron", void 0);
    __decorate54([
      n8({ type: Boolean })
    ], WuiListItem.prototype, "loading", void 0);
    WuiListItem = __decorate54([
      customElement("wui-list-item")
    ], WuiListItem);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-list-item.js
var init_wui_list_item2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-list-item.js"() {
    init_wui_list_item();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-downloads-view/index.js
var __decorate55, W3mDownloadsView;
var init_w3m_downloads_view = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-downloads-view/index.js"() {
    init_lit();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_list_item2();
    init_wui_text2();
    __decorate55 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mDownloadsView = class W3mDownloadsView2 extends i7 {
      constructor() {
        super(...arguments);
        this.wallet = RouterController.state.data?.wallet;
      }
      render() {
        if (!this.wallet) {
          throw new Error("w3m-downloads-view");
        }
        return x6`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
      }
      chromeTemplate() {
        if (!this.wallet?.chrome_store) {
          return null;
        }
        return x6`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
      }
      iosTemplate() {
        if (!this.wallet?.app_store) {
          return null;
        }
        return x6`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
      }
      androidTemplate() {
        if (!this.wallet?.play_store) {
          return null;
        }
        return x6`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
      }
      homepageTemplate() {
        if (!this.wallet?.homepage) {
          return null;
        }
        return x6`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
      }
      onChromeStore() {
        if (this.wallet?.chrome_store) {
          CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
        }
      }
      onAppStore() {
        if (this.wallet?.app_store) {
          CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
        }
      }
      onPlayStore() {
        if (this.wallet?.play_store) {
          CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
        }
      }
      onHomePage() {
        if (this.wallet?.homepage) {
          CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
        }
      }
    };
    W3mDownloadsView = __decorate55([
      customElement("w3m-downloads-view")
    ], W3mDownloadsView);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/exports/basic.js
var basic_exports = {};
__export(basic_exports, {
  W3mAllWalletsView: () => W3mAllWalletsView,
  W3mConnectingWcBasicView: () => W3mConnectingWcBasicView,
  W3mDownloadsView: () => W3mDownloadsView
});
var init_basic = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/exports/basic.js"() {
    init_w3m_connecting_wc_basic_view();
    init_w3m_all_wallets_view();
    init_w3m_downloads_view();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-card/styles.js
var styles_default35;
var init_styles35 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-card/styles.js"() {
    init_lit();
    styles_default35 = i4`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }

  :host([data-embedded='true']) {
    box-shadow:
      0 0 0 1px var(--wui-color-gray-glass-005),
      0px 4px 12px 4px var(--w3m-card-embedded-shadow-color);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/components/wui-card/index.js
var __decorate56, WuiCard;
var init_wui_card = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/components/wui-card/index.js"() {
    init_lit();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles35();
    __decorate56 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiCard = class WuiCard2 extends i7 {
      render() {
        return x6`<slot></slot>`;
      }
    };
    WuiCard.styles = [resetStyles, styles_default35];
    WuiCard = __decorate56([
      customElement("wui-card")
    ], WuiCard);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-card.js
var init_wui_card2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-card.js"() {
    init_wui_card();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-alertbar/styles.js
var styles_default36;
var init_styles36 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-alertbar/styles.js"() {
    init_lit();
    styles_default36 = i4`
  :host {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-dark-glass-100);
    box-sizing: border-box;
    background-color: var(--wui-color-bg-325);
    box-shadow: 0px 0px 16px 0px rgba(0, 0, 0, 0.25);
  }

  wui-flex {
    width: 100%;
  }

  wui-text {
    word-break: break-word;
    flex: 1;
  }

  .close {
    cursor: pointer;
  }

  .icon-box {
    height: 40px;
    width: 40px;
    border-radius: var(--wui-border-radius-3xs);
    background-color: var(--local-icon-bg-value);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-alertbar/index.js
var __decorate57, WuiAlertBar;
var init_wui_alertbar = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-alertbar/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_wui_icon();
    init_wui_text();
    init_wui_flex();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles36();
    __decorate57 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiAlertBar = class WuiAlertBar2 extends i7 {
      constructor() {
        super(...arguments);
        this.message = "";
        this.backgroundColor = "accent-100";
        this.iconColor = "accent-100";
        this.icon = "info";
      }
      render() {
        this.style.cssText = `
      --local-icon-bg-value: var(--wui-color-${this.backgroundColor});
   `;
        return x6`
      <wui-flex flexDirection="row" justifyContent="space-between" alignItems="center">
        <wui-flex columnGap="xs" flexDirection="row" alignItems="center">
          <wui-flex
            flexDirection="row"
            alignItems="center"
            justifyContent="center"
            class="icon-box"
          >
            <wui-icon color=${this.iconColor} size="md" name=${this.icon}></wui-icon>
          </wui-flex>
          <wui-text variant="small-500" color="bg-350" data-testid="wui-alertbar-text"
            >${this.message}</wui-text
          >
        </wui-flex>
        <wui-icon
          class="close"
          color="bg-350"
          size="sm"
          name="close"
          @click=${this.onClose}
        ></wui-icon>
      </wui-flex>
    `;
      }
      onClose() {
        AlertController.close();
      }
    };
    WuiAlertBar.styles = [resetStyles, styles_default36];
    __decorate57([
      n8()
    ], WuiAlertBar.prototype, "message", void 0);
    __decorate57([
      n8()
    ], WuiAlertBar.prototype, "backgroundColor", void 0);
    __decorate57([
      n8()
    ], WuiAlertBar.prototype, "iconColor", void 0);
    __decorate57([
      n8()
    ], WuiAlertBar.prototype, "icon", void 0);
    WuiAlertBar = __decorate57([
      customElement("wui-alertbar")
    ], WuiAlertBar);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-alertbar.js
var init_wui_alertbar2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-alertbar.js"() {
    init_wui_alertbar();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-alertbar/styles.js
var styles_default37;
var init_styles37 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-alertbar/styles.js"() {
    init_lit();
    styles_default37 = i4`
  :host {
    display: block;
    position: absolute;
    top: var(--wui-spacing-s);
    left: var(--wui-spacing-l);
    right: var(--wui-spacing-l);
    opacity: 0;
    pointer-events: none;
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-alertbar/index.js
var __decorate58, presets, W3mAlertBar;
var init_w3m_alertbar = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-alertbar/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_wui_alertbar2();
    init_styles37();
    __decorate58 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    presets = {
      info: {
        backgroundColor: "fg-350",
        iconColor: "fg-325",
        icon: "info"
      },
      success: {
        backgroundColor: "success-glass-reown-020",
        iconColor: "success-125",
        icon: "checkmark"
      },
      warning: {
        backgroundColor: "warning-glass-reown-020",
        iconColor: "warning-100",
        icon: "warningCircle"
      },
      error: {
        backgroundColor: "error-glass-reown-020",
        iconColor: "error-125",
        icon: "exclamationTriangle"
      }
    };
    W3mAlertBar = class W3mAlertBar2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.open = AlertController.state.open;
        this.onOpen(true);
        this.unsubscribe.push(AlertController.subscribeKey("open", (val) => {
          this.open = val;
          this.onOpen(false);
        }));
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const { message, variant } = AlertController.state;
        const preset = presets[variant];
        return x6`
      <wui-alertbar
        message=${message}
        backgroundColor=${preset?.backgroundColor}
        iconColor=${preset?.iconColor}
        icon=${preset?.icon}
      ></wui-alertbar>
    `;
      }
      onOpen(isMounted) {
        if (this.open) {
          this.animate([
            { opacity: 0, transform: "scale(0.85)" },
            { opacity: 1, transform: "scale(1)" }
          ], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
          });
          this.style.cssText = `pointer-events: auto`;
        } else if (!isMounted) {
          this.animate([
            { opacity: 1, transform: "scale(1)" },
            { opacity: 0, transform: "scale(0.85)" }
          ], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
          });
          this.style.cssText = `pointer-events: none`;
        }
      }
    };
    W3mAlertBar.styles = styles_default37;
    __decorate58([
      r7()
    ], W3mAlertBar.prototype, "open", void 0);
    W3mAlertBar = __decorate58([
      customElement("w3m-alertbar")
    ], W3mAlertBar);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-link/styles.js
var styles_default38;
var init_styles38 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-link/styles.js"() {
    init_lit();
    styles_default38 = i4`
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  @media (max-width: 700px) {
    :host(:not([size='sm'])) button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-link/index.js
var __decorate59, WuiIconLink;
var init_wui_icon_link = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-icon-link/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles38();
    __decorate59 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiIconLink = class WuiIconLink2 extends i7 {
      constructor() {
        super(...arguments);
        this.size = "md";
        this.disabled = false;
        this.icon = "copy";
        this.iconColor = "inherit";
      }
      render() {
        this.dataset["size"] = this.size;
        let borderRadius = "";
        let padding2 = "";
        switch (this.size) {
          case "lg":
            borderRadius = "--wui-border-radius-xs";
            padding2 = "--wui-spacing-1xs";
            break;
          case "sm":
            borderRadius = "--wui-border-radius-3xs";
            padding2 = "--wui-spacing-xxs";
            break;
          default:
            borderRadius = "--wui-border-radius-xxs";
            padding2 = "--wui-spacing-2xs";
            break;
        }
        this.style.cssText = `
    --local-border-radius: var(${borderRadius});
    --local-padding: var(${padding2});
    `;
        return x6`
      <button ?disabled=${this.disabled}>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
      }
    };
    WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles_default38];
    __decorate59([
      n8()
    ], WuiIconLink.prototype, "size", void 0);
    __decorate59([
      n8({ type: Boolean })
    ], WuiIconLink.prototype, "disabled", void 0);
    __decorate59([
      n8()
    ], WuiIconLink.prototype, "icon", void 0);
    __decorate59([
      n8()
    ], WuiIconLink.prototype, "iconColor", void 0);
    WuiIconLink = __decorate59([
      customElement("wui-icon-link")
    ], WuiIconLink);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-icon-link.js
var init_wui_icon_link2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-icon-link.js"() {
    init_wui_icon_link();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-select/styles.js
var styles_default39;
var init_styles39 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-select/styles.js"() {
    init_lit();
    styles_default39 = i4`
  button {
    display: block;
    display: flex;
    align-items: center;
    padding: var(--wui-spacing-xxs);
    gap: var(--wui-spacing-xxs);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-md);
    border-radius: var(--wui-border-radius-xxs);
  }

  wui-image {
    border-radius: 100%;
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  wui-icon-box {
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  button:active {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-select/index.js
var __decorate60, WuiSelect;
var init_wui_select = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-select/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_wui_image();
    init_wui_icon_box();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_styles39();
    __decorate60 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiSelect = class WuiSelect2 extends i7 {
      constructor() {
        super(...arguments);
        this.imageSrc = "";
      }
      render() {
        return x6`<button>
      ${this.imageTemplate()}
      <wui-icon size="xs" color="fg-200" name="chevronBottom"></wui-icon>
    </button>`;
      }
      imageTemplate() {
        if (this.imageSrc) {
          return x6`<wui-image src=${this.imageSrc} alt="select visual"></wui-image>`;
        }
        return x6`<wui-icon-box
      size="xxs"
      iconColor="fg-200"
      backgroundColor="fg-100"
      background="opaque"
      icon="networkPlaceholder"
    ></wui-icon-box>`;
      }
    };
    WuiSelect.styles = [resetStyles, elementStyles, colorStyles, styles_default39];
    __decorate60([
      n8()
    ], WuiSelect.prototype, "imageSrc", void 0);
    WuiSelect = __decorate60([
      customElement("wui-select")
    ], WuiSelect);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-select.js
var init_wui_select2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-select.js"() {
    init_wui_select();
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-tag.js
var init_wui_tag2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-tag.js"() {
    init_wui_tag();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/styles.js
var styles_default40;
var init_styles40 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/styles.js"() {
    init_lit();
    styles_default40 = i4`
  :host {
    height: 64px;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-flex.w3m-header-title {
    transform: translateY(0);
    opacity: 1;
  }

  wui-flex.w3m-header-title[view-direction='prev'] {
    animation:
      slide-down-out 120ms forwards var(--wui-ease-out-power-2),
      slide-down-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-flex.w3m-header-title[view-direction='next'] {
    animation:
      slide-up-out 120ms forwards var(--wui-ease-out-power-2),
      slide-up-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }

  @keyframes slide-up-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(3px);
      opacity: 0;
    }
  }

  @keyframes slide-up-in {
    from {
      transform: translateY(-3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slide-down-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(-3px);
      opacity: 0;
    }
  }

  @keyframes slide-down-in {
    from {
      transform: translateY(3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/index.js
function headings() {
  const connectorName = RouterController.state.data?.connector?.name;
  const walletName = RouterController.state.data?.wallet?.name;
  const networkName = RouterController.state.data?.network?.name;
  const name2 = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && connectors[0]?.id === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    Create: "Create Wallet",
    ChooseAccountName: void 0,
    Account: void 0,
    AccountSettings: void 0,
    AllWallets: "All Wallets",
    ApproveTransaction: "Approve Transaction",
    BuyInProgress: "Buy",
    ConnectingExternal: name2 ?? "Connect Wallet",
    ConnectingWalletConnect: name2 ?? "WalletConnect",
    ConnectingWalletConnectBasic: "WalletConnect",
    ConnectingSiwe: "Sign In",
    Convert: "Convert",
    ConvertSelectToken: "Select token",
    ConvertPreview: "Preview convert",
    Downloads: name2 ? `Get ${name2}` : "Downloads",
    EmailLogin: "Email Login",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    GetWallet: "Get a wallet",
    Networks: "Choose Network",
    OnRampProviders: "Choose Provider",
    OnRampActivity: "Activity",
    OnRampTokenSelect: "Select Token",
    OnRampFiatSelect: "Select Currency",
    Pay: "How you pay",
    ProfileWallets: "Wallets",
    SwitchNetwork: networkName ?? "Switch Network",
    Transactions: "Activity",
    UnsupportedChain: "Switch Network",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpdateEmailWallet: "Edit Email",
    UpdateEmailPrimaryOtp: "Confirm Current Email",
    UpdateEmailSecondaryOtp: "Confirm New Email",
    WhatIsABuy: "What is Buy?",
    RegisterAccountName: "Choose name",
    RegisterAccountNameSuccess: "",
    WalletReceive: "Receive",
    WalletCompatibleNetworks: "Compatible Networks",
    Swap: "Swap",
    SwapSelectToken: "Select token",
    SwapPreview: "Preview swap",
    WalletSend: "Send",
    WalletSendPreview: "Review send",
    WalletSendSelectToken: "Select Token",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    ConnectWallets: "Connect wallet",
    ConnectSocials: "All socials",
    ConnectingSocial: AccountController.state.socialProvider ? AccountController.state.socialProvider : "Connect Social",
    ConnectingMultiChain: "Select chain",
    ConnectingFarcaster: "Farcaster",
    SwitchActiveChain: "Switch chain",
    SmartSessionCreated: void 0,
    SmartSessionList: "Smart Sessions",
    SIWXSignMessage: "Sign In",
    PayLoading: "Payment in progress",
    DataCapture: "Profile",
    DataCaptureOtpConfirm: "Confirm Email"
  };
}
var __decorate61, BETA_SCREENS, W3mHeader;
var init_w3m_header = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_icon_link2();
    init_wui_select2();
    init_wui_tag2();
    init_wui_text2();
    init_ConstantsUtil4();
    init_styles40();
    __decorate61 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    BETA_SCREENS = ["SmartSessionList"];
    W3mHeader = class W3mHeader2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.heading = headings()[RouterController.state.view];
        this.network = ChainController.state.activeCaipNetwork;
        this.networkImage = AssetUtil.getNetworkImage(this.network);
        this.showBack = false;
        this.prevHistoryLength = 1;
        this.view = RouterController.state.view;
        this.viewDirection = "";
        this.headerText = headings()[RouterController.state.view];
        this.unsubscribe.push(AssetController.subscribeNetworkImages(() => {
          this.networkImage = AssetUtil.getNetworkImage(this.network);
        }), RouterController.subscribeKey("view", (val) => {
          setTimeout(() => {
            this.view = val;
            this.headerText = headings()[val];
          }, ConstantsUtil4.ANIMATION_DURATIONS.HeaderText);
          this.onViewChange();
          this.onHistoryChange();
        }), ChainController.subscribeKey("activeCaipNetwork", (val) => {
          this.network = val;
          this.networkImage = AssetUtil.getNetworkImage(this.network);
        }));
      }
      disconnectCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        return x6`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.leftHeaderTemplate()} ${this.titleTemplate()} ${this.rightHeaderTemplate()}
      </wui-flex>
    `;
      }
      onWalletHelp() {
        EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
        RouterController.push("WhatIsAWallet");
      }
      async onClose() {
        await ModalUtil.safeClose();
      }
      rightHeaderTemplate() {
        const isSmartSessionsEnabled = OptionsController?.state?.features?.smartSessions;
        if (RouterController.state.view !== "Account" || !isSmartSessionsEnabled) {
          return this.closeButtonTemplate();
        }
        return x6`<wui-flex>
      <wui-icon-link
        icon="clock"
        @click=${() => RouterController.push("SmartSessionList")}
        data-testid="w3m-header-smart-sessions"
      ></wui-icon-link>
      ${this.closeButtonTemplate()}
    </wui-flex> `;
      }
      closeButtonTemplate() {
        return x6`
      <wui-icon-link
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="w3m-header-close"
      ></wui-icon-link>
    `;
      }
      titleTemplate() {
        const isBeta = BETA_SCREENS.includes(this.view);
        return x6`
      <wui-flex
        view-direction="${this.viewDirection}"
        class="w3m-header-title"
        alignItems="center"
        gap="xs"
      >
        <wui-text variant="paragraph-700" color="fg-100" data-testid="w3m-header-text"
          >${this.headerText}</wui-text
        >
        ${isBeta ? x6`<wui-tag variant="main">Beta</wui-tag>` : null}
      </wui-flex>
    `;
      }
      leftHeaderTemplate() {
        const { view } = RouterController.state;
        const isConnectHelp = view === "Connect";
        const isEmbeddedEnable = OptionsController.state.enableEmbedded;
        const isApproveTransaction = view === "ApproveTransaction";
        const isConnectingSIWEView = view === "ConnectingSiwe";
        const isAccountView = view === "Account";
        const enableNetworkSwitch = OptionsController.state.enableNetworkSwitch;
        const shouldHideBack = isApproveTransaction || isConnectingSIWEView || isConnectHelp && isEmbeddedEnable;
        if (isAccountView && enableNetworkSwitch) {
          return x6`<wui-select
        id="dynamic"
        data-testid="w3m-account-select-network"
        active-network=${o10(this.network?.name)}
        @click=${this.onNetworks.bind(this)}
        imageSrc=${o10(this.networkImage)}
      ></wui-select>`;
        }
        if (this.showBack && !shouldHideBack) {
          return x6`<wui-icon-link
        data-testid="header-back"
        id="dynamic"
        icon="chevronLeft"
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
        }
        return x6`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
      }
      onNetworks() {
        if (this.isAllowedNetworkSwitch()) {
          EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
          RouterController.push("Networks");
        }
      }
      isAllowedNetworkSwitch() {
        const requestedCaipNetworks = ChainController.getAllRequestedCaipNetworks();
        const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
        const isValidNetwork = requestedCaipNetworks?.find(({ id }) => id === this.network?.id);
        return isMultiNetwork || !isValidNetwork;
      }
      getPadding() {
        if (this.heading) {
          return ["l", "2l", "l", "2l"];
        }
        return ["0", "2l", "0", "2l"];
      }
      onViewChange() {
        const { history } = RouterController.state;
        let direction = ConstantsUtil4.VIEW_DIRECTION.Next;
        if (history.length < this.prevHistoryLength) {
          direction = ConstantsUtil4.VIEW_DIRECTION.Prev;
        }
        this.prevHistoryLength = history.length;
        this.viewDirection = direction;
      }
      async onHistoryChange() {
        const { history } = RouterController.state;
        const buttonEl = this.shadowRoot?.querySelector("#dynamic");
        if (history.length > 1 && !this.showBack && buttonEl) {
          await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }).finished;
          this.showBack = true;
          buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          });
        } else if (history.length <= 1 && this.showBack && buttonEl) {
          await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }).finished;
          this.showBack = false;
          buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          });
        }
      }
      onGoBack() {
        RouterController.goBack();
      }
    };
    W3mHeader.styles = styles_default40;
    __decorate61([
      r7()
    ], W3mHeader.prototype, "heading", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "network", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "networkImage", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "showBack", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "prevHistoryLength", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "view", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "viewDirection", void 0);
    __decorate61([
      r7()
    ], W3mHeader.prototype, "headerText", void 0);
    W3mHeader = __decorate61([
      customElement("w3m-header")
    ], W3mHeader);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-snackbar/styles.js
var styles_default41;
var init_styles41 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-snackbar/styles.js"() {
    init_lit();
    styles_default41 = i4`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-005);
    box-sizing: border-box;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);

    max-width: 300px;
  }

  :host wui-loading-spinner {
    margin-left: var(--wui-spacing-3xs);
  }
`;
  }
});

// node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-snackbar/index.js
var __decorate62, WuiSnackbar;
var init_wui_snackbar = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/src/composites/wui-snackbar/index.js"() {
    init_lit();
    init_decorators();
    init_wui_icon();
    init_wui_loading_spinner();
    init_wui_text();
    init_ThemeUtil2();
    init_WebComponentsUtil();
    init_wui_icon_box();
    init_styles41();
    __decorate62 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    WuiSnackbar = class WuiSnackbar2 extends i7 {
      constructor() {
        super(...arguments);
        this.backgroundColor = "accent-100";
        this.iconColor = "accent-100";
        this.icon = "checkmark";
        this.message = "";
        this.loading = false;
        this.iconType = "default";
      }
      render() {
        return x6`
      ${this.templateIcon()}
      <wui-text variant="paragraph-500" color="fg-100" data-testid="wui-snackbar-message"
        >${this.message}</wui-text
      >
    `;
      }
      templateIcon() {
        if (this.loading) {
          return x6`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>`;
        }
        if (this.iconType === "default") {
          return x6`<wui-icon size="xl" color=${this.iconColor} name=${this.icon}></wui-icon>`;
        }
        return x6`<wui-icon-box
      size="sm"
      iconSize="xs"
      iconColor=${this.iconColor}
      backgroundColor=${this.backgroundColor}
      icon=${this.icon}
      background="opaque"
    ></wui-icon-box>`;
      }
    };
    WuiSnackbar.styles = [resetStyles, styles_default41];
    __decorate62([
      n8()
    ], WuiSnackbar.prototype, "backgroundColor", void 0);
    __decorate62([
      n8()
    ], WuiSnackbar.prototype, "iconColor", void 0);
    __decorate62([
      n8()
    ], WuiSnackbar.prototype, "icon", void 0);
    __decorate62([
      n8()
    ], WuiSnackbar.prototype, "message", void 0);
    __decorate62([
      n8()
    ], WuiSnackbar.prototype, "loading", void 0);
    __decorate62([
      n8()
    ], WuiSnackbar.prototype, "iconType", void 0);
    WuiSnackbar = __decorate62([
      customElement("wui-snackbar")
    ], WuiSnackbar);
  }
});

// node_modules/@reown/appkit-ui/dist/esm/exports/wui-snackbar.js
var init_wui_snackbar2 = __esm({
  "node_modules/@reown/appkit-ui/dist/esm/exports/wui-snackbar.js"() {
    init_wui_snackbar();
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/styles.js
var styles_default42;
var init_styles42 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/styles.js"() {
    init_lit();
    styles_default42 = i4`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/index.js
var __decorate63, presets2, W3mSnackBar;
var init_w3m_snackbar = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_wui_snackbar2();
    init_styles42();
    __decorate63 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    presets2 = {
      loading: void 0,
      success: {
        backgroundColor: "success-100",
        iconColor: "success-100",
        icon: "checkmark"
      },
      error: {
        backgroundColor: "error-100",
        iconColor: "error-100",
        icon: "close"
      }
    };
    W3mSnackBar = class W3mSnackBar2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.timeout = void 0;
        this.open = SnackController.state.open;
        this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
          this.open = val;
          this.onOpen();
        }));
      }
      disconnectedCallback() {
        clearTimeout(this.timeout);
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        const { message, variant, svg } = SnackController.state;
        const preset = presets2[variant];
        const { icon, iconColor } = svg ?? preset ?? {};
        return x6`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset?.backgroundColor}
        iconColor=${iconColor}
        icon=${icon}
        .loading=${variant === "loading"}
      ></wui-snackbar>
    `;
      }
      onOpen() {
        clearTimeout(this.timeout);
        if (this.open) {
          this.animate([
            { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
            { opacity: 1, transform: "translateX(-50%) scale(1)" }
          ], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
          });
          if (this.timeout) {
            clearTimeout(this.timeout);
          }
          if (SnackController.state.autoClose) {
            this.timeout = setTimeout(() => SnackController.hide(), 2500);
          }
        } else {
          this.animate([
            { opacity: 1, transform: "translateX(-50%) scale(1)" },
            { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
          ], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
          });
        }
      }
    };
    W3mSnackBar.styles = styles_default42;
    __decorate63([
      r7()
    ], W3mSnackBar.prototype, "open", void 0);
    W3mSnackBar = __decorate63([
      customElement("w3m-snackbar")
    ], W3mSnackBar);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/styles.js
var styles_default43;
var init_styles43 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/styles.js"() {
    init_lit();
    styles_default43 = i4`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/index.js
var __decorate64, W3mTooltip;
var init_w3m_tooltip = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_wui_flex2();
    init_wui_icon2();
    init_wui_text2();
    init_styles43();
    __decorate64 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mTooltip = class W3mTooltip2 extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.open = TooltipController.state.open;
        this.message = TooltipController.state.message;
        this.triggerRect = TooltipController.state.triggerRect;
        this.variant = TooltipController.state.variant;
        this.unsubscribe.push(...[
          TooltipController.subscribe((newState) => {
            this.open = newState.open;
            this.message = newState.message;
            this.triggerRect = newState.triggerRect;
            this.variant = newState.variant;
          })
        ]);
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        this.dataset["variant"] = this.variant;
        const topValue = this.triggerRect.top;
        const leftValue = this.triggerRect.left;
        this.style.cssText = `
    --w3m-tooltip-top: ${topValue}px;
    --w3m-tooltip-left: ${leftValue}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `;
        return x6`<wui-flex>
      <wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>
    </wui-flex>`;
      }
    };
    W3mTooltip.styles = [styles_default43];
    __decorate64([
      r7()
    ], W3mTooltip.prototype, "open", void 0);
    __decorate64([
      r7()
    ], W3mTooltip.prototype, "message", void 0);
    __decorate64([
      r7()
    ], W3mTooltip.prototype, "triggerRect", void 0);
    __decorate64([
      r7()
    ], W3mTooltip.prototype, "variant", void 0);
    W3mTooltip = __decorate64([
      customElement("w3m-tooltip"),
      customElement("w3m-tooltip")
    ], W3mTooltip);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/styles.js
var styles_default44;
var init_styles44 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/styles.js"() {
    init_lit();
    styles_default44 = i4`
  :host {
    --prev-height: 0px;
    --new-height: 0px;
    display: block;
  }

  div.w3m-router-container {
    transform: translateY(0);
    opacity: 1;
  }

  div.w3m-router-container[view-direction='prev'] {
    animation:
      slide-left-out 150ms forwards ease,
      slide-left-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  div.w3m-router-container[view-direction='next'] {
    animation:
      slide-right-out 150ms forwards ease,
      slide-right-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  @keyframes slide-left-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(10px);
      opacity: 0;
    }
  }

  @keyframes slide-left-in {
    from {
      transform: translateX(-10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-right-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(-10px);
      opacity: 0;
    }
  }

  @keyframes slide-right-in {
    from {
      transform: translateX(10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/index.js
var __decorate65, W3mRouter;
var init_w3m_router = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/index.js"() {
    init_lit();
    init_decorators();
    init_exports();
    init_exports3();
    init_ConstantsUtil4();
    init_styles44();
    __decorate65 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    W3mRouter = class W3mRouter2 extends i7 {
      constructor() {
        super();
        this.resizeObserver = void 0;
        this.prevHeight = "0px";
        this.prevHistoryLength = 1;
        this.unsubscribe = [];
        this.view = RouterController.state.view;
        this.viewDirection = "";
        this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
      }
      firstUpdated() {
        this.resizeObserver = new ResizeObserver(([content]) => {
          const height = `${content?.contentRect.height}px`;
          if (this.prevHeight !== "0px") {
            this.style.setProperty("--prev-height", this.prevHeight);
            this.style.setProperty("--new-height", height);
            this.style.animation = "w3m-view-height 150ms forwards ease";
            this.style.height = "auto";
          }
          setTimeout(() => {
            this.prevHeight = height;
            this.style.animation = "unset";
          }, ConstantsUtil4.ANIMATION_DURATIONS.ModalHeight);
        });
        this.resizeObserver?.observe(this.getWrapper());
      }
      disconnectedCallback() {
        this.resizeObserver?.unobserve(this.getWrapper());
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
      }
      render() {
        return x6`<div class="w3m-router-container" view-direction="${this.viewDirection}">
      ${this.viewTemplate()}
    </div>`;
      }
      viewTemplate() {
        switch (this.view) {
          case "AccountSettings":
            return x6`<w3m-account-settings-view></w3m-account-settings-view>`;
          case "Account":
            return x6`<w3m-account-view></w3m-account-view>`;
          case "AllWallets":
            return x6`<w3m-all-wallets-view></w3m-all-wallets-view>`;
          case "ApproveTransaction":
            return x6`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
          case "BuyInProgress":
            return x6`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
          case "ChooseAccountName":
            return x6`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
          case "Connect":
            return x6`<w3m-connect-view></w3m-connect-view>`;
          case "Create":
            return x6`<w3m-connect-view walletGuide="explore"></w3m-connect-view>`;
          case "ConnectingWalletConnect":
            return x6`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
          case "ConnectingWalletConnectBasic":
            return x6`<w3m-connecting-wc-basic-view></w3m-connecting-wc-basic-view>`;
          case "ConnectingExternal":
            return x6`<w3m-connecting-external-view></w3m-connecting-external-view>`;
          case "ConnectingSiwe":
            return x6`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
          case "ConnectWallets":
            return x6`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
          case "ConnectSocials":
            return x6`<w3m-connect-socials-view></w3m-connect-socials-view>`;
          case "ConnectingSocial":
            return x6`<w3m-connecting-social-view></w3m-connecting-social-view>`;
          case "DataCapture":
            return x6`<w3m-data-capture-view></w3m-data-capture-view>`;
          case "DataCaptureOtpConfirm":
            return x6`<w3m-data-capture-otp-confirm-view></w3m-data-capture-otp-confirm-view>`;
          case "Downloads":
            return x6`<w3m-downloads-view></w3m-downloads-view>`;
          case "EmailLogin":
            return x6`<w3m-email-login-view></w3m-email-login-view>`;
          case "EmailVerifyOtp":
            return x6`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
          case "EmailVerifyDevice":
            return x6`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
          case "GetWallet":
            return x6`<w3m-get-wallet-view></w3m-get-wallet-view>`;
          case "Networks":
            return x6`<w3m-networks-view></w3m-networks-view>`;
          case "SwitchNetwork":
            return x6`<w3m-network-switch-view></w3m-network-switch-view>`;
          case "ProfileWallets":
            return x6`<w3m-profile-wallets-view></w3m-profile-wallets-view>`;
          case "Transactions":
            return x6`<w3m-transactions-view></w3m-transactions-view>`;
          case "OnRampProviders":
            return x6`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
          case "OnRampTokenSelect":
            return x6`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
          case "OnRampFiatSelect":
            return x6`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
          case "UpgradeEmailWallet":
            return x6`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
          case "UpdateEmailWallet":
            return x6`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
          case "UpdateEmailPrimaryOtp":
            return x6`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
          case "UpdateEmailSecondaryOtp":
            return x6`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
          case "UnsupportedChain":
            return x6`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
          case "Swap":
            return x6`<w3m-swap-view></w3m-swap-view>`;
          case "SwapSelectToken":
            return x6`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
          case "SwapPreview":
            return x6`<w3m-swap-preview-view></w3m-swap-preview-view>`;
          case "WalletSend":
            return x6`<w3m-wallet-send-view></w3m-wallet-send-view>`;
          case "WalletSendSelectToken":
            return x6`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
          case "WalletSendPreview":
            return x6`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
          case "WhatIsABuy":
            return x6`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
          case "WalletReceive":
            return x6`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
          case "WalletCompatibleNetworks":
            return x6`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
          case "WhatIsAWallet":
            return x6`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
          case "ConnectingMultiChain":
            return x6`<w3m-connecting-multi-chain-view></w3m-connecting-multi-chain-view>`;
          case "WhatIsANetwork":
            return x6`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
          case "ConnectingFarcaster":
            return x6`<w3m-connecting-farcaster-view></w3m-connecting-farcaster-view>`;
          case "SwitchActiveChain":
            return x6`<w3m-switch-active-chain-view></w3m-switch-active-chain-view>`;
          case "RegisterAccountName":
            return x6`<w3m-register-account-name-view></w3m-register-account-name-view>`;
          case "RegisterAccountNameSuccess":
            return x6`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
          case "SmartSessionCreated":
            return x6`<w3m-smart-session-created-view></w3m-smart-session-created-view>`;
          case "SmartSessionList":
            return x6`<w3m-smart-session-list-view></w3m-smart-session-list-view>`;
          case "SIWXSignMessage":
            return x6`<w3m-siwx-sign-message-view></w3m-siwx-sign-message-view>`;
          case "Pay":
            return x6`<w3m-pay-view></w3m-pay-view>`;
          case "PayLoading":
            return x6`<w3m-pay-loading-view></w3m-pay-loading-view>`;
          default:
            return x6`<w3m-connect-view></w3m-connect-view>`;
        }
      }
      onViewChange(newView) {
        TooltipController.hide();
        let direction = ConstantsUtil4.VIEW_DIRECTION.Next;
        const { history } = RouterController.state;
        if (history.length < this.prevHistoryLength) {
          direction = ConstantsUtil4.VIEW_DIRECTION.Prev;
        }
        this.prevHistoryLength = history.length;
        this.viewDirection = direction;
        setTimeout(() => {
          this.view = newView;
        }, ConstantsUtil4.ANIMATION_DURATIONS.ViewTransition);
      }
      getWrapper() {
        return this.shadowRoot?.querySelector("div");
      }
    };
    W3mRouter.styles = styles_default44;
    __decorate65([
      r7()
    ], W3mRouter.prototype, "view", void 0);
    __decorate65([
      r7()
    ], W3mRouter.prototype, "viewDirection", void 0);
    W3mRouter = __decorate65([
      customElement("w3m-router")
    ], W3mRouter);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-modal/styles.js
var styles_default45;
var init_styles45 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-modal/styles.js"() {
    init_lit();
    styles_default45 = i4`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host(.open) {
    opacity: 1;
  }

  :host(.appkit-modal) {
    position: relative;
    pointer-events: unset;
    background: none;
    width: 100%;
    opacity: 1;
  }

  wui-card {
    max-width: var(--w3m-modal-width);
    width: 100%;
    position: relative;
    animation: zoom-in 0.2s var(--wui-ease-out-power-2);
    animation-fill-mode: backwards;
    outline: none;
    transition:
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius, background-color;
  }

  :host(.appkit-modal) wui-card {
    max-width: 400px;
  }

  wui-card[shake='true'] {
    animation:
      zoom-in 0.2s var(--wui-ease-out-power-2),
      w3m-shake 0.5s var(--wui-ease-out-power-2);
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: var(--local-border-bottom-mobile-radius);
      border-bottom-right-radius: var(--local-border-bottom-mobile-radius);
      border-bottom: none;
      animation: slide-in 0.2s var(--wui-ease-out-power-2);
    }

    wui-card[shake='true'] {
      animation:
        slide-in 0.2s var(--wui-ease-out-power-2),
        w3m-shake 0.5s var(--wui-ease-out-power-2);
    }
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes w3m-shake {
    0% {
      transform: scale(1) rotate(0deg);
    }
    20% {
      transform: scale(1) rotate(-1deg);
    }
    40% {
      transform: scale(1) rotate(1.5deg);
    }
    60% {
      transform: scale(1) rotate(-1.5deg);
    }
    80% {
      transform: scale(1) rotate(1deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
    }
  }

  @keyframes w3m-view-height {
    from {
      height: var(--prev-height);
    }
    to {
      height: var(--new-height);
    }
  }
`;
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-modal/index.js
var __decorate66, SCROLL_LOCK, W3mModalBase, W3mModal, AppKitModal;
var init_w3m_modal = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-modal/index.js"() {
    init_lit();
    init_decorators();
    init_if_defined2();
    init_esm8();
    init_exports();
    init_exports3();
    init_wui_card2();
    init_wui_flex2();
    init_w3m_alertbar();
    init_w3m_header();
    init_w3m_snackbar();
    init_w3m_tooltip();
    init_w3m_router();
    init_styles45();
    __decorate66 = function(decorators, target, key, desc) {
      var c12 = arguments.length, r9 = c12 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d7;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r9 = Reflect.decorate(decorators, target, key, desc);
      else for (var i11 = decorators.length - 1; i11 >= 0; i11--) if (d7 = decorators[i11]) r9 = (c12 < 3 ? d7(r9) : c12 > 3 ? d7(target, key, r9) : d7(target, key)) || r9;
      return c12 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
    };
    SCROLL_LOCK = "scroll-lock";
    W3mModalBase = class extends i7 {
      constructor() {
        super();
        this.unsubscribe = [];
        this.abortController = void 0;
        this.hasPrefetched = false;
        this.enableEmbedded = OptionsController.state.enableEmbedded;
        this.open = ModalController.state.open;
        this.caipAddress = ChainController.state.activeCaipAddress;
        this.caipNetwork = ChainController.state.activeCaipNetwork;
        this.shake = ModalController.state.shake;
        this.filterByNamespace = ConnectorController.state.filterByNamespace;
        this.initializeTheming();
        ApiController.prefetchAnalyticsConfig();
        this.unsubscribe.push(...[
          ModalController.subscribeKey("open", (val) => val ? this.onOpen() : this.onClose()),
          ModalController.subscribeKey("shake", (val) => this.shake = val),
          ChainController.subscribeKey("activeCaipNetwork", (val) => this.onNewNetwork(val)),
          ChainController.subscribeKey("activeCaipAddress", (val) => this.onNewAddress(val)),
          OptionsController.subscribeKey("enableEmbedded", (val) => this.enableEmbedded = val),
          ConnectorController.subscribeKey("filterByNamespace", (val) => {
            if (this.filterByNamespace !== val && !ChainController.getAccountData(val)?.caipAddress) {
              ApiController.fetchRecommendedWallets();
              this.filterByNamespace = val;
            }
          })
        ]);
      }
      firstUpdated() {
        if (this.caipAddress) {
          if (this.enableEmbedded) {
            ModalController.close();
            this.prefetch();
            return;
          }
          this.onNewAddress(this.caipAddress);
        }
        if (this.open) {
          this.onOpen();
        }
        if (this.enableEmbedded) {
          this.prefetch();
        }
      }
      disconnectedCallback() {
        this.unsubscribe.forEach((unsubscribe) => unsubscribe());
        this.onRemoveKeyboardListener();
      }
      render() {
        this.style.cssText = `
      --local-border-bottom-mobile-radius: ${this.enableEmbedded ? "clamp(0px, var(--wui-border-radius-l), 44px)" : "0px"};
    `;
        if (this.enableEmbedded) {
          return x6`${this.contentTemplate()}
        <w3m-tooltip></w3m-tooltip> `;
        }
        return this.open ? x6`
          <wui-flex @click=${this.onOverlayClick.bind(this)} data-testid="w3m-modal-overlay">
            ${this.contentTemplate()}
          </wui-flex>
          <w3m-tooltip></w3m-tooltip>
        ` : null;
      }
      contentTemplate() {
        return x6` <wui-card
      shake="${this.shake}"
      data-embedded="${o10(this.enableEmbedded)}"
      role="alertdialog"
      aria-modal="true"
      tabindex="0"
      data-testid="w3m-modal-card"
    >
      <w3m-header></w3m-header>
      <w3m-router></w3m-router>
      <w3m-snackbar></w3m-snackbar>
      <w3m-alertbar></w3m-alertbar>
    </wui-card>`;
      }
      async onOverlayClick(event) {
        if (event.target === event.currentTarget) {
          await this.handleClose();
        }
      }
      async handleClose() {
        await ModalUtil.safeClose();
      }
      initializeTheming() {
        const { themeVariables, themeMode } = ThemeController.state;
        const defaultThemeMode = UiHelperUtil.getColorTheme(themeMode);
        initializeTheming(themeVariables, defaultThemeMode);
      }
      onClose() {
        this.open = false;
        this.classList.remove("open");
        this.onScrollUnlock();
        SnackController.hide();
        this.onRemoveKeyboardListener();
      }
      onOpen() {
        this.open = true;
        this.classList.add("open");
        this.onScrollLock();
        this.onAddKeyboardListener();
      }
      onScrollLock() {
        const styleTag = document.createElement("style");
        styleTag.dataset["w3m"] = SCROLL_LOCK;
        styleTag.textContent = `
      body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `;
        document.head.appendChild(styleTag);
      }
      onScrollUnlock() {
        const styleTag = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
        if (styleTag) {
          styleTag.remove();
        }
      }
      onAddKeyboardListener() {
        this.abortController = new AbortController();
        const card = this.shadowRoot?.querySelector("wui-card");
        card?.focus();
        window.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            this.handleClose();
          } else if (event.key === "Tab") {
            const { tagName } = event.target;
            if (tagName && !tagName.includes("W3M-") && !tagName.includes("WUI-")) {
              card?.focus();
            }
          }
        }, this.abortController);
      }
      onRemoveKeyboardListener() {
        this.abortController?.abort();
        this.abortController = void 0;
      }
      async onNewAddress(caipAddress) {
        const isSwitchingNamespace = ChainController.state.isSwitchingNamespace;
        const isInProfileView = RouterController.state.view === "ProfileWallets";
        if (caipAddress) {
          await this.onConnected({
            caipAddress,
            isSwitchingNamespace,
            isInProfileView
          });
        } else if (!isSwitchingNamespace && !this.enableEmbedded && !isInProfileView) {
          ModalController.close();
        }
        await SIWXUtil.initializeIfEnabled(caipAddress);
        this.caipAddress = caipAddress;
        ChainController.setIsSwitchingNamespace(false);
      }
      async onConnected(args) {
        if (args.isInProfileView) {
          return;
        }
        const { chainNamespace, chainId, address: newAddress } = ParseUtil.parseCaipAddress(args.caipAddress);
        const caipNetworkId = `${chainNamespace}:${chainId}`;
        const wasPreviouslyDisconnected = !CoreHelperUtil.getPlainAddress(this.caipAddress);
        const sessions = await SIWXUtil.getSessions({ address: newAddress, caipNetworkId });
        const isAuthenticated = SIWXUtil.getSIWX() ? sessions.some((s8) => s8.data.accountAddress === newAddress) : true;
        const shouldGoBack = args.isSwitchingNamespace && isAuthenticated && !this.enableEmbedded;
        const shouldCloseEmbeddedModal = this.enableEmbedded && wasPreviouslyDisconnected;
        if (shouldGoBack) {
          RouterController.goBack();
        } else if (shouldCloseEmbeddedModal) {
          ModalController.close();
        }
      }
      onNewNetwork(nextCaipNetwork) {
        const prevCaipNetwork = this.caipNetwork;
        const prevCaipNetworkId = prevCaipNetwork?.caipNetworkId?.toString();
        const prevChainNamespace = prevCaipNetwork?.chainNamespace;
        const nextNetworkId = nextCaipNetwork?.caipNetworkId?.toString();
        const nextChainNamespace = nextCaipNetwork?.chainNamespace;
        const networkIdChanged = prevCaipNetworkId !== nextNetworkId;
        const namespaceChanged = prevChainNamespace !== nextChainNamespace;
        const isNetworkChangedInSameNamespace = networkIdChanged && !namespaceChanged;
        const wasUnsupportedNetwork = prevCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
        const isConnectingExternal = RouterController.state.view === "ConnectingExternal";
        const isInProfileWalletsView = RouterController.state.view === "ProfileWallets";
        const isNotConnected = !ChainController.getAccountData(nextCaipNetwork?.chainNamespace)?.caipAddress;
        const isUnsupportedNetworkScreen = RouterController.state.view === "UnsupportedChain";
        const isModalOpen = ModalController.state.open;
        let shouldGoBack = false;
        if (this.enableEmbedded && RouterController.state.view === "SwitchNetwork") {
          shouldGoBack = true;
        }
        if (isModalOpen && !isConnectingExternal && !isInProfileWalletsView) {
          if (isNotConnected) {
            if (networkIdChanged) {
              shouldGoBack = true;
            }
          } else if (isUnsupportedNetworkScreen) {
            shouldGoBack = true;
          } else if (isNetworkChangedInSameNamespace && !wasUnsupportedNetwork) {
            shouldGoBack = true;
          }
        }
        if (shouldGoBack && RouterController.state.view !== "SIWXSignMessage") {
          RouterController.goBack();
        }
        this.caipNetwork = nextCaipNetwork;
      }
      prefetch() {
        if (!this.hasPrefetched) {
          ApiController.prefetch();
          ApiController.fetchWalletsByPage({ page: 1 });
          this.hasPrefetched = true;
        }
      }
    };
    W3mModalBase.styles = styles_default45;
    __decorate66([
      n8({ type: Boolean })
    ], W3mModalBase.prototype, "enableEmbedded", void 0);
    __decorate66([
      r7()
    ], W3mModalBase.prototype, "open", void 0);
    __decorate66([
      r7()
    ], W3mModalBase.prototype, "caipAddress", void 0);
    __decorate66([
      r7()
    ], W3mModalBase.prototype, "caipNetwork", void 0);
    __decorate66([
      r7()
    ], W3mModalBase.prototype, "shake", void 0);
    __decorate66([
      r7()
    ], W3mModalBase.prototype, "filterByNamespace", void 0);
    W3mModal = class W3mModal2 extends W3mModalBase {
    };
    W3mModal = __decorate66([
      customElement("w3m-modal")
    ], W3mModal);
    AppKitModal = class AppKitModal2 extends W3mModalBase {
    };
    AppKitModal = __decorate66([
      customElement("appkit-modal")
    ], AppKitModal);
  }
});

// node_modules/@reown/appkit-scaffold-ui/dist/esm/exports/w3m-modal.js
var w3m_modal_exports = {};
__export(w3m_modal_exports, {
  AppKitModal: () => AppKitModal,
  W3mModal: () => W3mModal,
  W3mModalBase: () => W3mModalBase
});
var init_w3m_modal2 = __esm({
  "node_modules/@reown/appkit-scaffold-ui/dist/esm/exports/w3m-modal.js"() {
    init_w3m_modal();
  }
});

// node_modules/@stacks/common/dist/esm/utils.js
function intToBytes(value, byteLength) {
  return bigIntToBytes(intToBigInt(value), byteLength);
}
function intToBigInt(value) {
  if (typeof value === "bigint")
    return value;
  if (typeof value === "string")
    return BigInt(value);
  if (typeof value === "number") {
    if (!Number.isInteger(value)) {
      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
    }
    if (value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError(`Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`);
    }
    return BigInt(value);
  }
  if (isInstance(value, Uint8Array))
    return BigInt(`0x${bytesToHex(value)}`);
  throw new TypeError(`intToBigInt: Invalid value type. Must be a number, bigint, BigInt-compatible string, or Uint8Array.`);
}
function without0x(value) {
  return /^0x/i.test(value) ? value.slice(2) : value;
}
function hexToBigInt(hex) {
  if (typeof hex !== "string")
    throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);
  return BigInt(`0x${hex}`);
}
function intToHex(integer, byteLength = 8) {
  const value = typeof integer === "bigint" ? integer : intToBigInt(integer);
  return value.toString(16).padStart(byteLength * 2, "0");
}
function hexToInt(hex) {
  return parseInt(hex, 16);
}
function bigIntToBytes(value, length2 = 16) {
  const hex = intToHex(value, length2);
  return hexToBytes(hex);
}
function toTwos(value, width) {
  if (value < -(BigInt(1) << width - BigInt(1)) || (BigInt(1) << width - BigInt(1)) - BigInt(1) < value) {
    throw `Unable to represent integer in width: ${width}`;
  }
  if (value >= BigInt(0)) {
    return BigInt(value);
  }
  return value + (BigInt(1) << width);
}
function nthBit(value, n12) {
  return value & BigInt(1) << n12;
}
function bytesToTwosBigInt(bytes2) {
  return fromTwos(BigInt(`0x${bytesToHex(bytes2)}`), BigInt(bytes2.byteLength * 8));
}
function fromTwos(value, width) {
  if (nthBit(value, width - BigInt(1))) {
    return value - (BigInt(1) << width);
  }
  return value;
}
var hexes = Array.from({ length: 256 }, (_5, i11) => i11.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (const u6 of uint8a) {
    hex += hexes[u6];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
  }
  hex = without0x(hex);
  hex = hex.length % 2 ? `0${hex}` : hex;
  const array = new Uint8Array(hex.length / 2);
  for (let i11 = 0; i11 < array.length; i11++) {
    const j7 = i11 * 2;
    const hexByte = hex.slice(j7, j7 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i11] = byte;
  }
  return array;
}
function utf8ToBytes(str) {
  return new TextEncoder().encode(str);
}
function bytesToUtf8(arr) {
  return new TextDecoder().decode(arr);
}
function asciiToBytes(str) {
  const byteArray = [];
  for (let i11 = 0; i11 < str.length; i11++) {
    byteArray.push(str.charCodeAt(i11) & 255);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii(arr) {
  return String.fromCharCode.apply(null, arr);
}
function isNotOctet(octet) {
  return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes(numbers) {
  if (numbers.some(isNotOctet))
    throw new Error("Some values are invalid bytes.");
  return new Uint8Array(numbers);
}
function concatBytes(...arrays) {
  if (!arrays.every((a5) => a5 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a5, arr) => a5 + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i11 = 0, pad3 = 0; i11 < arrays.length; i11++) {
    const arr = arrays[i11];
    result.set(arr, pad3);
    pad3 += arr.length;
  }
  return result;
}
function concatArray(elements) {
  return concatBytes(...elements.map((e10) => {
    if (typeof e10 === "number")
      return octetsToBytes([e10]);
    if (e10 instanceof Array)
      return octetsToBytes(e10);
    return e10;
  }));
}
function isInstance(object, clazz) {
  return object instanceof clazz || object?.constructor?.name?.toLowerCase() === clazz.name;
}

// node_modules/@stacks/common/dist/esm/constants.js
var HIRO_MAINNET_URL = "https://api.mainnet.hiro.so";
var HIRO_TESTNET_URL = "https://api.testnet.hiro.so";
var DEVNET_URL = "http://localhost:3999";
var PRIVATE_KEY_BYTES_COMPRESSED = 33;

// node_modules/@stacks/common/dist/esm/signatures.js
var COORDINATE_BYTES = 32;
function parseRecoverableSignatureVrs(signature) {
  if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {
    throw new Error("Invalid signature");
  }
  const recoveryIdHex = signature.slice(0, 2);
  const r9 = signature.slice(2, 2 + COORDINATE_BYTES * 2);
  const s8 = signature.slice(2 + COORDINATE_BYTES * 2);
  return {
    recoveryId: hexToInt(recoveryIdHex),
    r: r9,
    s: s8
  };
}

// node_modules/@stacks/common/dist/esm/keys.js
function privateKeyToBytes(privateKey) {
  const privateKeyBuffer = typeof privateKey === "string" ? hexToBytes(privateKey) : privateKey;
  if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {
    throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);
  }
  if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {
    throw new Error("Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01");
  }
  return privateKeyBuffer;
}

// node_modules/@stacks/common/dist/esm/buffer.js
function readUInt16BE(source, offset) {
  return (source[offset + 0] << 8 | source[offset + 1]) >>> 0;
}
function writeUInt16BE(destination, value, offset = 0) {
  destination[offset + 0] = value >>> 8;
  destination[offset + 1] = value >>> 0;
  return destination;
}
function readUInt8(source, offset) {
  return source[offset];
}
function writeUInt8(destination, value, offset = 0) {
  destination[offset] = value;
  return destination;
}
function readUInt32BE(source, offset) {
  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];
}
function writeUInt32BE(destination, value, offset = 0) {
  destination[offset + 3] = value;
  value >>>= 8;
  destination[offset + 2] = value;
  value >>>= 8;
  destination[offset + 1] = value;
  value >>>= 8;
  destination[offset] = value;
  return destination;
}

// node_modules/@stacks/connect/dist/index.mjs
init_esm();

// node_modules/@stacks/connect-ui/dist/esm/index.js
var LOCAL_STORAGE_KEY = "STX_PROVIDER";
var getSelectedProviderId = () => {
  if (typeof window === "undefined")
    return null;
  return window.localStorage.getItem(LOCAL_STORAGE_KEY);
};
var setSelectedProviderId = (provider) => {
  if (typeof window !== "undefined") {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, provider);
  }
};
var getRegisteredProviders = () => {
  if (typeof window === "undefined")
    return [];
  const legacyProviders = window.webbtc_stx_providers || [];
  const wbipProviders = window.wbip_providers || [];
  return [...legacyProviders, ...wbipProviders];
};
var getInstalledProviders = (defaultProviders = []) => {
  if (typeof window === "undefined")
    return [];
  const registeredProviders = getRegisteredProviders();
  const additionalInstalledProviders = defaultProviders.filter((defaultProvider) => {
    if (registeredProviders.find((rp) => rp.id === defaultProvider.id))
      return false;
    const provider = getProviderFromId(defaultProvider.id);
    return !!provider;
  });
  return registeredProviders.concat(additionalInstalledProviders);
};
var getProvider = () => {
  const providerId = getSelectedProviderId();
  return getProviderFromId(providerId);
};
var getProviderFromId = (id) => {
  return id === null || id === void 0 ? void 0 : id.split(".").reduce((acc, part) => acc === null || acc === void 0 ? void 0 : acc[part], window);
};

// node_modules/@stacks/connect-ui/dist/esm/loader.js
init_index_BnFj5nlp();
init_index_BnFj5nlp();

// node_modules/@stacks/connect-ui/dist/esm/app-globals-DQuL1Twl.js
var globalScripts = () => {
};

// node_modules/@stacks/connect-ui/dist/esm/loader.js
var defineCustomElements = async (win2, options) => {
  if (typeof window === "undefined") return void 0;
  await globalScripts();
  return bootstrapLazy([["connect-modal", [[257, "connect-modal", { "defaultProviders": [16, "default-providers"], "installedProviders": [16, "installed-providers"], "callback": [16], "cancelCallback": [16, "cancel-callback"] }]]]], options);
};

// node_modules/@stacks/connect-ui/loader/index.js
(function() {
  if ("undefined" !== typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var a5 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(a5, [], this.constructor);
    };
    HTMLElement.prototype = a5.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, a5);
  }
})();

// node_modules/@stacks/transactions/dist/esm/BytesReader.js
function createEnumChecker(enumVariable) {
  const enumValues = Object.values(enumVariable).filter((v8) => typeof v8 === "number");
  const enumValueSet = new Set(enumValues);
  return (value) => enumValueSet.has(value);
}
var enumCheckFunctions = /* @__PURE__ */ new Map();
function isEnum(enumVariable, value) {
  const checker = enumCheckFunctions.get(enumVariable);
  if (checker !== void 0) {
    return checker(value);
  }
  const newChecker = createEnumChecker(enumVariable);
  enumCheckFunctions.set(enumVariable, newChecker);
  return isEnum(enumVariable, value);
}
var BytesReader = class {
  constructor(bytes2) {
    this.consumed = 0;
    this.source = typeof bytes2 === "string" ? hexToBytes(bytes2) : bytes2;
  }
  readBytes(length2) {
    const view = this.source.subarray(this.consumed, this.consumed + length2);
    this.consumed += length2;
    return view;
  }
  readUInt32BE() {
    return readUInt32BE(this.readBytes(4), 0);
  }
  readUInt8() {
    return readUInt8(this.readBytes(1), 0);
  }
  readUInt16BE() {
    return readUInt16BE(this.readBytes(2), 0);
  }
  readBigUIntLE(length2) {
    const bytes2 = this.readBytes(length2).slice().reverse();
    const hex = bytesToHex(bytes2);
    return BigInt(`0x${hex}`);
  }
  readBigUIntBE(length2) {
    const bytes2 = this.readBytes(length2);
    const hex = bytesToHex(bytes2);
    return BigInt(`0x${hex}`);
  }
  get readOffset() {
    return this.consumed;
  }
  set readOffset(val) {
    this.consumed = val;
  }
  get internalBytes() {
    return this.source;
  }
  readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
    const num2 = this.readUInt8();
    if (isEnum(enumVariable, num2)) {
      return num2;
    }
    throw invalidEnumErrorFormatter(num2);
  }
};

// node_modules/@stacks/network/dist/esm/constants.js
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Testnet"] = 2147483648] = "Testnet";
})(ChainId || (ChainId = {}));
var PeerNetworkId;
(function(PeerNetworkId2) {
  PeerNetworkId2[PeerNetworkId2["Mainnet"] = 385875968] = "Mainnet";
  PeerNetworkId2[PeerNetworkId2["Testnet"] = 4278190080] = "Testnet";
})(PeerNetworkId || (PeerNetworkId = {}));
var DEFAULT_CHAIN_ID = ChainId.Mainnet;
var TransactionVersion;
(function(TransactionVersion4) {
  TransactionVersion4[TransactionVersion4["Mainnet"] = 0] = "Mainnet";
  TransactionVersion4[TransactionVersion4["Testnet"] = 128] = "Testnet";
})(TransactionVersion || (TransactionVersion = {}));
var AddressVersion;
(function(AddressVersion3) {
  AddressVersion3[AddressVersion3["MainnetSingleSig"] = 22] = "MainnetSingleSig";
  AddressVersion3[AddressVersion3["MainnetMultiSig"] = 20] = "MainnetMultiSig";
  AddressVersion3[AddressVersion3["TestnetSingleSig"] = 26] = "TestnetSingleSig";
  AddressVersion3[AddressVersion3["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion || (AddressVersion = {}));
var DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;

// node_modules/@stacks/network/dist/esm/network.js
var STACKS_MAINNET = {
  chainId: ChainId.Mainnet,
  transactionVersion: TransactionVersion.Mainnet,
  peerNetworkId: PeerNetworkId.Mainnet,
  magicBytes: "X2",
  bootAddress: "SP000000000000000000002Q6VF78",
  addressVersion: {
    singleSig: AddressVersion.MainnetSingleSig,
    multiSig: AddressVersion.MainnetMultiSig
  },
  client: { baseUrl: HIRO_MAINNET_URL }
};
var STACKS_TESTNET = {
  chainId: ChainId.Testnet,
  transactionVersion: TransactionVersion.Testnet,
  peerNetworkId: PeerNetworkId.Testnet,
  magicBytes: "T2",
  bootAddress: "ST000000000000000000002AMW42H",
  addressVersion: {
    singleSig: AddressVersion.TestnetSingleSig,
    multiSig: AddressVersion.TestnetMultiSig
  },
  client: { baseUrl: HIRO_TESTNET_URL }
};
var STACKS_DEVNET = {
  ...STACKS_TESTNET,
  addressVersion: { ...STACKS_TESTNET.addressVersion },
  magicBytes: "id",
  client: { baseUrl: DEVNET_URL }
};
var STACKS_MOCKNET = {
  ...STACKS_DEVNET,
  addressVersion: { ...STACKS_DEVNET.addressVersion },
  client: { ...STACKS_DEVNET.client }
};
function networkFromName(name2) {
  switch (name2) {
    case "mainnet":
      return STACKS_MAINNET;
    case "testnet":
      return STACKS_TESTNET;
    case "devnet":
      return STACKS_DEVNET;
    case "mocknet":
      return STACKS_MOCKNET;
    default:
      throw new Error(`Unknown network name: ${name2}`);
  }
}
function networkFrom(network) {
  if (typeof network === "string")
    return networkFromName(network);
  return network;
}

// node_modules/@stacks/transactions/dist/esm/constants.js
var MAX_STRING_LENGTH_BYTES = 128;
var CLARITY_INT_SIZE = 128;
var CLARITY_INT_BYTE_SIZE = 16;
var COINBASE_BYTES_LENGTH = 32;
var VRF_PROOF_BYTES_LENGTH = 80;
var RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;
var COMPRESSED_PUBKEY_LENGTH_BYTES = 32;
var UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;
var MEMO_MAX_LENGTH_BYTES = 34;
var MAX_PAYLOAD_LEN = 1 + 16 * 1024 * 1024;
var PREAMBLE_ENCODED_SIZE = 165;
var MAX_RELAYERS_LEN = 16;
var PEER_ADDRESS_ENCODED_SIZE = 16;
var HASH160_ENCODED_SIZE = 20;
var NEIGHBOR_ADDRESS_ENCODED_SIZE = PEER_ADDRESS_ENCODED_SIZE + 2 + HASH160_ENCODED_SIZE;
var RELAY_DATA_ENCODED_SIZE = NEIGHBOR_ADDRESS_ENCODED_SIZE + 4;
var STRING_MAX_LENGTH = MAX_PAYLOAD_LEN + (PREAMBLE_ENCODED_SIZE + MAX_RELAYERS_LEN * RELAY_DATA_ENCODED_SIZE);
var PayloadType;
(function(PayloadType3) {
  PayloadType3[PayloadType3["TokenTransfer"] = 0] = "TokenTransfer";
  PayloadType3[PayloadType3["SmartContract"] = 1] = "SmartContract";
  PayloadType3[PayloadType3["VersionedSmartContract"] = 6] = "VersionedSmartContract";
  PayloadType3[PayloadType3["ContractCall"] = 2] = "ContractCall";
  PayloadType3[PayloadType3["PoisonMicroblock"] = 3] = "PoisonMicroblock";
  PayloadType3[PayloadType3["Coinbase"] = 4] = "Coinbase";
  PayloadType3[PayloadType3["CoinbaseToAltRecipient"] = 5] = "CoinbaseToAltRecipient";
  PayloadType3[PayloadType3["TenureChange"] = 7] = "TenureChange";
  PayloadType3[PayloadType3["NakamotoCoinbase"] = 8] = "NakamotoCoinbase";
})(PayloadType || (PayloadType = {}));
var ClarityVersion;
(function(ClarityVersion3) {
  ClarityVersion3[ClarityVersion3["Clarity1"] = 1] = "Clarity1";
  ClarityVersion3[ClarityVersion3["Clarity2"] = 2] = "Clarity2";
  ClarityVersion3[ClarityVersion3["Clarity3"] = 3] = "Clarity3";
})(ClarityVersion || (ClarityVersion = {}));
var AnchorMode;
(function(AnchorMode3) {
  AnchorMode3[AnchorMode3["OnChainOnly"] = 1] = "OnChainOnly";
  AnchorMode3[AnchorMode3["OffChainOnly"] = 2] = "OffChainOnly";
  AnchorMode3[AnchorMode3["Any"] = 3] = "Any";
})(AnchorMode || (AnchorMode = {}));
var AnchorModeNames = ["onChainOnly", "offChainOnly", "any"];
var AnchorModeMap = {
  [AnchorModeNames[0]]: AnchorMode.OnChainOnly,
  [AnchorModeNames[1]]: AnchorMode.OffChainOnly,
  [AnchorModeNames[2]]: AnchorMode.Any,
  [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,
  [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,
  [AnchorMode.Any]: AnchorMode.Any
};
var PostConditionMode;
(function(PostConditionMode3) {
  PostConditionMode3[PostConditionMode3["Allow"] = 1] = "Allow";
  PostConditionMode3[PostConditionMode3["Deny"] = 2] = "Deny";
})(PostConditionMode || (PostConditionMode = {}));
var PostConditionType;
(function(PostConditionType3) {
  PostConditionType3[PostConditionType3["STX"] = 0] = "STX";
  PostConditionType3[PostConditionType3["Fungible"] = 1] = "Fungible";
  PostConditionType3[PostConditionType3["NonFungible"] = 2] = "NonFungible";
})(PostConditionType || (PostConditionType = {}));
var AuthType;
(function(AuthType3) {
  AuthType3[AuthType3["Standard"] = 4] = "Standard";
  AuthType3[AuthType3["Sponsored"] = 5] = "Sponsored";
})(AuthType || (AuthType = {}));
var AddressHashMode;
(function(AddressHashMode3) {
  AddressHashMode3[AddressHashMode3["P2PKH"] = 0] = "P2PKH";
  AddressHashMode3[AddressHashMode3["P2SH"] = 1] = "P2SH";
  AddressHashMode3[AddressHashMode3["P2WPKH"] = 2] = "P2WPKH";
  AddressHashMode3[AddressHashMode3["P2WSH"] = 3] = "P2WSH";
  AddressHashMode3[AddressHashMode3["P2SHNonSequential"] = 5] = "P2SHNonSequential";
  AddressHashMode3[AddressHashMode3["P2WSHNonSequential"] = 7] = "P2WSHNonSequential";
})(AddressHashMode || (AddressHashMode = {}));
var PubKeyEncoding;
(function(PubKeyEncoding3) {
  PubKeyEncoding3[PubKeyEncoding3["Compressed"] = 0] = "Compressed";
  PubKeyEncoding3[PubKeyEncoding3["Uncompressed"] = 1] = "Uncompressed";
})(PubKeyEncoding || (PubKeyEncoding = {}));
var FungibleConditionCode;
(function(FungibleConditionCode3) {
  FungibleConditionCode3[FungibleConditionCode3["Equal"] = 1] = "Equal";
  FungibleConditionCode3[FungibleConditionCode3["Greater"] = 2] = "Greater";
  FungibleConditionCode3[FungibleConditionCode3["GreaterEqual"] = 3] = "GreaterEqual";
  FungibleConditionCode3[FungibleConditionCode3["Less"] = 4] = "Less";
  FungibleConditionCode3[FungibleConditionCode3["LessEqual"] = 5] = "LessEqual";
})(FungibleConditionCode || (FungibleConditionCode = {}));
var NonFungibleConditionCode;
(function(NonFungibleConditionCode3) {
  NonFungibleConditionCode3[NonFungibleConditionCode3["Sends"] = 16] = "Sends";
  NonFungibleConditionCode3[NonFungibleConditionCode3["DoesNotSend"] = 17] = "DoesNotSend";
})(NonFungibleConditionCode || (NonFungibleConditionCode = {}));
var PostConditionPrincipalId;
(function(PostConditionPrincipalId2) {
  PostConditionPrincipalId2[PostConditionPrincipalId2["Origin"] = 1] = "Origin";
  PostConditionPrincipalId2[PostConditionPrincipalId2["Standard"] = 2] = "Standard";
  PostConditionPrincipalId2[PostConditionPrincipalId2["Contract"] = 3] = "Contract";
})(PostConditionPrincipalId || (PostConditionPrincipalId = {}));
var AssetType;
(function(AssetType3) {
  AssetType3[AssetType3["STX"] = 0] = "STX";
  AssetType3[AssetType3["Fungible"] = 1] = "Fungible";
  AssetType3[AssetType3["NonFungible"] = 2] = "NonFungible";
})(AssetType || (AssetType = {}));
var TenureChangeCause;
(function(TenureChangeCause2) {
  TenureChangeCause2[TenureChangeCause2["BlockFound"] = 0] = "BlockFound";
  TenureChangeCause2[TenureChangeCause2["Extended"] = 1] = "Extended";
})(TenureChangeCause || (TenureChangeCause = {}));
var AuthFieldType;
(function(AuthFieldType2) {
  AuthFieldType2[AuthFieldType2["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
  AuthFieldType2[AuthFieldType2["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
  AuthFieldType2[AuthFieldType2["SignatureCompressed"] = 2] = "SignatureCompressed";
  AuthFieldType2[AuthFieldType2["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (AuthFieldType = {}));
var TxRejectedReason;
(function(TxRejectedReason3) {
  TxRejectedReason3["Serialization"] = "Serialization";
  TxRejectedReason3["Deserialization"] = "Deserialization";
  TxRejectedReason3["SignatureValidation"] = "SignatureValidation";
  TxRejectedReason3["FeeTooLow"] = "FeeTooLow";
  TxRejectedReason3["BadNonce"] = "BadNonce";
  TxRejectedReason3["NotEnoughFunds"] = "NotEnoughFunds";
  TxRejectedReason3["NoSuchContract"] = "NoSuchContract";
  TxRejectedReason3["NoSuchPublicFunction"] = "NoSuchPublicFunction";
  TxRejectedReason3["BadFunctionArgument"] = "BadFunctionArgument";
  TxRejectedReason3["ContractAlreadyExists"] = "ContractAlreadyExists";
  TxRejectedReason3["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
  TxRejectedReason3["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
  TxRejectedReason3["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
  TxRejectedReason3["BadAddressVersionByte"] = "BadAddressVersionByte";
  TxRejectedReason3["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
  TxRejectedReason3["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
  TxRejectedReason3["ServerFailureDatabase"] = "ServerFailureDatabase";
  TxRejectedReason3["ServerFailureOther"] = "ServerFailureOther";
})(TxRejectedReason || (TxRejectedReason = {}));

// node_modules/@stacks/transactions/dist/esm/errors.js
var TransactionError = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var SerializationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var DeserializationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var SigningError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};
var VerificationError = class extends TransactionError {
  constructor(message) {
    super(message);
  }
};

// node_modules/@noble/hashes/esm/_assert.js
function number(n12) {
  if (!Number.isSafeInteger(n12) || n12 < 0)
    throw new Error(`Wrong positive integer: ${n12}`);
}
function bool(b7) {
  if (typeof b7 !== "boolean")
    throw new Error(`Expected boolean, not ${b7}`);
}
function bytes(b7, ...lengths) {
  if (!(b7 instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b7.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b7.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// node_modules/@noble/hashes/esm/cryptoBrowser.js
var crypto2 = {
  node: void 0,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};

// node_modules/@noble/hashes/esm/utils.js
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (v8, i11) => i11.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i11 = 0; i11 < pad3.length; i11++)
      pad3[i11] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash2.create();
    for (let i11 = 0; i11 < pad3.length; i11++)
      pad3[i11] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to4) {
    to4 || (to4 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to4 = to4;
    to4.finished = finished;
    to4.destroyed = destroyed;
    to4.blockLen = blockLen;
    to4.outputLen = outputLen;
    to4.oHash = oHash._cloneInto(to4.oHash);
    to4.iHash = iHash._cloneInto(to4.iHash);
    return to4;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h12 = isLE3 ? 4 : 0;
  const l10 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h12, wh, isLE3);
  view.setUint32(byteOffset + l10, wl, isLE3);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i11 = pos; i11 < blockLen; i11++)
      buffer3[i11] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state24 = this.get();
    if (outLen > state24.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i11 = 0; i11 < outLen; i11++)
      oview.setUint32(4 * i11, state24[i11], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to4) {
    to4 || (to4 = new this.constructor());
    to4.set(...this.get());
    const { blockLen, buffer: buffer3, length: length2, finished, destroyed, pos } = this;
    to4.length = length2;
    to4.pos = pos;
    to4.finished = finished;
    to4.destroyed = destroyed;
    if (length2 % blockLen)
      to4.buffer.set(buffer3);
    return to4;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a5, b7, c12) => a5 & b7 ^ ~a5 & c12;
var Maj = (a5, b7, c12) => a5 & b7 ^ a5 & c12 ^ b7 & c12;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A6, B: B5, C: C7, D: D4, E: E8, F: F4, G: G5, H: H5 } = this;
    return [A6, B5, C7, D4, E8, F4, G5, H5];
  }
  // prettier-ignore
  set(A6, B5, C7, D4, E8, F4, G5, H5) {
    this.A = A6 | 0;
    this.B = B5 | 0;
    this.C = C7 | 0;
    this.D = D4 | 0;
    this.E = E8 | 0;
    this.F = F4 | 0;
    this.G = G5 | 0;
    this.H = H5 | 0;
  }
  process(view, offset) {
    for (let i11 = 0; i11 < 16; i11++, offset += 4)
      SHA256_W[i11] = view.getUint32(offset, false);
    for (let i11 = 16; i11 < 64; i11++) {
      const W15 = SHA256_W[i11 - 15];
      const W22 = SHA256_W[i11 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i11] = s1 + SHA256_W[i11 - 7] + s0 + SHA256_W[i11 - 16] | 0;
    }
    let { A: A6, B: B5, C: C7, D: D4, E: E8, F: F4, G: G5, H: H5 } = this;
    for (let i11 = 0; i11 < 64; i11++) {
      const sigma1 = rotr(E8, 6) ^ rotr(E8, 11) ^ rotr(E8, 25);
      const T1 = H5 + sigma1 + Chi(E8, F4, G5) + SHA256_K[i11] + SHA256_W[i11] | 0;
      const sigma0 = rotr(A6, 2) ^ rotr(A6, 13) ^ rotr(A6, 22);
      const T22 = sigma0 + Maj(A6, B5, C7) | 0;
      H5 = G5;
      G5 = F4;
      F4 = E8;
      E8 = D4 + T1 | 0;
      D4 = C7;
      C7 = B5;
      B5 = A6;
      A6 = T1 + T22 | 0;
    }
    A6 = A6 + this.A | 0;
    B5 = B5 + this.B | 0;
    C7 = C7 + this.C | 0;
    D4 = D4 + this.D | 0;
    E8 = E8 + this.E | 0;
    F4 = F4 + this.F | 0;
    G5 = G5 + this.G | 0;
    H5 = H5 + this.H | 0;
    this.set(A6, B5, C7, D4, E8, F4, G5, H5);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@noble/secp256k1/lib/esm/index.js
var nodeCrypto = __toESM(require_crypto(), 1);
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _8n = BigInt(8);
var CURVE = Object.freeze({
  a: _0n,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest = (a5, b7) => (a5 + b7 / _2n) / b7;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k7) {
    const { n: n12 } = CURVE;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b22 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest(b22 * k7, n12);
    const c22 = divNearest(-b1 * k7, n12);
    let k1 = mod(k7 - c1 * a1 - c22 * a22, n12);
    let k22 = mod(-c1 * b1 - c22 * b22, n12);
    const k1neg = k1 > POW_2_128;
    const k2neg = k22 > POW_2_128;
    if (k1neg)
      k1 = n12 - k1;
    if (k2neg)
      k22 = n12 - k22;
    if (k1 > POW_2_128 || k22 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k7);
    }
    return { k1neg, k1, k2neg, k2: k22 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x7) {
  const { a: a5, b: b7 } = CURVE;
  const x22 = mod(x7 * x7);
  const x32 = mod(x22 * x7);
  return mod(x32 + a5 * x7 + b7);
}
var USE_ENDOMORPHISM = CURVE.a === _0n;
var ShaError = class extends Error {
  constructor(message) {
    super(message);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
var JacobianPoint = class _JacobianPoint {
  constructor(x7, y9, z5) {
    this.x = x7;
    this.y = y9;
    this.z = z5;
  }
  static fromAffine(p8) {
    if (!(p8 instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p8.equals(Point.ZERO))
      return _JacobianPoint.ZERO;
    return new _JacobianPoint(p8.x, p8.y, _1n);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p8) => p8.z));
    return points.map((p8, i11) => p8.toAffine(toInv[i11]));
  }
  static normalizeZ(points) {
    return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X22, y: Y22, z: Z22 } = other;
    const Z1Z1 = mod(Z1 * Z1);
    const Z2Z2 = mod(Z22 * Z22);
    const U1 = mod(X1 * Z2Z2);
    const U22 = mod(X22 * Z1Z1);
    const S1 = mod(mod(Y1 * Z22) * Z2Z2);
    const S22 = mod(mod(Y22 * Z1) * Z1Z1);
    return U1 === U22 && S1 === S22;
  }
  negate() {
    return new _JacobianPoint(this.x, mod(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A6 = mod(X1 * X1);
    const B5 = mod(Y1 * Y1);
    const C7 = mod(B5 * B5);
    const x1b = X1 + B5;
    const D4 = mod(_2n * (mod(x1b * x1b) - A6 - C7));
    const E8 = mod(_3n * A6);
    const F4 = mod(E8 * E8);
    const X32 = mod(F4 - _2n * D4);
    const Y32 = mod(E8 * (D4 - X32) - _8n * C7);
    const Z32 = mod(_2n * Y1 * Z1);
    return new _JacobianPoint(X32, Y32, Z32);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X22, y: Y22, z: Z22 } = other;
    if (X22 === _0n || Y22 === _0n)
      return this;
    if (X1 === _0n || Y1 === _0n)
      return other;
    const Z1Z1 = mod(Z1 * Z1);
    const Z2Z2 = mod(Z22 * Z22);
    const U1 = mod(X1 * Z2Z2);
    const U22 = mod(X22 * Z1Z1);
    const S1 = mod(mod(Y1 * Z22) * Z2Z2);
    const S22 = mod(mod(Y22 * Z1) * Z1Z1);
    const H5 = mod(U22 - U1);
    const r9 = mod(S22 - S1);
    if (H5 === _0n) {
      if (r9 === _0n) {
        return this.double();
      } else {
        return _JacobianPoint.ZERO;
      }
    }
    const HH = mod(H5 * H5);
    const HHH = mod(H5 * HH);
    const V6 = mod(U1 * HH);
    const X32 = mod(r9 * r9 - HHH - _2n * V6);
    const Y32 = mod(r9 * (V6 - X32) - S1 * HHH);
    const Z32 = mod(Z1 * Z22 * H5);
    return new _JacobianPoint(X32, Y32, Z32);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = _JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n)
      return P0;
    let n12 = normalizeScalar(scalar);
    if (n12 === _1n)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p8 = P0;
      let d8 = this;
      while (n12 > _0n) {
        if (n12 & _1n)
          p8 = p8.add(d8);
        d8 = d8.double();
        n12 >>= _1n;
      }
      return p8;
    }
    let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n12);
    let k1p = P0;
    let k2p = P0;
    let d7 = this;
    while (k1 > _0n || k22 > _0n) {
      if (k1 & _1n)
        k1p = k1p.add(d7);
      if (k22 & _1n)
        k2p = k2p.add(d7);
      d7 = d7.double();
      k1 >>= _1n;
      k22 >>= _1n;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new _JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W6) {
    const windows = USE_ENDOMORPHISM ? 128 / W6 + 1 : 256 / W6 + 1;
    const points = [];
    let p8 = this;
    let base3 = p8;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p8;
      points.push(base3);
      for (let i11 = 1; i11 < 2 ** (W6 - 1); i11++) {
        base3 = base3.add(p8);
        points.push(base3);
      }
      p8 = base3.double();
    }
    return points;
  }
  wNAF(n12, affinePoint) {
    if (!affinePoint && this.equals(_JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W6 = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W6) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W6);
      if (affinePoint && W6 !== 1) {
        precomputes = _JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p8 = _JacobianPoint.ZERO;
    let f13 = _JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W6 : 256 / W6);
    const windowSize = 2 ** (W6 - 1);
    const mask = BigInt(2 ** W6 - 1);
    const maxNumber = 2 ** W6;
    const shiftBy = BigInt(W6);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n12 & mask);
      n12 >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n12 += _1n;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f13 = f13.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p8 = p8.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return { p: p8, f: f13 };
  }
  multiply(scalar, affinePoint) {
    let n12 = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n12);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k22, affinePoint);
      k1p = constTimeNegate(k1neg, k1p);
      k2p = constTimeNegate(k2neg, k2p);
      k2p = new _JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p: p8, f: f13 } = this.wNAF(n12, affinePoint);
      point = p8;
      fake = f13;
    }
    return _JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x: x7, y: y9, z: z5 } = this;
    const is0 = this.equals(_JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z5);
    const iz1 = invZ;
    const iz2 = mod(iz1 * iz1);
    const iz3 = mod(iz2 * iz1);
    const ax = mod(x7 * iz2);
    const ay = mod(y9 * iz3);
    const zz = mod(z5 * iz1);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class _Point {
  constructor(x7, y9) {
    this.x = x7;
    this.y = y9;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n === _0n;
  }
  static fromCompressedHex(bytes2) {
    const isShort = bytes2.length === 32;
    const x7 = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
    if (!isValidFieldElement(x7))
      throw new Error("Point is not on curve");
    const y22 = weierstrass(x7);
    let y9 = sqrtMod(y22);
    const isYOdd = (y9 & _1n) === _1n;
    if (isShort) {
      if (isYOdd)
        y9 = mod(-y9);
    } else {
      const isFirstByteOdd = (bytes2[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y9 = mod(-y9);
    }
    const point = new _Point(x7, y9);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes2) {
    const x7 = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
    const y9 = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new _Point(x7, y9);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes(hex);
    const len = bytes2.length;
    const header = bytes2[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes2);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes2);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return _Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r: r9, s: s8 } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h12 = truncateHash(ensureBytes(msgHash));
    const { n: n12 } = CURVE;
    const radj = recovery === 2 || recovery === 3 ? r9 + n12 : r9;
    const rinv = invert(radj, n12);
    const u1 = mod(-h12 * rinv, n12);
    const u22 = mod(s8 * rinv, n12);
    const prefix = recovery & 1 ? "03" : "02";
    const R6 = _Point.fromHex(prefix + numTo32bStr(radj));
    const Q6 = _Point.BASE.multiplyAndAddUnsafe(R6, u1, u22);
    if (!Q6)
      throw new Error("Cannot recover signature: point at infinify");
    Q6.assertValidity();
    return Q6;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes2(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x7 = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x7}`;
    } else {
      return `04${x7}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x: x7, y: y9 } = this;
    if (!isValidFieldElement(x7) || !isValidFieldElement(y9))
      throw new Error(msg);
    const left = mod(y9 * y9);
    const right = weierstrass(x7);
    if (mod(left - right) !== _0n)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new _Point(this.x, mod(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q6, a5, b7) {
    const P8 = JacobianPoint.fromAffine(this);
    const aP = a5 === _0n || a5 === _1n || this !== _Point.BASE ? P8.multiplyUnsafe(a5) : P8.multiply(a5);
    const bQ = JacobianPoint.fromAffine(Q6).multiplyUnsafe(b7);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s8) {
  return Number.parseInt(s8[0], 16) >= 8 ? "00" + s8 : s8;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex2(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex2(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r9, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s8, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex2(rBytesLeft)}`);
  }
  return { r: r9, s: s8 };
}
var Signature = class _Signature {
  constructor(r9, s8) {
    this.r = r9;
    this.s = s8;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name2 = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name2}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex2(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name2}: Expected 64-byte hex`);
    return new _Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r: r9, s: s8 } = parseDERSignature(arr ? hex : hexToBytes2(hex));
    return new _Signature(r9, s8);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r: r9, s: s8 } = this;
    if (!isWithinCurveOrder(r9))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s8))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new _Signature(this.r, mod(-this.s, CURVE.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes2(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded(sHexL);
    const rLen = numberToHexUnpadded(rHexL);
    const length2 = numberToHexUnpadded(rHexL + sHexL + 4);
    return `30${length2}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes2(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes2(...arrays) {
  if (!arrays.every((b7) => b7 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a5, arr) => a5 + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i11 = 0, pad3 = 0; i11 < arrays.length; i11++) {
    const arr = arrays[i11];
    result.set(arr, pad3);
    pad3 += arr.length;
  }
  return result;
}
var hexes3 = Array.from({ length: 256 }, (v8, i11) => i11.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i11 = 0; i11 < uint8a.length; i11++) {
    hex += hexes3[uint8a[i11]];
  }
  return hex;
}
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num2) {
  if (typeof num2 !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n <= num2 && num2 < POW_2_256))
    throw new Error("Expected number 0 <= n < 2^256");
  return num2.toString(16).padStart(64, "0");
}
function numTo32b(num2) {
  const b7 = hexToBytes2(numTo32bStr(num2));
  if (b7.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b7;
}
function numberToHexUnpadded(num2) {
  const hex = num2.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i11 = 0; i11 < array.length; i11++) {
    const j7 = i11 * 2;
    const hexByte = hex.slice(j7, j7 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i11] = byte;
  }
  return array;
}
function bytesToNumber(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
}
function normalizeScalar(num2) {
  if (typeof num2 === "number" && Number.isSafeInteger(num2) && num2 > 0)
    return BigInt(num2);
  if (typeof num2 === "bigint" && isWithinCurveOrder(num2))
    return num2;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(a5, b7 = CURVE.P) {
  const result = a5 % b7;
  return result >= _0n ? result : b7 + result;
}
function pow2(x7, power) {
  const { P: P8 } = CURVE;
  let res = x7;
  while (power-- > _0n) {
    res *= res;
    res %= P8;
  }
  return res;
}
function sqrtMod(x7) {
  const { P: P8 } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b22 = x7 * x7 * x7 % P8;
  const b32 = b22 * b22 * x7 % P8;
  const b62 = pow2(b32, _3n) * b32 % P8;
  const b9 = pow2(b62, _3n) * b32 % P8;
  const b11 = pow2(b9, _2n) * b22 % P8;
  const b222 = pow2(b11, _11n) * b11 % P8;
  const b44 = pow2(b222, _22n) * b222 % P8;
  const b88 = pow2(b44, _44n) * b44 % P8;
  const b176 = pow2(b88, _88n) * b88 % P8;
  const b220 = pow2(b176, _44n) * b44 % P8;
  const b223 = pow2(b220, _3n) * b32 % P8;
  const t1 = pow2(b223, _23n) * b222 % P8;
  const t22 = pow2(t1, _6n) * b22 % P8;
  const rt4 = pow2(t22, _2n);
  const xc2 = rt4 * rt4 % P8;
  if (xc2 !== x7)
    throw new Error("Cannot find square root");
  return rt4;
}
function invert(number2, modulo = CURVE.P) {
  if (number2 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a5 = mod(number2, modulo);
  let b7 = modulo;
  let x7 = _0n, y9 = _1n, u6 = _1n, v8 = _0n;
  while (a5 !== _0n) {
    const q3 = b7 / a5;
    const r9 = b7 % a5;
    const m6 = x7 - u6 * q3;
    const n12 = y9 - v8 * q3;
    b7 = a5, a5 = r9, x7 = u6, y9 = v8, u6 = m6, v8 = n12;
  }
  const gcd2 = b7;
  if (gcd2 !== _1n)
    throw new Error("invert: does not exist");
  return mod(x7, modulo);
}
function invertBatch(nums, p8 = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i11) => {
    if (num2 === _0n)
      return acc;
    scratch[i11] = acc;
    return mod(acc * num2, p8);
  }, _1n);
  const inverted = invert(lastMultiplied, p8);
  nums.reduceRight((acc, num2, i11) => {
    if (num2 === _0n)
      return acc;
    scratch[i11] = mod(acc * scratch[i11], p8);
    return mod(acc * num2, p8);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes2) {
  const delta = bytes2.length * 8 - groupLen * 8;
  const num2 = bytesToNumber(bytes2);
  return delta > 0 ? num2 >> BigInt(delta) : num2;
}
function truncateHash(hash2, truncateOnly = false) {
  const h12 = bits2int_2(hash2);
  if (truncateOnly)
    return h12;
  const { n: n12 } = CURVE;
  return h12 >= n12 ? h12 - n12 : h12;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed = new Uint8Array()) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
    this.v = await this.hmac(this.v);
    if (seed.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
};
function isWithinCurveOrder(num2) {
  return _0n < num2 && num2 < CURVE.n;
}
function isValidFieldElement(num2) {
  return _0n < num2 && num2 < CURVE.P;
}
function kmdToSig(kBytes, m6, d7, lowS = true) {
  const { n: n12 } = CURVE;
  const k7 = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k7))
    return;
  const kinv = invert(k7, n12);
  const q3 = Point.BASE.multiply(k7);
  const r9 = mod(q3.x, n12);
  if (r9 === _0n)
    return;
  const s8 = mod(kinv * mod(m6 + d7 * r9, n12), n12);
  if (s8 === _0n)
    return;
  let sig = new Signature(r9, s8);
  let recovery = (q3.x === sig.r ? 0 : 2) | Number(q3.y & _1n);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num2 = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num2 = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num2 = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num2))
    throw new Error("Expected private key: 0 < key < n");
  return num2;
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error2) {
    return Signature.fromCompact(signature);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes2) {
  const slice = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
  return bytesToNumber(slice);
}
function bits2octets(bytes2) {
  const z1 = bits2int(bytes2);
  const z22 = mod(z1, CURVE.n);
  return int2octets(z22 < _0n ? z1 : z22);
}
function int2octets(num2) {
  return numTo32b(num2);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes(msgHash);
  const d7 = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d7), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils.randomBytes(fieldLen);
    const e10 = ensureBytes(extraEntropy);
    if (e10.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e10);
  }
  const seed = concatBytes2(...seedArgs);
  const m6 = bits2int(h1);
  return { seed, m: m6, d: d7 };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
function signSync(msgHash, privKey, opts = {}) {
  const { seed, m: m6, d: d7 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  drbg.reseedSync(seed);
  let sig;
  while (!(sig = kmdToSig(drbg.generateSync(), m6, d7, opts.canonical)))
    drbg.reseedSync();
  return finalizeSig(sig, opts);
}
Point.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils = {
  bytesToHex: bytesToHex2,
  hexToBytes: hexToBytes2,
  concatBytes: concatBytes2,
  mod,
  invert,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error2) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash2) => {
    hash2 = ensureBytes(hash2);
    const minLen = groupLen + 8;
    if (hash2.length < minLen || hash2.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num2 = mod(bytesToNumber(hash2), CURVE.n - _1n) + _1n;
    return numTo32b(num2);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes: randomBytes2 } = crypto3.node;
      return Uint8Array.from(randomBytes2(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point === Point.BASE ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: async (...messages) => {
    if (crypto3.web) {
      const buffer3 = await crypto3.web.subtle.digest("SHA-256", concatBytes2(...messages));
      return new Uint8Array(buffer3);
    } else if (crypto3.node) {
      const { createHash } = crypto3.node;
      const hash2 = createHash("sha256");
      messages.forEach((m6) => hash2.update(m6));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages) => {
    if (crypto3.web) {
      const ckey = await crypto3.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message = concatBytes2(...messages);
      const buffer3 = await crypto3.web.subtle.sign("HMAC", ckey, message);
      return new Uint8Array(buffer3);
    } else if (crypto3.node) {
      const { createHmac } = crypto3.node;
      const hash2 = createHmac("sha256", key);
      messages.forEach((m6) => hash2.update(m6));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: async (tag, ...messages) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = await utils.sha256(Uint8Array.from(tag, (c12) => c12.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils.sha256(tagP, ...messages);
  },
  taggedHashSync: (tag, ...messages) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c12) => c12.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// node_modules/@stacks/transactions/dist/esm/keys.js
var import_c32check4 = __toESM(require_lib());

// node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_5, i11) => i11);
var Pi = Id.map((i11) => (9 * i11 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i11 = 0; i11 < 4; i11++)
  for (let j7 of [idxL, idxR])
    j7.push(j7[i11].map((k7) => Rho[k7]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i11) => new Uint8Array(i11));
var shiftsL = idxL.map((idx, i11) => idx.map((j7) => shifts[i11][j7]));
var shiftsR = idxR.map((idx, i11) => idx.map((j7) => shifts[i11][j7]));
var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x7, y9, z5) {
  if (group === 0)
    return x7 ^ y9 ^ z5;
  else if (group === 1)
    return x7 & y9 | ~x7 & z5;
  else if (group === 2)
    return (x7 | ~y9) ^ z5;
  else if (group === 3)
    return x7 & z5 | y9 & ~z5;
  else
    return x7 ^ (y9 | ~z5);
}
var BUF = new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i11 = 0; i11 < 16; i11++, offset += 4)
      BUF[i11] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar3 = al, bl = this.h1 | 0, br4 = bl, cl = this.h2 | 0, cr4 = cl, dl = this.h3 | 0, dr4 = dl, el = this.h4 | 0, er3 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr4 = idxR[group];
      const sl = shiftsL[group], sr4 = shiftsR[group];
      for (let i11 = 0; i11 < 16; i11++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i11]] + hbl, sl[i11]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i11 = 0; i11 < 16; i11++) {
        const tr4 = rotl(ar3 + f(rGroup, br4, cr4, dr4) + BUF[rr4[i11]] + hbr, sr4[i11]) + er3 | 0;
        ar3 = er3, er3 = dr4, dr4 = rotl(cr4, 10) | 0, cr4 = br4, br4 = tr4;
      }
    }
    this.set(this.h1 + cl + dr4 | 0, this.h2 + dl + er3 | 0, this.h3 + el + ar3 | 0, this.h4 + al + br4 | 0, this.h0 + bl + cr4 | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n12, le5 = false) {
  if (le5)
    return { h: Number(n12 & U32_MASK64), l: Number(n12 >> _32n & U32_MASK64) };
  return { h: Number(n12 >> _32n & U32_MASK64) | 0, l: Number(n12 & U32_MASK64) | 0 };
}
function split(lst, le5 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i11 = 0; i11 < lst.length; i11++) {
    const { h: h12, l: l10 } = fromBig(lst[i11], le5);
    [Ah[i11], Al[i11]] = [h12, l10];
  }
  return [Ah, Al];
}
var toBig = (h12, l10) => BigInt(h12 >>> 0) << _32n | BigInt(l10 >>> 0);
var shrSH = (h12, l10, s8) => h12 >>> s8;
var shrSL = (h12, l10, s8) => h12 << 32 - s8 | l10 >>> s8;
var rotrSH = (h12, l10, s8) => h12 >>> s8 | l10 << 32 - s8;
var rotrSL = (h12, l10, s8) => h12 << 32 - s8 | l10 >>> s8;
var rotrBH = (h12, l10, s8) => h12 << 64 - s8 | l10 >>> s8 - 32;
var rotrBL = (h12, l10, s8) => h12 >>> s8 - 32 | l10 << 64 - s8;
var rotr32H = (h12, l10) => l10;
var rotr32L = (h12, l10) => h12;
var rotlSH = (h12, l10, s8) => h12 << s8 | l10 >>> 32 - s8;
var rotlSL = (h12, l10, s8) => l10 << s8 | h12 >>> 32 - s8;
var rotlBH = (h12, l10, s8) => l10 << s8 - 32 | h12 >>> 64 - s8;
var rotlBL = (h12, l10, s8) => h12 << s8 - 32 | l10 >>> 64 - s8;
function add(Ah, Al, Bh, Bl) {
  const l10 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l10 / 2 ** 32 | 0) | 0, l: l10 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n12) => BigInt(n12)));
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i11 = 0; i11 < 16; i11++, offset += 4) {
      SHA512_W_H[i11] = view.getUint32(offset);
      SHA512_W_L[i11] = view.getUint32(offset += 4);
    }
    for (let i11 = 16; i11 < 80; i11++) {
      const W15h = SHA512_W_H[i11 - 15] | 0;
      const W15l = SHA512_W_L[i11 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i11 - 2] | 0;
      const W2l = SHA512_W_L[i11 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i11 - 7], SHA512_W_L[i11 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i11 - 7], SHA512_W_H[i11 - 16]);
      SHA512_W_H[i11] = SUMh | 0;
      SHA512_W_L[i11] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i11 = 0; i11 < 80; i11++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i11], SHA512_W_L[i11]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i11], SHA512_W_H[i11]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@stacks/transactions/dist/esm/utils.js
var import_c32check3 = __toESM(require_lib());
var import_lodash = __toESM(require_lodash());

// node_modules/@stacks/transactions/dist/esm/clarity/constants.js
var ClarityType;
(function(ClarityType3) {
  ClarityType3["Int"] = "int";
  ClarityType3["UInt"] = "uint";
  ClarityType3["Buffer"] = "buffer";
  ClarityType3["BoolTrue"] = "true";
  ClarityType3["BoolFalse"] = "false";
  ClarityType3["PrincipalStandard"] = "address";
  ClarityType3["PrincipalContract"] = "contract";
  ClarityType3["ResponseOk"] = "ok";
  ClarityType3["ResponseErr"] = "err";
  ClarityType3["OptionalNone"] = "none";
  ClarityType3["OptionalSome"] = "some";
  ClarityType3["List"] = "list";
  ClarityType3["Tuple"] = "tuple";
  ClarityType3["StringASCII"] = "ascii";
  ClarityType3["StringUTF8"] = "utf8";
})(ClarityType || (ClarityType = {}));
var ClarityWireType;
(function(ClarityWireType2) {
  ClarityWireType2[ClarityWireType2["int"] = 0] = "int";
  ClarityWireType2[ClarityWireType2["uint"] = 1] = "uint";
  ClarityWireType2[ClarityWireType2["buffer"] = 2] = "buffer";
  ClarityWireType2[ClarityWireType2["true"] = 3] = "true";
  ClarityWireType2[ClarityWireType2["false"] = 4] = "false";
  ClarityWireType2[ClarityWireType2["address"] = 5] = "address";
  ClarityWireType2[ClarityWireType2["contract"] = 6] = "contract";
  ClarityWireType2[ClarityWireType2["ok"] = 7] = "ok";
  ClarityWireType2[ClarityWireType2["err"] = 8] = "err";
  ClarityWireType2[ClarityWireType2["none"] = 9] = "none";
  ClarityWireType2[ClarityWireType2["some"] = 10] = "some";
  ClarityWireType2[ClarityWireType2["list"] = 11] = "list";
  ClarityWireType2[ClarityWireType2["tuple"] = 12] = "tuple";
  ClarityWireType2[ClarityWireType2["ascii"] = 13] = "ascii";
  ClarityWireType2[ClarityWireType2["utf8"] = 14] = "utf8";
})(ClarityWireType || (ClarityWireType = {}));
function clarityTypeToByte(type) {
  return ClarityWireType[type];
}

// node_modules/@stacks/transactions/dist/esm/clarity/values/booleanCV.js
var trueCV = () => ({ type: ClarityType.BoolTrue });
var falseCV = () => ({ type: ClarityType.BoolFalse });
var boolCV = (bool3) => bool3 ? trueCV() : falseCV();

// node_modules/@stacks/transactions/dist/esm/clarity/values/bufferCV.js
var bufferCV = (buffer3) => {
  if (buffer3.byteLength > 1048576) {
    throw new Error("Cannot construct clarity buffer that is greater than 1MB");
  }
  return { type: ClarityType.Buffer, value: bytesToHex(buffer3) };
};

// node_modules/@stacks/transactions/dist/esm/clarity/values/intCV.js
var MAX_U128 = BigInt("0xffffffffffffffffffffffffffffffff");
var MIN_U128 = BigInt(0);
var MAX_I128 = BigInt("0x7fffffffffffffffffffffffffffffff");
var MIN_I128 = BigInt("-170141183460469231731687303715884105728");
var intCV = (value) => {
  if (typeof value === "string" && value.toLowerCase().startsWith("0x")) {
    value = bytesToTwosBigInt(hexToBytes(value));
  }
  if (isInstance(value, Uint8Array))
    value = bytesToTwosBigInt(value);
  const bigInt = intToBigInt(value);
  if (bigInt > MAX_I128) {
    throw new RangeError(`Cannot construct clarity integer from value greater than ${MAX_I128}`);
  } else if (bigInt < MIN_I128) {
    throw new RangeError(`Cannot construct clarity integer form value less than ${MIN_I128}`);
  }
  return { type: ClarityType.Int, value: bigInt };
};
var uintCV = (value) => {
  const bigInt = intToBigInt(value);
  if (bigInt < MIN_U128) {
    throw new RangeError("Cannot construct unsigned clarity integer from negative value");
  } else if (bigInt > MAX_U128) {
    throw new RangeError(`Cannot construct unsigned clarity integer greater than ${MAX_U128}`);
  }
  return { type: ClarityType.UInt, value: bigInt };
};

// node_modules/@stacks/transactions/dist/esm/clarity/values/listCV.js
function listCV(values) {
  return { type: ClarityType.List, value: values };
}

// node_modules/@stacks/transactions/dist/esm/clarity/values/optionalCV.js
function noneCV() {
  return { type: ClarityType.OptionalNone };
}
function someCV(value) {
  return { type: ClarityType.OptionalSome, value };
}

// node_modules/@stacks/transactions/dist/esm/wire/create.js
var import_c32check = __toESM(require_lib());

// node_modules/@stacks/transactions/dist/esm/wire/types.js
var StacksWireType;
(function(StacksWireType2) {
  StacksWireType2[StacksWireType2["Address"] = 0] = "Address";
  StacksWireType2[StacksWireType2["Principal"] = 1] = "Principal";
  StacksWireType2[StacksWireType2["LengthPrefixedString"] = 2] = "LengthPrefixedString";
  StacksWireType2[StacksWireType2["MemoString"] = 3] = "MemoString";
  StacksWireType2[StacksWireType2["Asset"] = 4] = "Asset";
  StacksWireType2[StacksWireType2["PostCondition"] = 5] = "PostCondition";
  StacksWireType2[StacksWireType2["PublicKey"] = 6] = "PublicKey";
  StacksWireType2[StacksWireType2["LengthPrefixedList"] = 7] = "LengthPrefixedList";
  StacksWireType2[StacksWireType2["Payload"] = 8] = "Payload";
  StacksWireType2[StacksWireType2["MessageSignature"] = 9] = "MessageSignature";
  StacksWireType2[StacksWireType2["StructuredDataSignature"] = 10] = "StructuredDataSignature";
  StacksWireType2[StacksWireType2["TransactionAuthField"] = 11] = "TransactionAuthField";
})(StacksWireType || (StacksWireType = {}));

// node_modules/@stacks/transactions/dist/esm/wire/create.js
function createEmptyAddress() {
  return {
    type: StacksWireType.Address,
    version: AddressVersion.MainnetSingleSig,
    hash160: "0".repeat(40)
  };
}
function createMemoString(content) {
  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {
    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES} bytes`);
  }
  return { type: StacksWireType.MemoString, content };
}
function createLPList(values, lengthPrefixBytes) {
  return {
    type: StacksWireType.LengthPrefixedList,
    lengthPrefixBytes: lengthPrefixBytes || 4,
    values
  };
}
function createMessageSignature(signature) {
  const length2 = hexToBytes(signature).byteLength;
  if (length2 != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
    throw Error("Invalid signature");
  }
  return {
    type: StacksWireType.MessageSignature,
    data: signature
  };
}
function createTokenTransferPayload(recipient, amount, memo) {
  if (typeof recipient === "string") {
    recipient = principalCV(recipient);
  }
  if (typeof memo === "string") {
    memo = createMemoString(memo);
  }
  return {
    type: StacksWireType.Payload,
    payloadType: PayloadType.TokenTransfer,
    recipient,
    amount: intToBigInt(amount),
    memo: memo ?? createMemoString("")
  };
}
function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
  if (typeof contractName === "string") {
    contractName = createLPString(contractName);
  }
  if (typeof functionName === "string") {
    functionName = createLPString(functionName);
  }
  return {
    type: StacksWireType.Payload,
    payloadType: PayloadType.ContractCall,
    contractAddress: typeof contractAddress === "string" ? createAddress(contractAddress) : contractAddress,
    contractName,
    functionName,
    functionArgs
  };
}
function codeBodyString(content) {
  return createLPString(content, 4, 1e5);
}
function createSmartContractPayload(contractName, codeBody, clarityVersion) {
  if (typeof contractName === "string") {
    contractName = createLPString(contractName);
  }
  if (typeof codeBody === "string") {
    codeBody = codeBodyString(codeBody);
  }
  if (typeof clarityVersion === "number") {
    return {
      type: StacksWireType.Payload,
      payloadType: PayloadType.VersionedSmartContract,
      clarityVersion,
      contractName,
      codeBody
    };
  }
  return {
    type: StacksWireType.Payload,
    payloadType: PayloadType.SmartContract,
    contractName,
    codeBody
  };
}
function createPoisonPayload() {
  return { type: StacksWireType.Payload, payloadType: PayloadType.PoisonMicroblock };
}
function createCoinbasePayload(coinbaseBytes, altRecipient) {
  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {
    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);
  }
  if (altRecipient != void 0) {
    return {
      type: StacksWireType.Payload,
      payloadType: PayloadType.CoinbaseToAltRecipient,
      coinbaseBytes,
      recipient: altRecipient
    };
  }
  return {
    type: StacksWireType.Payload,
    payloadType: PayloadType.Coinbase,
    coinbaseBytes
  };
}
function createNakamotoCoinbasePayload(coinbaseBytes, recipient, vrfProof) {
  if (coinbaseBytes.byteLength != COINBASE_BYTES_LENGTH) {
    throw Error(`Coinbase buffer size must be ${COINBASE_BYTES_LENGTH} bytes`);
  }
  if (vrfProof.byteLength != VRF_PROOF_BYTES_LENGTH) {
    throw Error(`VRF proof buffer size must be ${VRF_PROOF_BYTES_LENGTH} bytes`);
  }
  return {
    type: StacksWireType.Payload,
    payloadType: PayloadType.NakamotoCoinbase,
    coinbaseBytes,
    recipient: recipient.type === ClarityType.OptionalSome ? recipient.value : void 0,
    vrfProof
  };
}
function createTenureChangePayload(tenureHash, previousTenureHash, burnViewHash, previousTenureEnd, previousTenureBlocks, cause, publicKeyHash) {
  return {
    type: StacksWireType.Payload,
    payloadType: PayloadType.TenureChange,
    tenureHash,
    previousTenureHash,
    burnViewHash,
    previousTenureEnd,
    previousTenureBlocks,
    cause,
    publicKeyHash
  };
}
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
  const prefixLength = lengthPrefixBytes || 1;
  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;
  if (exceedsMaxLengthBytes(content, maxLength)) {
    throw new Error(`String length exceeds maximum bytes ${maxLength}`);
  }
  return {
    type: StacksWireType.LengthPrefixedString,
    content,
    lengthPrefixBytes: prefixLength,
    maxLengthBytes: maxLength
  };
}
function createAsset(addressString, contractName, assetName) {
  return {
    type: StacksWireType.Asset,
    address: createAddress(addressString),
    contractName: createLPString(contractName),
    assetName: createLPString(assetName)
  };
}
function createAddress(c32AddressString) {
  const addressData = (0, import_c32check.c32addressDecode)(c32AddressString);
  return {
    type: StacksWireType.Address,
    version: addressData[0],
    hash160: addressData[1]
  };
}
function createContractPrincipal(addressString, contractName) {
  const addr = createAddress(addressString);
  const name2 = createLPString(contractName);
  return {
    type: StacksWireType.Principal,
    prefix: PostConditionPrincipalId.Contract,
    address: addr,
    contractName: name2
  };
}
function createStandardPrincipal(addressString) {
  const addr = createAddress(addressString);
  return {
    type: StacksWireType.Principal,
    prefix: PostConditionPrincipalId.Standard,
    address: addr
  };
}
function createTransactionAuthField(pubKeyEncoding, contents) {
  return {
    pubKeyEncoding,
    type: StacksWireType.TransactionAuthField,
    contents
  };
}

// node_modules/@stacks/transactions/dist/esm/wire/helpers.js
var import_c32check2 = __toESM(require_lib());

// node_modules/@stacks/transactions/dist/esm/wire/serialization.js
function serializeStacksWireBytes(wire) {
  switch (wire.type) {
    case StacksWireType.Address:
      return serializeAddressBytes(wire);
    case StacksWireType.Principal:
      return serializePrincipalBytes(wire);
    case StacksWireType.LengthPrefixedString:
      return serializeLPStringBytes(wire);
    case StacksWireType.MemoString:
      return serializeMemoStringBytes(wire);
    case StacksWireType.Asset:
      return serializeAssetBytes(wire);
    case StacksWireType.PostCondition:
      return serializePostConditionWireBytes(wire);
    case StacksWireType.PublicKey:
      return serializePublicKeyBytes(wire);
    case StacksWireType.LengthPrefixedList:
      return serializeLPListBytes(wire);
    case StacksWireType.Payload:
      return serializePayloadBytes(wire);
    case StacksWireType.TransactionAuthField:
      return serializeTransactionAuthFieldBytes(wire);
    case StacksWireType.MessageSignature:
      return serializeMessageSignatureBytes(wire);
  }
}
function serializeAddressBytes(address2) {
  const bytesArray = [];
  bytesArray.push(hexToBytes(intToHex(address2.version, 1)));
  bytesArray.push(hexToBytes(address2.hash160));
  return concatArray(bytesArray);
}
function deserializeAddress(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const version4 = hexToInt(bytesToHex(bytesReader.readBytes(1)));
  const data = bytesToHex(bytesReader.readBytes(20));
  return { type: StacksWireType.Address, version: version4, hash160: data };
}
function serializePrincipalBytes(principal2) {
  const bytesArray = [];
  bytesArray.push(principal2.prefix);
  if (principal2.prefix === PostConditionPrincipalId.Standard || principal2.prefix === PostConditionPrincipalId.Contract) {
    bytesArray.push(serializeAddressBytes(principal2.address));
  }
  if (principal2.prefix === PostConditionPrincipalId.Contract) {
    bytesArray.push(serializeLPStringBytes(principal2.contractName));
  }
  return concatArray(bytesArray);
}
function deserializePrincipal(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const prefix = bytesReader.readUInt8Enum(PostConditionPrincipalId, (n12) => {
    throw new DeserializationError(`Unexpected Principal payload type: ${n12}`);
  });
  if (prefix === PostConditionPrincipalId.Origin) {
    return { type: StacksWireType.Principal, prefix };
  }
  const address2 = deserializeAddress(bytesReader);
  if (prefix === PostConditionPrincipalId.Standard) {
    return { type: StacksWireType.Principal, prefix, address: address2 };
  }
  const contractName = deserializeLPString(bytesReader);
  return {
    type: StacksWireType.Principal,
    prefix,
    address: address2,
    contractName
  };
}
function serializeLPStringBytes(lps) {
  const bytesArray = [];
  const contentBytes = utf8ToBytes(lps.content);
  const length2 = contentBytes.byteLength;
  bytesArray.push(hexToBytes(intToHex(length2, lps.lengthPrefixBytes)));
  bytesArray.push(contentBytes);
  return concatArray(bytesArray);
}
function deserializeLPString(serialized, prefixBytes, maxLength) {
  prefixBytes = prefixBytes ? prefixBytes : 1;
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const length2 = hexToInt(bytesToHex(bytesReader.readBytes(prefixBytes)));
  const content = bytesToUtf8(bytesReader.readBytes(length2));
  return createLPString(content, prefixBytes, maxLength ?? 128);
}
function serializeMemoStringBytes(memoString) {
  const bytesArray = [];
  const contentBytes = utf8ToBytes(memoString.content);
  const paddedContent = rightPadHexToLength(bytesToHex(contentBytes), MEMO_MAX_LENGTH_BYTES * 2);
  bytesArray.push(hexToBytes(paddedContent));
  return concatArray(bytesArray);
}
function deserializeMemoString(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  let content = bytesToUtf8(bytesReader.readBytes(MEMO_MAX_LENGTH_BYTES));
  content = content.replace(/\u0000*$/, "");
  return { type: StacksWireType.MemoString, content };
}
function serializeAssetBytes(info) {
  const bytesArray = [];
  bytesArray.push(serializeAddressBytes(info.address));
  bytesArray.push(serializeLPStringBytes(info.contractName));
  bytesArray.push(serializeLPStringBytes(info.assetName));
  return concatArray(bytesArray);
}
function deserializeAsset(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  return {
    type: StacksWireType.Asset,
    address: deserializeAddress(bytesReader),
    contractName: deserializeLPString(bytesReader),
    assetName: deserializeLPString(bytesReader)
  };
}
function serializeLPListBytes(lpList) {
  const list2 = lpList.values;
  const bytesArray = [];
  bytesArray.push(hexToBytes(intToHex(list2.length, lpList.lengthPrefixBytes)));
  for (const l10 of list2) {
    bytesArray.push(serializeStacksWireBytes(l10));
  }
  return concatArray(bytesArray);
}
function deserializeLPList(serialized, type, lengthPrefixBytes) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const length2 = hexToInt(bytesToHex(bytesReader.readBytes(lengthPrefixBytes || 4)));
  const l10 = [];
  for (let index2 = 0; index2 < length2; index2++) {
    switch (type) {
      case StacksWireType.Address:
        l10.push(deserializeAddress(bytesReader));
        break;
      case StacksWireType.LengthPrefixedString:
        l10.push(deserializeLPString(bytesReader));
        break;
      case StacksWireType.MemoString:
        l10.push(deserializeMemoString(bytesReader));
        break;
      case StacksWireType.Asset:
        l10.push(deserializeAsset(bytesReader));
        break;
      case StacksWireType.PostCondition:
        l10.push(deserializePostConditionWire(bytesReader));
        break;
      case StacksWireType.PublicKey:
        l10.push(deserializePublicKey(bytesReader));
        break;
      case StacksWireType.TransactionAuthField:
        l10.push(deserializeTransactionAuthField(bytesReader));
        break;
    }
  }
  return createLPList(l10, lengthPrefixBytes);
}
function serializePostConditionWire(postCondition) {
  return bytesToHex(serializePostConditionWireBytes(postCondition));
}
function serializePostConditionWireBytes(postCondition) {
  const bytesArray = [];
  bytesArray.push(postCondition.conditionType);
  bytesArray.push(serializePrincipalBytes(postCondition.principal));
  if (postCondition.conditionType === PostConditionType.Fungible || postCondition.conditionType === PostConditionType.NonFungible) {
    bytesArray.push(serializeAssetBytes(postCondition.asset));
  }
  if (postCondition.conditionType === PostConditionType.NonFungible) {
    bytesArray.push(serializeCVBytes(postCondition.assetName));
  }
  bytesArray.push(postCondition.conditionCode);
  if (postCondition.conditionType === PostConditionType.STX || postCondition.conditionType === PostConditionType.Fungible) {
    if (postCondition.amount > BigInt("0xffffffffffffffff"))
      throw new SerializationError("The post-condition amount may not be larger than 8 bytes");
    bytesArray.push(intToBytes(postCondition.amount, 8));
  }
  return concatArray(bytesArray);
}
function deserializePostConditionWire(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const postConditionType = bytesReader.readUInt8Enum(PostConditionType, (n12) => {
    throw new DeserializationError(`Could not read ${n12} as PostConditionType`);
  });
  const principal2 = deserializePrincipal(bytesReader);
  let conditionCode;
  let asset;
  let amount;
  switch (postConditionType) {
    case PostConditionType.STX:
      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, (n12) => {
        throw new DeserializationError(`Could not read ${n12} as FungibleConditionCode`);
      });
      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
      return {
        type: StacksWireType.PostCondition,
        conditionType: PostConditionType.STX,
        principal: principal2,
        conditionCode,
        amount
      };
    case PostConditionType.Fungible:
      asset = deserializeAsset(bytesReader);
      conditionCode = bytesReader.readUInt8Enum(FungibleConditionCode, (n12) => {
        throw new DeserializationError(`Could not read ${n12} as FungibleConditionCode`);
      });
      amount = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
      return {
        type: StacksWireType.PostCondition,
        conditionType: PostConditionType.Fungible,
        principal: principal2,
        conditionCode,
        amount,
        asset
      };
    case PostConditionType.NonFungible:
      asset = deserializeAsset(bytesReader);
      const assetName = deserializeCV(bytesReader);
      conditionCode = bytesReader.readUInt8Enum(NonFungibleConditionCode, (n12) => {
        throw new DeserializationError(`Could not read ${n12} as FungibleConditionCode`);
      });
      return {
        type: StacksWireType.PostCondition,
        conditionType: PostConditionType.NonFungible,
        principal: principal2,
        conditionCode,
        asset,
        assetName
      };
  }
}
function serializePayloadBytes(payload) {
  const bytesArray = [];
  bytesArray.push(payload.payloadType);
  switch (payload.payloadType) {
    case PayloadType.TokenTransfer:
      bytesArray.push(serializeCVBytes(payload.recipient));
      bytesArray.push(intToBytes(payload.amount, 8));
      bytesArray.push(serializeStacksWireBytes(payload.memo));
      break;
    case PayloadType.ContractCall:
      bytesArray.push(serializeStacksWireBytes(payload.contractAddress));
      bytesArray.push(serializeStacksWireBytes(payload.contractName));
      bytesArray.push(serializeStacksWireBytes(payload.functionName));
      const numArgs = new Uint8Array(4);
      writeUInt32BE(numArgs, payload.functionArgs.length, 0);
      bytesArray.push(numArgs);
      payload.functionArgs.forEach((arg) => {
        bytesArray.push(serializeCVBytes(arg));
      });
      break;
    case PayloadType.SmartContract:
      bytesArray.push(serializeStacksWireBytes(payload.contractName));
      bytesArray.push(serializeStacksWireBytes(payload.codeBody));
      break;
    case PayloadType.VersionedSmartContract:
      bytesArray.push(payload.clarityVersion);
      bytesArray.push(serializeStacksWireBytes(payload.contractName));
      bytesArray.push(serializeStacksWireBytes(payload.codeBody));
      break;
    case PayloadType.PoisonMicroblock:
      break;
    case PayloadType.Coinbase:
      bytesArray.push(payload.coinbaseBytes);
      break;
    case PayloadType.CoinbaseToAltRecipient:
      bytesArray.push(payload.coinbaseBytes);
      bytesArray.push(serializeCVBytes(payload.recipient));
      break;
    case PayloadType.NakamotoCoinbase:
      bytesArray.push(payload.coinbaseBytes);
      bytesArray.push(serializeCVBytes(payload.recipient ? someCV(payload.recipient) : noneCV()));
      bytesArray.push(payload.vrfProof);
      break;
    case PayloadType.TenureChange:
      bytesArray.push(hexToBytes(payload.tenureHash));
      bytesArray.push(hexToBytes(payload.previousTenureHash));
      bytesArray.push(hexToBytes(payload.burnViewHash));
      bytesArray.push(hexToBytes(payload.previousTenureEnd));
      bytesArray.push(writeUInt32BE(new Uint8Array(4), payload.previousTenureBlocks));
      bytesArray.push(writeUInt8(new Uint8Array(1), payload.cause));
      bytesArray.push(hexToBytes(payload.publicKeyHash));
      break;
  }
  return concatArray(bytesArray);
}
function deserializePayload(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const payloadType = bytesReader.readUInt8Enum(PayloadType, (n12) => {
    throw new Error(`Cannot recognize PayloadType: ${n12}`);
  });
  switch (payloadType) {
    case PayloadType.TokenTransfer:
      const recipient = deserializeCV(bytesReader);
      const amount = intToBigInt(bytesReader.readBytes(8));
      const memo = deserializeMemoString(bytesReader);
      return createTokenTransferPayload(recipient, amount, memo);
    case PayloadType.ContractCall:
      const contractAddress = deserializeAddress(bytesReader);
      const contractCallName = deserializeLPString(bytesReader);
      const functionName = deserializeLPString(bytesReader);
      const functionArgs = [];
      const numberOfArgs = bytesReader.readUInt32BE();
      for (let i11 = 0; i11 < numberOfArgs; i11++) {
        const clarityValue = deserializeCV(bytesReader);
        functionArgs.push(clarityValue);
      }
      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);
    case PayloadType.SmartContract:
      const smartContractName = deserializeLPString(bytesReader);
      const codeBody = deserializeLPString(bytesReader, 4, 1e5);
      return createSmartContractPayload(smartContractName, codeBody);
    case PayloadType.VersionedSmartContract: {
      const clarityVersion = bytesReader.readUInt8Enum(ClarityVersion, (n12) => {
        throw new Error(`Cannot recognize ClarityVersion: ${n12}`);
      });
      const smartContractName2 = deserializeLPString(bytesReader);
      const codeBody2 = deserializeLPString(bytesReader, 4, STRING_MAX_LENGTH);
      return createSmartContractPayload(smartContractName2, codeBody2, clarityVersion);
    }
    case PayloadType.PoisonMicroblock:
      return createPoisonPayload();
    case PayloadType.Coinbase: {
      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);
      return createCoinbasePayload(coinbaseBytes);
    }
    case PayloadType.CoinbaseToAltRecipient: {
      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);
      const altRecipient = deserializeCV(bytesReader);
      return createCoinbasePayload(coinbaseBytes, altRecipient);
    }
    case PayloadType.NakamotoCoinbase: {
      const coinbaseBytes = bytesReader.readBytes(COINBASE_BYTES_LENGTH);
      const recipient2 = deserializeCV(bytesReader);
      const vrfProof = bytesReader.readBytes(VRF_PROOF_BYTES_LENGTH);
      return createNakamotoCoinbasePayload(coinbaseBytes, recipient2, vrfProof);
    }
    case PayloadType.TenureChange:
      const tenureHash = bytesToHex(bytesReader.readBytes(20));
      const previousTenureHash = bytesToHex(bytesReader.readBytes(20));
      const burnViewHash = bytesToHex(bytesReader.readBytes(20));
      const previousTenureEnd = bytesToHex(bytesReader.readBytes(32));
      const previousTenureBlocks = bytesReader.readUInt32BE();
      const cause = bytesReader.readUInt8Enum(TenureChangeCause, (n12) => {
        throw new Error(`Cannot recognize TenureChangeCause: ${n12}`);
      });
      const publicKeyHash = bytesToHex(bytesReader.readBytes(20));
      return createTenureChangePayload(tenureHash, previousTenureHash, burnViewHash, previousTenureEnd, previousTenureBlocks, cause, publicKeyHash);
  }
}
function deserializeMessageSignature(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  return createMessageSignature(bytesToHex(bytesReader.readBytes(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));
}
function deserializeTransactionAuthField(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, (n12) => {
    throw new DeserializationError(`Could not read ${n12} as AuthFieldType`);
  });
  switch (authFieldType) {
    case AuthFieldType.PublicKeyCompressed:
      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bytesReader));
    case AuthFieldType.PublicKeyUncompressed:
      return createTransactionAuthField(PubKeyEncoding.Uncompressed, createStacksPublicKey(uncompressPublicKey(deserializePublicKey(bytesReader).data)));
    case AuthFieldType.SignatureCompressed:
      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));
    case AuthFieldType.SignatureUncompressed:
      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));
    default:
      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
  }
}
function serializeMessageSignatureBytes(messageSignature) {
  return hexToBytes(messageSignature.data);
}
function serializeTransactionAuthFieldBytes(field) {
  const bytesArray = [];
  switch (field.contents.type) {
    case StacksWireType.PublicKey:
      bytesArray.push(field.pubKeyEncoding === PubKeyEncoding.Compressed ? AuthFieldType.PublicKeyCompressed : AuthFieldType.PublicKeyUncompressed);
      bytesArray.push(hexToBytes(compressPublicKey(field.contents.data)));
      break;
    case StacksWireType.MessageSignature:
      bytesArray.push(field.pubKeyEncoding === PubKeyEncoding.Compressed ? AuthFieldType.SignatureCompressed : AuthFieldType.SignatureUncompressed);
      bytesArray.push(serializeMessageSignatureBytes(field.contents));
      break;
  }
  return concatArray(bytesArray);
}
function serializePublicKeyBytes(key) {
  return key.data.slice();
}
function deserializePublicKey(serialized) {
  const bytesReader = isInstance(serialized, BytesReader) ? serialized : new BytesReader(serialized);
  const fieldId = bytesReader.readUInt8();
  const keyLength = fieldId === 4 ? UNCOMPRESSED_PUBKEY_LENGTH_BYTES : COMPRESSED_PUBKEY_LENGTH_BYTES;
  return createStacksPublicKey(concatArray([fieldId, bytesReader.readBytes(keyLength)]));
}

// node_modules/@stacks/transactions/dist/esm/wire/helpers.js
function addressFromPublicKeys(version4, hashMode, numSigs, publicKeys) {
  if (publicKeys.length === 0) {
    throw Error("Invalid number of public keys");
  }
  if (hashMode === AddressHashMode.P2PKH || hashMode === AddressHashMode.P2WPKH) {
    if (publicKeys.length !== 1 || numSigs !== 1) {
      throw Error("Invalid number of public keys or signatures");
    }
  }
  if (hashMode === AddressHashMode.P2WPKH || hashMode === AddressHashMode.P2WSH || hashMode === AddressHashMode.P2WSHNonSequential) {
    if (!publicKeys.map((p8) => p8.data).every(publicKeyIsCompressed)) {
      throw Error("Public keys must be compressed for segwit");
    }
  }
  switch (hashMode) {
    case AddressHashMode.P2PKH:
      return addressFromVersionHash(version4, hashP2PKH(publicKeys[0].data));
    case AddressHashMode.P2WPKH:
      return addressFromVersionHash(version4, hashP2WPKH(publicKeys[0].data));
    case AddressHashMode.P2SH:
    case AddressHashMode.P2SHNonSequential:
      return addressFromVersionHash(version4, hashP2SH(numSigs, publicKeys.map(serializePublicKeyBytes)));
    case AddressHashMode.P2WSH:
    case AddressHashMode.P2WSHNonSequential:
      return addressFromVersionHash(version4, hashP2WSH(numSigs, publicKeys.map(serializePublicKeyBytes)));
  }
}
function addressFromVersionHash(version4, hash2) {
  return { type: StacksWireType.Address, version: version4, hash160: hash2 };
}
function addressToString(address2) {
  return (0, import_c32check2.c32address)(address2.version, address2.hash160);
}
function parseAssetString(id) {
  const [assetAddress, assetContractName, assetTokenName] = id.split(/\.|::/);
  const asset = createAsset(assetAddress, assetContractName, assetTokenName);
  return asset;
}
function parsePrincipalString(principalString) {
  if (principalString.includes(".")) {
    const [address2, contractName] = principalString.split(".");
    return createContractPrincipal(address2, contractName);
  } else {
    return createStandardPrincipal(principalString);
  }
}

// node_modules/@stacks/transactions/dist/esm/clarity/values/principalCV.js
function principalCV(principal2) {
  if (principal2.includes(".")) {
    const [address2, contractName] = principal2.split(".");
    return contractPrincipalCV(address2, contractName);
  } else {
    return standardPrincipalCV(principal2);
  }
}
function standardPrincipalCV(addressString) {
  const addr = createAddress(addressString);
  return { type: ClarityType.PrincipalStandard, value: addressToString(addr) };
}
function standardPrincipalCVFromAddress(address2) {
  return { type: ClarityType.PrincipalStandard, value: addressToString(address2) };
}
function contractPrincipalCV(addressString, contractName) {
  const addr = createAddress(addressString);
  const lengthPrefixedContractName = createLPString(contractName);
  return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);
}
function contractPrincipalCVFromAddress(address2, contractName) {
  if (utf8ToBytes(contractName.content).byteLength >= 128) {
    throw new Error("Contract name must be less than 128 bytes");
  }
  return {
    type: ClarityType.PrincipalContract,
    value: `${addressToString(address2)}.${contractName.content}`
  };
}

// node_modules/@stacks/transactions/dist/esm/clarity/values/responseCV.js
function responseErrorCV(value) {
  return { type: ClarityType.ResponseErr, value };
}
function responseOkCV(value) {
  return { type: ClarityType.ResponseOk, value };
}

// node_modules/@stacks/transactions/dist/esm/clarity/values/stringCV.js
var stringAsciiCV = (data) => {
  return { type: ClarityType.StringASCII, value: data };
};
var stringUtf8CV = (data) => {
  return { type: ClarityType.StringUTF8, value: data };
};

// node_modules/@stacks/transactions/dist/esm/clarity/values/tupleCV.js
function tupleCV(data) {
  for (const key in data) {
    if (!isClarityName(key)) {
      throw new Error(`"${key}" is not a valid Clarity name`);
    }
  }
  return { type: ClarityType.Tuple, value: data };
}

// node_modules/@stacks/transactions/dist/esm/clarity/deserialize.js
function deserializeCV(serializedClarityValue) {
  let bytesReader;
  if (typeof serializedClarityValue === "string") {
    const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === "0x";
    bytesReader = new BytesReader(hexToBytes(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue));
  } else if (serializedClarityValue instanceof Uint8Array) {
    bytesReader = new BytesReader(serializedClarityValue);
  } else {
    bytesReader = serializedClarityValue;
  }
  const type = bytesReader.readUInt8Enum(ClarityWireType, (n12) => {
    throw new DeserializationError(`Cannot recognize Clarity Type: ${n12}`);
  });
  switch (type) {
    case ClarityWireType.int:
      return intCV(bytesToTwosBigInt(bytesReader.readBytes(16)));
    case ClarityWireType.uint:
      return uintCV(bytesReader.readBytes(16));
    case ClarityWireType.buffer:
      const bufferLength = bytesReader.readUInt32BE();
      return bufferCV(bytesReader.readBytes(bufferLength));
    case ClarityWireType.true:
      return trueCV();
    case ClarityWireType.false:
      return falseCV();
    case ClarityWireType.address:
      const sAddress = deserializeAddress(bytesReader);
      return standardPrincipalCVFromAddress(sAddress);
    case ClarityWireType.contract:
      const cAddress = deserializeAddress(bytesReader);
      const contractName = deserializeLPString(bytesReader);
      return contractPrincipalCVFromAddress(cAddress, contractName);
    case ClarityWireType.ok:
      return responseOkCV(deserializeCV(bytesReader));
    case ClarityWireType.err:
      return responseErrorCV(deserializeCV(bytesReader));
    case ClarityWireType.none:
      return noneCV();
    case ClarityWireType.some:
      return someCV(deserializeCV(bytesReader));
    case ClarityWireType.list:
      const listLength = bytesReader.readUInt32BE();
      const listContents = [];
      for (let i11 = 0; i11 < listLength; i11++) {
        listContents.push(deserializeCV(bytesReader));
      }
      return listCV(listContents);
    case ClarityWireType.tuple:
      const tupleLength = bytesReader.readUInt32BE();
      const tupleContents = {};
      for (let i11 = 0; i11 < tupleLength; i11++) {
        const clarityName = deserializeLPString(bytesReader).content;
        if (clarityName === void 0) {
          throw new DeserializationError('"content" is undefined');
        }
        tupleContents[clarityName] = deserializeCV(bytesReader);
      }
      return tupleCV(tupleContents);
    case ClarityWireType.ascii:
      const asciiStrLen = bytesReader.readUInt32BE();
      const asciiStr = bytesToAscii(bytesReader.readBytes(asciiStrLen));
      return stringAsciiCV(asciiStr);
    case ClarityWireType.utf8:
      const utf8StrLen = bytesReader.readUInt32BE();
      const utf8Str = bytesToUtf8(bytesReader.readBytes(utf8StrLen));
      return stringUtf8CV(utf8Str);
    default:
      throw new DeserializationError("Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.");
  }
}

// node_modules/@stacks/transactions/dist/esm/clarity/serialize.js
function bytesWithTypeID(typeId, bytes2) {
  return concatArray([clarityTypeToByte(typeId), bytes2]);
}
function serializeBoolCV(value) {
  return new Uint8Array([clarityTypeToByte(value.type)]);
}
function serializeOptionalCV(cv) {
  if (cv.type === ClarityType.OptionalNone) {
    return new Uint8Array([clarityTypeToByte(cv.type)]);
  } else {
    return bytesWithTypeID(cv.type, serializeCVBytes(cv.value));
  }
}
function serializeBufferCV(cv) {
  const length2 = new Uint8Array(4);
  writeUInt32BE(length2, Math.ceil(cv.value.length / 2), 0);
  return bytesWithTypeID(cv.type, concatBytes(length2, hexToBytes(cv.value)));
}
function serializeIntCV(cv) {
  const bytes2 = bigIntToBytes(toTwos(BigInt(cv.value), BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);
  return bytesWithTypeID(cv.type, bytes2);
}
function serializeUIntCV(cv) {
  const bytes2 = bigIntToBytes(BigInt(cv.value), CLARITY_INT_BYTE_SIZE);
  return bytesWithTypeID(cv.type, bytes2);
}
function serializeStandardPrincipalCV(cv) {
  return bytesWithTypeID(cv.type, serializeAddressBytes(createAddress(cv.value)));
}
function serializeContractPrincipalCV(cv) {
  const [address2, name2] = parseContractId(cv.value);
  return bytesWithTypeID(cv.type, concatBytes(serializeAddressBytes(createAddress(address2)), serializeLPStringBytes(createLPString(name2))));
}
function serializeResponseCV(cv) {
  return bytesWithTypeID(cv.type, serializeCVBytes(cv.value));
}
function serializeListCV(cv) {
  const bytesArray = [];
  const length2 = new Uint8Array(4);
  writeUInt32BE(length2, cv.value.length, 0);
  bytesArray.push(length2);
  for (const value of cv.value) {
    const serializedValue = serializeCVBytes(value);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeTupleCV(cv) {
  const bytesArray = [];
  const length2 = new Uint8Array(4);
  writeUInt32BE(length2, Object.keys(cv.value).length, 0);
  bytesArray.push(length2);
  const lexicographicOrder = Object.keys(cv.value).sort((a5, b7) => a5.localeCompare(b7));
  for (const key of lexicographicOrder) {
    const nameWithLength = createLPString(key);
    bytesArray.push(serializeLPStringBytes(nameWithLength));
    const serializedValue = serializeCVBytes(cv.value[key]);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringCV(cv, encoding) {
  const bytesArray = [];
  const str = encoding == "ascii" ? asciiToBytes(cv.value) : utf8ToBytes(cv.value);
  const len = new Uint8Array(4);
  writeUInt32BE(len, str.length, 0);
  bytesArray.push(len);
  bytesArray.push(str);
  return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringAsciiCV(cv) {
  return serializeStringCV(cv, "ascii");
}
function serializeStringUtf8CV(cv) {
  return serializeStringCV(cv, "utf8");
}
function serializeCV(value) {
  return bytesToHex(serializeCVBytes(value));
}
function serializeCVBytes(value) {
  switch (value.type) {
    case ClarityType.BoolTrue:
    case ClarityType.BoolFalse:
      return serializeBoolCV(value);
    case ClarityType.OptionalNone:
    case ClarityType.OptionalSome:
      return serializeOptionalCV(value);
    case ClarityType.Buffer:
      return serializeBufferCV(value);
    case ClarityType.UInt:
      return serializeUIntCV(value);
    case ClarityType.Int:
      return serializeIntCV(value);
    case ClarityType.PrincipalStandard:
      return serializeStandardPrincipalCV(value);
    case ClarityType.PrincipalContract:
      return serializeContractPrincipalCV(value);
    case ClarityType.ResponseOk:
    case ClarityType.ResponseErr:
      return serializeResponseCV(value);
    case ClarityType.List:
      return serializeListCV(value);
    case ClarityType.Tuple:
      return serializeTupleCV(value);
    case ClarityType.StringASCII:
      return serializeStringAsciiCV(value);
    case ClarityType.StringUTF8:
      return serializeStringUtf8CV(value);
    default:
      throw new SerializationError("Unable to serialize. Invalid Clarity Value.");
  }
}

// node_modules/@stacks/transactions/dist/esm/clarity/parser.js
function regex(pattern, map2) {
  return (s8) => {
    const match = s8.match(pattern);
    if (!match || match.index !== 0)
      return { success: false };
    return {
      success: true,
      value: match[0],
      rest: s8.substring(match[0].length),
      capture: map2 ? map2(match[0]) : void 0
    };
  };
}
function whitespace() {
  return regex(/\s+/);
}
function lazy(c12) {
  return (s8) => c12()(s8);
}
function either(combinators) {
  return (s8) => {
    for (const c12 of combinators) {
      const result = c12(s8);
      if (result.success)
        return result;
    }
    return { success: false };
  };
}
function entire(combinator) {
  return (s8) => {
    const result = combinator(s8);
    if (!result.success || result.rest)
      return { success: false };
    return result;
  };
}
function optional(c12) {
  return (s8) => {
    const result = c12(s8);
    if (result.success)
      return result;
    return {
      success: true,
      value: "",
      rest: s8
    };
  };
}
function sequence(combinators, reduce = (v8) => v8[0]) {
  return (s8) => {
    let rest = s8;
    let value = "";
    const captures = [];
    for (const c12 of combinators) {
      const result = c12(rest);
      if (!result.success)
        return { success: false };
      rest = result.rest;
      value += result.value;
      if (result.capture)
        captures.push(result.capture);
    }
    return {
      success: true,
      value,
      rest,
      capture: reduce(captures)
    };
  };
}
function chain2(combinators, reduce = (v8) => v8[0]) {
  const joined = combinators.flatMap((combinator, index2) => index2 === 0 ? [combinator] : [optional(whitespace()), combinator]);
  return sequence(joined, reduce);
}
function parens(combinator) {
  return chain2([regex(/\(/), combinator, regex(/\)/)]);
}
function greedy(min, combinator, reduce = (v8) => v8[v8.length - 1], separator) {
  return (s8) => {
    let rest = s8;
    let value = "";
    const captures = [];
    let count;
    for (count = 0; ; count++) {
      const result = combinator(rest);
      if (!result.success)
        break;
      rest = result.rest;
      value += result.value;
      if (result.capture)
        captures.push(result.capture);
      if (separator) {
        const sepResult = separator(rest);
        if (!sepResult.success) {
          count++;
          break;
        }
        rest = sepResult.rest;
        value += sepResult.value;
      }
    }
    if (count < min)
      return { success: false };
    return {
      success: true,
      value,
      rest,
      capture: reduce(captures)
    };
  };
}
function capture(combinator, map2) {
  return (s8) => {
    const result = combinator(s8);
    if (!result.success)
      return { success: false };
    return {
      success: true,
      value: result.value,
      rest: result.rest,
      capture: map2 ? map2(result.value) : result.value
    };
  };
}
function clInt() {
  return capture(regex(/\-?[0-9]+/), (v8) => cl_exports.int(parseInt(v8)));
}
function clUint() {
  return sequence([regex(/u/), capture(regex(/[0-9]+/), (v8) => cl_exports.uint(parseInt(v8)))]);
}
function clBool() {
  return capture(regex(/true|false/), (v8) => cl_exports.bool(v8 === "true"));
}
function clPrincipal() {
  return sequence([
    regex(/\'/),
    capture(sequence([regex(/[A-Z0-9]+/), optional(sequence([regex(/\./), regex(/[a-zA-Z0-9\-]+/)]))]), cl_exports.address)
  ]);
}
function clBuffer() {
  return sequence([regex(/0x/), capture(regex(/[0-9a-fA-F]+/), cl_exports.bufferFromHex)]);
}
function unescape2(input) {
  try {
    return JSON.parse(`"${input}"`);
  } catch (error2) {
    throw new Error(`Failed to unescape string: "${input}" ${error2 instanceof Error ? error2.message : error2}`);
  }
}
function clAscii() {
  return sequence([
    regex(/"/),
    capture(regex(/(\\.|[^"])*/), (t5) => cl_exports.stringAscii(unescape2(t5))),
    regex(/"/)
  ]);
}
function clUtf8() {
  return sequence([
    regex(/u"/),
    capture(regex(/(\\.|[^"])*/), (t5) => cl_exports.stringUtf8(unescape2(t5))),
    regex(/"/)
  ]);
}
function clList() {
  return parens(sequence([
    regex(/list/),
    greedy(0, sequence([whitespace(), clValue()]), (c12) => cl_exports.list(c12))
  ]));
}
function clTuple() {
  const tupleCurly = chain2([
    regex(/\{/),
    greedy(1, sequence([
      capture(regex(/[a-zA-Z][a-zA-Z0-9_]*/)),
      regex(/\s*\:/),
      whitespace(),
      clValue()
    ], ([k7, v8]) => cl_exports.tuple({ [k7]: v8 })), (c12) => cl_exports.tuple(Object.assign({}, ...c12.map((t5) => t5.value))), regex(/\s*\,\s*/)),
    regex(/\}/)
  ]);
  const tupleFunction = parens(sequence([
    optional(whitespace()),
    regex(/tuple/),
    whitespace(),
    greedy(1, parens(sequence([
      optional(whitespace()),
      capture(regex(/[a-zA-Z][a-zA-Z0-9_]*/)),
      whitespace(),
      clValue(),
      optional(whitespace())
    ], ([k7, v8]) => cl_exports.tuple({ [k7]: v8 }))), (c12) => cl_exports.tuple(Object.assign({}, ...c12.map((t5) => t5.value))), whitespace())
  ]));
  return either([tupleCurly, tupleFunction]);
}
function clNone() {
  return capture(regex(/none/), cl_exports.none);
}
function clSome() {
  return parens(sequence([regex(/some/), whitespace(), clValue()], (c12) => cl_exports.some(c12[0])));
}
function clOk() {
  return parens(sequence([regex(/ok/), whitespace(), clValue()], (c12) => cl_exports.ok(c12[0])));
}
function clErr() {
  return parens(sequence([regex(/err/), whitespace(), clValue()], (c12) => cl_exports.error(c12[0])));
}
function clValue(map2 = (v8) => v8) {
  return either([
    clBuffer,
    clAscii,
    clUtf8,
    clInt,
    clUint,
    clBool,
    clPrincipal,
    clList,
    clTuple,
    clNone,
    clSome,
    clOk,
    clErr
  ].map(lazy).map(map2));
}
function parse(clarityValueString) {
  const result = clValue(entire)(clarityValueString);
  if (!result.success || !result.capture)
    throw "Parse error";
  return result.capture;
}

// node_modules/@stacks/transactions/dist/esm/utils.js
var leftPadHex = (hexString) => hexString.length % 2 ? `0${hexString}` : hexString;
var rightPadHexToLength = (hexString, length2) => hexString.padEnd(length2, "0");
var exceedsMaxLengthBytes = (string2, maxLengthBytes) => string2 ? utf8ToBytes(string2).length > maxLengthBytes : false;
function cloneDeep(obj) {
  return (0, import_lodash.default)(obj);
}
var hash160 = (input) => {
  return ripemd160(sha256(input));
};
var txidFromData = (data) => {
  return bytesToHex(sha512_256(data));
};
var hashP2PKH = (input) => {
  return bytesToHex(hash160(input));
};
var hashP2WPKH = (input) => {
  const keyHash = hash160(input);
  const redeemScript = concatBytes(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);
  const redeemScriptHash = hash160(redeemScript);
  return bytesToHex(redeemScriptHash);
};
var hashP2SH = (numSigs, pubKeys) => {
  if (numSigs > 15 || pubKeys.length > 15) {
    throw Error("P2SH multisig address can only contain up to 15 public keys");
  }
  const bytesArray = [];
  bytesArray.push(80 + numSigs);
  pubKeys.forEach((pubKey) => {
    bytesArray.push(pubKey.length);
    bytesArray.push(pubKey);
  });
  bytesArray.push(80 + pubKeys.length);
  bytesArray.push(174);
  const redeemScript = concatArray(bytesArray);
  const redeemScriptHash = hash160(redeemScript);
  return bytesToHex(redeemScriptHash);
};
var hashP2WSH = (numSigs, pubKeys) => {
  if (numSigs > 15 || pubKeys.length > 15) {
    throw Error("P2WSH multisig address can only contain up to 15 public keys");
  }
  const scriptArray = [];
  scriptArray.push(80 + numSigs);
  pubKeys.forEach((pubKey) => {
    scriptArray.push(pubKey.length);
    scriptArray.push(pubKey);
  });
  scriptArray.push(80 + pubKeys.length);
  scriptArray.push(174);
  const script = concatArray(scriptArray);
  const digest2 = sha256(script);
  const bytesArray = [];
  bytesArray.push(0);
  bytesArray.push(digest2.length);
  bytesArray.push(digest2);
  const redeemScript = concatArray(bytesArray);
  const redeemScriptHash = hash160(redeemScript);
  return bytesToHex(redeemScriptHash);
};
function isClarityName(name2) {
  const regex2 = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
  return regex2.test(name2) && name2.length < 128;
}
function parseContractId(contractId) {
  const [address2, name2] = contractId.split(".");
  if (!address2 || !name2)
    throw new Error(`Invalid contract identifier: ${contractId}`);
  return [address2, name2];
}

// node_modules/@stacks/transactions/dist/esm/keys.js
utils.hmacSha256Sync = (key, ...msgs) => {
  const h12 = hmac.create(sha256, key);
  msgs.forEach((msg) => h12.update(msg));
  return h12.digest();
};
function createStacksPublicKey(publicKey) {
  publicKey = typeof publicKey === "string" ? hexToBytes(publicKey) : publicKey;
  return {
    type: StacksWireType.PublicKey,
    data: publicKey
  };
}
function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = PubKeyEncoding.Compressed) {
  const parsedSignature = parseRecoverableSignatureVrs(messageSignature);
  const signature = new Signature(hexToBigInt(parsedSignature.r), hexToBigInt(parsedSignature.s));
  const point = Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);
  const compressed = pubKeyEncoding === PubKeyEncoding.Compressed;
  return point.toHex(compressed);
}
function privateKeyToHex(publicKey) {
  return typeof publicKey === "string" ? publicKey : bytesToHex(publicKey);
}
var publicKeyToHex = privateKeyToHex;
function privateKeyIsCompressed(privateKey) {
  const length2 = typeof privateKey === "string" ? privateKey.length / 2 : privateKey.byteLength;
  return length2 === PRIVATE_KEY_BYTES_COMPRESSED;
}
function publicKeyIsCompressed(publicKey) {
  return !publicKeyToHex(publicKey).startsWith("04");
}
function privateKeyToPublic(privateKey) {
  privateKey = privateKeyToBytes(privateKey);
  const isCompressed = privateKeyIsCompressed(privateKey);
  return bytesToHex(getPublicKey(privateKey.slice(0, 32), isCompressed));
}
function compressPublicKey(publicKey) {
  return Point.fromHex(publicKeyToHex(publicKey)).toHex(true);
}
function uncompressPublicKey(publicKey) {
  return Point.fromHex(publicKeyToHex(publicKey)).toHex(false);
}
function signWithKey(privateKey, messageHash) {
  privateKey = privateKeyToBytes(privateKey);
  const [rawSignature, recoveryId] = signSync(messageHash, privateKey.slice(0, 32), {
    canonical: true,
    recovered: true
  });
  if (recoveryId == null) {
    throw new Error("No signature recoveryId received");
  }
  const recoveryIdHex = intToHex(recoveryId, 1);
  return recoveryIdHex + Signature.fromHex(rawSignature).toCompactHex();
}
function privateKeyToAddress(privateKey, network) {
  const publicKey = privateKeyToPublic(privateKey);
  return publicKeyToAddressSingleSig(publicKey, network);
}
function publicKeyToAddressSingleSig(publicKey, network) {
  network = network ? networkFrom(network) : STACKS_MAINNET;
  publicKey = typeof publicKey === "string" ? hexToBytes(publicKey) : publicKey;
  return (0, import_c32check4.c32address)(network.addressVersion.singleSig, bytesToHex(hash160(publicKey)));
}

// node_modules/@stacks/transactions/dist/esm/authorization.js
function emptyMessageSignature() {
  return {
    type: StacksWireType.MessageSignature,
    data: bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES))
  };
}
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;
  const keyEncoding = publicKeyIsCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;
  return {
    hashMode,
    signer,
    nonce: intToBigInt(nonce),
    fee: intToBigInt(fee),
    keyEncoding,
    signature: emptyMessageSignature()
  };
}
function isSingleSig(condition) {
  return "signature" in condition;
}
function isSequentialMultiSig(hashMode) {
  return hashMode === AddressHashMode.P2SH || hashMode === AddressHashMode.P2WSH;
}
function isNonSequentialMultiSig(hashMode) {
  return hashMode === AddressHashMode.P2SHNonSequential || hashMode === AddressHashMode.P2WSHNonSequential;
}
function clearCondition(condition) {
  const cloned = cloneDeep(condition);
  cloned.nonce = 0;
  cloned.fee = 0;
  if (isSingleSig(cloned)) {
    cloned.signature = emptyMessageSignature();
  } else {
    cloned.fields = [];
  }
  return {
    ...cloned,
    nonce: BigInt(0),
    fee: BigInt(0)
  };
}
function serializeSingleSigSpendingConditionBytes(condition) {
  const bytesArray = [
    condition.hashMode,
    hexToBytes(condition.signer),
    intToBytes(condition.nonce, 8),
    intToBytes(condition.fee, 8),
    condition.keyEncoding,
    serializeMessageSignatureBytes(condition.signature)
  ];
  return concatArray(bytesArray);
}
function serializeMultiSigSpendingConditionBytes(condition) {
  const bytesArray = [
    condition.hashMode,
    hexToBytes(condition.signer),
    intToBytes(condition.nonce, 8),
    intToBytes(condition.fee, 8)
  ];
  const fields = createLPList(condition.fields);
  bytesArray.push(serializeLPListBytes(fields));
  const numSigs = new Uint8Array(2);
  writeUInt16BE(numSigs, condition.signaturesRequired, 0);
  bytesArray.push(numSigs);
  return concatArray(bytesArray);
}
function deserializeSingleSigSpendingCondition(hashMode, bytesReader) {
  const signer = bytesToHex(bytesReader.readBytes(20));
  const nonce = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
  const fee = BigInt(`0x${bytesToHex(bytesReader.readBytes(8))}`);
  const keyEncoding = bytesReader.readUInt8Enum(PubKeyEncoding, (n12) => {
    throw new DeserializationError(`Could not parse ${n12} as PubKeyEncoding`);
  });
  if (hashMode === AddressHashMode.P2WPKH && keyEncoding != PubKeyEncoding.Compressed) {
    throw new DeserializationError("Failed to parse singlesig spending condition: incomaptible hash mode and key encoding");
  }
  const signature = deserializeMessageSignature(bytesReader);
  return {
    hashMode,
    signer,
    nonce,
    fee,
    keyEncoding,
    signature
  };
}
function deserializeMultiSigSpendingCondition(hashMode, bytesReader) {
  const signer = bytesToHex(bytesReader.readBytes(20));
  const nonce = BigInt("0x" + bytesToHex(bytesReader.readBytes(8)));
  const fee = BigInt("0x" + bytesToHex(bytesReader.readBytes(8)));
  const fields = deserializeLPList(bytesReader, StacksWireType.TransactionAuthField).values;
  let haveUncompressed = false;
  let numSigs = 0;
  for (const field of fields) {
    switch (field.contents.type) {
      case StacksWireType.PublicKey:
        if (!publicKeyIsCompressed(field.contents.data))
          haveUncompressed = true;
        break;
      case StacksWireType.MessageSignature:
        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)
          haveUncompressed = true;
        numSigs += 1;
        if (numSigs === 65536)
          throw new VerificationError("Failed to parse multisig spending condition: too many signatures");
        break;
    }
  }
  const signaturesRequired = bytesReader.readUInt16BE();
  if (haveUncompressed && (hashMode === AddressHashMode.P2WSH || hashMode === AddressHashMode.P2WSHNonSequential)) {
    throw new VerificationError("Uncompressed keys are not allowed in this hash mode");
  }
  return {
    hashMode,
    signer,
    nonce,
    fee,
    fields,
    signaturesRequired
  };
}
function serializeSpendingConditionBytes(condition) {
  if (isSingleSig(condition))
    return serializeSingleSigSpendingConditionBytes(condition);
  return serializeMultiSigSpendingConditionBytes(condition);
}
function deserializeSpendingCondition(bytesReader) {
  const hashMode = bytesReader.readUInt8Enum(AddressHashMode, (n12) => {
    throw new DeserializationError(`Could not parse ${n12} as AddressHashMode`);
  });
  if (hashMode === AddressHashMode.P2PKH || hashMode === AddressHashMode.P2WPKH) {
    return deserializeSingleSigSpendingCondition(hashMode, bytesReader);
  } else {
    return deserializeMultiSigSpendingCondition(hashMode, bytesReader);
  }
}
function sigHashPreSign(curSigHash, authType, fee, nonce) {
  const hashLength = 32 + 1 + 8 + 8;
  const sigHash = curSigHash + bytesToHex(new Uint8Array([authType])) + bytesToHex(intToBytes(fee, 8)) + bytesToHex(intToBytes(nonce, 8));
  if (hexToBytes(sigHash).byteLength !== hashLength) {
    throw Error("Invalid signature hash length");
  }
  return txidFromData(hexToBytes(sigHash));
}
function sigHashPostSign(curSigHash, pubKey, signature) {
  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
  const pubKeyEncoding = publicKeyIsCompressed(pubKey.data) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;
  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature;
  const sigHashBytes = hexToBytes(sigHash);
  if (sigHashBytes.byteLength > hashLength) {
    throw Error("Invalid signature hash length");
  }
  return txidFromData(sigHashBytes);
}
function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
  const sigHashPre = sigHashPreSign(curSigHash, authType, fee, nonce);
  const signature = signWithKey(privateKey, sigHashPre);
  const publicKey = createStacksPublicKey(privateKeyToPublic(privateKey));
  const nextSigHash = sigHashPostSign(sigHashPre, publicKey, signature);
  return {
    nextSig: signature,
    nextSigHash
  };
}
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
  const sigHashPre = sigHashPreSign(initialSigHash, authType, fee, nonce);
  const publicKey = createStacksPublicKey(publicKeyFromSignatureVrs(sigHashPre, signature, pubKeyEncoding));
  const nextSigHash = sigHashPostSign(sigHashPre, publicKey, signature);
  return {
    pubKey: publicKey,
    nextSigHash
  };
}
function newInitialSigHash() {
  const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.P2PKH, "", 0, 0);
  spendingCondition.signer = createEmptyAddress().hash160;
  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;
  spendingCondition.signature = emptyMessageSignature();
  return spendingCondition;
}
function verify2(condition, initialSigHash, authType) {
  if (isSingleSig(condition)) {
    return verifySingleSig(condition, initialSigHash, authType);
  } else {
    return verifyMultiSig(condition, initialSigHash, authType);
  }
}
function verifySingleSig(condition, initialSigHash, authType) {
  const { pubKey, nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature.data);
  const addrBytes = addressFromPublicKeys(0, condition.hashMode, 1, [pubKey]).hash160;
  if (addrBytes !== condition.signer)
    throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
  return nextSigHash;
}
function verifyMultiSig(condition, initialSigHash, authType) {
  const publicKeys = [];
  let curSigHash = initialSigHash;
  let haveUncompressed = false;
  let numSigs = 0;
  for (const field of condition.fields) {
    switch (field.contents.type) {
      case StacksWireType.PublicKey:
        if (!publicKeyIsCompressed(field.contents.data))
          haveUncompressed = true;
        publicKeys.push(field.contents);
        break;
      case StacksWireType.MessageSignature:
        if (field.pubKeyEncoding === PubKeyEncoding.Uncompressed)
          haveUncompressed = true;
        const { pubKey, nextSigHash } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents.data);
        if (isSequentialMultiSig(condition.hashMode)) {
          curSigHash = nextSigHash;
        }
        publicKeys.push(pubKey);
        numSigs += 1;
        if (numSigs === 65536)
          throw new VerificationError("Too many signatures");
        break;
    }
  }
  if (isSequentialMultiSig(condition.hashMode) && numSigs !== condition.signaturesRequired || isNonSequentialMultiSig(condition.hashMode) && numSigs < condition.signaturesRequired)
    throw new VerificationError("Incorrect number of signatures");
  if (haveUncompressed && (condition.hashMode === AddressHashMode.P2WSH || condition.hashMode === AddressHashMode.P2WSHNonSequential))
    throw new VerificationError("Uncompressed keys are not allowed in this hash mode");
  const addrBytes = addressFromPublicKeys(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;
  if (addrBytes !== condition.signer)
    throw new VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
  return curSigHash;
}
function createStandardAuth(spendingCondition) {
  return {
    authType: AuthType.Standard,
    spendingCondition
  };
}
function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {
  return {
    authType: AuthType.Sponsored,
    spendingCondition,
    sponsorSpendingCondition: sponsorSpendingCondition ? sponsorSpendingCondition : createSingleSigSpendingCondition(AddressHashMode.P2PKH, "0".repeat(66), 0, 0)
  };
}
function intoInitialSighashAuth(auth) {
  if (auth.spendingCondition) {
    switch (auth.authType) {
      case AuthType.Standard:
        return createStandardAuth(clearCondition(auth.spendingCondition));
      case AuthType.Sponsored:
        return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());
      default:
        throw new SigningError("Unexpected authorization type for signing");
    }
  }
  throw new Error("Authorization missing SpendingCondition");
}
function verifyOrigin(auth, initialSigHash) {
  switch (auth.authType) {
    case AuthType.Standard:
      return verify2(auth.spendingCondition, initialSigHash, AuthType.Standard);
    case AuthType.Sponsored:
      return verify2(auth.spendingCondition, initialSigHash, AuthType.Standard);
    default:
      throw new SigningError("Invalid origin auth type");
  }
}
function setFee(auth, amount) {
  switch (auth.authType) {
    case AuthType.Standard:
      const spendingCondition = {
        ...auth.spendingCondition,
        fee: intToBigInt(amount)
      };
      return { ...auth, spendingCondition };
    case AuthType.Sponsored:
      const sponsorSpendingCondition = {
        ...auth.sponsorSpendingCondition,
        fee: intToBigInt(amount)
      };
      return { ...auth, sponsorSpendingCondition };
  }
}
function setNonce2(auth, nonce) {
  const spendingCondition = {
    ...auth.spendingCondition,
    nonce: intToBigInt(nonce)
  };
  return {
    ...auth,
    spendingCondition
  };
}
function setSponsorNonce(auth, nonce) {
  const sponsorSpendingCondition = {
    ...auth.sponsorSpendingCondition,
    nonce: intToBigInt(nonce)
  };
  return {
    ...auth,
    sponsorSpendingCondition
  };
}
function setSponsor(auth, sponsorSpendingCondition) {
  const sc2 = {
    ...sponsorSpendingCondition,
    nonce: intToBigInt(sponsorSpendingCondition.nonce),
    fee: intToBigInt(sponsorSpendingCondition.fee)
  };
  return {
    ...auth,
    sponsorSpendingCondition: sc2
  };
}
function serializeAuthorizationBytes(auth) {
  const bytesArray = [];
  bytesArray.push(auth.authType);
  switch (auth.authType) {
    case AuthType.Standard:
      bytesArray.push(serializeSpendingConditionBytes(auth.spendingCondition));
      break;
    case AuthType.Sponsored:
      bytesArray.push(serializeSpendingConditionBytes(auth.spendingCondition));
      bytesArray.push(serializeSpendingConditionBytes(auth.sponsorSpendingCondition));
      break;
  }
  return concatArray(bytesArray);
}
function deserializeAuthorization(bytesReader) {
  const authType = bytesReader.readUInt8Enum(AuthType, (n12) => {
    throw new DeserializationError(`Could not parse ${n12} as AuthType`);
  });
  let spendingCondition;
  switch (authType) {
    case AuthType.Standard:
      spendingCondition = deserializeSpendingCondition(bytesReader);
      return createStandardAuth(spendingCondition);
    case AuthType.Sponsored:
      spendingCondition = deserializeSpendingCondition(bytesReader);
      const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);
      return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);
  }
}

// node_modules/@stacks/transactions/dist/esm/transaction.js
var StacksTransactionWire = class {
  constructor({ auth, payload, postConditions = createLPList([]), postConditionMode = PostConditionMode.Deny, transactionVersion, chainId, network = "mainnet" }) {
    network = networkFrom(network);
    this.transactionVersion = transactionVersion ?? network.transactionVersion;
    this.chainId = chainId ?? network.chainId;
    this.auth = auth;
    if ("amount" in payload) {
      this.payload = {
        ...payload,
        amount: intToBigInt(payload.amount)
      };
    } else {
      this.payload = payload;
    }
    this.postConditionMode = postConditionMode;
    this.postConditions = postConditions;
    this.anchorMode = AnchorMode.Any;
  }
  signBegin() {
    const tx = cloneDeep(this);
    tx.auth = intoInitialSighashAuth(tx.auth);
    return tx.txid();
  }
  verifyBegin() {
    const tx = cloneDeep(this);
    tx.auth = intoInitialSighashAuth(tx.auth);
    return tx.txid();
  }
  verifyOrigin() {
    return verifyOrigin(this.auth, this.verifyBegin());
  }
  signNextOrigin(sigHash, privateKey) {
    if (this.auth.spendingCondition === void 0) {
      throw new Error('"auth.spendingCondition" is undefined');
    }
    if (this.auth.authType === void 0) {
      throw new Error('"auth.authType" is undefined');
    }
    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);
  }
  signNextSponsor(sigHash, privateKey) {
    if (this.auth.authType === AuthType.Sponsored) {
      return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);
    } else {
      throw new Error('"auth.sponsorSpendingCondition" is undefined');
    }
  }
  appendPubkey(publicKey) {
    const wire = typeof publicKey === "object" && "type" in publicKey ? publicKey : createStacksPublicKey(publicKey);
    const cond = this.auth.spendingCondition;
    if (cond && !isSingleSig(cond)) {
      const compressed = publicKeyIsCompressed(wire.data);
      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, wire));
    } else {
      throw new Error(`Can't append public key to a singlesig condition`);
    }
  }
  signAndAppend(condition, curSigHash, authType, privateKey) {
    const { nextSig, nextSigHash } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);
    if (isSingleSig(condition)) {
      condition.signature = createMessageSignature(nextSig);
    } else {
      const compressed = privateKeyIsCompressed(privateKey);
      condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, createMessageSignature(nextSig)));
    }
    return nextSigHash;
  }
  txid() {
    const serialized = this.serializeBytes();
    return txidFromData(serialized);
  }
  setSponsor(sponsorSpendingCondition) {
    if (this.auth.authType != AuthType.Sponsored) {
      throw new SigningError("Cannot sponsor sign a non-sponsored transaction");
    }
    this.auth = setSponsor(this.auth, sponsorSpendingCondition);
  }
  setFee(amount) {
    this.auth = setFee(this.auth, amount);
  }
  setNonce(nonce) {
    this.auth = setNonce2(this.auth, nonce);
  }
  setSponsorNonce(nonce) {
    if (this.auth.authType != AuthType.Sponsored) {
      throw new SigningError("Cannot sponsor sign a non-sponsored transaction");
    }
    this.auth = setSponsorNonce(this.auth, nonce);
  }
  serialize() {
    return bytesToHex(this.serializeBytes());
  }
  serializeBytes() {
    if (this.transactionVersion === void 0) {
      throw new SerializationError('"transactionVersion" is undefined');
    }
    if (this.chainId === void 0) {
      throw new SerializationError('"chainId" is undefined');
    }
    if (this.auth === void 0) {
      throw new SerializationError('"auth" is undefined');
    }
    if (this.payload === void 0) {
      throw new SerializationError('"payload" is undefined');
    }
    const bytesArray = [];
    bytesArray.push(this.transactionVersion);
    const chainIdBytes = new Uint8Array(4);
    writeUInt32BE(chainIdBytes, this.chainId, 0);
    bytesArray.push(chainIdBytes);
    bytesArray.push(serializeAuthorizationBytes(this.auth));
    bytesArray.push(this.anchorMode);
    bytesArray.push(this.postConditionMode);
    bytesArray.push(serializeLPListBytes(this.postConditions));
    bytesArray.push(serializePayloadBytes(this.payload));
    return concatArray(bytesArray);
  }
};
function deserializeTransaction(tx) {
  const bytesReader = isInstance(tx, BytesReader) ? tx : new BytesReader(tx);
  const transactionVersion = bytesReader.readUInt8Enum(TransactionVersion, (n12) => {
    throw new Error(`Could not parse ${n12} as TransactionVersion`);
  });
  const chainId = bytesReader.readUInt32BE();
  const auth = deserializeAuthorization(bytesReader);
  const anchorMode = bytesReader.readUInt8Enum(AnchorMode, (n12) => {
    throw new Error(`Could not parse ${n12} as AnchorMode`);
  });
  const postConditionMode = bytesReader.readUInt8Enum(PostConditionMode, (n12) => {
    throw new Error(`Could not parse ${n12} as PostConditionMode`);
  });
  const postConditions = deserializeLPList(bytesReader, StacksWireType.PostCondition);
  const payload = deserializePayload(bytesReader);
  const transaction = new StacksTransactionWire({
    transactionVersion,
    chainId,
    auth,
    payload,
    postConditions,
    postConditionMode
  });
  transaction.anchorMode = anchorMode;
  return transaction;
}

// node_modules/@stacks/transactions/dist/esm/postcondition.js
var PostConditionCodeWireType;
(function(PostConditionCodeWireType2) {
  PostConditionCodeWireType2[PostConditionCodeWireType2["eq"] = 1] = "eq";
  PostConditionCodeWireType2[PostConditionCodeWireType2["gt"] = 2] = "gt";
  PostConditionCodeWireType2[PostConditionCodeWireType2["lt"] = 4] = "lt";
  PostConditionCodeWireType2[PostConditionCodeWireType2["gte"] = 3] = "gte";
  PostConditionCodeWireType2[PostConditionCodeWireType2["lte"] = 5] = "lte";
  PostConditionCodeWireType2[PostConditionCodeWireType2["sent"] = 16] = "sent";
  PostConditionCodeWireType2[PostConditionCodeWireType2["not-sent"] = 17] = "not-sent";
})(PostConditionCodeWireType || (PostConditionCodeWireType = {}));
function postConditionToWire(postcondition) {
  switch (postcondition.type) {
    case "stx-postcondition":
      return {
        type: StacksWireType.PostCondition,
        conditionType: PostConditionType.STX,
        principal: postcondition.address === "origin" ? { type: StacksWireType.Principal, prefix: PostConditionPrincipalId.Origin } : parsePrincipalString(postcondition.address),
        conditionCode: conditionTypeToByte(postcondition.condition),
        amount: BigInt(postcondition.amount)
      };
    case "ft-postcondition":
      return {
        type: StacksWireType.PostCondition,
        conditionType: PostConditionType.Fungible,
        principal: postcondition.address === "origin" ? { type: StacksWireType.Principal, prefix: PostConditionPrincipalId.Origin } : parsePrincipalString(postcondition.address),
        conditionCode: conditionTypeToByte(postcondition.condition),
        amount: BigInt(postcondition.amount),
        asset: parseAssetString(postcondition.asset)
      };
    case "nft-postcondition":
      return {
        type: StacksWireType.PostCondition,
        conditionType: PostConditionType.NonFungible,
        principal: postcondition.address === "origin" ? { type: StacksWireType.Principal, prefix: PostConditionPrincipalId.Origin } : parsePrincipalString(postcondition.address),
        conditionCode: conditionTypeToByte(postcondition.condition),
        asset: parseAssetString(postcondition.asset),
        assetName: postcondition.assetId
      };
    default:
      throw new Error("Invalid post condition type");
  }
}
function conditionTypeToByte(condition) {
  return PostConditionCodeWireType[condition];
}
function postConditionToHex(postcondition) {
  const wire = postConditionToWire(postcondition);
  return serializePostConditionWire(wire);
}

// node_modules/@stacks/transactions/dist/esm/namespaces/address.js
var address_exports = {};
__export(address_exports, {
  fromPrivateKey: () => fromPrivateKey,
  fromPublicKey: () => fromPublicKey,
  parse: () => parse2,
  stringify: () => stringify
});
var import_c32check5 = __toESM(require_lib());
var C32 = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function parse2(address2) {
  const [addr, contractName] = address2.split(".");
  const parsed = (0, import_c32check5.c32addressDecode)(addr);
  return {
    version: parsed[0],
    versionChar: C32[parsed[0]],
    hash160: parsed[1],
    contractName
  };
}
function stringify(address2) {
  const version4 = "version" in address2 ? address2.version : C32.indexOf(address2.versionChar.toUpperCase());
  const addr = (0, import_c32check5.c32address)(version4, address2.hash160);
  if (address2.contractName)
    return `${addr}.${address2.contractName}`;
  return addr;
}
var fromPrivateKey = privateKeyToAddress;
var fromPublicKey = publicKeyToAddressSingleSig;

// node_modules/@stacks/transactions/dist/esm/cl.js
var cl_exports = {};
__export(cl_exports, {
  address: () => address,
  bool: () => bool2,
  buffer: () => buffer,
  bufferFromAscii: () => bufferFromAscii,
  bufferFromHex: () => bufferFromHex,
  bufferFromUtf8: () => bufferFromUtf8,
  contractPrincipal: () => contractPrincipal,
  deserialize: () => deserialize,
  error: () => error,
  int: () => int,
  list: () => list,
  none: () => none,
  ok: () => ok2,
  parse: () => parse,
  prettyPrint: () => prettyPrint,
  principal: () => principal,
  serialize: () => serialize,
  some: () => some,
  standardPrincipal: () => standardPrincipal,
  stringAscii: () => stringAscii,
  stringUtf8: () => stringUtf8,
  stringify: () => stringify2,
  tuple: () => tuple,
  uint: () => uint
});

// node_modules/@stacks/transactions/dist/esm/clarity/prettyPrint.js
function escape(value) {
  return JSON.stringify(value).slice(1, -1);
}
function formatSpace(space, depth, end = false) {
  if (!space)
    return " ";
  return `
${" ".repeat(space * (depth - (end ? 1 : 0)))}`;
}
function formatList(cv, space, depth = 1) {
  if (cv.value.length === 0)
    return "(list)";
  const spaceBefore = formatSpace(space, depth, false);
  const endSpace = space ? formatSpace(space, depth, true) : "";
  const items = cv.value.map((v8) => prettyPrintWithDepth(v8, space, depth)).join(spaceBefore);
  return `(list${spaceBefore}${items}${endSpace})`;
}
function formatTuple(cv, space, depth = 1) {
  if (Object.keys(cv.value).length === 0)
    return "{}";
  const items = [];
  for (const [key, value] of Object.entries(cv.value)) {
    items.push(`${key}: ${prettyPrintWithDepth(value, space, depth)}`);
  }
  const spaceBefore = formatSpace(space, depth, false);
  const endSpace = formatSpace(space, depth, true);
  return `{${spaceBefore}${items.sort().join(`,${spaceBefore}`)}${endSpace}}`;
}
function exhaustiveCheck(param) {
  throw new Error(`invalid clarity value type: ${param}`);
}
function prettyPrintWithDepth(cv, space = 0, depth) {
  if (cv.type === ClarityType.BoolFalse)
    return "false";
  if (cv.type === ClarityType.BoolTrue)
    return "true";
  if (cv.type === ClarityType.Int)
    return cv.value.toString();
  if (cv.type === ClarityType.UInt)
    return `u${cv.value.toString()}`;
  if (cv.type === ClarityType.StringASCII)
    return `"${escape(cv.value)}"`;
  if (cv.type === ClarityType.StringUTF8)
    return `u"${escape(cv.value)}"`;
  if (cv.type === ClarityType.PrincipalContract)
    return `'${cv.value}`;
  if (cv.type === ClarityType.PrincipalStandard)
    return `'${cv.value}`;
  if (cv.type === ClarityType.Buffer)
    return `0x${cv.value}`;
  if (cv.type === ClarityType.OptionalNone)
    return "none";
  if (cv.type === ClarityType.OptionalSome)
    return `(some ${prettyPrintWithDepth(cv.value, space, depth)})`;
  if (cv.type === ClarityType.ResponseOk)
    return `(ok ${prettyPrintWithDepth(cv.value, space, depth)})`;
  if (cv.type === ClarityType.ResponseErr)
    return `(err ${prettyPrintWithDepth(cv.value, space, depth)})`;
  if (cv.type === ClarityType.List) {
    return formatList(cv, space, depth + 1);
  }
  if (cv.type === ClarityType.Tuple) {
    return formatTuple(cv, space, depth + 1);
  }
  exhaustiveCheck(cv);
}
function stringify2(cv, space = 0) {
  return prettyPrintWithDepth(cv, space, 0);
}
var prettyPrint = stringify2;

// node_modules/@stacks/transactions/dist/esm/cl.js
var bool2 = boolCV;
var int = intCV;
var uint = uintCV;
function principal(address2) {
  const [addr, name2] = address2.split(".");
  return name2 ? contractPrincipalCV(addr, name2) : standardPrincipalCV(addr);
}
var address = principal;
var contractPrincipal = contractPrincipalCV;
var standardPrincipal = standardPrincipalCV;
var list = listCV;
var stringAscii = stringAsciiCV;
var stringUtf8 = stringUtf8CV;
var buffer = bufferCV;
var bufferFromHex = (hex) => bufferCV(hexToBytes(hex));
var bufferFromAscii = (ascii2) => bufferCV(asciiToBytes(ascii2));
var bufferFromUtf8 = (utf8) => bufferCV(utf8ToBytes(utf8));
var none = noneCV;
var some = someCV;
var ok2 = responseOkCV;
var error = responseErrorCV;
var tuple = tupleCV;
var serialize = serializeCV;
var deserialize = deserializeCV;

// node_modules/@stacks/network-v6/dist/esm/fetch.js
var import_polyfill = __toESM(require_browser_polyfill());
var defaultFetchOpts = {
  referrerPolicy: "origin",
  headers: {
    "x-hiro-product": "stacksjs"
  }
};
async function fetchWrapper(input, init) {
  const fetchOpts = {};
  Object.assign(fetchOpts, defaultFetchOpts, init);
  const fetchResult = await fetch(input, fetchOpts);
  return fetchResult;
}
function argsForCreateFetchFn(args) {
  let fetchLib = fetchWrapper;
  let middlewares = [];
  if (args.length > 0 && typeof args[0] === "function") {
    fetchLib = args.shift();
  }
  if (args.length > 0) {
    middlewares = args;
  }
  return { fetchLib, middlewares };
}
function createFetchFn2(...args) {
  const { fetchLib, middlewares } = argsForCreateFetchFn(args);
  const fetchFn = async (url, init) => {
    let fetchParams = { url, init: init ?? {} };
    for (const middleware of middlewares) {
      if (typeof middleware.pre === "function") {
        const result = await Promise.resolve(middleware.pre({
          fetch: fetchLib,
          ...fetchParams
        }));
        fetchParams = result ?? fetchParams;
      }
    }
    let response = await fetchLib(fetchParams.url, fetchParams.init);
    for (const middleware of middlewares) {
      if (typeof middleware.post === "function") {
        const result = await Promise.resolve(middleware.post({
          fetch: fetchLib,
          url: fetchParams.url,
          init: fetchParams.init,
          response: response?.clone() ?? response
        }));
        response = result ?? response;
      }
    }
    return response;
  };
  return fetchFn;
}

// node_modules/@stacks/network-v6/node_modules/@stacks/common/dist/esm/constants.js
var ChainID;
(function(ChainID3) {
  ChainID3[ChainID3["Testnet"] = 2147483648] = "Testnet";
  ChainID3[ChainID3["Mainnet"] = 1] = "Mainnet";
})(ChainID || (ChainID = {}));
var TransactionVersion2;
(function(TransactionVersion4) {
  TransactionVersion4[TransactionVersion4["Mainnet"] = 0] = "Mainnet";
  TransactionVersion4[TransactionVersion4["Testnet"] = 128] = "Testnet";
})(TransactionVersion2 || (TransactionVersion2 = {}));
var PeerNetworkID;
(function(PeerNetworkID2) {
  PeerNetworkID2[PeerNetworkID2["Mainnet"] = 385875968] = "Mainnet";
  PeerNetworkID2[PeerNetworkID2["Testnet"] = 4278190080] = "Testnet";
})(PeerNetworkID || (PeerNetworkID = {}));

// node_modules/@stacks/network-v6/dist/esm/network.js
var HIRO_MAINNET_DEFAULT = "https://api.mainnet.hiro.so";
var HIRO_TESTNET_DEFAULT = "https://api.testnet.hiro.so";
var HIRO_MOCKNET_DEFAULT = "http://localhost:3999";
var StacksNetworks = ["mainnet", "testnet", "devnet", "mocknet"];
var StacksNetwork = class {
  constructor(networkConfig) {
    this.version = TransactionVersion2.Mainnet;
    this.chainId = ChainID.Mainnet;
    this.bnsLookupUrl = "https://api.mainnet.hiro.so";
    this.broadcastEndpoint = "/v2/transactions";
    this.transferFeeEstimateEndpoint = "/v2/fees/transfer";
    this.transactionFeeEstimateEndpoint = "/v2/fees/transaction";
    this.accountEndpoint = "/v2/accounts";
    this.contractAbiEndpoint = "/v2/contracts/interface";
    this.readOnlyFunctionCallEndpoint = "/v2/contracts/call-read";
    this.isMainnet = () => this.version === TransactionVersion2.Mainnet;
    this.getBroadcastApiUrl = () => `${this.coreApiUrl}${this.broadcastEndpoint}`;
    this.getTransferFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`;
    this.getTransactionFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`;
    this.getAccountApiUrl = (address2) => `${this.coreApiUrl}${this.accountEndpoint}/${address2}?proof=0`;
    this.getAccountExtendedBalancesApiUrl = (address2) => `${this.coreApiUrl}/extended/v1/address/${address2}/balances`;
    this.getAbiApiUrl = (address2, contract) => `${this.coreApiUrl}${this.contractAbiEndpoint}/${address2}/${contract}`;
    this.getReadOnlyFunctionCallApiUrl = (contractAddress, contractName, functionName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${contractAddress}/${contractName}/${encodeURIComponent(functionName)}`;
    this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`;
    this.getBlockTimeInfoUrl = () => `${this.coreApiUrl}/extended/v1/info/network_block_times`;
    this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`;
    this.getRewardsUrl = (address2, options) => {
      let url = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address2}`;
      if (options) {
        url = `${url}?limit=${options.limit}&offset=${options.offset}`;
      }
      return url;
    };
    this.getRewardsTotalUrl = (address2) => `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address2}/total`;
    this.getRewardHoldersUrl = (address2, options) => {
      let url = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${address2}`;
      if (options) {
        url = `${url}?limit=${options.limit}&offset=${options.offset}`;
      }
      return url;
    };
    this.getStackerInfoUrl = (contractAddress, contractName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}
    ${contractAddress}/${contractName}/get-stacker-info`;
    this.getDataVarUrl = (contractAddress, contractName, dataVarName) => `${this.coreApiUrl}/v2/data_var/${contractAddress}/${contractName}/${dataVarName}?proof=0`;
    this.getMapEntryUrl = (contractAddress, contractName, mapName) => `${this.coreApiUrl}/v2/map_entry/${contractAddress}/${contractName}/${mapName}?proof=0`;
    this.coreApiUrl = networkConfig.url;
    this.fetchFn = networkConfig.fetchFn ?? createFetchFn2();
  }
  getNameInfo(fullyQualifiedName) {
    const nameLookupURL = `${this.bnsLookupUrl}/v1/names/${fullyQualifiedName}`;
    return this.fetchFn(nameLookupURL).then((resp) => {
      if (resp.status === 404) {
        throw new Error("Name not found");
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then((nameInfo) => {
      if (nameInfo.address) {
        return Object.assign({}, nameInfo, { address: nameInfo.address });
      } else {
        return nameInfo;
      }
    });
  }
};
StacksNetwork.fromName = (networkName) => {
  switch (networkName) {
    case "mainnet":
      return new StacksMainnet();
    case "testnet":
      return new StacksTestnet();
    case "devnet":
      return new StacksDevnet();
    case "mocknet":
      return new StacksMocknet();
    default:
      throw new Error(`Invalid network name provided. Must be one of the following: ${StacksNetworks.join(", ")}`);
  }
};
StacksNetwork.fromNameOrNetwork = (network) => {
  if (typeof network !== "string" && "version" in network) {
    return network;
  }
  return StacksNetwork.fromName(network);
};
var StacksMainnet = class extends StacksNetwork {
  constructor(opts) {
    super({
      url: opts?.url ?? HIRO_MAINNET_DEFAULT,
      fetchFn: opts?.fetchFn
    });
    this.version = TransactionVersion2.Mainnet;
    this.chainId = ChainID.Mainnet;
  }
};
var StacksTestnet = class extends StacksNetwork {
  constructor(opts) {
    super({
      url: opts?.url ?? HIRO_TESTNET_DEFAULT,
      fetchFn: opts?.fetchFn
    });
    this.version = TransactionVersion2.Testnet;
    this.chainId = ChainID.Testnet;
  }
};
var StacksMocknet = class extends StacksNetwork {
  constructor(opts) {
    super({
      url: opts?.url ?? HIRO_MOCKNET_DEFAULT,
      fetchFn: opts?.fetchFn
    });
    this.version = TransactionVersion2.Testnet;
    this.chainId = ChainID.Testnet;
  }
};
var StacksDevnet = StacksMocknet;

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/utils.js
function intToBytes2(value, signed, byteLength) {
  return bigIntToBytes2(intToBigInt2(value, signed), byteLength);
}
function intToBigInt2(value, signed) {
  let parsedValue = value;
  if (typeof parsedValue === "number") {
    if (!Number.isInteger(parsedValue)) {
      throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
    }
    if (parsedValue > Number.MAX_SAFE_INTEGER) {
      throw new RangeError(`Invalid value. Values of type 'number' must be less than or equal to ${Number.MAX_SAFE_INTEGER}. For larger values, try using a BigInt instead.`);
    }
    return BigInt(parsedValue);
  }
  if (typeof parsedValue === "string") {
    if (parsedValue.toLowerCase().startsWith("0x")) {
      let hex = parsedValue.slice(2);
      hex = hex.padStart(hex.length + hex.length % 2, "0");
      parsedValue = hexToBytes3(hex);
    } else {
      try {
        return BigInt(parsedValue);
      } catch (error2) {
        if (error2 instanceof SyntaxError) {
          throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);
        }
      }
    }
  }
  if (typeof parsedValue === "bigint") {
    return parsedValue;
  }
  if (parsedValue instanceof Uint8Array) {
    if (signed) {
      const bn4 = fromTwos2(BigInt(`0x${bytesToHex3(parsedValue)}`), BigInt(parsedValue.byteLength * 8));
      return BigInt(bn4.toString());
    } else {
      return BigInt(`0x${bytesToHex3(parsedValue)}`);
    }
  }
  if (parsedValue != null && typeof parsedValue === "object" && parsedValue.constructor.name === "BN") {
    return BigInt(parsedValue.toString());
  }
  throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);
}
function intToHex2(integer, lengthBytes = 8) {
  const value = typeof integer === "bigint" ? integer : intToBigInt2(integer, false);
  return value.toString(16).padStart(lengthBytes * 2, "0");
}
function bigIntToBytes2(value, length2 = 16) {
  const hex = intToHex2(value, length2);
  return hexToBytes3(hex);
}
function toTwos2(value, width) {
  if (value < -(BigInt(1) << width - BigInt(1)) || (BigInt(1) << width - BigInt(1)) - BigInt(1) < value) {
    throw `Unable to represent integer in width: ${width}`;
  }
  if (value >= BigInt(0)) {
    return BigInt(value);
  }
  return value + (BigInt(1) << width);
}
function nthBit2(value, n12) {
  return value & BigInt(1) << n12;
}
function fromTwos2(value, width) {
  if (nthBit2(value, width - BigInt(1))) {
    return value - (BigInt(1) << width);
  }
  return value;
}
var hexes4 = Array.from({ length: 256 }, (_5, i11) => i11.toString(16).padStart(2, "0"));
function bytesToHex3(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (const u6 of uint8a) {
    hex += hexes4[u6];
  }
  return hex;
}
function hexToBytes3(hex) {
  if (typeof hex !== "string") {
    throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
  }
  hex = hex.startsWith("0x") || hex.startsWith("0X") ? hex.slice(2) : hex;
  const paddedHex = hex.length % 2 ? `0${hex}` : hex;
  const array = new Uint8Array(paddedHex.length / 2);
  for (let i11 = 0; i11 < array.length; i11++) {
    const j7 = i11 * 2;
    const hexByte = paddedHex.slice(j7, j7 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i11] = byte;
  }
  return array;
}
function utf8ToBytes3(str) {
  return new TextEncoder().encode(str);
}
function asciiToBytes2(str) {
  const byteArray = [];
  for (let i11 = 0; i11 < str.length; i11++) {
    byteArray.push(str.charCodeAt(i11) & 255);
  }
  return new Uint8Array(byteArray);
}
function isNotOctet2(octet) {
  return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes2(numbers) {
  if (numbers.some(isNotOctet2))
    throw new Error("Some values are invalid bytes.");
  return new Uint8Array(numbers);
}
function concatBytes3(...arrays) {
  if (!arrays.every((a5) => a5 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length2 = arrays.reduce((a5, arr) => a5 + arr.length, 0);
  const result = new Uint8Array(length2);
  for (let i11 = 0, pad3 = 0; i11 < arrays.length; i11++) {
    const arr = arrays[i11];
    result.set(arr, pad3);
    pad3 += arr.length;
  }
  return result;
}
function concatArray2(elements) {
  return concatBytes3(...elements.map((e10) => {
    if (typeof e10 === "number")
      return octetsToBytes2([e10]);
    if (e10 instanceof Array)
      return octetsToBytes2(e10);
    return e10;
  }));
}

// node_modules/@stacks/transactions-v6/node_modules/@stacks/common/dist/esm/buffer.js
function writeUInt32BE2(destination, value, offset = 0) {
  destination[offset + 3] = value;
  value >>>= 8;
  destination[offset + 2] = value;
  value >>>= 8;
  destination[offset + 1] = value;
  value >>>= 8;
  destination[offset] = value;
  return destination;
}

// node_modules/@stacks/transactions-v6/dist/esm/constants.js
var ChainID2;
(function(ChainID3) {
  ChainID3[ChainID3["Testnet"] = 2147483648] = "Testnet";
  ChainID3[ChainID3["Mainnet"] = 1] = "Mainnet";
})(ChainID2 || (ChainID2 = {}));
var DEFAULT_CHAIN_ID2 = ChainID2.Mainnet;
var MAX_STRING_LENGTH_BYTES2 = 128;
var CLARITY_INT_SIZE2 = 128;
var CLARITY_INT_BYTE_SIZE2 = 16;
var StacksMessageType;
(function(StacksMessageType2) {
  StacksMessageType2[StacksMessageType2["Address"] = 0] = "Address";
  StacksMessageType2[StacksMessageType2["Principal"] = 1] = "Principal";
  StacksMessageType2[StacksMessageType2["LengthPrefixedString"] = 2] = "LengthPrefixedString";
  StacksMessageType2[StacksMessageType2["MemoString"] = 3] = "MemoString";
  StacksMessageType2[StacksMessageType2["AssetInfo"] = 4] = "AssetInfo";
  StacksMessageType2[StacksMessageType2["PostCondition"] = 5] = "PostCondition";
  StacksMessageType2[StacksMessageType2["PublicKey"] = 6] = "PublicKey";
  StacksMessageType2[StacksMessageType2["LengthPrefixedList"] = 7] = "LengthPrefixedList";
  StacksMessageType2[StacksMessageType2["Payload"] = 8] = "Payload";
  StacksMessageType2[StacksMessageType2["MessageSignature"] = 9] = "MessageSignature";
  StacksMessageType2[StacksMessageType2["StructuredDataSignature"] = 10] = "StructuredDataSignature";
  StacksMessageType2[StacksMessageType2["TransactionAuthField"] = 11] = "TransactionAuthField";
})(StacksMessageType || (StacksMessageType = {}));
var PayloadType2;
(function(PayloadType3) {
  PayloadType3[PayloadType3["TokenTransfer"] = 0] = "TokenTransfer";
  PayloadType3[PayloadType3["SmartContract"] = 1] = "SmartContract";
  PayloadType3[PayloadType3["VersionedSmartContract"] = 6] = "VersionedSmartContract";
  PayloadType3[PayloadType3["ContractCall"] = 2] = "ContractCall";
  PayloadType3[PayloadType3["PoisonMicroblock"] = 3] = "PoisonMicroblock";
  PayloadType3[PayloadType3["Coinbase"] = 4] = "Coinbase";
  PayloadType3[PayloadType3["CoinbaseToAltRecipient"] = 5] = "CoinbaseToAltRecipient";
  PayloadType3[PayloadType3["TenureChange"] = 7] = "TenureChange";
  PayloadType3[PayloadType3["NakamotoCoinbase"] = 8] = "NakamotoCoinbase";
})(PayloadType2 || (PayloadType2 = {}));
var ClarityVersion2;
(function(ClarityVersion3) {
  ClarityVersion3[ClarityVersion3["Clarity1"] = 1] = "Clarity1";
  ClarityVersion3[ClarityVersion3["Clarity2"] = 2] = "Clarity2";
  ClarityVersion3[ClarityVersion3["Clarity3"] = 3] = "Clarity3";
})(ClarityVersion2 || (ClarityVersion2 = {}));
var AnchorMode2;
(function(AnchorMode3) {
  AnchorMode3[AnchorMode3["OnChainOnly"] = 1] = "OnChainOnly";
  AnchorMode3[AnchorMode3["OffChainOnly"] = 2] = "OffChainOnly";
  AnchorMode3[AnchorMode3["Any"] = 3] = "Any";
})(AnchorMode2 || (AnchorMode2 = {}));
var AnchorModeNames2 = ["onChainOnly", "offChainOnly", "any"];
var AnchorModeMap2 = {
  [AnchorModeNames2[0]]: AnchorMode2.OnChainOnly,
  [AnchorModeNames2[1]]: AnchorMode2.OffChainOnly,
  [AnchorModeNames2[2]]: AnchorMode2.Any,
  [AnchorMode2.OnChainOnly]: AnchorMode2.OnChainOnly,
  [AnchorMode2.OffChainOnly]: AnchorMode2.OffChainOnly,
  [AnchorMode2.Any]: AnchorMode2.Any
};
var TransactionVersion3;
(function(TransactionVersion4) {
  TransactionVersion4[TransactionVersion4["Mainnet"] = 0] = "Mainnet";
  TransactionVersion4[TransactionVersion4["Testnet"] = 128] = "Testnet";
})(TransactionVersion3 || (TransactionVersion3 = {}));
var DEFAULT_TRANSACTION_VERSION2 = TransactionVersion3.Mainnet;
var PostConditionMode2;
(function(PostConditionMode3) {
  PostConditionMode3[PostConditionMode3["Allow"] = 1] = "Allow";
  PostConditionMode3[PostConditionMode3["Deny"] = 2] = "Deny";
})(PostConditionMode2 || (PostConditionMode2 = {}));
var PostConditionType2;
(function(PostConditionType3) {
  PostConditionType3[PostConditionType3["STX"] = 0] = "STX";
  PostConditionType3[PostConditionType3["Fungible"] = 1] = "Fungible";
  PostConditionType3[PostConditionType3["NonFungible"] = 2] = "NonFungible";
})(PostConditionType2 || (PostConditionType2 = {}));
var AuthType2;
(function(AuthType3) {
  AuthType3[AuthType3["Standard"] = 4] = "Standard";
  AuthType3[AuthType3["Sponsored"] = 5] = "Sponsored";
})(AuthType2 || (AuthType2 = {}));
var AddressHashMode2;
(function(AddressHashMode3) {
  AddressHashMode3[AddressHashMode3["SerializeP2PKH"] = 0] = "SerializeP2PKH";
  AddressHashMode3[AddressHashMode3["SerializeP2SH"] = 1] = "SerializeP2SH";
  AddressHashMode3[AddressHashMode3["SerializeP2WPKH"] = 2] = "SerializeP2WPKH";
  AddressHashMode3[AddressHashMode3["SerializeP2WSH"] = 3] = "SerializeP2WSH";
  AddressHashMode3[AddressHashMode3["SerializeP2SHNonSequential"] = 5] = "SerializeP2SHNonSequential";
  AddressHashMode3[AddressHashMode3["SerializeP2WSHNonSequential"] = 7] = "SerializeP2WSHNonSequential";
})(AddressHashMode2 || (AddressHashMode2 = {}));
var AddressVersion2;
(function(AddressVersion3) {
  AddressVersion3[AddressVersion3["MainnetSingleSig"] = 22] = "MainnetSingleSig";
  AddressVersion3[AddressVersion3["MainnetMultiSig"] = 20] = "MainnetMultiSig";
  AddressVersion3[AddressVersion3["TestnetSingleSig"] = 26] = "TestnetSingleSig";
  AddressVersion3[AddressVersion3["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion2 || (AddressVersion2 = {}));
var PubKeyEncoding2;
(function(PubKeyEncoding3) {
  PubKeyEncoding3[PubKeyEncoding3["Compressed"] = 0] = "Compressed";
  PubKeyEncoding3[PubKeyEncoding3["Uncompressed"] = 1] = "Uncompressed";
})(PubKeyEncoding2 || (PubKeyEncoding2 = {}));
var FungibleConditionCode2;
(function(FungibleConditionCode3) {
  FungibleConditionCode3[FungibleConditionCode3["Equal"] = 1] = "Equal";
  FungibleConditionCode3[FungibleConditionCode3["Greater"] = 2] = "Greater";
  FungibleConditionCode3[FungibleConditionCode3["GreaterEqual"] = 3] = "GreaterEqual";
  FungibleConditionCode3[FungibleConditionCode3["Less"] = 4] = "Less";
  FungibleConditionCode3[FungibleConditionCode3["LessEqual"] = 5] = "LessEqual";
})(FungibleConditionCode2 || (FungibleConditionCode2 = {}));
var NonFungibleConditionCode2;
(function(NonFungibleConditionCode3) {
  NonFungibleConditionCode3[NonFungibleConditionCode3["Sends"] = 16] = "Sends";
  NonFungibleConditionCode3[NonFungibleConditionCode3["DoesNotSend"] = 17] = "DoesNotSend";
})(NonFungibleConditionCode2 || (NonFungibleConditionCode2 = {}));
var PostConditionPrincipalID;
(function(PostConditionPrincipalID2) {
  PostConditionPrincipalID2[PostConditionPrincipalID2["Origin"] = 1] = "Origin";
  PostConditionPrincipalID2[PostConditionPrincipalID2["Standard"] = 2] = "Standard";
  PostConditionPrincipalID2[PostConditionPrincipalID2["Contract"] = 3] = "Contract";
})(PostConditionPrincipalID || (PostConditionPrincipalID = {}));
var AssetType2;
(function(AssetType3) {
  AssetType3[AssetType3["STX"] = 0] = "STX";
  AssetType3[AssetType3["Fungible"] = 1] = "Fungible";
  AssetType3[AssetType3["NonFungible"] = 2] = "NonFungible";
})(AssetType2 || (AssetType2 = {}));
var TxRejectedReason2;
(function(TxRejectedReason3) {
  TxRejectedReason3["Serialization"] = "Serialization";
  TxRejectedReason3["Deserialization"] = "Deserialization";
  TxRejectedReason3["SignatureValidation"] = "SignatureValidation";
  TxRejectedReason3["FeeTooLow"] = "FeeTooLow";
  TxRejectedReason3["BadNonce"] = "BadNonce";
  TxRejectedReason3["NotEnoughFunds"] = "NotEnoughFunds";
  TxRejectedReason3["NoSuchContract"] = "NoSuchContract";
  TxRejectedReason3["NoSuchPublicFunction"] = "NoSuchPublicFunction";
  TxRejectedReason3["BadFunctionArgument"] = "BadFunctionArgument";
  TxRejectedReason3["ContractAlreadyExists"] = "ContractAlreadyExists";
  TxRejectedReason3["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
  TxRejectedReason3["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
  TxRejectedReason3["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
  TxRejectedReason3["BadAddressVersionByte"] = "BadAddressVersionByte";
  TxRejectedReason3["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
  TxRejectedReason3["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
  TxRejectedReason3["TooMuchChaining"] = "TooMuchChaining";
  TxRejectedReason3["ConflictingNonceInMempool"] = "ConflictingNonceInMempool";
  TxRejectedReason3["BadTransactionVersion"] = "BadTransactionVersion";
  TxRejectedReason3["TransferRecipientCannotEqualSender"] = "TransferRecipientCannotEqualSender";
  TxRejectedReason3["TransferAmountMustBePositive"] = "TransferAmountMustBePositive";
  TxRejectedReason3["ServerFailureDatabase"] = "ServerFailureDatabase";
  TxRejectedReason3["EstimatorError"] = "EstimatorError";
  TxRejectedReason3["TemporarilyBlacklisted"] = "TemporarilyBlacklisted";
  TxRejectedReason3["ServerFailureOther"] = "ServerFailureOther";
})(TxRejectedReason2 || (TxRejectedReason2 = {}));

// node_modules/@stacks/transactions-v6/dist/esm/utils.js
var import_c32check7 = __toESM(require_lib());
var import_lodash2 = __toESM(require_lodash());

// node_modules/@stacks/transactions-v6/dist/esm/postcondition-types.js
var import_c32check6 = __toESM(require_lib());
function createLPString2(content, lengthPrefixBytes, maxLengthBytes) {
  const prefixLength = lengthPrefixBytes || 1;
  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES2;
  if (exceedsMaxLengthBytes2(content, maxLength)) {
    throw new Error(`String length exceeds maximum bytes ${maxLength}`);
  }
  return {
    type: StacksMessageType.LengthPrefixedString,
    content,
    lengthPrefixBytes: prefixLength,
    maxLengthBytes: maxLength
  };
}

// node_modules/@stacks/transactions-v6/dist/esm/clarity/constants.js
var ClarityType2;
(function(ClarityType3) {
  ClarityType3[ClarityType3["Int"] = 0] = "Int";
  ClarityType3[ClarityType3["UInt"] = 1] = "UInt";
  ClarityType3[ClarityType3["Buffer"] = 2] = "Buffer";
  ClarityType3[ClarityType3["BoolTrue"] = 3] = "BoolTrue";
  ClarityType3[ClarityType3["BoolFalse"] = 4] = "BoolFalse";
  ClarityType3[ClarityType3["PrincipalStandard"] = 5] = "PrincipalStandard";
  ClarityType3[ClarityType3["PrincipalContract"] = 6] = "PrincipalContract";
  ClarityType3[ClarityType3["ResponseOk"] = 7] = "ResponseOk";
  ClarityType3[ClarityType3["ResponseErr"] = 8] = "ResponseErr";
  ClarityType3[ClarityType3["OptionalNone"] = 9] = "OptionalNone";
  ClarityType3[ClarityType3["OptionalSome"] = 10] = "OptionalSome";
  ClarityType3[ClarityType3["List"] = 11] = "List";
  ClarityType3[ClarityType3["Tuple"] = 12] = "Tuple";
  ClarityType3[ClarityType3["StringASCII"] = 13] = "StringASCII";
  ClarityType3[ClarityType3["StringUTF8"] = 14] = "StringUTF8";
})(ClarityType2 || (ClarityType2 = {}));

// node_modules/@stacks/transactions-v6/dist/esm/errors.js
var TransactionError2 = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var SerializationError2 = class extends TransactionError2 {
  constructor(message) {
    super(message);
  }
};

// node_modules/@stacks/transactions-v6/dist/esm/types.js
function serializeAddress(address2) {
  const bytesArray = [];
  bytesArray.push(hexToBytes3(intToHex2(address2.version, 1)));
  bytesArray.push(hexToBytes3(address2.hash160));
  return concatArray2(bytesArray);
}
function serializePrincipal(principal2) {
  const bytesArray = [];
  bytesArray.push(principal2.prefix);
  bytesArray.push(serializeAddress(principal2.address));
  if (principal2.prefix === PostConditionPrincipalID.Contract) {
    bytesArray.push(serializeLPString(principal2.contractName));
  }
  return concatArray2(bytesArray);
}
function serializeLPString(lps) {
  const bytesArray = [];
  const contentBytes = utf8ToBytes3(lps.content);
  const length2 = contentBytes.byteLength;
  bytesArray.push(hexToBytes3(intToHex2(length2, lps.lengthPrefixBytes)));
  bytesArray.push(contentBytes);
  return concatArray2(bytesArray);
}
function serializeAssetInfo(info) {
  const bytesArray = [];
  bytesArray.push(serializeAddress(info.address));
  bytesArray.push(serializeLPString(info.contractName));
  bytesArray.push(serializeLPString(info.assetName));
  return concatArray2(bytesArray);
}
function serializePostCondition(postCondition) {
  const bytesArray = [];
  bytesArray.push(postCondition.conditionType);
  bytesArray.push(serializePrincipal(postCondition.principal));
  if (postCondition.conditionType === PostConditionType2.Fungible || postCondition.conditionType === PostConditionType2.NonFungible) {
    bytesArray.push(serializeAssetInfo(postCondition.assetInfo));
  }
  if (postCondition.conditionType === PostConditionType2.NonFungible) {
    bytesArray.push(serializeCV2(postCondition.assetName));
  }
  bytesArray.push(postCondition.conditionCode);
  if (postCondition.conditionType === PostConditionType2.STX || postCondition.conditionType === PostConditionType2.Fungible) {
    if (postCondition.amount > BigInt("0xffffffffffffffff"))
      throw new SerializationError2("The post-condition amount may not be larger than 8 bytes");
    bytesArray.push(intToBytes2(postCondition.amount, false, 8));
  }
  return concatArray2(bytesArray);
}

// node_modules/@stacks/transactions-v6/dist/esm/clarity/serialize.js
function bytesWithTypeID2(typeId, bytes2) {
  return concatArray2([typeId, bytes2]);
}
function serializeBoolCV2(value) {
  return new Uint8Array([value.type]);
}
function serializeOptionalCV2(cv) {
  if (cv.type === ClarityType2.OptionalNone) {
    return new Uint8Array([cv.type]);
  } else {
    return bytesWithTypeID2(cv.type, serializeCV2(cv.value));
  }
}
function serializeBufferCV2(cv) {
  const length2 = new Uint8Array(4);
  writeUInt32BE2(length2, cv.buffer.length, 0);
  return bytesWithTypeID2(cv.type, concatBytes3(length2, cv.buffer));
}
function serializeIntCV2(cv) {
  const bytes2 = bigIntToBytes2(toTwos2(cv.value, BigInt(CLARITY_INT_SIZE2)), CLARITY_INT_BYTE_SIZE2);
  return bytesWithTypeID2(cv.type, bytes2);
}
function serializeUIntCV2(cv) {
  const bytes2 = bigIntToBytes2(cv.value, CLARITY_INT_BYTE_SIZE2);
  return bytesWithTypeID2(cv.type, bytes2);
}
function serializeStandardPrincipalCV2(cv) {
  return bytesWithTypeID2(cv.type, serializeAddress(cv.address));
}
function serializeContractPrincipalCV2(cv) {
  return bytesWithTypeID2(cv.type, concatBytes3(serializeAddress(cv.address), serializeLPString(cv.contractName)));
}
function serializeResponseCV2(cv) {
  return bytesWithTypeID2(cv.type, serializeCV2(cv.value));
}
function serializeListCV2(cv) {
  const bytesArray = [];
  const length2 = new Uint8Array(4);
  writeUInt32BE2(length2, cv.list.length, 0);
  bytesArray.push(length2);
  for (const value of cv.list) {
    const serializedValue = serializeCV2(value);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID2(cv.type, concatArray2(bytesArray));
}
function serializeTupleCV2(cv) {
  const bytesArray = [];
  const length2 = new Uint8Array(4);
  writeUInt32BE2(length2, Object.keys(cv.data).length, 0);
  bytesArray.push(length2);
  const lexicographicOrder = Object.keys(cv.data).sort((a5, b7) => a5.localeCompare(b7));
  for (const key of lexicographicOrder) {
    const nameWithLength = createLPString2(key);
    bytesArray.push(serializeLPString(nameWithLength));
    const serializedValue = serializeCV2(cv.data[key]);
    bytesArray.push(serializedValue);
  }
  return bytesWithTypeID2(cv.type, concatArray2(bytesArray));
}
function serializeStringCV2(cv, encoding) {
  const bytesArray = [];
  const str = encoding == "ascii" ? asciiToBytes2(cv.data) : utf8ToBytes3(cv.data);
  const len = new Uint8Array(4);
  writeUInt32BE2(len, str.length, 0);
  bytesArray.push(len);
  bytesArray.push(str);
  return bytesWithTypeID2(cv.type, concatArray2(bytesArray));
}
function serializeStringAsciiCV2(cv) {
  return serializeStringCV2(cv, "ascii");
}
function serializeStringUtf8CV2(cv) {
  return serializeStringCV2(cv, "utf8");
}
function serializeCV2(value) {
  switch (value.type) {
    case ClarityType2.BoolTrue:
    case ClarityType2.BoolFalse:
      return serializeBoolCV2(value);
    case ClarityType2.OptionalNone:
    case ClarityType2.OptionalSome:
      return serializeOptionalCV2(value);
    case ClarityType2.Buffer:
      return serializeBufferCV2(value);
    case ClarityType2.UInt:
      return serializeUIntCV2(value);
    case ClarityType2.Int:
      return serializeIntCV2(value);
    case ClarityType2.PrincipalStandard:
      return serializeStandardPrincipalCV2(value);
    case ClarityType2.PrincipalContract:
      return serializeContractPrincipalCV2(value);
    case ClarityType2.ResponseOk:
    case ClarityType2.ResponseErr:
      return serializeResponseCV2(value);
    case ClarityType2.List:
      return serializeListCV2(value);
    case ClarityType2.Tuple:
      return serializeTupleCV2(value);
    case ClarityType2.StringASCII:
      return serializeStringAsciiCV2(value);
    case ClarityType2.StringUTF8:
      return serializeStringUtf8CV2(value);
    default:
      throw new SerializationError2("Unable to serialize. Invalid Clarity Value.");
  }
}

// node_modules/@stacks/transactions-v6/dist/esm/utils.js
var exceedsMaxLengthBytes2 = (string2, maxLengthBytes) => string2 ? utf8ToBytes3(string2).length > maxLengthBytes : false;

// node_modules/@reown/appkit-universal-connector/dist/esm/src/UniversalConnector.js
init_index_es14();

// node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
init_exports();

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
init_index_es14();
init_esm8();
init_exports();

// node_modules/@reown/appkit-scaffold-ui/dist/esm/exports/utils.js
init_ConnectorUtil();
init_ConstantsUtil4();
init_WalletUtil();

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
init_exports3();
init_exports2();
init_exports2();

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
init_esm6();
init_esm9();
init_esm8();
init_exports();

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
init_index_es14();
init_esm8();
init_exports();
init_exports2();

// node_modules/@reown/appkit-utils/dist/esm/src/ethers/EthersHelpersUtil.js
init_PresetsUtil();
var EthersHelpersUtil = {
  hexStringToNumber(value) {
    const string2 = value.startsWith("0x") ? value.slice(2) : value;
    const number2 = parseInt(string2, 16);
    return number2;
  },
  numberToHexString(value) {
    return `0x${value.toString(16)}`;
  },
  async getUserInfo(provider) {
    const [addresses, chainId] = await Promise.all([
      EthersHelpersUtil.getAddresses(provider),
      EthersHelpersUtil.getChainId(provider)
    ]);
    return { chainId, addresses };
  },
  async getChainId(provider) {
    const chainId = await provider.request({ method: "eth_chainId" });
    return Number(chainId);
  },
  async getAddress(provider) {
    const [address2] = await provider.request({ method: "eth_accounts" });
    return address2;
  },
  async getAddresses(provider) {
    const addresses = await provider.request({ method: "eth_accounts" });
    return addresses;
  },
  async addEthereumChain(provider, caipNetwork) {
    const rpcUrls = caipNetwork.rpcUrls["chainDefault"]?.http || [];
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id),
          rpcUrls: [...rpcUrls],
          chainName: caipNetwork.name,
          nativeCurrency: {
            name: caipNetwork.nativeCurrency.name,
            decimals: caipNetwork.nativeCurrency.decimals,
            symbol: caipNetwork.nativeCurrency.symbol
          },
          blockExplorerUrls: [caipNetwork.blockExplorers?.default.url],
          iconUrls: [PresetsUtil.NetworkImageIds[caipNetwork.id]]
        }
      ]
    });
  }
};

// node_modules/@reown/appkit/dist/esm/src/connections/ConnectionManager.js
init_esm8();
init_exports();
init_exports2();

// node_modules/@reown/appkit-utils/dist/esm/src/bitcoin/BitcoinConstantsUtil.js
var BitcoinConstantsUtil = {
  ACCOUNT_INDEXES: {
    PAYMENT: 0,
    ORDINAL: 1
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
init_esm8();
init_exports();

// node_modules/@reown/appkit/dist/esm/src/networks/utils.js
function defineChain(chain3) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain3
  };
}

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solana.js
var solana = defineChain({
  id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  name: "Solana",
  network: "solana-mainnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: false,
  chainNamespace: "solana",
  caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaDevnet.js
var solanaDevnet = defineChain({
  id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  name: "Solana Devnet",
  network: "solana-devnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"
});

// node_modules/@reown/appkit/dist/esm/src/networks/solana/solanaTestnet.js
var solanaTestnet = defineChain({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: true,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
});

// node_modules/@reown/appkit/dist/esm/src/networks/bitcoin.js
var bitcoin = defineChain({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  }
});
var bitcoinTestnet = defineChain({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 8
  },
  rpcUrls: {
    default: { http: ["https://rpc.walletconnect.org/v1"] }
  },
  testnet: true
});

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var DEFAULT_METHODS = {
  solana: [
    "solana_signMessage",
    "solana_signTransaction",
    "solana_requestAccounts",
    "solana_getAccounts",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction"
  ],
  eip155: [
    "eth_accounts",
    "eth_requestAccounts",
    "eth_sendRawTransaction",
    "eth_sign",
    "eth_signTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "personal_sign",
    "wallet_switchEthereumChain",
    "wallet_addEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
    // EIP-5792
    "wallet_getCallsStatus",
    "wallet_showCallsStatus",
    "wallet_sendCalls",
    "wallet_getCapabilities",
    // EIP-7715
    "wallet_grantPermissions",
    "wallet_revokePermissions",
    //EIP-7811
    "wallet_getAssets"
  ],
  bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"]
};
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    return DEFAULT_METHODS[chainNamespace] || [];
  },
  createDefaultNamespace(chainNamespace) {
    return {
      methods: this.getMethodsByChainNamespace(chainNamespace),
      events: ["accountsChanged", "chainChanged"],
      chains: [],
      rpcMap: {}
    };
  },
  applyNamespaceOverrides(baseNamespaces, overrides) {
    if (!overrides) {
      return { ...baseNamespaces };
    }
    const result = { ...baseNamespaces };
    const namespacesToOverride = /* @__PURE__ */ new Set();
    if (overrides.methods) {
      Object.keys(overrides.methods).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.chains) {
      Object.keys(overrides.chains).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.events) {
      Object.keys(overrides.events).forEach((ns3) => namespacesToOverride.add(ns3));
    }
    if (overrides.rpcMap) {
      Object.keys(overrides.rpcMap).forEach((chainId) => {
        const [ns3] = chainId.split(":");
        if (ns3) {
          namespacesToOverride.add(ns3);
        }
      });
    }
    namespacesToOverride.forEach((ns3) => {
      if (!result[ns3]) {
        result[ns3] = this.createDefaultNamespace(ns3);
      }
    });
    if (overrides.methods) {
      Object.entries(overrides.methods).forEach(([ns3, methods]) => {
        if (result[ns3]) {
          result[ns3].methods = methods;
        }
      });
    }
    if (overrides.chains) {
      Object.entries(overrides.chains).forEach(([ns3, chains]) => {
        if (result[ns3]) {
          result[ns3].chains = chains;
        }
      });
    }
    if (overrides.events) {
      Object.entries(overrides.events).forEach(([ns3, events]) => {
        if (result[ns3]) {
          result[ns3].events = events;
        }
      });
    }
    if (overrides.rpcMap) {
      const processedNamespaces = /* @__PURE__ */ new Set();
      Object.entries(overrides.rpcMap).forEach(([chainId, rpcUrl]) => {
        const [ns3, id] = chainId.split(":");
        if (!ns3 || !id || !result[ns3]) {
          return;
        }
        if (!result[ns3].rpcMap) {
          result[ns3].rpcMap = {};
        }
        if (!processedNamespaces.has(ns3)) {
          result[ns3].rpcMap = {};
          processedNamespaces.add(ns3);
        }
        result[ns3].rpcMap[id] = rpcUrl;
      });
    }
    return result;
  },
  createNamespaces(caipNetworks, configOverride) {
    const defaultNamespaces = caipNetworks.reduce((acc, chain3) => {
      const { id, chainNamespace, rpcUrls } = chain3;
      const rpcUrl = rpcUrls.default.http[0];
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = this.createDefaultNamespace(chainNamespace);
      }
      const caipNetworkId = `${chainNamespace}:${id}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(caipNetworkId);
      switch (caipNetworkId) {
        case solana.caipNetworkId:
          namespace.chains.push(solana.deprecatedCaipNetworkId);
          break;
        case solanaDevnet.caipNetworkId:
          namespace.chains.push(solanaDevnet.deprecatedCaipNetworkId);
          break;
        default:
      }
      if (namespace?.rpcMap && rpcUrl) {
        namespace.rpcMap[id] = rpcUrl;
      }
      return acc;
    }, {});
    return this.applyNamespaceOverrides(defaultNamespaces, configOverride);
  },
  resolveReownName: async (name2) => {
    const wcNameAddress = await EnsController.resolveName(name2);
    const networkNameAddresses = Object.values(wcNameAddress?.addresses) || [];
    return networkNameAddresses[0]?.address || false;
  },
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const [chainNamespace, chainId] = account.split(":");
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  },
  isSessionEventData(data) {
    return typeof data === "object" && data !== null && "id" in data && "topic" in data && "params" in data && typeof data.params === "object" && data.params !== null && "chainId" in data.params && "event" in data.params && typeof data.params.event === "object" && data.params.event !== null;
  },
  isOriginAllowed(currentOrigin, allowedPatterns, defaultAllowedOrigins) {
    for (const pattern of [...allowedPatterns, ...defaultAllowedOrigins]) {
      if (pattern.includes("*")) {
        const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        const regexString = `^${escapedPattern.replace(/\\\*/gu, ".*")}$`;
        const regex2 = new RegExp(regexString, "u");
        if (regex2.test(currentOrigin)) {
          return true;
        }
      } else {
        try {
          if (new URL(pattern).origin === currentOrigin) {
            return true;
          }
        } catch (e10) {
          if (pattern === currentOrigin) {
            return true;
          }
        }
      }
    }
    return false;
  },
  listenWcProvider({ universalProvider, namespace, onConnect, onDisconnect, onAccountsChanged, onChainChanged, onDisplayUri }) {
    if (onConnect) {
      universalProvider.on("connect", () => {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, namespace);
        onConnect(accounts);
      });
    }
    if (onDisconnect) {
      universalProvider.on("disconnect", () => {
        onDisconnect();
      });
    }
    if (onAccountsChanged) {
      universalProvider.on("session_event", (callbackData) => {
        if (WcHelpersUtil.isSessionEventData(callbackData)) {
          const { name: name2, data } = callbackData.params.event;
          if (name2 === "accountsChanged" && Array.isArray(data)) {
            const parsedCaipAddresses = data.filter((account) => CoreHelperUtil.isCaipAddress(account)).map((account) => ParseUtil.parseCaipAddress(account)).filter((caipAddress) => caipAddress.chainNamespace === namespace);
            onAccountsChanged(parsedCaipAddresses);
          }
        }
      });
    }
    if (onChainChanged) {
      universalProvider.on("chainChanged", (chainId) => {
        onChainChanged(chainId);
      });
    }
    if (onDisplayUri) {
      universalProvider.on("display_uri", (uri) => {
        onDisplayUri(uri);
      });
    }
  },
  getWalletConnectAccounts(universalProvider, namespace) {
    const accountsAdded = /* @__PURE__ */ new Set();
    const accounts = universalProvider?.session?.namespaces?.[namespace]?.accounts?.map((account) => ParseUtil.parseCaipAddress(account)).filter(({ address: address2 }) => {
      if (accountsAdded.has(address2.toLowerCase())) {
        return false;
      }
      accountsAdded.add(address2.toLowerCase());
      return true;
    });
    if (accounts && accounts.length > 0) {
      return accounts;
    }
    return [];
  }
};

// node_modules/@reown/appkit/dist/esm/src/connections/ConnectionManager.js
var ConnectionManager = class {
  constructor(params) {
    this.namespace = params.namespace;
  }
  async syncConnections(params) {
    switch (this.namespace) {
      case ConstantsUtil.CHAIN.EVM:
        await this.syncEVMConnections(params);
        break;
      case ConstantsUtil.CHAIN.SOLANA:
        await this.syncSolanaConnections(params);
        break;
      case ConstantsUtil.CHAIN.BITCOIN:
        await this.syncBitcoinConnections(params);
        break;
      default:
        throw new Error(`Unsupported chain namespace: ${this.namespace}`);
    }
  }
  async syncEVMConnections({ connectors, caipNetworks, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c12) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c12.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        const caipNetwork = caipNetworks.find((n12) => n12.chainNamespace === this.namespace && n12.id.toString() === accounts[0]?.chainId?.toString());
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const { accounts, chainId } = await ConnectorUtil.fetchProviderData(connector);
        if (accounts.length > 0 && chainId) {
          const caipNetwork = caipNetworks.find((n12) => n12.chainNamespace === this.namespace && n12.id.toString() === chainId.toString());
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((address2) => ({ address: address2 })),
            caipNetwork
          });
          if (connector.provider && connector.id !== ConstantsUtil.CONNECTOR_ID.AUTH && connector.id !== ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            onListenProvider(connector.id, connector.provider);
          }
        }
      }
    }));
  }
  async syncSolanaConnections({ connectors, caipNetwork, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c12) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c12.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
      } else {
        const address2 = await connector.connect({
          chainId: caipNetwork?.id
        });
        if (address2) {
          onConnection({
            connectorId: connector.id,
            accounts: [{ address: address2 }],
            caipNetwork
          });
          onListenProvider(connector.id, connector.provider);
        }
      }
    }));
  }
  async syncBitcoinConnections({ connectors, caipNetwork, universalProvider, getConnectionStatusInfo, onConnection, onListenProvider }) {
    await Promise.all(connectors.filter((c12) => {
      const { hasDisconnected, hasConnected } = getConnectionStatusInfo(c12.id);
      return !hasDisconnected && hasConnected;
    }).map(async (connector) => {
      if (connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
        const accounts2 = WcHelpersUtil.getWalletConnectAccounts(universalProvider, this.namespace);
        if (accounts2.length > 0) {
          onConnection({
            connectorId: connector.id,
            accounts: accounts2.map((account) => ({ address: account.address })),
            caipNetwork
          });
        }
        return;
      }
      const address2 = await connector.connect();
      const addresses = await connector.getAccountAddresses();
      let accounts = addresses?.map((a5) => CoreHelperUtil.createAccount(ConstantsUtil.CHAIN.BITCOIN, a5.address, a5.purpose || "payment", a5.publicKey, a5.path));
      if (accounts && accounts.length > 1) {
        accounts = [
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]?.publicKey ?? "",
            path: accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]?.path ?? "",
            address: accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.PAYMENT]?.address ?? "",
            type: "payment"
          },
          {
            namespace: ConstantsUtil.CHAIN.BITCOIN,
            publicKey: accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]?.publicKey ?? "",
            path: accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]?.path ?? "",
            address: accounts[BitcoinConstantsUtil.ACCOUNT_INDEXES.ORDINAL]?.address ?? "",
            type: "ordinal"
          }
        ];
      }
      const chain3 = connector.chains.find((c12) => c12.id === caipNetwork?.id) || connector.chains[0];
      if (!chain3) {
        throw new Error("The connector does not support any of the requested chains");
      }
      if (address2) {
        onListenProvider(connector.id, connector.provider);
        onConnection({
          connectorId: connector.id,
          accounts: accounts.map((a5) => ({ address: a5.address, type: a5.type })),
          caipNetwork
        });
      }
    }));
  }
  /**
   * Gets a connection based on provided parameters.
   * If connectorId is provided, returns connection for that specific connector.
   * Otherwise, returns the first available valid connection.
   *
   * @param params - Connection parameters
   * @param params.address - Optional address to filter by
   * @param params.connectorId - Optional connector ID to filter by
   * @param params.connections - List of available connections
   * @param params.connectors - List of available connectors
   * @returns Connection or null if none found
   */
  getConnection({ address: address2, connectorId, connections, connectors }) {
    if (connectorId) {
      const connection = connections.find((c12) => HelpersUtil.isLowerCaseMatch(c12.connectorId, connectorId));
      if (!connection) {
        return null;
      }
      const connector = connectors.find((c12) => HelpersUtil.isLowerCaseMatch(c12.id, connection.connectorId));
      const account = address2 ? connection.accounts.find((a5) => HelpersUtil.isLowerCaseMatch(a5.address, address2)) : connection.accounts[0];
      return { ...connection, account, connector };
    }
    const validConnection = connections.find((c12) => c12.accounts.length > 0 && connectors.some((conn) => HelpersUtil.isLowerCaseMatch(conn.id, c12.connectorId)));
    if (validConnection) {
      const [account] = validConnection.accounts;
      const connector = connectors.find((c12) => HelpersUtil.isLowerCaseMatch(c12.id, validConnection.connectorId));
      return {
        ...validConnection,
        account,
        connector
      };
    }
    return null;
  }
};

// node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
init_index_es14();
init_esm8();
init_exports();
init_exports2();

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3,
  ERROR_INVALID_CHAIN_ID: 32603,
  DEFAULT_ALLOWED_ANCESTORS: [
    "http://localhost:*",
    "https://localhost:*",
    "http://127.0.0.1:*",
    "https://127.0.0.1:*",
    "https://*.pages.dev",
    "https://*.vercel.app",
    "https://*.ngrok-free.app",
    "https://secure-mobile.walletconnect.com",
    "https://secure-mobile.walletconnect.org"
  ]
};

// node_modules/@reown/appkit/dist/esm/src/connectors/WalletConnectConnector.js
var WalletConnectConnector = class {
  constructor({ provider, namespace }) {
    this.id = ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    this.name = PresetsUtil.ConnectorNamesMap[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.type = "WALLET_CONNECT";
    this.imageId = PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT];
    this.getCaipNetworks = ChainController.getCaipNetworks.bind(ChainController);
    this.caipNetworks = this.getCaipNetworks();
    this.provider = provider;
    this.chain = namespace;
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    const isAuthenticated = await this.authenticate();
    if (!isAuthenticated) {
      const caipNetworks = this.getCaipNetworks();
      const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
      const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
      await this.provider.connect({ optionalNamespaces: namespaces });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const chains = this.chains.map((network) => network.caipNetworkId);
    return SIWXUtil.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains,
      methods: OPTIONAL_METHODS
    });
  }
};
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  // EIP-5792
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  // EIP-7715
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  //EIP-7811
  "wallet_getAssets"
];

// node_modules/@reown/appkit/dist/esm/src/adapters/ChainAdapterBlueprint.js
var IGNORED_CONNECTOR_IDS_FOR_LISTENER = [
  ConstantsUtil.CONNECTOR_ID.AUTH,
  ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT
];
var AdapterBlueprint = class {
  /**
   * Creates an instance of AdapterBlueprint.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  constructor(params) {
    this.availableConnectors = [];
    this.availableConnections = [];
    this.providerHandlers = {};
    this.eventListeners = /* @__PURE__ */ new Map();
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getConnectorId = (namespace) => ConnectorController.getConnectorId(namespace);
    if (params) {
      this.construct(params);
    }
    if (params?.namespace) {
      this.connectionManager = new ConnectionManager({
        namespace: params.namespace
      });
    }
  }
  /**
   * Initializes the adapter with the given parameters.
   * @param {AdapterBlueprint.Params} params - The parameters for initializing the adapter
   */
  construct(params) {
    this.projectId = params.projectId;
    this.namespace = params.namespace;
    this.adapterType = params.adapterType;
  }
  /**
   * Gets the available connectors.
   * @returns {Connector[]} An array of available connectors
   */
  get connectors() {
    return this.availableConnectors;
  }
  /**
   * Gets the available connections.
   * @returns {Connection[]} An array of available connections
   */
  get connections() {
    return this.availableConnections;
  }
  /**
   * Gets the supported networks.
   * @returns {CaipNetwork[]} An array of supported networks
   */
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  /**
   * Handles the auth connected event.
   * @param {W3mFrameTypes.Responses['FrameGetUserResponse']} user - The user response
   */
  onAuthConnected({ accounts, chainId }) {
    const caipNetwork = this.getCaipNetworks().filter((n12) => n12.chainNamespace === this.namespace).find((n12) => n12.id.toString() === chainId?.toString());
    if (accounts && caipNetwork) {
      this.addConnection({
        connectorId: ConstantsUtil.CONNECTOR_ID.AUTH,
        accounts,
        caipNetwork
      });
    }
  }
  /**
   * Sets the auth provider.
   * @param {W3mFrameProvider} authProvider - The auth provider instance
   */
  setAuthProvider(authProvider) {
    authProvider.onConnect(this.onAuthConnected.bind(this));
    authProvider.onSocialConnected(this.onAuthConnected.bind(this));
    this.addConnector({
      id: ConstantsUtil.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
      provider: authProvider,
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: []
    });
  }
  /**
   * Adds one or more connectors to the available connectors list.
   * @param {...Connector} connectors - The connectors to add
   */
  addConnector(...connectors) {
    const connectorsAdded = /* @__PURE__ */ new Set();
    this.availableConnectors = [...connectors, ...this.availableConnectors].filter((connector) => {
      if (connectorsAdded.has(connector.id)) {
        return false;
      }
      connectorsAdded.add(connector.id);
      return true;
    });
    this.emit("connectors", this.availableConnectors);
  }
  /**
   * Adds connections to the available connections list
   * @param {...Connection} connections - The connections to add
   */
  addConnection(...connections) {
    const connectionsAdded = /* @__PURE__ */ new Set();
    this.availableConnections = [...connections, ...this.availableConnections].filter((connection) => {
      if (connectionsAdded.has(connection.connectorId.toLowerCase())) {
        return false;
      }
      connectionsAdded.add(connection.connectorId.toLowerCase());
      return true;
    });
    this.emit("connections", this.availableConnections);
  }
  /**
   * Deletes a connection from the available connections list
   * @param {string} connectorId - The connector ID of the connection to delete
   */
  deleteConnection(connectorId) {
    this.availableConnections = this.availableConnections.filter((c12) => !HelpersUtil.isLowerCaseMatch(c12.connectorId, connectorId));
    this.emit("connections", this.availableConnections);
  }
  /**
   * Clears all connections from the available connections list
   * @param {boolean} emit - Whether to emit the connections event
   */
  clearConnections(emit = false) {
    this.availableConnections = [];
    if (emit) {
      this.emit("connections", this.availableConnections);
    }
  }
  setStatus(status, chainNamespace) {
    AccountController.setStatus(status, chainNamespace);
  }
  /**
   * Adds an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be called when the event is emitted
   */
  on(eventName, callback) {
    if (!this.eventListeners.has(eventName)) {
      this.eventListeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(eventName)?.add(callback);
  }
  /**
   * Removes an event listener for a specific event.
   * @template T
   * @param {T} eventName - The name of the event
   * @param {EventCallback<T>} callback - The callback function to be removed
   */
  off(eventName, callback) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.delete(callback);
    }
  }
  /**
   * Removes all event listeners.
   */
  removeAllEventListeners() {
    this.eventListeners.forEach((listeners) => {
      listeners.clear();
    });
  }
  /**
   * Emits an event with the given name and optional data.
   * @template T
   * @param {T} eventName - The name of the event to emit
   * @param {EventData[T]} [data] - The optional data to be passed to the event listeners
   */
  emit(eventName, data) {
    const listeners = this.eventListeners.get(eventName);
    if (listeners) {
      listeners.forEach((callback) => callback(data));
    }
  }
  /**
   * Connects to WalletConnect.
   * @param {number | string} [_chainId] - Optional chain ID to connect to
   */
  async connectWalletConnect(_chainId) {
    const connector = this.getWalletConnectConnector();
    const result = await connector.connectWalletConnect();
    return { clientId: result.clientId };
  }
  /**
   * Switches the network.
   * @param {AdapterBlueprint.SwitchNetworkParams} params - Network switching parameters
   */
  async switchNetwork(params) {
    const { caipNetwork, providerType } = params;
    if (!params.provider) {
      return;
    }
    const provider = "provider" in params.provider ? params.provider.provider : params.provider;
    if (providerType === "WALLET_CONNECT") {
      ;
      provider.setDefaultChain(caipNetwork.caipNetworkId);
      return;
    }
    if (provider && providerType === "AUTH") {
      const authProvider = provider;
      const preferredAccountType = getPreferredAccountType(caipNetwork.chainNamespace);
      await authProvider.switchNetwork({ chainId: caipNetwork.caipNetworkId });
      const user = await authProvider.getUser({
        chainId: caipNetwork.caipNetworkId,
        preferredAccountType
      });
      this.emit("switchNetwork", user);
    }
  }
  getWalletConnectConnector() {
    const connector = this.connectors.find((c12) => c12 instanceof WalletConnectConnector);
    if (!connector) {
      throw new Error("WalletConnectConnector not found");
    }
    return connector;
  }
  /**
   * Handles connect event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onConnect(accounts, connectorId) {
    if (accounts.length > 0) {
      const { address: address2, chainId } = CoreHelperUtil.getAccount(accounts[0]);
      const caipNetwork = this.getCaipNetworks().filter((n12) => n12.chainNamespace === this.namespace).find((n12) => n12.id.toString() === chainId?.toString());
      const connector = this.connectors.find((c12) => c12.id === connectorId);
      if (address2) {
        this.emit("accountChanged", {
          address: address2,
          chainId,
          connector
        });
        this.addConnection({
          connectorId,
          accounts: accounts.map((_account) => {
            const { address: address3 } = CoreHelperUtil.getAccount(_account);
            return { address: address3 };
          }),
          caipNetwork
        });
      }
    }
  }
  /**
   * Handles accounts changed event for a specific connector.
   * @param {string[]} accounts - The accounts that changed
   * @param {string} connectorId - The ID of the connector
   */
  onAccountsChanged(accounts, connectorId, disconnectIfNoAccounts = true) {
    if (accounts.length > 0) {
      const { address: address2 } = CoreHelperUtil.getAccount(accounts[0]);
      const connection = this.connectionManager?.getConnection({
        connectorId,
        connections: this.connections,
        connectors: this.connectors
      });
      if (address2 && HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
        this.emit("accountChanged", {
          address: address2,
          chainId: connection?.caipNetwork?.id,
          connector: connection?.connector
        });
      }
      this.addConnection({
        connectorId,
        accounts: accounts.map((_account) => {
          const { address: address3 } = CoreHelperUtil.getAccount(_account);
          return { address: address3 };
        }),
        caipNetwork: connection?.caipNetwork
      });
    } else if (disconnectIfNoAccounts) {
      this.onDisconnect(connectorId);
    }
  }
  /**
   * Handles disconnect event for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  onDisconnect(connectorId) {
    this.removeProviderListeners(connectorId);
    this.deleteConnection(connectorId);
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emitFirstAvailableConnection();
    }
    if (this.connections.length === 0) {
      this.emit("disconnect");
    }
  }
  /**
   * Handles chain changed event for a specific connector.
   * @param {string} chainId - The ID of the chain that changed
   * @param {string} connectorId - The ID of the connector
   */
  onChainChanged(chainId, connectorId) {
    const formattedChainId = typeof chainId === "string" && chainId.startsWith("0x") ? EthersHelpersUtil.hexStringToNumber(chainId).toString() : chainId.toString();
    const connection = this.connectionManager?.getConnection({
      connectorId,
      connections: this.connections,
      connectors: this.connectors
    });
    const caipNetwork = this.getCaipNetworks().filter((n12) => n12.chainNamespace === this.namespace).find((n12) => n12.id.toString() === formattedChainId);
    if (connection) {
      this.addConnection({
        connectorId,
        accounts: connection.accounts,
        caipNetwork
      });
    }
    if (HelpersUtil.isLowerCaseMatch(this.getConnectorId(ConstantsUtil.CHAIN.EVM), connectorId)) {
      this.emit("switchNetwork", { chainId: formattedChainId });
    }
  }
  /**
   * Listens to provider events for a specific connector.
   * @param {string} connectorId - The ID of the connector
   * @param {Provider | CombinedProvider} provider - The provider to listen to
   */
  listenProviderEvents(connectorId, provider) {
    if (IGNORED_CONNECTOR_IDS_FOR_LISTENER.includes(connectorId)) {
      return;
    }
    const accountsChangedHandler = (accounts) => this.onAccountsChanged(accounts, connectorId);
    const chainChangedHandler = (chainId) => this.onChainChanged(chainId, connectorId);
    const disconnectHandler = () => this.onDisconnect(connectorId);
    if (!this.providerHandlers[connectorId]) {
      provider.on("disconnect", disconnectHandler);
      provider.on("accountsChanged", accountsChangedHandler);
      provider.on("chainChanged", chainChangedHandler);
      this.providerHandlers[connectorId] = {
        provider,
        disconnect: disconnectHandler,
        accountsChanged: accountsChangedHandler,
        chainChanged: chainChangedHandler
      };
    }
  }
  /**
   * Removes provider listeners for a specific connector.
   * @param {string} connectorId - The ID of the connector
   */
  removeProviderListeners(connectorId) {
    if (this.providerHandlers[connectorId]) {
      const { provider, disconnect, accountsChanged, chainChanged } = this.providerHandlers[connectorId];
      provider.removeListener("disconnect", disconnect);
      provider.removeListener("accountsChanged", accountsChanged);
      provider.removeListener("chainChanged", chainChanged);
      this.providerHandlers[connectorId] = null;
    }
  }
  /**
   * Emits the first available connection.
   */
  emitFirstAvailableConnection() {
    const connection = this.connectionManager?.getConnection({
      connections: this.connections,
      connectors: this.connectors
    });
    if (connection) {
      const [account] = connection.accounts;
      this.emit("accountChanged", {
        address: account?.address,
        chainId: connection.caipNetwork?.id,
        connector: connection.connector
      });
    }
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var UniversalAdapter = class extends AdapterBlueprint {
  async setUniversalProvider(universalProvider) {
    if (!this.namespace) {
      throw new Error("UniversalAdapter:setUniversalProvider - namespace is required");
    }
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: this.namespace
    }));
    return Promise.resolve();
  }
  async connect(params) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(params.chainId),
      provider: this.provider,
      address: ""
    });
  }
  async disconnect() {
    try {
      const connector = this.getWalletConnectConnector();
      await connector.disconnect();
      this.emit("disconnect");
    } catch (error2) {
      console.warn("UniversalAdapter:disconnect - error", error2);
    }
    return { connections: [] };
  }
  syncConnections() {
    return Promise.resolve();
  }
  async getAccounts({ namespace }) {
    const provider = this.provider;
    const addresses = provider?.session?.namespaces?.[namespace]?.accounts?.map((account) => {
      const [, , address2] = account.split(":");
      return address2;
    }).filter((address2, index2, self2) => self2.indexOf(address2) === index2) || [];
    return Promise.resolve({
      accounts: addresses.map((address2) => CoreHelperUtil.createAccount(namespace, address2, namespace === "bip122" ? "payment" : "eoa"))
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(params) {
    const isBalanceSupported = params.caipNetwork && ConstantsUtil2.BALANCE_SUPPORTED_CHAINS.includes(params.caipNetwork?.chainNamespace);
    if (!isBalanceSupported || params.caipNetwork?.testnet) {
      return {
        balance: "0.00",
        symbol: params.caipNetwork?.nativeCurrency.symbol || ""
      };
    }
    if (AccountController.state.balanceLoading && params.chainId === ChainController.state.activeCaipNetwork?.id) {
      return {
        balance: AccountController.state.balance || "0.00",
        symbol: AccountController.state.balanceSymbol || ""
      };
    }
    const balances = await AccountController.fetchTokenBalance();
    const balance = balances.find((b7) => b7.chainId === `${params.caipNetwork?.chainNamespace}:${params.chainId}` && b7.symbol === params.caipNetwork?.nativeCurrency.symbol);
    return {
      balance: balance?.quantity.numeric || "0.00",
      symbol: balance?.symbol || params.caipNetwork?.nativeCurrency.symbol || ""
    };
  }
  async signMessage(params) {
    const { provider, message, address: address2 } = params;
    if (!provider) {
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    }
    let signature = "";
    if (ChainController.state.activeCaipNetwork?.chainNamespace === ConstantsUtil.CHAIN.SOLANA) {
      const response = await provider.request({
        method: "solana_signMessage",
        params: {
          message: esm_default2.encode(new TextEncoder().encode(message)),
          pubkey: address2
        }
      }, ChainController.state.activeCaipNetwork?.caipNetworkId);
      signature = response.signature;
    } else {
      signature = await provider.request({
        method: "personal_sign",
        params: [message, address2]
      }, ChainController.state.activeCaipNetwork?.caipNetworkId);
    }
    return { signature };
  }
  // -- Transaction methods ---------------------------------------------------
  /**
   *
   * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
   * These function definition is to have a type parity between the clients. Currently not in use.
   */
  async estimateGas() {
    return Promise.resolve({
      gas: BigInt(0)
    });
  }
  async sendTransaction() {
    return Promise.resolve({
      hash: ""
    });
  }
  walletGetAssets(_params) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({
      hash: ""
    });
  }
  emitFirstAvailableConnection() {
    return void 0;
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: ""
    });
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async switchNetwork(params) {
    const { caipNetwork } = params;
    const connector = this.getWalletConnectConnector();
    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
      try {
        await connector.provider?.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: toHex2(caipNetwork.id) }]
        });
      } catch (switchError) {
        if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID || switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT || switchError?.data?.originalError?.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
          try {
            await connector.provider?.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: toHex2(caipNetwork.id),
                  rpcUrls: [caipNetwork?.rpcUrls["chainDefault"]?.http],
                  chainName: caipNetwork.name,
                  nativeCurrency: caipNetwork.nativeCurrency,
                  blockExplorerUrls: [caipNetwork.blockExplorers?.default.url]
                }
              ]
            });
          } catch (error2) {
            throw new Error("Chain is not supported");
          }
        }
      }
    }
    connector.provider.setDefaultChain(caipNetwork.caipNetworkId);
  }
  getWalletConnectProvider() {
    const connector = this.connectors.find((c12) => c12.type === "WALLET_CONNECT");
    const provider = connector?.provider;
    return provider;
  }
};

// node_modules/@reown/appkit/dist/esm/src/utils/ConfigUtil.js
init_exports();
init_exports2();
var FEATURE_KEYS = [
  "email",
  "socials",
  "swaps",
  "onramp",
  "activity",
  "reownBranding",
  "multiWallet",
  "emailCapture"
];
var featureConfig = {
  email: {
    apiFeatureName: "social_login",
    localFeatureName: "email",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.includes("email");
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.email;
      }
      return Boolean(localValue);
    }
  },
  socials: {
    apiFeatureName: "social_login",
    localFeatureName: "socials",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config.filter((s8) => s8 !== "email") : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.socials : false;
      }
      return localValue;
    }
  },
  swaps: {
    apiFeatureName: "swap",
    localFeatureName: "swaps",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.swaps : false;
      }
      return localValue;
    }
  },
  onramp: {
    apiFeatureName: "onramp",
    localFeatureName: "onramp",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => {
      if (!apiConfig?.config) {
        return false;
      }
      const config = apiConfig.config;
      return Boolean(apiConfig.isEnabled) && config.length > 0 ? config : false;
    },
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp;
      }
      if (typeof localValue === "boolean") {
        return localValue ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES.onramp : false;
      }
      return localValue;
    }
  },
  activity: {
    apiFeatureName: "activity",
    localFeatureName: "history",
    returnType: false,
    isLegacy: true,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.activity;
      }
      return Boolean(localValue);
    }
  },
  reownBranding: {
    apiFeatureName: "reown_branding",
    localFeatureName: "reownBranding",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: (localValue) => {
      if (localValue === void 0) {
        return ConstantsUtil2.DEFAULT_REMOTE_FEATURES.reownBranding;
      }
      return Boolean(localValue);
    }
  },
  emailCapture: {
    apiFeatureName: "email_capture",
    localFeatureName: "emailCapture",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => apiConfig.isEnabled && (apiConfig.config ?? []),
    processFallback: (_localValue) => false
  },
  multiWallet: {
    apiFeatureName: "multi_wallet",
    localFeatureName: "multiWallet",
    returnType: false,
    isLegacy: false,
    isAvailableOnBasic: false,
    processApi: (apiConfig) => Boolean(apiConfig.isEnabled),
    processFallback: () => ConstantsUtil2.DEFAULT_REMOTE_FEATURES.multiWallet
  }
};
var ConfigUtil = {
  localSettingsOverridden: /* @__PURE__ */ new Set(),
  getApiConfig(id, apiProjectConfig) {
    return apiProjectConfig?.find((f13) => f13.id === id);
  },
  addWarning(localFeatureValue, featureKey) {
    if (localFeatureValue !== void 0) {
      const config = featureConfig[featureKey];
      const warningName = config.isLegacy ? `"features.${config.localFeatureName}" (now "${featureKey}")` : `"features.${featureKey}"`;
      this.localSettingsOverridden.add(warningName);
    }
  },
  processFeature(featureKey, localFeatures, apiProjectConfig, useApi, isBasic) {
    const config = featureConfig[featureKey];
    const localValue = localFeatures[config.localFeatureName];
    if (isBasic && !config.isAvailableOnBasic) {
      return false;
    }
    if (useApi) {
      const apiConfig = this.getApiConfig(config.apiFeatureName, apiProjectConfig);
      if (apiConfig?.config === null) {
        return this.processFallbackFeature(featureKey, localValue);
      }
      if (!apiConfig?.config) {
        return false;
      }
      if (localValue !== void 0) {
        this.addWarning(localValue, featureKey);
      }
      return this.processApiFeature(featureKey, apiConfig);
    }
    return this.processFallbackFeature(featureKey, localValue);
  },
  processApiFeature(featureKey, apiConfig) {
    return featureConfig[featureKey].processApi(apiConfig);
  },
  processFallbackFeature(featureKey, localValue) {
    return featureConfig[featureKey].processFallback(localValue);
  },
  async fetchRemoteFeatures(config) {
    const isBasic = config.basic ?? false;
    const localFeatures = config.features || {};
    this.localSettingsOverridden.clear();
    let apiProjectConfig = null;
    let useApiConfig = false;
    try {
      apiProjectConfig = await ApiController.fetchProjectConfig();
      useApiConfig = apiProjectConfig !== null && apiProjectConfig !== void 0;
    } catch (e10) {
      console.warn("[Reown Config] Failed to fetch remote project configuration. Using local/default values.", e10);
    }
    const remoteFeaturesConfig = useApiConfig && !isBasic ? ConstantsUtil2.DEFAULT_REMOTE_FEATURES : ConstantsUtil2.DEFAULT_REMOTE_FEATURES_DISABLED;
    try {
      for (const featureKey of FEATURE_KEYS) {
        const result = this.processFeature(featureKey, localFeatures, apiProjectConfig, useApiConfig, isBasic);
        Object.assign(remoteFeaturesConfig, { [featureKey]: result });
      }
    } catch (e10) {
      console.warn("[Reown Config] Failed to process the configuration from Cloud. Using default values.", e10);
      return ConstantsUtil2.DEFAULT_REMOTE_FEATURES;
    }
    if (useApiConfig && this.localSettingsOverridden.size > 0) {
      const warningMessage = `Your local configuration for ${Array.from(this.localSettingsOverridden).join(", ")} was ignored because a remote configuration was successfully fetched. Please manage these features via your project dashboard on dashboard.reown.com.`;
      AlertController.open({
        debugMessage: ErrorUtil.ALERT_WARNINGS.LOCAL_CONFIGURATION_IGNORED.debugMessage(warningMessage)
      }, "warning");
    }
    return remoteFeaturesConfig;
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-base-client.js
var AppKitBaseClient = class {
  constructor(options) {
    this.chainNamespaces = [];
    this.remoteFeatures = {};
    this.reportedAlertErrors = {};
    this.getCaipNetwork = (chainNamespace, id) => {
      if (chainNamespace) {
        const caipNetworkWithId = ChainController.getCaipNetworks(chainNamespace)?.find((c12) => c12.id === id);
        if (caipNetworkWithId) {
          return caipNetworkWithId;
        }
        const namespaceCaipNetwork = ChainController.getNetworkData(chainNamespace)?.caipNetwork;
        if (namespaceCaipNetwork) {
          return namespaceCaipNetwork;
        }
        const requestedCaipNetworks = ChainController.getRequestedCaipNetworks(chainNamespace);
        return requestedCaipNetworks.filter((c12) => c12.chainNamespace === chainNamespace)?.[0];
      }
      return ChainController.state.activeCaipNetwork || this.defaultCaipNetwork;
    };
    this.getCaipNetworkId = () => {
      const network = this.getCaipNetwork();
      if (network) {
        return network.id;
      }
      return void 0;
    };
    this.getCaipNetworks = (namespace) => ChainController.getCaipNetworks(namespace);
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain3) => {
      ChainController.setRequestedCaipNetworks(requestedCaipNetworks, chain3);
    };
    this.getApprovedCaipNetworkIds = () => ChainController.getAllApprovedCaipNetworkIds();
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.state.chains.get(chainNamespace)?.accountState?.caipAddress;
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getProvider = (namespace) => ProviderUtil.getProvider(namespace);
    this.getProviderType = (namespace) => ProviderUtil.getProviderId(namespace);
    this.getPreferredAccountType = (namespace) => getPreferredAccountType(namespace);
    this.setCaipAddress = (caipAddress, chain3) => {
      AccountController.setCaipAddress(caipAddress, chain3);
    };
    this.setBalance = (balance, balanceSymbol, chain3) => {
      AccountController.setBalance(balance, balanceSymbol, chain3);
    };
    this.setProfileName = (profileName, chain3) => {
      AccountController.setProfileName(profileName, chain3);
    };
    this.setProfileImage = (profileImage, chain3) => {
      AccountController.setProfileImage(profileImage, chain3);
    };
    this.setUser = (user, chain3) => {
      AccountController.setUser(user, chain3);
    };
    this.resetAccount = (chain3) => {
      AccountController.resetAccount(chain3);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.setCaipNetworkOfNamespace = (caipNetwork, chainNamespace) => {
      ChainController.setChainNetworkData(chainNamespace, { caipNetwork });
    };
    this.setStatus = (status, chain3) => {
      AccountController.setStatus(status, chain3);
      if (ConnectorController.isConnected()) {
        StorageUtil.setConnectionStatus("connected");
      } else {
        StorageUtil.setConnectionStatus("disconnected");
      }
    };
    this.getAddressByChainNamespace = (chainNamespace) => ChainController.state.chains.get(chainNamespace)?.accountState?.address;
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.state.allConnectors, ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.setConnections = (connections, chainNamespace) => {
      StorageUtil.setConnections(connections, chainNamespace);
      ConnectionController.setConnections(connections, chainNamespace);
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.getReownName = (address2) => EnsController.getNamesForAddress(address2);
    this.getConnectors = () => ConnectorController.getConnectors();
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.getConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).connections;
    };
    this.getRecentConnections = (namespace) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return [];
      }
      return ConnectionControllerUtil.getConnectionsData(namespace).recentConnections;
    };
    this.switchConnection = async (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      await ConnectionController.switchConnection(params);
    };
    this.deleteConnection = (params) => {
      if (!this.remoteFeatures.multiWallet) {
        AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
        return;
      }
      StorageUtil.deleteAddressFromConnection(params);
      ConnectionController.syncStorageConnections();
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain3) => {
      const type = ProviderUtil.getProviderId(chain3);
      const walletInfo = connectedWalletInfo ? { ...connectedWalletInfo, type } : void 0;
      AccountController.setConnectedWalletInfo(walletInfo, chain3);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.addAddressLabel = (address2, label, chain3) => {
      AccountController.addAddressLabel(address2, label, chain3);
    };
    this.removeAddressLabel = (address2, chain3) => {
      AccountController.removeAddressLabel(address2, chain3);
    };
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.state.chains.get(chainNamespace)?.accountState?.address;
    };
    this.setApprovedCaipNetworksData = (namespace) => ChainController.setApprovedCaipNetworksData(namespace);
    this.resetNetwork = (namespace) => {
      ChainController.resetNetwork(namespace);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.setAddressExplorerUrl = (addressExplorerUrl, chain3) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain3);
    };
    this.setSmartAccountDeployed = (isDeployed, chain3) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain3);
    };
    this.setPreferredAccountType = (preferredAccountType, chain3) => {
      ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain3);
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.options = options;
    this.version = options.sdkVersion;
    this.caipNetworks = this.extendCaipNetworks(options);
    this.chainNamespaces = this.getChainNamespacesSet(options.adapters, this.caipNetworks);
    this.defaultCaipNetwork = this.extendDefaultCaipNetwork(options);
    this.chainAdapters = this.createAdapters(options.adapters);
    this.readyPromise = this.initialize(options);
  }
  getChainNamespacesSet(adapters, caipNetworks) {
    const adapterNamespaces = adapters?.map((adapter) => adapter.namespace).filter((namespace) => Boolean(namespace));
    if (adapterNamespaces?.length) {
      return [...new Set(adapterNamespaces)];
    }
    const networkNamespaces = caipNetworks?.map((network) => network.chainNamespace);
    return [...new Set(networkNamespaces)];
  }
  async initialize(options) {
    this.initializeProjectSettings(options);
    this.initControllers(options);
    await this.initChainAdapters();
    this.sendInitializeEvent(options);
    if (OptionsController.state.enableReconnect) {
      await this.syncExistingConnection();
      await this.syncAdapterConnections();
    } else {
      await this.unSyncExistingConnection();
    }
    this.remoteFeatures = await ConfigUtil.fetchRemoteFeatures(options);
    OptionsController.setRemoteFeatures(this.remoteFeatures);
    if (this.remoteFeatures.onramp) {
      OnRampController.setOnrampProviders(this.remoteFeatures.onramp);
    }
    if (OptionsController.state.remoteFeatures?.email || Array.isArray(OptionsController.state.remoteFeatures?.socials) && OptionsController.state.remoteFeatures?.socials.length > 0) {
      await this.checkAllowedOrigins();
    }
  }
  async checkAllowedOrigins() {
    try {
      const allowedOrigins = await ApiController.fetchAllowedOrigins();
      if (!allowedOrigins || !CoreHelperUtil.isClient()) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      const currentOrigin = window.location.origin;
      const isOriginAllowed = WcHelpersUtil.isOriginAllowed(currentOrigin, allowedOrigins, WcConstantsUtil.DEFAULT_ALLOWED_ANCESTORS);
      if (!isOriginAllowed) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.ORIGIN_NOT_ALLOWED, "error");
      }
    } catch (error2) {
      if (!(error2 instanceof Error)) {
        AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
        return;
      }
      switch (error2.message) {
        case "RATE_LIMITED":
          AlertController.open(ErrorUtil.ALERT_ERRORS.RATE_LIMITED_APP_CONFIGURATION, "error");
          break;
        case "SERVER_ERROR": {
          const originalError = error2.cause instanceof Error ? error2.cause : error2;
          AlertController.open({
            displayMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.displayMessage,
            debugMessage: ErrorUtil.ALERT_ERRORS.SERVER_ERROR_APP_CONFIGURATION.debugMessage(originalError.message)
          }, "error");
          break;
        }
        default:
          AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      }
    }
  }
  sendInitializeEvent(options) {
    const { ...optionsCopy } = options;
    delete optionsCopy.adapters;
    delete optionsCopy.universalProvider;
    EventsController.sendEvent({
      type: "track",
      event: "INITIALIZE",
      properties: {
        ...optionsCopy,
        networks: options.networks.map((n12) => n12.id),
        siweConfig: {
          options: options.siweConfig?.options || {}
        }
      }
    });
  }
  // -- Controllers initialization ---------------------------------------------------
  initControllers(options) {
    this.initializeOptionsController(options);
    this.initializeChainController(options);
    this.initializeThemeController(options);
    this.initializeConnectionController(options);
    this.initializeConnectorController();
  }
  initializeThemeController(options) {
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  initializeChainController(options) {
    if (!this.connectionControllerClient || !this.networkControllerClient) {
      throw new Error("ConnectionControllerClient and NetworkControllerClient must be set");
    }
    ChainController.initialize(options.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient
    });
    const network = this.getDefaultNetwork();
    if (network) {
      ChainController.setActiveCaipNetwork(network);
    }
  }
  initializeConnectionController(options) {
    ConnectionController.initialize(options.adapters ?? []);
    ConnectionController.setWcBasic(options.basic ?? false);
  }
  initializeConnectorController() {
    ConnectorController.initialize(this.chainNamespaces);
  }
  initializeProjectSettings(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
  }
  initializeOptionsController(options) {
    OptionsController.setDebug(options.debug !== false);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWalletGuide(options.enableWalletGuide !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    OptionsController.setEIP6963Enabled(options.enableEIP6963 !== false);
    OptionsController.setEnableNetworkSwitch(options.enableNetworkSwitch !== false);
    OptionsController.setEnableReconnect(options.enableReconnect !== false);
    OptionsController.setEnableAuthLogger(options.enableAuthLogger !== false);
    OptionsController.setCustomRpcUrls(options.customRpcUrls);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setAllowUnsupportedChain(options.allowUnsupportedChain);
    OptionsController.setUniversalProviderConfigOverride(options.universalProviderConfigOverride);
    OptionsController.setPreferUniversalLinks(options.experimental_preferUniversalLinks);
    OptionsController.setDefaultAccountTypes(options.defaultAccountTypes);
    const defaultMetaData = this.getDefaultMetaData();
    if (!options.metadata && defaultMetaData) {
      options.metadata = defaultMetaData;
    }
    OptionsController.setMetadata(options.metadata);
    OptionsController.setDisableAppend(options.disableAppend);
    OptionsController.setEnableEmbedded(options.enableEmbedded);
    OptionsController.setSIWX(options.siwx);
    if (!options.projectId) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    const evmAdapter = options.adapters?.find((adapter) => adapter.namespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        if (options.siwx) {
          throw new Error("Cannot set both `siweConfig` and `siwx` options");
        }
        OptionsController.setSIWX(options.siweConfig.mapToSIWX());
      }
    }
  }
  getDefaultMetaData() {
    if (CoreHelperUtil.isClient()) {
      return {
        name: document.getElementsByTagName("title")?.[0]?.textContent || "",
        description: document.querySelector('meta[property="og:description"]')?.content || "",
        url: window.location.origin,
        icons: [document.querySelector('link[rel~="icon"]')?.href || ""]
      };
    }
    return null;
  }
  // -- Network Initialization ---------------------------------------------------
  setUnsupportedNetwork(chainId) {
    const namespace = this.getActiveChainNamespace();
    if (namespace) {
      const unsupportedNetwork = CaipNetworksUtil.getUnsupportedNetwork(`${namespace}:${chainId}`);
      ChainController.setActiveCaipNetwork(unsupportedNetwork);
    }
  }
  getDefaultNetwork() {
    return CaipNetworksUtil.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(network, options) {
    const extendedNetwork = CaipNetworksUtil.extendCaipNetwork(network, {
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    return extendedNetwork;
  }
  extendCaipNetworks(options) {
    const extendedNetworks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    });
    return extendedNetworks;
  }
  extendDefaultCaipNetwork(options) {
    const defaultNetwork = options.networks.find((n12) => n12.id === options.defaultNetwork?.id);
    const extendedNetwork = defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(defaultNetwork, {
      customNetworkImageUrls: options.chainImages,
      customRpcUrls: options.customRpcUrls,
      projectId: options.projectId
    }) : void 0;
    return extendedNetwork;
  }
  async disconnectNamespace(namespace, id) {
    try {
      this.setLoading(true, namespace);
      let disconnectResult = {
        connections: []
      };
      const adapter = this.getAdapter(namespace);
      const caipAddress = ChainController.state.chains.get(namespace)?.accountState?.caipAddress;
      if ((caipAddress || !OptionsController.state.enableReconnect) && adapter?.disconnect) {
        disconnectResult = await adapter.disconnect({ id });
      }
      this.setLoading(false, namespace);
      return disconnectResult;
    } catch (error2) {
      this.setLoading(false, namespace);
      throw new Error(`Failed to disconnect chains: ${error2.message}`);
    }
  }
  // -- Client Initialization ---------------------------------------------------
  createClients() {
    this.connectionControllerClient = {
      connectWalletConnect: async () => {
        const activeChain = ChainController.state.activeChain;
        const adapter = this.getAdapter(activeChain);
        const chainId = this.getCaipNetwork(activeChain)?.id;
        const connections = ConnectionController.getConnections(activeChain);
        const isMultiWallet = this.remoteFeatures.multiWallet;
        const hasConnections = connections.length > 0;
        if (!adapter) {
          throw new Error("Adapter not found");
        }
        const result = await adapter.connectWalletConnect(chainId);
        const shouldClose = !hasConnections || !isMultiWallet;
        if (shouldClose) {
          this.close();
        }
        this.setClientId(result?.clientId || null);
        StorageUtil.setConnectedNamespaces([...ChainController.state.chains.keys()]);
        await this.syncWalletConnectAccount();
        await SIWXUtil.initializeIfEnabled();
      },
      connectExternal: async ({ id, address: address2, info, type, provider, chain: chain3, caipNetwork, socialUri }) => {
        const activeChain = ChainController.state.activeChain;
        const namespace = chain3 || activeChain;
        const adapter = this.getAdapter(namespace);
        if (chain3 && chain3 !== activeChain && !caipNetwork) {
          const toConnectNetwork = this.getCaipNetworks().find((network) => network.chainNamespace === chain3);
          if (toConnectNetwork) {
            this.setCaipNetwork(toConnectNetwork);
          }
        }
        if (!namespace) {
          throw new Error("connectExternal: namespace not found");
        }
        if (!adapter) {
          throw new Error("connectExternal: adapter not found");
        }
        const fallbackCaipNetwork = this.getCaipNetwork(namespace);
        const res = await adapter.connect({
          id,
          address: address2,
          info,
          type,
          provider,
          socialUri,
          chainId: caipNetwork?.id || fallbackCaipNetwork?.id,
          rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0] || fallbackCaipNetwork?.rpcUrls?.default?.http?.[0]
        });
        if (!res) {
          return void 0;
        }
        StorageUtil.addConnectedNamespace(namespace);
        this.syncProvider({ ...res, chainNamespace: namespace });
        this.setStatus("connected", namespace);
        this.syncConnectedWalletInfo(namespace);
        StorageUtil.removeDisconnectedConnectorId(id, namespace);
        return { address: res.address };
      },
      reconnectExternal: async ({ id, info, type, provider }) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("reconnectExternal: namespace not found");
        }
        if (!adapter) {
          throw new Error("reconnectExternal: adapter not found");
        }
        if (adapter?.reconnect) {
          await adapter?.reconnect({ id, info, type, provider, chainId: this.getCaipNetwork()?.id });
          StorageUtil.addConnectedNamespace(namespace);
          this.syncConnectedWalletInfo(namespace);
        }
      },
      disconnect: async (params) => {
        const { id: connectorIdParam, chainNamespace, initialDisconnect } = params || {};
        const namespace = chainNamespace || ChainController.state.activeChain;
        const namespaceConnectorId = ConnectorController.getConnectorId(namespace);
        const isAuth = connectorIdParam === ConstantsUtil.CONNECTOR_ID.AUTH || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
        const isWalletConnect = connectorIdParam === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT || namespaceConnectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
        try {
          const namespaces = Array.from(ChainController.state.chains.keys());
          let namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
          if (isWalletConnect || isAuth) {
            namespacesToDisconnect = namespaces;
          }
          const disconnectPromises = namespacesToDisconnect.map(async (ns3) => {
            const connectorIdToDisconnect = ConnectorController.getConnectorId(ns3);
            const disconnectData = await this.disconnectNamespace(ns3, connectorIdParam || connectorIdToDisconnect);
            if (disconnectData) {
              if (isAuth) {
                StorageUtil.deleteConnectedSocialProvider();
              }
              disconnectData.connections.forEach((connection) => {
                StorageUtil.addDisconnectedConnectorId(connection.connectorId, ns3);
              });
            }
            if (initialDisconnect) {
              this.onDisconnectNamespace({ chainNamespace: ns3, closeModal: false });
            }
          });
          const disconnectResults = await Promise.allSettled(disconnectPromises);
          SendController.resetSend();
          ConnectionController.resetWcConnection();
          if (SIWXUtil.getSIWX()?.signOutOnDisconnect) {
            await SIWXUtil.clearSessions();
          }
          ConnectorController.setFilterByNamespace(void 0);
          ConnectionController.syncStorageConnections();
          const failures = disconnectResults.filter((result) => result.status === "rejected");
          if (failures.length > 0) {
            throw new Error(failures.map((f13) => f13.reason.message).join(", "));
          }
          EventsController.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: {
              namespace: chainNamespace || "all"
            }
          });
        } catch (error2) {
          throw new Error(`Failed to disconnect chains: ${error2.message}`);
        }
      },
      checkInstalled: (ids) => {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        return ids.some((id) => Boolean(window.ethereum?.[String(id)]));
      },
      signMessage: async (message) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!namespace) {
          throw new Error("signMessage: namespace not found");
        }
        if (!adapter) {
          throw new Error("signMessage: adapter not found");
        }
        const result = await adapter?.signMessage({
          message,
          address: AccountController.state.address,
          provider: ProviderUtil.getProvider(namespace)
        });
        return result?.signature || "";
      },
      sendTransaction: async (args) => {
        const namespace = args.chainNamespace;
        if (!namespace) {
          throw new Error("sendTransaction: namespace not found");
        }
        if (ConstantsUtil2.SEND_SUPPORTED_NAMESPACES.includes(namespace)) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("sendTransaction: adapter not found");
          }
          const provider = ProviderUtil.getProvider(namespace);
          const result = await adapter?.sendTransaction({
            ...args,
            caipNetwork: this.getCaipNetwork(),
            provider
          });
          return result?.hash || "";
        }
        return "";
      },
      estimateGas: async (args) => {
        const namespace = args.chainNamespace;
        if (namespace === ConstantsUtil.CHAIN.EVM) {
          const adapter = this.getAdapter(namespace);
          if (!adapter) {
            throw new Error("estimateGas: adapter is required but got undefined");
          }
          const provider = ProviderUtil.getProvider(namespace);
          const caipNetwork = this.getCaipNetwork();
          if (!caipNetwork) {
            throw new Error("estimateGas: caipNetwork is required but got undefined");
          }
          const result = await adapter?.estimateGas({ ...args, provider, caipNetwork });
          return result?.gas || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        const namespace = ChainController.state.activeChain;
        if (!namespace) {
          throw new Error("getEnsAvatar: namespace is required but got undefined");
        }
        await this.syncIdentity({
          address: AccountController.state.address,
          chainId: Number(this.getCaipNetwork()?.id),
          chainNamespace: namespace
        });
        return AccountController.state.profileImage || false;
      },
      getEnsAddress: async (name2) => await WcHelpersUtil.resolveReownName(name2),
      writeContract: async (args) => {
        const namespace = ChainController.state.activeChain;
        const adapter = this.getAdapter(namespace);
        if (!namespace) {
          throw new Error("writeContract: namespace is required but got undefined");
        }
        if (!adapter) {
          throw new Error("writeContract: adapter is required but got undefined");
        }
        const caipNetwork = this.getCaipNetwork();
        const caipAddress = this.getCaipAddress();
        const provider = ProviderUtil.getProvider(namespace);
        if (!caipNetwork || !caipAddress) {
          throw new Error("writeContract: caipNetwork or caipAddress is required but got undefined");
        }
        const result = await adapter?.writeContract({ ...args, caipNetwork, provider, caipAddress });
        return result?.hash;
      },
      parseUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("parseUnits: adapter is required but got undefined");
        }
        return adapter?.parseUnits({ value, decimals }) ?? 0n;
      },
      formatUnits: (value, decimals) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("formatUnits: adapter is required but got undefined");
        }
        return adapter?.formatUnits({ value, decimals }) ?? "0";
      },
      getCapabilities: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("getCapabilities: adapter is required but got undefined");
        }
        return await adapter?.getCapabilities(params);
      },
      grantPermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("grantPermissions: adapter is required but got undefined");
        }
        return await adapter?.grantPermissions(params);
      },
      revokePermissions: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("revokePermissions: adapter is required but got undefined");
        }
        if (adapter?.revokePermissions) {
          return await adapter.revokePermissions(params);
        }
        return "0x";
      },
      walletGetAssets: async (params) => {
        const adapter = this.getAdapter(ChainController.state.activeChain);
        if (!adapter) {
          throw new Error("walletGetAssets: adapter is required but got undefined");
        }
        return await adapter?.walletGetAssets(params) ?? {};
      },
      updateBalance: (namespace) => {
        const caipNetwork = this.getCaipNetwork(namespace);
        if (!caipNetwork || !AccountController.state.address) {
          return;
        }
        this.updateNativeBalance(AccountController.state.address, caipNetwork?.id, namespace);
      }
    };
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => await this.switchCaipNetwork(caipNetwork),
      // eslint-disable-next-line @typescript-eslint/require-await
      getApprovedCaipNetworksData: async () => this.getApprovedCaipNetworksData()
    };
    ConnectionController.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    const providerType = ProviderUtil.getProviderId(ChainController.state.activeChain);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const namespaces = this.universalProvider?.session?.namespaces;
      return {
        /*
         * MetaMask Wallet only returns 1 namespace in the session object. This makes it imposible
         * to switch to other networks. Setting supportsAllNetworks to true for MetaMask Wallet
         * will make it possible to switch to other networks.
         */
        supportsAllNetworks: this.universalProvider?.session?.peer?.metadata.name === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(namespaces)
      };
    }
    return { supportsAllNetworks: true, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(caipNetwork.chainNamespace);
    if (namespaceAddress) {
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      if (caipNetwork.chainNamespace === ChainController.state.activeChain) {
        const adapter = this.getAdapter(networkNamespace);
        await adapter?.switchNetwork({ caipNetwork, provider, providerType });
      } else {
        this.setCaipNetwork(caipNetwork);
        if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
          this.syncWalletConnectAccount();
        } else {
          const address2 = this.getAddressByChainNamespace(networkNamespace);
          if (address2) {
            this.syncAccount({
              address: address2,
              chainId: caipNetwork.id,
              chainNamespace: networkNamespace
            });
          }
        }
      }
    } else {
      this.setCaipNetwork(caipNetwork);
    }
  }
  getChainsFromNamespaces(namespaces = {}) {
    return Object.values(namespaces).flatMap((namespace) => {
      const chains = namespace.chains || [];
      const accountsChains = namespace.accounts.map((account) => {
        const { chainId, chainNamespace } = ParseUtil.parseCaipAddress(account);
        return `${chainNamespace}:${chainId}`;
      });
      return Array.from(/* @__PURE__ */ new Set([...chains, ...accountsChains]));
    });
  }
  // -- Adapter Initialization ---------------------------------------------------
  createAdapters(blueprints) {
    this.createClients();
    return this.chainNamespaces.reduce((adapters, namespace) => {
      const blueprint = blueprints?.find((b7) => b7.namespace === namespace);
      if (blueprint) {
        blueprint.construct({
          namespace,
          projectId: this.options?.projectId,
          networks: this.getCaipNetworks()
        });
        adapters[namespace] = blueprint;
      } else {
        adapters[namespace] = new UniversalAdapter({
          namespace,
          networks: this.getCaipNetworks()
        });
      }
      return adapters;
    }, {});
  }
  async initChainAdapter(namespace) {
    this.onConnectors(namespace);
    this.listenAdapter(namespace);
    await this.chainAdapters?.[namespace].syncConnectors(this.options, this);
    await this.createUniversalProviderForAdapter(namespace);
  }
  async initChainAdapters() {
    await Promise.all(this.chainNamespaces.map(async (namespace) => {
      await this.initChainAdapter(namespace);
    }));
  }
  onConnectors(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    adapter?.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(chainNamespace) {
    const adapter = this.getAdapter(chainNamespace);
    if (!adapter) {
      return;
    }
    const connectionStatus = StorageUtil.getConnectionStatus();
    if (OptionsController.state.enableReconnect === false) {
      this.setStatus("disconnected", chainNamespace);
    } else if (connectionStatus === "connected") {
      this.setStatus("connecting", chainNamespace);
    } else if (connectionStatus === "disconnected") {
      StorageUtil.clearAddressCache();
      this.setStatus(connectionStatus, chainNamespace);
    } else {
      this.setStatus(connectionStatus, chainNamespace);
    }
    adapter.on("switchNetwork", ({ address: address2, chainId }) => {
      const caipNetwork = this.getCaipNetworks().find((n12) => n12.id.toString() === chainId.toString() || n12.caipNetworkId.toString() === chainId.toString());
      const isSameNamespace = ChainController.state.activeChain === chainNamespace;
      const accountAddress = ChainController.state.chains.get(chainNamespace)?.accountState?.address;
      if (caipNetwork) {
        const account = isSameNamespace && address2 ? address2 : accountAddress;
        if (account) {
          this.syncAccount({ address: account, chainId: caipNetwork.id, chainNamespace });
        }
      } else {
        this.setUnsupportedNetwork(chainId);
      }
    });
    adapter.on("disconnect", () => {
      const isMultiWallet = this.remoteFeatures.multiWallet;
      const allConnections = Array.from(ConnectionController.state.connections.values()).flat();
      this.onDisconnectNamespace({
        chainNamespace,
        closeModal: !isMultiWallet || allConnections.length === 0
      });
    });
    adapter.on("connections", (connections) => {
      this.setConnections(connections, chainNamespace);
    });
    adapter.on("pendingTransactions", () => {
      const address2 = AccountController.state.address;
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      if (!address2 || !activeCaipNetwork?.id) {
        return;
      }
      this.updateNativeBalance(address2, activeCaipNetwork.id, activeCaipNetwork.chainNamespace);
    });
    adapter.on("accountChanged", ({ address: address2, chainId, connector }) => {
      const isActiveChain = ChainController.state.activeChain === chainNamespace;
      if (connector?.provider) {
        this.syncProvider({
          id: connector.id,
          type: connector.type,
          provider: connector.provider,
          chainNamespace
        });
        this.syncConnectedWalletInfo(chainNamespace);
      }
      if (isActiveChain && chainId) {
        this.syncAccount({
          address: address2,
          chainId,
          chainNamespace
        });
      } else if (isActiveChain && ChainController.state.activeCaipNetwork?.id) {
        this.syncAccount({
          address: address2,
          chainId: ChainController.state.activeCaipNetwork?.id,
          chainNamespace
        });
      } else {
        this.syncAccountInfo(address2, chainId, chainNamespace);
      }
      StorageUtil.addConnectedNamespace(chainNamespace);
    });
  }
  async createUniversalProviderForAdapter(chainNamespace) {
    await this.getUniversalProvider();
    if (this.universalProvider) {
      await this.chainAdapters?.[chainNamespace]?.setUniversalProvider?.(this.universalProvider);
    }
  }
  // -- Connection Sync ---------------------------------------------------
  async syncExistingConnection() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => this.syncNamespaceConnection(namespace)));
  }
  async unSyncExistingConnection() {
    try {
      await Promise.allSettled(this.chainNamespaces.map((namespace) => ConnectionController.disconnect({ namespace, initialDisconnect: true })));
    } catch (error2) {
      console.error("Error disconnecting existing connections:", error2);
    }
  }
  async syncNamespaceConnection(namespace) {
    try {
      if (namespace === ConstantsUtil.CHAIN.EVM && CoreHelperUtil.isSafeApp()) {
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.SAFE, namespace);
      }
      const connectorId = ConnectorController.getConnectorId(namespace);
      this.setStatus("connecting", namespace);
      switch (connectorId) {
        case ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case ConstantsUtil.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(namespace);
      }
    } catch (err2) {
      console.warn("AppKit couldn't sync existing connection", err2);
      this.setStatus("disconnected", namespace);
    }
  }
  onDisconnectNamespace(options) {
    const { chainNamespace, closeModal } = options || {};
    ChainController.resetAccount(chainNamespace);
    ChainController.resetNetwork(chainNamespace);
    StorageUtil.removeConnectedNamespace(chainNamespace);
    const namespaces = Array.from(ChainController.state.chains.keys());
    const namespacesToDisconnect = chainNamespace ? [chainNamespace] : namespaces;
    namespacesToDisconnect.forEach((ns3) => StorageUtil.addDisconnectedConnectorId(ConnectorController.getConnectorId(ns3) || "", ns3));
    ConnectorController.removeConnectorId(chainNamespace);
    ProviderUtil.resetChain(chainNamespace);
    this.setUser(void 0, chainNamespace);
    this.setStatus("disconnected", chainNamespace);
    this.setConnectedWalletInfo(void 0, chainNamespace);
    if (closeModal !== false) {
      ModalController.close();
    }
  }
  async syncAdapterConnections() {
    await Promise.allSettled(this.chainNamespaces.map((namespace) => {
      const caipAddress = this.getCaipAddress(namespace);
      const caipNetwork = this.getCaipNetwork(namespace);
      return this.chainAdapters?.[namespace].syncConnections({
        connectToFirstConnector: !caipAddress,
        caipNetwork,
        getConnectorStorageInfo(connectorId) {
          const storageConnectionsByNamespace = StorageUtil.getConnections();
          const storageConnections = storageConnectionsByNamespace[namespace] ?? [];
          return {
            hasDisconnected: StorageUtil.isConnectorDisconnected(connectorId, namespace),
            hasConnected: storageConnections.some((c12) => HelpersUtil.isLowerCaseMatch(c12.connectorId, connectorId))
          };
        }
      });
    }));
  }
  async syncAdapterConnection(namespace) {
    const adapter = this.getAdapter(namespace);
    const connectorId = ConnectorController.getConnectorId(namespace);
    const caipNetwork = this.getCaipNetwork(namespace);
    const connectors = ConnectorController.getConnectors(namespace);
    const connector = connectors.find((c12) => c12.id === connectorId);
    try {
      if (!adapter || !connector) {
        throw new Error(`Adapter or connector not found for namespace ${namespace}`);
      }
      if (!caipNetwork?.id) {
        throw new Error("CaipNetwork not found");
      }
      const connection = await adapter?.syncConnection({
        namespace,
        id: connector.id,
        chainId: caipNetwork.id,
        rpcUrl: caipNetwork?.rpcUrls?.default?.http?.[0]
      });
      if (connection) {
        this.syncProvider({ ...connection, chainNamespace: namespace });
        await this.syncAccount({ ...connection, chainNamespace: namespace });
        this.setStatus("connected", namespace);
      } else {
        this.setStatus("disconnected", namespace);
      }
    } catch (e10) {
      this.onDisconnectNamespace({ chainNamespace: namespace, closeModal: false });
    }
  }
  async syncWalletConnectAccount() {
    const sessionNamespaces = Object.keys(this.universalProvider?.session?.namespaces || {});
    const syncTasks = this.chainNamespaces.map(async (chainNamespace) => {
      const adapter = this.getAdapter(chainNamespace);
      if (!adapter) {
        return;
      }
      const namespaceAccounts = this.universalProvider?.session?.namespaces?.[chainNamespace]?.accounts || [];
      const activeChainId = ChainController.state.activeCaipNetwork?.id;
      const sessionAddress = namespaceAccounts.find((account) => {
        const { chainId } = ParseUtil.parseCaipAddress(account);
        return chainId === activeChainId?.toString();
      }) || namespaceAccounts[0];
      if (sessionAddress) {
        const caipAddress = ParseUtil.validateCaipAddress(sessionAddress);
        const { chainId, address: address2 } = ParseUtil.parseCaipAddress(caipAddress);
        ProviderUtil.setProviderId(chainNamespace, ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT);
        if (this.caipNetworks && ChainController.state.activeCaipNetwork && adapter.namespace !== ConstantsUtil.CHAIN.EVM) {
          const provider = adapter.getWalletConnectProvider({
            caipNetworks: this.getCaipNetworks(),
            provider: this.universalProvider,
            activeCaipNetwork: ChainController.state.activeCaipNetwork
          });
          ProviderUtil.setProvider(chainNamespace, provider);
        } else {
          ProviderUtil.setProvider(chainNamespace, this.universalProvider);
        }
        ConnectorController.setConnectorId(ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT, chainNamespace);
        StorageUtil.addConnectedNamespace(chainNamespace);
        await this.syncAccount({
          address: address2,
          chainId,
          chainNamespace
        });
      } else if (sessionNamespaces.includes(chainNamespace)) {
        this.setStatus("disconnected", chainNamespace);
      }
      this.syncConnectedWalletInfo(chainNamespace);
      await ChainController.setApprovedCaipNetworksData(chainNamespace);
    });
    await Promise.all(syncTasks);
  }
  syncProvider({ type, provider, id, chainNamespace }) {
    ProviderUtil.setProviderId(chainNamespace, type);
    ProviderUtil.setProvider(chainNamespace, provider);
    ConnectorController.setConnectorId(id, chainNamespace);
  }
  async syncAccount(params) {
    const isActiveNamespace = params.chainNamespace === ChainController.state.activeChain;
    const networkOfChain = ChainController.getCaipNetworkByNamespace(params.chainNamespace, params.chainId);
    const { address: address2, chainId, chainNamespace } = params;
    const { chainId: activeChainId } = StorageUtil.getActiveNetworkProps();
    const chainIdToUse = chainId || activeChainId;
    const isUnsupportedNetwork = ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME;
    const shouldSupportAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", chainNamespace);
    this.setStatus("connected", chainNamespace);
    if (isUnsupportedNetwork && !shouldSupportAllNetworks) {
      return;
    }
    if (chainIdToUse) {
      let caipNetwork = this.getCaipNetworks().find((n12) => n12.id.toString() === chainIdToUse.toString());
      let fallbackCaipNetwork = this.getCaipNetworks().find((n12) => n12.chainNamespace === chainNamespace);
      if (!shouldSupportAllNetworks && !caipNetwork && !fallbackCaipNetwork) {
        const caipNetworkIds = this.getApprovedCaipNetworkIds() || [];
        const caipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainId === chainIdToUse.toString());
        const fallBackCaipNetworkId = caipNetworkIds.find((id) => ParseUtil.parseCaipNetworkId(id)?.chainNamespace === chainNamespace);
        caipNetwork = this.getCaipNetworks().find((n12) => n12.caipNetworkId === caipNetworkId);
        fallbackCaipNetwork = this.getCaipNetworks().find((n12) => n12.caipNetworkId === fallBackCaipNetworkId || // This is a workaround used in Solana network to support deprecated caipNetworkId
        "deprecatedCaipNetworkId" in n12 && n12.deprecatedCaipNetworkId === fallBackCaipNetworkId);
      }
      const network = caipNetwork || fallbackCaipNetwork;
      if (network?.chainNamespace === ChainController.state.activeChain) {
        if (OptionsController.state.enableNetworkSwitch && !OptionsController.state.allowUnsupportedChain && ChainController.state.activeCaipNetwork?.name === ConstantsUtil.UNSUPPORTED_NETWORK_NAME) {
          ChainController.showUnsupportedChainUI();
        } else {
          this.setCaipNetwork(network);
        }
      } else if (!isActiveNamespace) {
        if (networkOfChain) {
          this.setCaipNetworkOfNamespace(networkOfChain, chainNamespace);
        }
      }
      this.syncConnectedWalletInfo(chainNamespace);
      if (!HelpersUtil.isLowerCaseMatch(address2, AccountController.state.address)) {
        this.syncAccountInfo(address2, network?.id, chainNamespace);
      }
      if (isActiveNamespace) {
        await this.syncBalance({ address: address2, chainId: network?.id, chainNamespace });
      } else {
        await this.syncBalance({ address: address2, chainId: networkOfChain?.id, chainNamespace });
      }
    }
  }
  async syncAccountInfo(address2, chainId, chainNamespace) {
    const caipAddress = this.getCaipAddress(chainNamespace);
    const newChainId = chainId || caipAddress?.split(":")[1];
    if (!newChainId) {
      return;
    }
    const newCaipAddress = `${chainNamespace}:${newChainId}:${address2}`;
    this.setCaipAddress(newCaipAddress, chainNamespace);
    await this.syncIdentity({
      address: address2,
      chainId: newChainId,
      chainNamespace
    });
  }
  async syncReownName(address2, chainNamespace) {
    try {
      const registeredWcNames = await this.getReownName(address2);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.setProfileName(wcName.name, chainNamespace);
      } else {
        this.setProfileName(null, chainNamespace);
      }
    } catch {
      this.setProfileName(null, chainNamespace);
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    const connectorId = ConnectorController.getConnectorId(chainNamespace);
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_ANNOUNCED || providerType === ConstantsUtil3.CONNECTOR_TYPE_INJECTED) {
      if (connectorId) {
        const connectors = this.getConnectors();
        const connector = connectors.find((c12) => {
          const isConnectorId = c12.id === connectorId;
          const isRdns = c12.info?.rdns === connectorId;
          const hasMultiChainConnector = c12.connectors?.some((_c2) => _c2.id === connectorId || _c2.info?.rdns === connectorId);
          return isConnectorId || isRdns || Boolean(hasMultiChainConnector);
        });
        if (connector) {
          const { info, name: name2, imageUrl } = connector;
          const icon = imageUrl || this.getConnectorImage(connector);
          this.setConnectedWalletInfo({ name: name2, icon, ...info }, chainNamespace);
        }
      }
    } else if (providerType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
      const provider = ProviderUtil.getProvider(chainNamespace);
      if (provider?.session) {
        this.setConnectedWalletInfo({
          ...provider.session.peer.metadata,
          name: provider.session.peer.metadata.name,
          icon: provider.session.peer.metadata.icons?.[0]
        }, chainNamespace);
      }
    } else if (connectorId) {
      if (connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE_SDK || connectorId === ConstantsUtil.CONNECTOR_ID.COINBASE) {
        const connector = this.getConnectors().find((c12) => c12.id === connectorId);
        const name2 = connector?.name || "Coinbase Wallet";
        const icon = connector?.imageUrl || this.getConnectorImage(connector);
        const info = connector?.info;
        this.setConnectedWalletInfo({
          ...info,
          name: name2,
          icon
        }, chainNamespace);
      }
    }
  }
  async syncBalance(params) {
    const caipNetwork = NetworkUtil.getNetworksByNamespace(this.getCaipNetworks(), params.chainNamespace).find((n12) => n12.id.toString() === params.chainId?.toString());
    if (!caipNetwork || !params.chainId) {
      return;
    }
    await this.updateNativeBalance(params.address, params.chainId, params.chainNamespace);
  }
  async ready() {
    await this.readyPromise;
  }
  async updateNativeBalance(address2, chainId, namespace) {
    const adapter = this.getAdapter(namespace);
    const caipNetwork = ChainController.getCaipNetworkByNamespace(namespace, chainId);
    if (adapter) {
      const balance = await adapter.getBalance({
        address: address2,
        chainId,
        caipNetwork,
        tokens: this.options.tokens
      });
      this.setBalance(balance.balance, balance.symbol, namespace);
      return balance;
    }
    return void 0;
  }
  // -- Universal Provider ---------------------------------------------------
  async initializeUniversalAdapter() {
    const logger = LoggerUtil.createLogger((error2, ...args) => {
      if (error2) {
        this.handleAlertError(error2);
      }
      console.error(...args);
    });
    const universalProviderOptions = {
      projectId: this.options?.projectId,
      metadata: {
        name: this.options?.metadata ? this.options?.metadata.name : "",
        description: this.options?.metadata ? this.options?.metadata.description : "",
        url: this.options?.metadata ? this.options?.metadata.url : "",
        icons: this.options?.metadata ? this.options?.metadata.icons : [""]
      },
      logger
    };
    OptionsController.setManualWCControl(Boolean(this.options?.manualWCControl));
    this.universalProvider = this.options.universalProvider ?? await G4.init(universalProviderOptions);
    if (OptionsController.state.enableReconnect === false && this.universalProvider.session) {
      await this.universalProvider.disconnect();
    }
    this.listenWalletConnect();
  }
  listenWalletConnect() {
    if (this.universalProvider) {
      this.chainNamespaces.forEach((namespace) => {
        WcHelpersUtil.listenWcProvider({
          universalProvider: this.universalProvider,
          namespace,
          onDisplayUri: (uri) => {
            ConnectionController.setUri(uri);
          },
          onConnect: () => {
            ConnectionController.finalizeWcConnection();
          },
          onDisconnect: () => {
            if (ChainController.state.noAdapters) {
              this.resetAccount(namespace);
            }
            ConnectionController.resetWcConnection();
          },
          onChainChanged: (chainId) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              const caipNetwork = this.getCaipNetworks().find((n12) => n12.id.toString() === chainId.toString() || n12.caipNetworkId.toString() === chainId.toString());
              const currentCaipNetwork = this.getCaipNetwork();
              if (!caipNetwork) {
                this.setUnsupportedNetwork(chainId);
                return;
              }
              if (currentCaipNetwork?.id.toString() !== caipNetwork?.id.toString() && currentCaipNetwork?.chainNamespace === caipNetwork?.chainNamespace) {
                this.setCaipNetwork(caipNetwork);
              }
            }
          },
          onAccountsChanged: (accounts) => {
            const activeNamespace = ChainController.state.activeChain;
            const isCurrentConnectorWalletConnect = activeNamespace && ConnectorController.state.activeConnectorIds[activeNamespace] === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
            if (activeNamespace === namespace && (ChainController.state.noAdapters || isCurrentConnectorWalletConnect)) {
              if (accounts.length > 0) {
                const account = accounts[0];
                this.syncAccount({
                  address: account.address,
                  chainId: account.chainId,
                  chainNamespace: account.chainNamespace
                });
              }
            }
          }
        });
      });
    }
  }
  createUniversalProvider() {
    if (!this.universalProviderInitPromise && CoreHelperUtil.isClient() && this.options?.projectId) {
      this.universalProviderInitPromise = this.initializeUniversalAdapter();
    }
    return this.universalProviderInitPromise;
  }
  async getUniversalProvider() {
    if (!this.universalProvider) {
      try {
        await this.createUniversalProvider();
      } catch (err2) {
        EventsController.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: err2 instanceof Error ? err2.message : "Unknown",
            uncaught: false
          }
        });
        console.error("AppKit:getUniversalProvider - Cannot create provider", err2);
      }
    }
    return this.universalProvider;
  }
  // - Utils -------------------------------------------------------------------
  handleAlertError(error2) {
    const matchedUniversalProviderError = Object.entries(ErrorUtil.UniversalProviderErrors).find(([, { message: message2 }]) => error2.message.includes(message2));
    const [errorKey, errorValue] = matchedUniversalProviderError ?? [];
    const { message, alertErrorKey } = errorValue ?? {};
    if (errorKey && message && !this.reportedAlertErrors[errorKey]) {
      const alertError = ErrorUtil.ALERT_ERRORS[alertErrorKey];
      if (alertError) {
        AlertController.open(alertError, "error");
        this.reportedAlertErrors[errorKey] = true;
      }
    }
  }
  getAdapter(namespace) {
    if (!namespace) {
      return void 0;
    }
    return this.chainAdapters?.[namespace];
  }
  createAdapter(blueprint) {
    if (!blueprint) {
      return;
    }
    const namespace = blueprint.namespace;
    if (!namespace) {
      return;
    }
    this.createClients();
    const adapterBlueprint = blueprint;
    adapterBlueprint.namespace = namespace;
    adapterBlueprint.construct({
      namespace,
      projectId: this.options?.projectId,
      networks: this.getCaipNetworks()
    });
    if (!this.chainNamespaces.includes(namespace)) {
      this.chainNamespaces.push(namespace);
    }
    if (this.chainAdapters) {
      this.chainAdapters[namespace] = adapterBlueprint;
    }
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.injectModalUi();
    if (options?.uri) {
      ConnectionController.setUri(options.uri);
    }
    if (options?.arguments) {
      switch (options?.view) {
        case "Swap":
          return ModalController.open({ ...options, data: { swap: options.arguments } });
        default:
      }
    }
    return ModalController.open(options);
  }
  async close() {
    await this.injectModalUi();
    ModalController.close();
  }
  setLoading(loading, namespace) {
    ModalController.setLoading(loading, namespace);
  }
  async disconnect(chainNamespace) {
    await ConnectionController.disconnect({ namespace: chainNamespace });
  }
  getSIWX() {
    return OptionsController.state.siwx;
  }
  // -- review these -------------------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    return ChainController.state.activeCaipNetwork?.id;
  }
  async switchNetwork(appKitNetwork) {
    const network = this.getCaipNetworks().find((n12) => n12.id === appKitNetwork.id);
    if (!network) {
      AlertController.open(ErrorUtil.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await ChainController.switchActiveNetwork(network);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ProviderUtil.getProviderId(ChainController.state.activeChain);
  }
  subscribeProviders(callback) {
    return ProviderUtil.subscribeProviders(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setTermsConditionsUrl(termsConditionsUrl) {
    OptionsController.setTermsConditionsUrl(termsConditionsUrl);
  }
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    OptionsController.setPrivacyPolicyUrl(privacyPolicyUrl);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  subscribeConnections(callback) {
    if (!this.remoteFeatures.multiWallet) {
      AlertController.open(ConstantsUtil.REMOTE_FEATURES_ALERTS.MULTI_WALLET_NOT_ENABLED.DEFAULT, "info");
      return () => void 0;
    }
    return ConnectionController.subscribe(callback);
  }
  getWalletInfo(namespace) {
    if (namespace) {
      return ChainController.state.chains.get(namespace)?.accountState?.connectedWalletInfo;
    }
    return AccountController.state.connectedWalletInfo;
  }
  getAccount(_namespace) {
    const namespace = _namespace || ChainController.state.activeChain;
    const authConnector = ConnectorController.getAuthConnector(namespace);
    const accountState2 = ChainController.getAccountData(namespace);
    const activeConnectorId = StorageUtil.getConnectedConnectorId(ChainController.state.activeChain);
    const connections = ConnectionController.getConnections(namespace);
    if (!namespace) {
      throw new Error("AppKit:getAccount - namespace is required");
    }
    const allAccounts = connections.flatMap((connection) => connection.accounts.map(({ address: address2, type }) => CoreHelperUtil.createAccount(namespace, address2, type || "eoa")));
    if (!accountState2) {
      return void 0;
    }
    return {
      allAccounts,
      caipAddress: accountState2.caipAddress,
      address: CoreHelperUtil.getPlainAddress(accountState2.caipAddress),
      isConnected: Boolean(accountState2.caipAddress),
      status: accountState2.status,
      embeddedWalletInfo: authConnector && activeConnectorId === ConstantsUtil.CONNECTOR_ID.AUTH ? {
        user: accountState2.user ? {
          ...accountState2.user,
          /*
           * Getting the username from the chain controller works well for social logins,
           * but Farcaster uses a different connection flow and doesn't emit the username via events.
           * Since the username is stored in local storage before the chain controller updates,
           * it's safe to use the local storage value here.
           */
          username: StorageUtil.getConnectedSocialUsername()
        } : void 0,
        authProvider: accountState2.socialProvider || "email",
        accountType: getPreferredAccountType(namespace),
        isSmartAccountDeployed: Boolean(accountState2.smartAccountDeployed)
      } : void 0
    };
  }
  subscribeAccount(callback, namespace) {
    const updateVal = () => {
      const account = this.getAccount(namespace);
      if (!account) {
        return;
      }
      callback(account);
    };
    if (namespace) {
      ChainController.subscribeChainProp("accountState", updateVal, namespace);
    } else {
      ChainController.subscribe(updateVal);
    }
    ConnectorController.subscribe(updateVal);
  }
  subscribeNetwork(callback) {
    return ChainController.subscribe(({ activeCaipNetwork }) => {
      callback({
        caipNetwork: activeCaipNetwork,
        chainId: activeCaipNetwork?.id,
        caipNetworkId: activeCaipNetwork?.caipNetworkId
      });
    });
  }
  subscribeWalletInfo(callback, namespace) {
    if (namespace) {
      return AccountController.subscribeKey("connectedWalletInfo", callback, namespace);
    }
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    ChainController.subscribeKey("activeCaipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  getRemoteFeatures() {
    return OptionsController.state.remoteFeatures;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  subscribeRemoteFeatures(callback) {
    return OptionsController.subscribeKey("remoteFeatures", callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(status) {
    RouterController.popTransactionStack(status);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(newFeatures) {
    OptionsController.setFeatures(newFeatures);
  }
  updateRemoteFeatures(newRemoteFeatures) {
    OptionsController.setRemoteFeatures(newRemoteFeatures);
  }
  updateOptions(newOptions) {
    const currentOptions = OptionsController.state || {};
    const updatedOptions = { ...currentOptions, ...newOptions };
    OptionsController.setOptions(updatedOptions);
  }
  setConnectMethodsOrder(connectMethodsOrder) {
    OptionsController.setConnectMethodsOrder(connectMethodsOrder);
  }
  setWalletFeaturesOrder(walletFeaturesOrder) {
    OptionsController.setWalletFeaturesOrder(walletFeaturesOrder);
  }
  setCollapseWallets(collapseWallets) {
    OptionsController.setCollapseWallets(collapseWallets);
  }
  setSocialsOrder(socialsOrder) {
    OptionsController.setSocialsOrder(socialsOrder);
  }
  getConnectMethodsOrder() {
    return WalletUtil.getConnectOrderMethod(OptionsController.state.features, ConnectorController.getConnectors());
  }
  /**
   * Adds a network to an existing adapter in AppKit.
   * @param namespace - The chain namespace to add the network to (e.g. 'eip155', 'solana')
   * @param network - The network configuration to add
   * @throws Error if adapter for namespace doesn't exist
   */
  addNetwork(namespace, network) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const extendedNetwork = this.extendCaipNetwork(network, this.options);
    if (!this.getCaipNetworks().find((n12) => n12.id === extendedNetwork.id)) {
      ChainController.addNetwork(extendedNetwork);
    }
  }
  /**
   * Removes a network from an existing adapter in AppKit.
   * @param namespace - The chain namespace the network belongs to
   * @param networkId - The network ID to remove
   * @throws Error if adapter for namespace doesn't exist or if removing last network
   */
  removeNetwork(namespace, networkId) {
    if (this.chainAdapters && !this.chainAdapters[namespace]) {
      throw new Error(`Adapter for namespace ${namespace} doesn't exist`);
    }
    const networkToRemove = this.getCaipNetworks().find((n12) => n12.id === networkId);
    if (!networkToRemove) {
      return;
    }
    ChainController.removeNetwork(namespace, networkId);
  }
};

// node_modules/@reown/appkit/dist/esm/src/client/appkit-core.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Overrides --------------------------------------------------------------
  async open(options) {
    const isConnected = ConnectorController.isConnected();
    if (!isConnected) {
      await super.open(options);
    }
  }
  async close() {
    await super.close();
    if (this.options.manualWCControl) {
      ConnectionController.finalizeWcConnection();
    }
  }
  async syncIdentity(_request) {
    return Promise.resolve();
  }
  async syncBalance(_params) {
    return Promise.resolve();
  }
  async injectModalUi() {
    if (!isInitialized && CoreHelperUtil.isClient()) {
      await Promise.resolve().then(() => (init_basic(), basic_exports));
      await Promise.resolve().then(() => (init_w3m_modal2(), w3m_modal_exports));
      const isElementCreated = document.querySelector("w3m-modal");
      if (!isElementCreated) {
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
      }
      isInitialized = true;
    }
  }
};

// node_modules/@reown/appkit/dist/esm/exports/constants.js
var PACKAGE_VERSION = "1.7.17";

// node_modules/@reown/appkit/dist/esm/exports/core.js
function createAppKit(options) {
  return new AppKit({
    ...options,
    basic: true,
    sdkVersion: `html-core-${PACKAGE_VERSION}`
  });
}

// node_modules/@reown/appkit-universal-connector/dist/esm/src/UniversalConnector.js
var UniversalConnector = class _UniversalConnector {
  constructor({ appKit, provider, config }) {
    this.appKit = appKit;
    this.provider = provider;
    this.config = config;
  }
  static async init(config) {
    const provider = await vi3.init({
      projectId: config.projectId,
      metadata: config.metadata
    });
    const appKitConfig = {
      networks: config.networks.flatMap((network) => network.chains),
      projectId: config.projectId,
      metadata: config.metadata,
      universalProvider: provider,
      manualWCControl: true
    };
    const appKit = createAppKit(appKitConfig);
    return new _UniversalConnector({ appKit, provider, config });
  }
  async connect() {
    const namespaces = this.config?.networks.reduce((acc, namespace) => {
      acc[namespace.namespace] = {
        ...namespace || {},
        methods: namespace?.methods || [],
        events: namespace?.events || [],
        chains: namespace?.chains?.map((chain3) => chain3.caipNetworkId) || []
      };
      return acc;
    }, {});
    try {
      await this.appKit.open();
      const session = await this.provider.connect({
        optionalNamespaces: namespaces
      });
      if (!session) {
        throw new Error("Error connecting to wallet: No session found");
      }
      await this.appKit.close();
      return { session };
    } catch (error2) {
      await this.appKit.close();
      throw new Error(`Error connecting to wallet: ${error2 instanceof Error ? error2.message : "Unknown error"}`);
    }
  }
  async disconnect() {
    await this.appKit.disconnect();
    await this.provider.disconnect();
  }
  async request(params, chain3) {
    return await this.provider.request(params, chain3);
  }
};

// node_modules/@stacks/connect/dist/index.mjs
var Ve5 = Object.defineProperty;
var Ke6 = Object.defineProperties;
var Je4 = Object.getOwnPropertyDescriptors;
var j6 = Object.getOwnPropertySymbols;
var Se5 = Object.prototype.hasOwnProperty;
var Ae4 = Object.prototype.propertyIsEnumerable;
var ge5 = (e10, t5, s8) => t5 in e10 ? Ve5(e10, t5, { enumerable: true, configurable: true, writable: true, value: s8 }) : e10[t5] = s8;
var u5 = (e10, t5) => {
  for (var s8 in t5 || (t5 = {})) Se5.call(t5, s8) && ge5(e10, s8, t5[s8]);
  if (j6) for (var s8 of j6(t5)) Ae4.call(t5, s8) && ge5(e10, s8, t5[s8]);
  return e10;
};
var p7 = (e10, t5) => Ke6(e10, Je4(t5));
var fe5 = (e10, t5) => {
  var s8 = {};
  for (var o13 in e10) Se5.call(e10, o13) && t5.indexOf(o13) < 0 && (s8[o13] = e10[o13]);
  if (e10 != null && j6) for (var o13 of j6(e10)) t5.indexOf(o13) < 0 && Ae4.call(e10, o13) && (s8[o13] = e10[o13]);
  return s8;
};
var N14 = class e9 extends Error {
  constructor(s8, o13, r9, n12) {
    super(s8);
    this.message = s8;
    this.code = o13;
    this.data = r9;
    this.cause = n12;
    this.name = "JsonRpcError", this.message = s8, this.code = o13, this.data = r9, this.cause = n12;
  }
  static fromResponse(s8) {
    return new e9(s8.message, s8.code, s8.data);
  }
  toString() {
    return `${this.name} (${this.code}): ${this.message}${this.data ? `: ${JSON.stringify(this.data)}` : ""}`;
  }
};
var me5 = ((c12) => (c12[c12.ParseError = -32700] = "ParseError", c12[c12.InvalidRequest = -32600] = "InvalidRequest", c12[c12.MethodNotFound = -32601] = "MethodNotFound", c12[c12.InvalidParams = -32602] = "InvalidParams", c12[c12.InternalError = -32603] = "InternalError", c12[c12.UserRejection = -32e3] = "UserRejection", c12[c12.MethodAddressMismatch = -32001] = "MethodAddressMismatch", c12[c12.MethodAccessDenied = -32002] = "MethodAccessDenied", c12[c12.UnknownError = -31e3] = "UnknownError", c12[c12.UserCanceled = -31001] = "UserCanceled", c12))(me5 || {});
var Ie5 = "asigna-stx";
var Y4 = (e10, t5) => new Promise((s8) => {
  function o13(r9) {
    r9.data.source === Ie5 && r9.data[t5] && (s8(r9.data[t5]), window.removeEventListener("message", o13));
  }
  window.addEventListener("message", o13), window.top.postMessage(et(e10, t5), "*");
});
var $e5 = { authenticationRequest: async (e10) => Y4(e10, "authenticationRequest"), transactionRequest: async (e10) => Y4(e10, "transactionRequest"), request: async (e10, t5) => Y4(t5, e10) };
var et = (e10, t5) => ({ source: Ie5, [t5]: e10 });
var ye5 = () => {
  if (typeof window == "undefined") return;
  window.top !== window.self && (window.AsignaProvider = $e5);
};
ye5();
var Ne4 = [{ id: "LeatherProvider", name: "Leather", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiByeD0iMjYuODM4NyIgZmlsbD0iIzEyMTAwRiIvPgo8cGF0aCBkPSJNNzQuOTE3MSA1Mi43MTE0QzgyLjQ3NjYgNTEuNTQwOCA5My40MDg3IDQzLjU4MDQgOTMuNDA4NyAzNy4zNzYxQzkzLjQwODcgMzUuNTAzMSA5MS44OTY4IDM0LjIxNTQgODkuNjg3MSAzNC4yMTU0Qzg1LjUwMDQgMzQuMjE1NCA3OC40MDYxIDQwLjUzNjggNzQuOTE3MSA1Mi43MTE0Wk0zOS45MTEgODMuNDk5MUMzMC4wMjU2IDgzLjQ5OTEgMjkuMjExNSA5My4zMzI0IDM5LjA5NjkgOTMuMzMyNEM0My41MTYzIDkzLjMzMjQgNDguODY2MSA5MS41NzY0IDUxLjY1NzMgODguNDE1N0M0Ny41ODY4IDg0LjkwMzggNDQuMjE0MSA4My40OTkxIDM5LjkxMSA4My40OTkxWk0xMDIuODI5IDc5LjI4NDhDMTAzLjQxIDk1Ljc5MDcgOTUuMDM2OSAxMDUuMDM5IDgwLjg0ODQgMTA1LjAzOUM3Mi40NzQ4IDEwNS4wMzkgNjguMjg4MSAxMDEuODc4IDU5LjMzMyA5Ni4wMjQ5QzU0LjY4MSAxMDEuMTc2IDQ1Ljg0MjMgMTA1LjAzOSAzOC41MTU0IDEwNS4wMzlDMTMuMjc4NSAxMDUuMDM5IDE0LjMyNTIgNzIuODQ2MyA0MC4wMjczIDcyLjg0NjNDNDUuMzc3MSA3Mi44NDYzIDQ5LjkxMjggNzQuMjUxMSA1NS43Mjc3IDc3Ljg4TDU5LjU2NTYgNjQuNDE3N0M0My43NDg5IDYwLjA4NjQgMzUuODQwNSA0Ny45MTE4IDQzLjYzMjYgMzAuNDY5M0g1Ni4xOTI5QzQ5LjIxNSA0Mi4wNTg2IDUzLjk4MzIgNTEuNjU3OCA2Mi44MjIgNTIuNzExNEM2Ny41OTAzIDM1LjczNzIgNzcuODI0NiAyMi41MDkgOTEuNDMxNiAyMi41MDlDOTkuMTA3NCAyMi41MDkgMTA1LjE1NSAyNy41NDI4IDEwNS4xNTUgMzYuNjczN0MxMDUuMTU1IDUxLjMwNjYgODYuMDgxOSA2My4yNDcxIDcxLjY2MDcgNjQuNDE3N0w2NS43Mjk1IDg1LjM3MjFDNzIuNDc0OCA5My4yMTUzIDkxLjE5OSAxMDAuODI0IDkxLjE5OSA3OS4yODQ4SDEwMi44MjlaIiBmaWxsPSIjRjVGMUVEIi8+Cjwvc3ZnPgo=", webUrl: "https://leather.io", chromeWebStoreUrl: "https://chrome.google.com/webstore/detail/hiro-wallet/ldinpeekobnhjjdofggfgjlcehhmanlj", mozillaAddOnsUrl: "https://leather.io/install-extension" }, { id: "XverseProviders.BitcoinProvider", name: "Xverse Wallet", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2MDAiIGhlaWdodD0iNjAwIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGZpbGw9IiMxNzE3MTciIGQ9Ik0wIDBoNjAwdjYwMEgweiIvPjxwYXRoIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTQ0MCA0MzUuNHYtNTFjMC0yLS44LTMuOS0yLjItNS4zTDIyMCAxNjIuMmE3LjYgNy42IDAgMCAwLTUuNC0yLjJoLTUxLjFjLTIuNSAwLTQuNiAyLTQuNiA0LjZ2NDcuM2MwIDIgLjggNCAyLjIgNS40bDc4LjIgNzcuOGE0LjYgNC42IDAgMCAxIDAgNi41bC03OSA3OC43Yy0xIC45LTEuNCAyLTEuNCAzLjJ2NTJjMCAyLjQgMiA0LjUgNC42IDQuNUgyNDljMi42IDAgNC42LTIgNC42LTQuNlY0MDVjMC0xLjIuNS0yLjQgMS40LTMuM2w0Mi40LTQyLjJhNC42IDQuNiAwIDAgMSA2LjQgMGw3OC43IDc4LjRhNy42IDcuNiAwIDAgMCA1LjQgMi4yaDQ3LjVjMi41IDAgNC42LTIgNC42LTQuNloiLz48cGF0aCBmaWxsPSIjRUU3QTMwIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0zMjUuNiAyMjcuMmg0Mi44YzIuNiAwIDQuNiAyLjEgNC42IDQuNnY0Mi42YzAgNCA1IDYuMSA4IDMuMmw1OC43LTU4LjVjLjgtLjggMS4zLTIgMS4zLTMuMnYtNTEuMmMwLTIuNi0yLTQuNi00LjYtNC42TDM4NCAxNjBjLTEuMiAwLTIuNC41LTMuMyAxLjNsLTU4LjQgNTguMWE0LjYgNC42IDAgMCAwIDMuMiA3LjhaIi8+PC9nPjwvc3ZnPg==", webUrl: "https://xverse.app", chromeWebStoreUrl: "https://chrome.google.com/webstore/detail/xverse-wallet/idnnbdplmphpflfnlkomgpfbpcgelopg", googlePlayStoreUrl: "https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse", iOSAppStoreUrl: "https://apps.apple.com/app/xverse-bitcoin-web3-wallet/id1552272513", mozillaAddOnsUrl: "https://www.xverse.app/download" }, { id: "AsignaProvider", name: "Asigna Multisig", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMDEwMCIgZD0iTTAgMGgzMnYzMkgweiIvPjxwYXRoIGZpbGw9InVybCgjYSkiIGQ9Ik0xNS4xMSA1LjU1YTMgMyAwIDAgMC0xLjgyIDEuM2wtLjA1LjA4LS40My43Mi0uMDcuMTEtLjUuODUtLjA1LjA5LTEuMjkgMi4xOC0uMDQuMDctLjQ3LjgtLjA2LjEtLjQ2Ljc4LS4wNy4xMS0xLjYzIDIuNzYtLjA3LjExLS4zOC42Ni0uMDUuMDgtLjczIDEuMjQtLjM1LjYtLjQuNjctLjA1LjA5TDUuMSAyMC43bC0uMTEuMTgtLjE0LjIzLS4wNy4xMy0uMzMuNTUtLjA0LjA3di4wMWExLjI2IDEuMjYgMCAwIDAtLjE0LjQ3IDEuMzEgMS4zMSAwIDAgMCAxLjI0IDEuNGgxLjVsLjA1LS4wNi4wNC0uMDYuODctMS4yMS4wNS0uMDguNzctMS4wNy4wNS0uMDcuNC0uNTcuMDUtLjA2LjI0LS4zNGExLjUyIDEuNTIgMCAwIDEgMS4zOS0uNjIgMS41IDEuNSAwIDAgMSAuNjQuMiAxLjQ3IDEuNDcgMCAwIDEgLjczIDEuMjcgMS40NCAxLjQ0IDAgMCAxLS4yNy44NGwtLjYzLjg4LS4wNS4wNy0uMzIuNDUtLjA2LjA4LS4wOC4xMi0uMTIuMTYtLjA1LjA4aDIuMTNhMi4zMiAyLjMyIDAgMCAwIDEuNzctLjk2bDEuMTgtMS42My43Ny0xLjA4IDEuMy0xLjhhMS4yNCAxLjI0IDAgMCAxIC41NS0uNDNsLjA4LS4wM2ExLjMgMS4zIDAgMCAxIC4zLS4wNiAxLjI4IDEuMjggMCAwIDEgMS4xNS41NGwuMTEuMmExLjEzIDEuMTMgMCAwIDEgLjEuNDEgMS4xOSAxLjE5IDAgMCAxLS4yMy43N2wtLjAzLjA1LS41Ny44LS43Ljk4LS4yNy4zN2ExLjIyIDEuMjIgMCAwIDAtLjIuNSAxLjA1IDEuMDUgMCAwIDAtLjAyLjIzdi4wNmExLjE3IDEuMTcgMCAwIDAgLjE0LjQzbC4wMi4wNS4wNy4xYTEuNDQgMS40NCAwIDAgMCAuMS4xMWwuMDUuMDYuMDEuMDFhMS44IDEuOCAwIDAgMCAuMTQuMWMwIC4wMi4wMi4wMy4wNC4wM2ExIDEgMCAwIDAgLjA4LjA1bC4wNy4wNGExLjI1IDEuMjUgMCAwIDAgLjUuMWg2LjljLjEgMCAuMi0uMDEuMjktLjAzbC4wNi0uMDJhMS4yNyAxLjI3IDAgMCAwIC4yNy0uMS41Ny41NyAwIDAgMCAuMDctLjAzIDEuMjEgMS4yMSAwIDAgMCAuMjYtLjE5bC4wOC0uMDdhLjkyLjkyIDAgMCAwIC4xNS0uMTkgMS41NSAxLjU1IDAgMCAwIC4wOS0uMTdsLjAyLS4wNWExLjIyIDEuMjIgMCAwIDAgLjA4LS4yNnYtLjA0bC4wMi0uMDh2LS4wOGExLjMyIDEuMzIgMCAwIDAtLjItLjc0bC0xLjYtMi42NC0uMDYtLjEtLjItLjMyLS4zMy0uNTR2LS4wMWwtLjA1LS4wOC0xLjMtMi4xNS0uMDctLjEtLjA0LS4wNi0uOC0xLjMyLS4wNC0uMDctLjItLjM0LS4xLS4xNC0uMS0uMTYtLjUzLS45LS4xMy0uMi0uMDktLjE0LTIuMTctMy41Ny0uMDQtLjA3LS43Mi0xLjE5LS4wNS0uMDctLjQtLjY1YTIuNjUgMi42NSAwIDAgMC0uMy0uNCAyLjk2IDIuOTYgMCAwIDAtLjk3LS43NCAzLjA0IDMuMDQgMCAwIDAtMS4zLS4zYy0uMjUgMC0uNS4wNC0uNzQuMVoiLz48cGF0aCBmaWxsPSJ1cmwoI2IpIiBkPSJNMTkgMTYuM2E1LjQ1IDUuNDUgMCAwIDAtLjgzIDEuNTZsLS4wNC4xNWExLjM2IDEuMzYgMCAwIDEgLjI4LS4xNiAxLjI0IDEuMjQgMCAwIDEgLjM4LS4wOGguMWExLjI4IDEuMjggMCAwIDEgMS4wNS41NGMuMDQuMDYuMDguMTMuMS4yYTEuMjQgMS4yNCAwIDAgMSAuMDkuMjcgMS4xOSAxLjE5IDAgMCAxLS4yLjkxbC0uMDQuMDUtLjU3Ljc5LS43Ljk5LS4yNy4zN2ExLjIzIDEuMjMgMCAwIDAtLjIuNDIgMS4wNiAxLjA2IDAgMCAwLS4wMi4zMXYuMDZhMS4xNyAxLjE3IDAgMCAwIC4xNi40Ny45My45MyAwIDAgMCAuMDcuMSAxLjUgMS41IDAgMCAwIC4xLjEybC4wNS4wNmguMDFhMS45NCAxLjk0IDAgMCAwIC4wOS4wOCAxIDEgMCAwIDAgLjE3LjFsLjA3LjA0YTEuMjUgMS4yNSAwIDAgMCAuNS4xaDYuOWMuMSAwIC4yIDAgLjI4LS4wMmwuMDctLjAyYTEuMzIgMS4zMiAwIDAgMCAuMzQtLjEzbC4xNi0uMS4wMy0uMDNhMS4yOSAxLjI5IDAgMCAwIC4yLS4yIDIuNDMgMi40MyAwIDAgMCAuMTItLjE3Yy4wMy0uMDMuMDUtLjA4LjA3LS4xMmwuMDItLjA1YTEuMjEgMS4yMSAwIDAgMCAuMDktLjN2LS4wOGwuMDEtLjA5YTEuMzIgMS4zMiAwIDAgMC0uMi0uNzNsLTEuNi0yLjY0LS4wNi0uMS0uMi0uMzItLjMzLS41NHYtLjAybC0uMDUtLjA3LTEuMy0yLjE1LS4xMi0uMDctLjA3LS4wNGE0Ljk0IDQuOTQgMCAwIDAtMi40Ni0uNjdjLTEuMDMgMC0xLjc2LjU3LTIuMjYgMS4yWiIvPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik0xMi4yOSAyMS4wOGMwIC4yOS0uMDkuNTgtLjI3Ljg0bC0xLjMxIDEuODRIN2wyLjUyLTMuNTNhMS41NCAxLjU0IDAgMCAxIDIuMS0uMzZjLjQzLjI4LjY2Ljc0LjY2IDEuMloiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTEuMTYgMjEuMjVhLjU2LjU2IDAgMCAxLS41Ny41NS41Ni41NiAwIDAgMS0uNTctLjU2LjU2LjU2IDAgMCAxIC41Ny0uNTUuNTYuNTYgMCAwIDEgLjU3LjU2WiIvPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9IjE1LjIzIiB4Mj0iMTkuMyIgeTE9IjI1Ljc4IiB5Mj0iNi4xMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiM2NTIyRjQiLz48c3RvcCBvZmZzZXQ9Ii41NSIgc3RvcC1jb2xvcj0iIzlCNkJGRiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0E1ODVGRiIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iMjIuNTkiIHgyPSIyNC44IiB5MT0iMjQuNzEiIHkyPSIxNS41MyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiM0MjFGOEIiLz48c3RvcCBvZmZzZXQ9Ii41NSIgc3RvcC1jb2xvcj0iIzcyMzBGRiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzk3NzNGRiIvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjwvc3ZnPg==", webUrl: "https://asigna.io", chromeWebStoreUrl: "https://stx.asigna.io/" }, { id: "FordefiProviders.UtxoProvider", name: "Fordefi", icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIiIGhlaWdodD0iNDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbD0iIzEwMTExNCIgZD0iTTAgMGg0MnY0MkgweiIvPgogIDxwYXRoIGQ9Ik0xOS40NyAyNi44OUg1djMuNTdhNC41NyA0LjU3IDAgMCAwIDQuNTggNC41N2g1LjgzbDQuMDYtOC4xNFoiIGZpbGw9IiM3OTk0RkYiLz4KICA8cGF0aCBkPSJNNSAxNy40aDI3LjU4bC0zLjIgNi43OEg1VjE3LjRaIiBmaWxsPSIjNDg2REZGIi8+CiAgPHBhdGggZD0iTTE0LjY3IDdINXY3LjY4aDMzVjdoLTkuNjd2NS43NGgtMlY3aC05LjY3djUuNzRoLTEuOTlWN1oiIGZpbGw9IiM1Q0QxRkEiLz4KPC9zdmc+Cg==", webUrl: "https://www.fordefi.com/", chromeWebStoreUrl: "https://chromewebstore.google.com/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle" }];
var De5 = { id: "WalletConnectProvider", name: "WalletConnect", icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MDAiIGhlaWdodD0iNDAwIiBmaWxsPSJub25lIj48bWFzayBpZD0iYSIgd2lkdGg9IjQwMCIgaGVpZ2h0PSI0MDAiIHg9IjAiIHk9IjAiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHN0eWxlPSJtYXNrLXR5cGU6bHVtaW5hbmNlIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDQwMHY0MDBIMFYwWiIvPjwvbWFzaz48ZyBtYXNrPSJ1cmwoI2EpIj48cGF0aCBmaWxsPSIjMzM5NkZGIiBkPSJNNDAwIDQwMEgwVjBoNDAwdjQwMFoiLz48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMTIyLjUyIDE0OC45N2M0Mi43OS00MS43MyAxMTIuMTctNDEuNzMgMTU0Ljk2IDBsNS4xNSA1LjAyYTUuMjUgNS4yNSAwIDAgMSAwIDcuNTVsLTE3LjYyIDE3LjE4YTIuNzkgMi43OSAwIDAgMS0zLjg3IDBsLTcuMDktNi45Yy0yOS44NS0yOS4xMi03OC4yNS0yOS4xMi0xMDguMSAwbC03LjYgNy40YTIuNzkgMi43OSAwIDAgMS0zLjg3IDBsLTE3LjYxLTE3LjE5YTUuMjUgNS4yNSAwIDAgMSAwLTcuNTVsNS42NS01LjUxWm0xOTEuNCAzNS41MiAxNS42OCAxNS4zYTUuMjUgNS4yNSAwIDAgMSAwIDcuNTVsLTcwLjcgNjguOTRhNS41OCA1LjU4IDAgMCAxLTcuNzUgMGwtNTAuMTgtNDguOTNhMS40IDEuNCAwIDAgMC0xLjk0IDBsLTUwLjE4IDQ4LjkzYTUuNTggNS41OCAwIDAgMS03Ljc0IDBsLTcwLjctNjguOTRhNS4yNSA1LjI1IDAgMCAxIDAtNy41NmwxNS42Ny0xNS4yOWE1LjU4IDUuNTggMCAwIDEgNy43NSAwbDUwLjE4IDQ4Ljk0Yy41NC41MiAxLjQuNTIgMS45NCAwbDUwLjE4LTQ4Ljk0YTUuNTggNS41OCAwIDAgMSA3Ljc0IDBsNTAuMTggNDguOTRjLjU0LjUyIDEuNC41MiAxLjk0IDBsNTAuMTgtNDguOTRhNS41OCA1LjU4IDAgMCAxIDcuNzUgMFoiLz48L2c+PC9zdmc+", webUrl: "https://walletconnect.com/", chromeWebStoreUrl: "" };
function O7(e10, t5) {
  var s8, o13;
  return e10 instanceof t5 || ((o13 = (s8 = e10 == null ? void 0 : e10.constructor) == null ? void 0 : s8.name) == null ? void 0 : o13.toLowerCase()) === t5.name;
}
function E7(e10) {
  return e10 ? typeof e10 == "string" ? e10 : O7(e10, StacksMainnet) ? "mainnet" : O7(e10, StacksTestnet) ? "testnet" : O7(e10, StacksDevnet) || O7(e10, StacksMocknet) ? "devnet" : "coreApiUrl" in e10 ? e10.coreApiUrl : "url" in e10 ? e10.url : "transactionVersion" in e10 ? e10.transactionVersion === TransactionVersion.Mainnet ? "mainnet" : "testnet" : "mainnet" : "mainnet";
}
function y8(e10) {
  if (typeof e10.type == "string") return e10;
  switch (e10.type) {
    case ClarityType2.BoolFalse:
      return cl_exports.bool(false);
    case ClarityType2.BoolTrue:
      return cl_exports.bool(true);
    case ClarityType2.Int:
      return cl_exports.int(e10.value);
    case ClarityType2.UInt:
      return cl_exports.uint(e10.value);
    case ClarityType2.Buffer:
      return cl_exports.buffer(e10.buffer);
    case ClarityType2.StringASCII:
      return cl_exports.stringAscii(e10.data);
    case ClarityType2.StringUTF8:
      return cl_exports.stringUtf8(e10.data);
    case ClarityType2.List:
      return cl_exports.list(e10.list.map(y8));
    case ClarityType2.Tuple:
      return cl_exports.tuple(Object.fromEntries(Object.entries(e10.data).map(([s8, o13]) => [s8, y8(o13)])));
    case ClarityType2.OptionalNone:
      return cl_exports.none();
    case ClarityType2.OptionalSome:
      return cl_exports.some(y8(e10.value));
    case ClarityType2.ResponseErr:
      return cl_exports.error(y8(e10.value));
    case ClarityType2.ResponseOk:
      return cl_exports.ok(y8(e10.value));
    case ClarityType2.PrincipalContract:
      return cl_exports.contractPrincipal(address_exports.stringify(e10.address), e10.contractName.content);
    case ClarityType2.PrincipalStandard:
      return cl_exports.standardPrincipal(address_exports.stringify(e10.address));
    default:
      let t5 = e10;
      throw new Error(`Unknown clarity type: ${t5}`);
  }
}
function Le6(e10) {
  return p7(u5({}, e10), { onFinish: void 0, onCancel: void 0 });
}
var W5 = (e10) => e10;
var Q5 = (e10) => e10.profile;
var F3 = (e10) => e10;
var q2 = (e10) => e10;
var Z4 = (e10) => ({ message: y8(e10.message), domain: y8(e10.domain) });
var H4 = (e10) => e10;
var X4 = (e10) => {
  var s8;
  let t5 = (s8 = e10.functionArgs) == null ? void 0 : s8.map((o13) => typeof o13 == "string" ? cl_exports.deserialize(o13) : y8(o13)).map((o13) => cl_exports.serialize(o13));
  return p7(u5({}, e10), { contract: `${e10.contractAddress}.${e10.contractName}`, functionArgs: t5, network: E7(e10.network), postConditionMode: Ee5(e10.postConditionMode), postConditions: Oe4(e10.postConditions), address: e10.stxAddress });
};
var V5 = (e10) => ({ txId: e10.txid, txRaw: e10.transaction, stacksTransaction: deserializeTransaction(e10.transaction) });
var K4 = (e10) => p7(u5({}, e10), { name: e10.contractName, clarityCode: e10.codeBody, network: E7(e10.network), postConditionMode: Ee5(e10.postConditionMode), postConditions: Oe4(e10.postConditions), address: e10.stxAddress });
var J4 = (e10) => ({ txId: e10.txid, txRaw: e10.transaction, stacksTransaction: deserializeTransaction(e10.transaction) });
var $5 = (e10) => p7(u5({}, e10), { amount: e10.amount.toString(), network: E7(e10.network), address: e10.stxAddress });
var ee4 = (e10) => ({ txId: e10.txid, txRaw: e10.transaction, stacksTransaction: deserializeTransaction(e10.transaction) });
var te4 = (e10) => p7(u5({}, e10), { transaction: e10.txHex });
var se4 = (e10) => p7(u5({}, e10), { stacksTransaction: deserializeTransaction(e10.transaction) });
function Oe4(e10) {
  if (typeof e10 != "undefined") return e10.map((t5) => typeof t5 == "string" ? t5 : typeof t5.type == "string" ? p7(u5({}, t5), { amount: "amount" in t5 ? t5.amount.toString() : void 0 }) : bytesToHex(serializePostCondition(t5)));
}
function Ee5(e10) {
  if (typeof e10 != "undefined") {
    if (typeof e10 == "string") return e10;
    switch (e10) {
      case PostConditionMode.Allow:
        return "allow";
      case PostConditionMode.Deny:
        return "deny";
      default:
        let t5 = e10;
        throw new Error(`Unknown post condition mode: ${t5}. Should be one of: 'allow', 'deny'`);
    }
  }
}
function C6(e10, t5, s8) {
  return (o13, r9) => {
    let n12 = t5(Le6(o13)), i11 = o13;
    P7({ provider: r9 }, e10, n12).then((a5) => {
      var M6;
      let d7 = s8(a5);
      (M6 = i11.onFinish) == null || M6.call(i11, d7);
    }).catch((a5) => {
      var d7;
      console.error(a5), (d7 = i11.onCancel) == null || d7.call(i11, a5);
    });
  };
}
var lo4 = C6("stx_transferStx", $5, ee4);
var go4 = C6("stx_callContract", X4, V5);
var So4 = C6("stx_deployContract", K4, J4);
var Ao4 = C6("stx_signTransaction", te4, se4);
var fo4 = C6("stx_updateProfile", W5, Q5);
var mo4 = C6("stx_signMessage", F3, q2);
var Io4 = C6("stx_signStructuredMessage", Z4, H4);
var oe2 = "@stacks/connect";
var Bt5 = { addresses: { stx: [], btc: [] }, version: "0.0.1" };
var Re4 = (e10) => [...new Map(e10.map((s8) => [s8.address, s8])).values()].map((o13) => {
  var s8 = fe5(o13, []);
  return "publicKey" in s8 && delete s8.publicKey, "derivationPath" in s8 && delete s8.derivationPath, "tweakedPublicKey" in s8 && delete s8.tweakedPublicKey, s8;
});
function _e6(e10) {
  try {
    let s8 = ne4() || Bt5, o13 = p7(u5({}, s8), { updatedAt: Date.now(), addresses: u5(u5({}, s8.addresses), e10.addresses && { stx: e10.addresses.stx && Re4([...s8.addresses.stx, ...e10.addresses.stx]), btc: e10.addresses.btc && Re4([...s8.addresses.btc, ...e10.addresses.btc]) }) });
    localStorage.setItem(oe2, bytesToHex(utf8ToBytes(JSON.stringify(o13))));
  } catch (t5) {
    console.warn("Failed to store data in localStorage:", t5);
  }
}
function ne4() {
  try {
    let e10 = localStorage.getItem(oe2);
    return e10 ? JSON.parse(bytesToUtf8(hexToBytes(e10))) : null;
  } catch (e10) {
    return console.warn("Failed to get data from localStorage:", e10), null;
  }
}
function Qt5() {
  let e10 = ne4();
  return (e10 == null ? void 0 : e10.addresses.stx.length) > 0 || (e10 == null ? void 0 : e10.addresses.btc.length) > 0;
}
var qt4 = ["stx_signMessage", "stx_signTransaction", "stx_signStructuredMessage", "stx_getAccounts", "stx_getAddresses", "stx_updateProfile", "stx_transferStx", "stx_transferSip10Ft", "stx_transferSip9Nft", "stx_callContract", "stx_deployContract", "sendTransfer", "signPsbt", "getAddresses"];
var R5 = { id: 1, chainNamespace: "stacks", caipNetworkId: "stacks:1", name: "Stacks", nativeCurrency: { name: "STX", symbol: "STX", decimals: 6 }, rpcUrls: { default: { http: ["https://api.mainnet.hiro.so"] } } };
var Ue5 = { projectId: "your_project_id", metadata: { name: "Universal Connector", description: "Universal Connector", url: "https://appkit.reown.com", icons: ["https://appkit.reown.com/icon.png"] }, networks: [{ namespace: "stacks", chains: [R5], methods: qt4, events: ["stx_chainChanged", "stx_accountsChanged"] }, { namespace: "bip122", chains: [bitcoin], methods: ["signMessage", "sendTransfer", "signPsbt", "getAccountAddresses"], events: ["bip122_addressesChanged"] }] };
function ze4(e10) {
  return { jsonrpc: "2.0", id: 1, result: e10 };
}
var re3 = class {
  constructor(t5) {
    this.connector = t5;
  }
  async connect() {
    try {
      let { session: t5 } = await this.connector.connect();
      return t5;
    } catch (t5) {
      throw console.error(">> WalletConnectProvider connect error", t5), t5;
    }
  }
  get stacksAddresses() {
    var i11;
    let t5 = (i11 = this.connector.provider) == null ? void 0 : i11.session, s8 = t5 == null ? void 0 : t5.sessionProperties.stacks_getAddresses, o13 = JSON.parse(s8 || "[]"), n12 = [...t5.namespaces.stacks.accounts.map((a5) => ({ address: a5.split(":")[2], publicKey: "" })) || [], ...o13 || []].sort((a5) => a5.publicKey ? 1 : -1);
    return Array.from(new Map(n12.map((a5) => [a5.address, a5])).values());
  }
  get btcAddresses() {
    var i11;
    let t5 = (i11 = this.connector.provider) == null ? void 0 : i11.session, s8 = t5 == null ? void 0 : t5.sessionProperties.bip122_getAccountAddresses, o13 = JSON.parse(s8 || "{}"), r9 = t5.namespaces.bip122.accounts.map((a5) => ({ address: a5.split(":")[2], publicKey: "" })), n12 = [...(o13 == null ? void 0 : o13.payment.map((a5) => p7(u5({}, a5), { purpose: "payment" }))) || [], ...(o13 == null ? void 0 : o13.ordinal.map((a5) => p7(u5({}, a5), { purpose: "ordinal" }))) || [], ...r9 || []].sort((a5) => a5.publicKey ? 1 : -1).sort((a5, d7) => (a5 == null ? void 0 : a5.address.length) - (d7 == null ? void 0 : d7.address.length));
    return Array.from(new Map(n12.map((a5) => [a5.address, a5])).values());
  }
  async getAddresses() {
    var n12;
    let t5 = (n12 = this.connector.provider) == null ? void 0 : n12.session;
    t5 || (t5 = await this.connect());
    let s8 = this.stacksAddresses || [], o13 = this.btcAddresses || [];
    return { addresses: [...s8, ...o13] };
  }
  validateRpcMethod(t5) {
    var a5, d7, M6, c12;
    if (["getAddresses", "stx_getAccounts", "stx_getAddresses"].includes(t5)) return;
    if (!((a5 = this.connector.provider) != null && a5.session)) throw new Error("WalletConnectProvider not connected. Please connect first.");
    let o13 = (d7 = this.connector.provider) == null ? void 0 : d7.session.namespaces, r9 = ((M6 = o13.stacks) == null ? void 0 : M6.methods) || [], n12 = ((c12 = o13.bip122) == null ? void 0 : c12.methods) || [];
    if (![...r9, ...n12].includes(t5)) throw new Error(`WalletConnectProvider does not support method ${t5}. Please use a supported method.`);
  }
  getTargetCaipNetworkId(t5) {
    var o13, r9, n12, i11, a5, d7, M6, c12;
    if (["getAddresses", "stx_getAccounts", "stx_getAddresses"].includes(t5)) return R5.caipNetworkId;
    if ((i11 = (n12 = (r9 = (o13 = this.connector.provider) == null ? void 0 : o13.session) == null ? void 0 : r9.namespaces) == null ? void 0 : n12.stacks) != null && i11.methods.includes(t5)) return R5.caipNetworkId;
    if ((c12 = (M6 = (d7 = (a5 = this.connector.provider) == null ? void 0 : a5.session) == null ? void 0 : d7.namespaces) == null ? void 0 : M6.bip122) != null && c12.methods.includes(t5)) return bitcoin.caipNetworkId;
    throw new Error(`WalletConnectProvider does not support method ${t5}. Please use a supported method.`);
  }
  async request(t5, s8) {
    var o13, r9, n12, i11;
    try {
      this.validateRpcMethod(t5);
      let a5 = this.getTargetCaipNetworkId(t5);
      switch (t5) {
        case "getAddresses":
        case "stx_getAddresses":
        case "stx_getAccounts":
          let d7 = await this.getAddresses();
          return ze4(d7);
        case "stx_signMessage":
          let c12 = ((i11 = (n12 = (r9 = (o13 = this.connector.provider) == null ? void 0 : o13.session) == null ? void 0 : r9.namespaces) == null ? void 0 : n12.stacks) == null ? void 0 : i11.accounts[0]).split(":")[2], I6 = await this.connector.request({ method: t5, params: u5({ address: c12 }, s8) }, a5);
          return ze4(I6);
        default:
          return await this.connector.request({ method: t5, params: s8 }, a5);
      }
    } catch (a5) {
      throw console.error(">> WalletConnectProvider request error", a5), a5;
    }
  }
  async disconnect() {
    await this.connector.disconnect();
  }
};
var Ye5 = async (e10) => {
  let t5 = await UniversalConnector.init(p7(u5({}, Ue5), { projectId: e10 })), s8 = new re3(t5);
  window.WalletConnectProvider = s8;
};
async function v7(e10, t5, s8) {
  var o13;
  try {
    let r9 = await e10.request(t5, s8);
    if ("error" in r9) throw N14.fromResponse(r9.error);
    return r9.result;
  } catch (r9) {
    if (r9 instanceof N14) throw r9;
    if ("jsonrpc" in r9) throw N14.fromResponse(r9.error);
    let n12 = (o13 = r9.code) != null ? o13 : -31e3;
    throw new N14(r9.message, n12, r9.data, r9);
  }
}
function ss2(e10) {
  return e10 ? async function(s8, o13, r9) {
    let n12 = await v7(s8, o13, r9);
    if ((o13 === "getAddresses" || o13 === "wallet_connect") && "addresses" in n12) {
      let { stx: i11, btc: a5 } = us2(n12.addresses).reduce((d7, M6) => (d7[M6.address.startsWith("S") ? "stx" : "btc"].push(M6), d7), { stx: [], btc: [] });
      _e6({ addresses: { stx: i11, btc: a5 } });
    }
    return n12;
  } : v7;
}
async function P7(...e10) {
  let { options: t5, method: s8, params: o13 } = os2(e10), r9 = Ne4;
  t5 != null && t5.walletConnectProjectId && (await Ye5(t5.walletConnectProjectId).catch(console.error), r9 = [...r9, De5]);
  let n12 = Object.assign({ provider: getProvider(), defaultProviders: r9, forceWalletSelect: false, persistWalletSelect: true, enableOverrides: true, enableLocalStorage: true }, is2(t5)), i11 = cs2(n12.enableOverrides, ss2(n12.enableLocalStorage));
  if (n12.provider && !n12.forceWalletSelect) {
    let { method: a5, params: d7 } = ae4(n12.provider, s8, o13, n12.enableOverrides);
    return await i11(n12.provider, a5, ie4(d7));
  }
  if (typeof window != "undefined") return defineCustomElements(window), new Promise((a5, d7) => {
    let M6 = document.createElement("connect-modal");
    M6.defaultProviders = We4(n12.approvedProviderIds, r9), M6.installedProviders = We4(n12.approvedProviderIds, getInstalledProviders(r9));
    let c12 = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    let I6 = () => {
      M6.remove(), document.body.style.overflow = c12;
    };
    M6.callback = (D4) => {
      I6();
      let f13 = getProviderFromId(D4), { method: w6, params: z5 } = ae4(f13, s8, o13, n12.enableOverrides), h12 = ds2(n12.persistWalletSelect, D4);
      a5(i11(f13, w6, ie4(z5)).then(h12));
    }, M6.cancelCallback = () => {
      I6(), d7(new N14("User canceled the request", -31001));
    }, document.body.appendChild(M6);
    let T6 = (D4) => {
      D4.key === "Escape" && (document.removeEventListener("keydown", T6), M6.remove(), d7(new N14("User canceled the request", -31001)));
    };
    document.addEventListener("keydown", T6);
  });
}
function os2(e10) {
  return typeof e10[0] == "string" ? { method: e10[0], params: e10[1] } : { options: e10[0], method: e10[1], params: e10[2] };
}
function We4(e10, t5) {
  return e10 ? t5.filter((s8) => e10.includes(s8.id)) : t5;
}
function ns2(e10) {
  let t5 = e10 && "network" in e10 ? { network: e10.network } : void 0;
  return P7(p7(u5({}, e10), { forceWalletSelect: true }), "getAddresses", t5);
}
function _4(e10) {
  return rs2(e10) || as2(e10);
}
function rs2(e10) {
  return "signMultipleTransactions" in e10 && "createRepeatInscriptions" in e10 && !(e10 != null && e10.isLeather) && !(e10 != null && e10.isFordefi);
}
function as2(e10) {
  return "isFordefi" in e10 && !!e10.isFordefi;
}
function Qe5(e10) {
  return "isLeather" in e10 && !!e10.isLeather;
}
function is2(e10) {
  if (e10 === void 0) return {};
  let t5 = {};
  for (let [s8, o13] of Object.entries(e10)) o13 !== void 0 && (t5[s8] = o13);
  return t5;
}
function cs2(e10, t5) {
  return e10 ? async (s8, o13, r9) => {
    let n12 = await t5(s8, o13, r9), i11 = u5({}, n12);
    return n12 !== null && "txId" in n12 && n12.txId && !("txid" in i11) && (i11.txid = n12.txId), n12 !== null && "hex" in n12 && n12.hex && typeof n12.hex == "string" && !("psbt" in i11) && (i11.psbt = base64.encode(hexToBytes(n12.hex))), i11;
  } : t5;
}
function ae4(e10, t5, s8, o13 = true) {
  if (!o13) return { method: t5, params: s8 };
  if (_4(e10) && ["getAddresses", "stx_getAddresses"].includes(t5)) return { method: "wallet_connect", params: s8 };
  if (_4(e10) && t5 === "sendTransfer") {
    let r9 = p7(u5({}, s8), { recipients: s8.recipients.map((n12) => p7(u5({}, n12), { amount: Number(n12.amount) })), network: void 0 });
    return { method: t5, params: r9 };
  }
  if (_4(e10) && t5 === "signPsbt") {
    let r9 = s8.signInputs;
    if (!r9) return { method: t5, params: s8 };
    let n12 = {};
    for (let a5 of r9) typeof a5 != "number" && a5.address && (n12[a5.address] || (n12[a5.address] = []), n12[a5.address].push(a5.index));
    let i11 = { psbt: s8.psbt, signInputs: n12, broadcast: s8.broadcast };
    return { method: t5, params: i11 };
  }
  if (!_4(e10) && t5 === "stx_signMessage") {
    let r9 = u5({}, s8);
    return delete r9.publicKey, { method: t5, params: r9 };
  }
  if (Qe5(e10) && t5 === "sendTransfer") {
    let r9 = p7(u5({}, s8), { recipients: s8.recipients.map((n12) => p7(u5({}, n12), { amount: n12.amount.toString() })) });
    return { method: t5, params: r9 };
  }
  if (Qe5(e10) && t5 === "signPsbt") {
    let r9 = { hex: bytesToHex(base64.decode(s8.psbt)), signAtIndex: s8.signInputs.map((n12) => typeof n12 == "number" ? n12 : n12.index), allowedSighash: s8.allowedSighash, broadcast: s8.broadcast, network: s8.network };
    return { method: t5, params: r9 };
  }
  return { method: t5, params: s8 };
}
var Fe4 = ["stx-postcondition", "ft-postcondition", "nft-postcondition"];
function ie4(e10) {
  if (!e10 || typeof e10 != "object") return e10;
  let t5 = u5({}, e10);
  for (let [s8, o13] of Object.entries(e10)) {
    if (typeof o13 == "bigint") {
      t5[s8] = o13.toString();
      continue;
    }
    if (o13) {
      if (Array.isArray(o13)) {
        t5[s8] = o13.map((r9) => typeof r9 == "bigint" ? r9.toString() : !r9 || typeof r9 != "object" || !("type" in r9) ? r9 : Fe4.includes(r9.type) ? postConditionToHex(r9) : cl_exports.serialize(r9));
        continue;
      }
      typeof o13 == "object" && "type" in o13 && (t5[s8] = Fe4.includes(o13.type) ? postConditionToHex(o13) : cl_exports.serialize(o13));
    }
  }
  return JSON.parse(JSON.stringify(t5));
}
function ds2(e10, t5) {
  return function(o13) {
    if (e10) try {
      setSelectedProviderId(t5);
    } catch (r9) {
    }
    return o13;
  };
}
function us2(e10) {
  return e10.slice().sort((t5, s8) => {
    let o13 = "purpose" in t5 && t5.purpose === "payment", r9 = "purpose" in s8 && s8.purpose === "payment";
    return o13 && !r9 ? -1 : !o13 && r9 ? 1 : 0;
  });
}
typeof window != "undefined" && (window.__CONNECT_VERSION__ = "__VERSION__");
var ps2 = ((o13) => (o13.ContractCall = "contract_call", o13.ContractDeploy = "smart_contract", o13.STXTransfer = "token_transfer", o13))(ps2 || {});
var ls2 = ((n12) => (n12.BUFFER = "buffer", n12.UINT = "uint", n12.INT = "int", n12.PRINCIPAL = "principal", n12.BOOL = "bool", n12))(ls2 || {});
var Me6 = ((n12) => (n12[n12.DEFAULT = 0] = "DEFAULT", n12[n12.ALL = 1] = "ALL", n12[n12.NONE = 2] = "NONE", n12[n12.SINGLE = 3] = "SINGLE", n12[n12.ANYONECANPAY = 128] = "ANYONECANPAY", n12))(Me6 || {});

// src/client/islands/EnvBandIsland.ts
var EnvBandIsland = (() => {
  function h12() {
    return window.__PAGE__ || {};
  }
  function ensureBand() {
    let el = document.getElementById("env-band");
    if (el) return el;
    el = document.createElement("div");
    el.id = "env-band";
    el.className = "env-band";
    el.innerHTML = `
      <span id="env-pill" class="pill"></span>
      <span class="dot">\u2022</span>
      <span id="net-pill" class="pill"></span>
      <span class="dot">\u2022</span>
      <span id="wallet-pill" class="pill"></span>
    `;
    document.body.appendChild(el);
    return el;
  }
  function setTxt(id, text) {
    const n12 = document.getElementById(id);
    if (n12) n12.textContent = text;
  }
  async function refreshWallet() {
    try {
      if (!Qt5()) await ns2();
      const acc = await P7("stx_getAccounts");
      const n12 = Array.isArray(acc?.addresses) ? acc.addresses.length : 0;
      setTxt("wallet-pill", n12 > 0 ? `wallet: connected (${n12})` : "wallet: connected");
    } catch {
      setTxt("wallet-pill", "wallet: not connected");
    }
  }
  async function init() {
    ensureBand();
    const { env, lastNetwork } = h12();
    setTxt("env-pill", `env: ${env || (location.hostname.includes("localhost") ? "dev" : "prod")}`);
    setTxt("net-pill", `network: ${lastNetwork || "unknown"}`);
    refreshWallet();
  }
  document.addEventListener("DOMContentLoaded", init);
  return { init };
})();
export {
  EnvBandIsland
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@walletconnect/relay-auth/dist/index.es.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/private-async-helpers.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/until.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=EnvBandIsland.js.map
