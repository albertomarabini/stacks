import UniversalProvider from '@walletconnect/universal-provider';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import * as AppKitCore from '@reown/appkit/core';
import { UniversalConnector } from '../src/UniversalConnector';
const provider = {
    connect: vi.fn(),
    disconnect: vi.fn(),
    request: vi.fn()
};
const mockAppKit = {
    open: vi.fn(),
    close: vi.fn(),
    disconnect: vi.fn()
};
const baseConfig = {
    projectId: 'test-project',
    metadata: {
        name: 'Test Dapp',
        description: 'A test dapp',
        url: 'https://test.dapp',
        icons: ['https://test.dapp/icon.png']
    },
    networks: [
        {
            namespace: 'eip155',
            chains: [
                {
                    caipNetworkId: 'eip155:1'
                }
            ],
            methods: ['eth_sendTransaction'],
            events: []
        }
    ]
};
describe('UniversalConnector', () => {
    beforeEach(() => {
        vi.restoreAllMocks();
    });
    describe('init', () => {
        it('should initialize UniversalProvider and return a UniversalConnector instance', async () => {
            vi.spyOn(UniversalProvider, 'init').mockResolvedValue(provider);
            vi.spyOn(AppKitCore, 'createAppKit').mockReturnValue(mockAppKit);
            const connector = await UniversalConnector.init(baseConfig);
            expect(UniversalProvider.init).toHaveBeenCalledWith({
                projectId: baseConfig.projectId,
                metadata: baseConfig.metadata
            });
            expect(AppKitCore.createAppKit).toHaveBeenCalled();
            expect(connector).toBeInstanceOf(UniversalConnector);
            expect(connector.provider).toBe(provider);
        });
    });
    describe('connect', () => {
        let connector;
        beforeEach(() => {
            vi.restoreAllMocks();
            connector = new UniversalConnector({
                appKit: mockAppKit,
                provider: provider,
                config: baseConfig
            });
        });
        it('should establish a session and close the AppKit', async () => {
            const mockSession = { topic: 'mock_session_topic' };
            provider.connect.mockResolvedValueOnce(mockSession);
            const result = await connector.connect();
            expect(mockAppKit.open).toHaveBeenCalled();
            expect(provider.connect).toHaveBeenCalled();
            expect(mockAppKit.close).toHaveBeenCalled();
            expect(result).toEqual({ session: mockSession });
        });
        it('should throw when no session is returned', async () => {
            provider.connect.mockResolvedValueOnce(undefined);
            await expect(connector.connect()).rejects.toThrow('Error connecting to wallet: No session found');
            expect(mockAppKit.close).toHaveBeenCalled();
        });
        it('should throw and close AppKit when provider.connect rejects', async () => {
            const error = new Error('connect failed');
            provider.connect.mockRejectedValueOnce(error);
            await expect(connector.connect()).rejects.toThrow(`Error connecting to wallet: ${error.message}`);
            expect(mockAppKit.close).toHaveBeenCalled();
        });
    });
    describe('disconnect', () => {
        beforeEach(() => {
            vi.restoreAllMocks();
        });
        it('should call disconnect on AppKit and provider', async () => {
            const connector = new UniversalConnector({
                appKit: mockAppKit,
                provider: provider,
                config: baseConfig
            });
            await connector.disconnect();
            expect(mockAppKit.disconnect).toHaveBeenCalled();
            expect(provider.disconnect).toHaveBeenCalled();
        });
    });
    describe('request', () => {
        beforeEach(() => {
            vi.restoreAllMocks();
        });
        it('should delegate the request to the provider', async () => {
            const connector = new UniversalConnector({
                appKit: mockAppKit,
                provider: provider,
                config: baseConfig
            });
            const params = { method: 'eth_chainId', params: [] };
            provider.request.mockResolvedValueOnce('0x1');
            const result = await connector.request(params, 'eip155:1');
            expect(provider.request).toHaveBeenCalledWith(params, 'eip155:1');
            expect(result).toBe('0x1');
        });
    });
});
//# sourceMappingURL=UniversalConnector.test.js.map