

# Architectural Plan:
| Component Name | Description |
| -------------- | ----------- |
| ExpressApp | ExpressApp is the universal HTTP application and SSR entrypoint, orchestrating application lifecycle, request flow, and cross-cutting concerns. <br><br>  Component Role:  <br> - Initializes and configures all HTTP routes (public, merchant, admin) at process startup. <br> - Registers and sequences all global Express middlewares, including session (`express-session`), CSRF protection (`csurf`), security (`helmet` for CSP), and rate limiting (`express-rate-limit`). <br> - Serves static assets from `/public` under `/static` using `express.static`, exposing only the intended paths. <br> - On each SSR or API request, injects a sanitized branding object into Express `res.locals` for view rendering, calling BrandingService as required. <br> - Injects hydration objects (`window.__PAGE__`) for SSR pages that require client-side islands, using HydrationInjector. <br> - Applies strict CSP headers to all SSR responses using `helmet` middleware, and ensures page-level script hashes are calculated and injected for any island scripts or inline scripts. <br> - For public POST/GET routes, disables CSRF as required via precise route-level exemptions. <br> - For all `/admin/*` and `/merchant/*` SSR responses, enforces `Cache-Control: no-store, max-age=0` and `Pragma: no-cache` headers. <br> - Delegates all business logic to controllers, never mutating domain/business data. <br> - Handles all error events via global error middleware, SSR-rendering `error.ejs` with branding and friendly error messages. <br> - Ensures only sanitized/normalized data is passed to EJS templates or hydration. <br> - Never exposes secrets or raw error data to SSR or hydration. <br><br>  System Boundaries & State Flow:  <br> - Owns and manages session and CSRF state for authenticated (merchant/admin) flows; state for public routes is transient (request/response only). <br> - No persistent business/domain data is held; all cross-cutting data (branding, hydration) is per-request and transient. <br> - Orchestrates per-request branding, hydration, CSRF/caching/security logic. <br><br>  Component Responsibilities & Interactions:  <br> - Loads, sequences, and configures all Express middleware and route handlers.<br> - Applies session, CSRF, CSP, and rate limiting as appropriate to each route.<br> - Calls BrandingService on every SSR render, handling fallback injection and logging warnings on failure.<br> - Triggers HydrationInjector on all SSR pages that need hydrated client islands.<br> - Applies helmet CSP middleware globally; for each SSR response, ensures required script hashes are calculated and injected into the CSP header (critical for islands).<br> - Applies per-route CSRF exemptions (public endpoints).<br> - Handles error events globally, passing errors to ErrorMiddleware.<br> - Mediates asset/static/public/private boundaries, ensuring only permitted files are served.<br> - Manages one-time secret API key display for key rotation using session state.<br> - Guarantees all SSR/asset/hydration logic is sequenced and isolated.<br> - Destroys session and redirects on Bridge 401/403 error propagation.<br> - Never leaks secrets or privileged internal data. <br><br>  Non-Boilerplate Behaviors:  <br> - Computes page-scoped script hashes for CSP with helmet, enabling granular security for SSR-injected islands.<br> - Ensures order of hydration and asset/script injection is correct for SSR/islands.<br> - Applies error/fallback branding logic per-request. <br><br>  Data Ownership & Lifespan:  <br> - Manages session state for authenticated contexts (merchant/admin).<br> - Holds per-request branding and hydration data in memory for SSR only.<br> - Never stores business data beyond session. <br><br>  External Dependencies & Integration Points:  <br> Express.js, express-session, helmet, csurf, express-rate-limit, ejs-mate, BrandingService, HydrationInjector, SSRViewRenderer, file system APIs. |
| PublicRouteHandlers | PublicRouteHandlers governs all public SSR endpoints and API surfaces, enforcing business rules and output contract for checkout, magic-link, status, invoice, and landing pages.  Component Role:  Handles request parsing, validation, Bridge API interaction, and SSR rendering for all public, non-authenticated customer flows.<br> Operational Behaviors: <br>- For `/checkout/:storeId` (POST): Validates request shape (amount, TTL, memo), calls BridgeClient.prepareInvoice, issues HTTP 302 to received magicLink, disables CSRF for this route.<br>- For `/w/:storeId/:invoiceId` (GET magic-link): Validates presence and structure of `u` param, decodes and parses JSON, fetches hmacSecret, verifies HMAC, checks storeId/invoiceId match, expiry, TTL, unsignedCall safety gates, cross-checks invoice via BridgeClient (status, amounts, expiry), and network context. Rejects on any failure with mapped error. On success, sets `Cache-Control: no-store` and `Pragma: no-cache`, SSR-renders `magic-link.ejs` with branding, invoice, magicLink, returnUrl, and hydration.<br>- For `/status/:invoiceId` (GET): Calls BridgeClient.fetchInvoice, normalizes as DTO, returns JSON (no secrets), disables CSRF.<br>- For `/invoice/:invoiceId` (GET): Fetches invoice DTO and branding, SSR-renders `invoice.ejs` with strict hydration.<br>- For `/` (GET): Fetches public branding or fallback, SSR-renders `landing.ejs`.<br>- Applies proper headers and disables CSRF for all public endpoints.<br>- Injects branding via BrandingService, hydration via HydrationInjector.<br>- Passes any errors to ErrorMiddleware, never leaks details.<br> Domain-Specific Logic:  Magic-link parsing, HMAC, and cross-checking enforce business safety gates; only magic-link is allowed for public payment; cancel/refund actions are never exposed on `/w/*`.<br> Non-Boilerplate Behaviors:  Sets HTTP cache-control headers on all SSR payment pages; strictly normalizes all output to DTO contract; applies per-route CSRF exemption; injects branding and hydration per SSR contract.<br> System Boundaries & State Flow:  No persistent state; all data is per-request.  Data Ownership & Lifespan:  Never stores business or secret data; all output is per-request, sanitized, and transient.  Integration Points:  Calls BrandingService, HydrationInjector, BridgeClient, and SSRViewRenderer. |
| MerchantRouteHandlers | Handles all merchant SSR endpoints and actions for POS, dashboard, invoices, subscriptions, branding, settings, and API keys.  Operational behaviors: <br>- For every `/merchant/*` GET/POST/PATCH: Verifies session via AuthService, applies CSRF middleware where required, validates all user and form input with domain rules (amount > 0, TTL range, color hex, IDs, etc).<br>- On GET: Fetches store branding/profile via BrandingService, sanitizes data, sets HTTP cache headers (`no-store`), SSR-renders page via EJS with normalized DTOs and hydration as needed.<br>- On POST/PATCH: Validates CSRF, parses and validates domain input for invoice creation, refund, cancel, profile updates, key rotation, subscriptions, etc; proxies to BridgeClient.<br>- After any successful POST action that affects domain data (create, cancel, refund, archive, subscription, branding), re-fetches the updated DTO from Bridge (invoice, subscription, branding, etc) before SSR rendering, ensuring UI always reflects latest state.<br>- For API key rotation, after initial POST and first reveal, tracks one-time display using session/flash; on subsequent reloads, masks/hides secrets in SSR context.<br>- Handles POS invoice creation/cancel, manages UI state for POS via islands; injects hydration for status polling and QR generation.<br>- For each SSR POST form, injects CSRF token as hidden input using SSRViewRenderer.<br>- Maps all Bridge/service errors to friendly messages or error views; never leaks secrets or raw error data.<br>- Always applies SSR branding injection, disables caching, and ensures output is sanitized for client/hydration.<br> Domain-specific logic: <br>- Enforces one-time API key/hmacSecret display logic in API keys page; never shows secrets after first reveal.<br>- On session invalidation (Bridge 401/403), destroys session and renders error with friendly copy.<br>- For branding color, always applies regex (`#[0-9A-Fa-f]{6}`) server-side; injects fallback if invalid.<br>- When saving branding/profile, re-fetches latest public branding for preview/theming.<br>- For POS flows, enforces that only magic-link QR is shown.<br>- Validates invoice state/amount matches before showing magic-link.<br> Non-boilerplate: <br>- Applies live preview logic for branding settings in UI with sanitized color.<br>- Ensures all POSTs mutate state only after full validation.<br>- Re-fetches latest state after every mutation for SSR.<br>- Maintains session and one-time logic for secret display.<br>- Injects hydration strictly per contract (never secrets).<br>- All error propagation passes to error middleware for SSR rendering.<br>- For POS/islands, no Bridge calls are ever performed client-side.<br>- Enforces cache, hydration, branding, and error mapping on every SSR flow. |
| AdminRouteHandlers | Handles all admin SSR endpoints (stores, keys, token config, poller, webhooks, bootstrap). <br><br> Component Role : Handles admin HTTP GET/POST/PATCH for `/admin/*`, covering UI-driven form submissions, toggles, and complex flows like key rotation, token setup, poller, and webhooks. Ensures SSR rendering, state updates, secure secret handling, and error mapping. <br><br> Technological Capabilities Used : Express.js routing, express-session for session state, csurf for CSRF, EJS/EJS-mate for SSR, node-fetch/axios for Bridge API calls, DTO normalization, and hydration object construction for client islands. Relies on BridgeClient for all admin data/proxy actions. <br><br> System Boundaries & State Flow : Owns session state for admin authentication, manages one-time secret reveal logic with in-session or in-memory flags, fetches all relevant admin-scoped data from Bridge (never merchant/tenant data), ensures DTO normalization, injects sanitized branding, never exposes secrets to SSR/hydration, and handles transient form and error data per request. <br><br> Component Responsibilities & Interactions :<br>- Receives GET/POST/PATCH for `/admin/*`.<br>- Validates session using AuthService middleware.<br>- Handles login POST, parses and validates credentials, sets session, redirects or SSR-renders error.<br>- Handles store creation POST, validates/sanitizes inputs (brandColor regex), ensures uniqueness, proxies to Bridge, SSR-renders updated store list or error.<br>- Handles key rotation POST, proxies to Bridge, injects secrets for one-time SSR reveal, manages one-time state, masks secrets on reload, ensures no hydration of secrets.<br>- Handles sBTC token config POST, validates/sanitizes, proxies to Bridge, hydrates unsigned call for client signing, SSR-renders state or errors.<br>- Handles bootstrap POST, proxies to Bridge, hydrates unsigned call for client signing, SSR-renders state; on confirmation POST, re-fetches updated state.<br>- Handles poller restart POST, proxies to Bridge, SSR-renders updated status view.<br>- Handles webhook retry POST, proxies to Bridge, SSR-renders updated table.<br>- Handles store activate PATCH, proxies to Bridge, SSR-renders updated activation state, or error.<br>- For all SSR views, fetches and injects sanitized branding.<br>- Enforces scoping: only admin-relevant data is fetched, DTOs are validated for context.<br>- Ensures error mapping for all Bridge/service errors, SSR-renders error.ejs with branding and friendly messages.<br>- For hydration, strictly omits secrets, only hydrates unsigned calls for @stacks/connect flows as needed.<br>- Handles data normalization, error mapping, and one-time behaviors at boundary to SSR view.<br><br> Event Flow :<br>- Handles SSR form submissions, toggles, and button clicks via Express routes.<br>- Delegates data proxying and normalization to BridgeClient and other services.<br>- Triggers SSRViewRenderer for all view renders.<br>- Triggers ErrorMiddleware on any error.<br><br> Data Ownership & Lifespan : Session data for admin user, transient per-request data for forms, errors, revealed secrets (never persisted), in-memory/session flag for one-time secret display.<br><br> External Dependencies & Integration Points : Express.js, express-session, csurf, axios/node-fetch, BridgeClient, AuthService, SSRViewRenderer, BrandingService, EJS/ejs-mate, DTOs, HydrationInjector.<br><br> Domain-Specific or Custom Logic :<br>- Manages one-time display of API keys/HMAC secrets post-rotation, never persists or hydrates secrets, masks on reload, enforces strict boundary.<br>- Enforces brandColor regex (`#[0-9A-Fa-f]{6}`) before saving/using.<br>- On store deactivation, fetches updated state/branding and includes deactivation reasons in SSR views.<br>- Hydrates only unsigned call data for wallet flows, never secrets.<br>- Maps all error flows to SSR error.ejs, injects context/branding.<br>- Strictly fetches/passes only admin-scoped data; filters and validates context.<br>- Handles confirmation POSTs from client islands for token/bootstrap/sync flows, refetches and SSR-renders updated state.<br>- Never exposes stack traces or technical details in user-facing output.<br> |
| BridgeClient | Acts as the stateless HTTP service adapter for all Bridge API calls (prepare-invoice, fetch-invoice, key rotation, branding, webhooks, etc).  Operational behaviors: <br>- Prepares and sends all HTTP requests to Bridge endpoints, always signing with the correct X-API-Key header (never leaks to client).<br>- Receives raw Bridge responses and passes them to the service layer for normalization into DTOs.<br>- Catches all HTTP/network errors, passes to the service layer for mapping into user-friendly messages.<br>- Handles error status codes, converts to friendly messages excluding stack traces and technical details.<br>- Retrieves secrets (apiKey, hmacSecret) for key rotation (one-time), and propagates session invalidation (401/403) up for session destruction.<br>- Never caches, stores, or exposes raw Bridge payloads; only normalized DTOs are returned upstream.<br>- Ensures all Bridge responses are mapped to shapes required by downstream services; never returns unknown or untyped fields.<br>- Used synchronously by service layer for all domain CRUD, key management, branding, and webhook flows.<br> Domain-specific logic: <br>- Never exposes raw Bridge payloads outside service layer.<br>- Returns only normalized DTOs as defined in `/shared/types/dto.ts`.<br>- Error mapping and normalization to user-friendly messages is always performed before controller/view.<br>- On session invalidation (401/403), triggers session destruction and error render via service/controller.<br> Non-boilerplate: <br>- Implements normalization and error mapping logic for every API response.<br>- Integrates tightly with session, error, and secret handling.<br>- Orchestrates one-time secret display via service/controller.<br>- Applies strict response and error typing throughout integration flows.<br>- Never invoked client-side.<br>- For all POST or GET actions, ensures error mapping always occurs before propagation. |
| MagicLinkService | Validates and parses the magic-link (`u` blob), HMAC verification, TTL checks, and safety gates before SSR magic-link page render.  Operational behaviors: <br>- On invocation, receives the `u` blob and route params, base64url-decodes and parses the payload as JSON.<br>- Fetches the per-store hmacSecret for HMAC verification.<br>- Generates exact payload for HMAC using stable key order, computes and validates HMAC using constant-time compare.<br>- Verifies correspondence of storeId and invoiceId between payload and route params.<br>- Enforces expiry and TTL window (rejects expired, too-long, or out-of-bounds TTLS).<br>- Applies strict unsignedCall safety gate: function must be `pay-invoice`, postConditionMode must be 'deny', postconditions must include at least one FT PC for sBTC with exact amount and payer.<br>- Fetches live invoice DTO from BridgeClient and cross-checks state: status must be unpaid, amountSats must match FT PC, quoteExpiresAt must match expiry.<br>- Checks that unsignedCall.network matches deployment context.<br>- Throws error on any check failure, for controller to catch and render error.ejs.<br>- Returns validated data for SSR render (never exposes secrets or HMAC material).<br> Domain-specific logic: <br>- All validation steps, HMAC gates, TTL/expiry checks, and unsignedCall shape verification are custom to business.<br>- Defensive-in-depth: even if client-side checks are attempted, server-side gating is absolute and enforced prior to render.<br>- Never persists or exposes any key or secret material.<br> Non-boilerplate: <br>- Applies full cross-check of hydrated call data against Bridge invoice at render time.<br>- Validates both cryptographic and business rules before any SSR output.<br>- Handles exact error mapping for each failure case.<br>- Always stateless and synchronous/asynchronous as needed.<br>- All logic is server-side only. |
| InvoiceService | Encapsulates all invoice-related business logic; creates, fetches, normalizes invoice DTOs, emits server events as needed.<br>**System Boundaries & State Flow**No persistent state. Stateless per-call.<br>Receives and returns invoice DTOs.<br>Transforms and validates data from Bridge.<br>Does not own state beyond per-request data.<br><br>**Responsibilities & Interactions**:<br>- Creates invoices via Bridge (`prepare-invoice`).<br>- Fetches invoices by id or via list/filter API.<br>- Normalizes Bridge invoice responses to canonical DTOs.<br>- Computes payment state.<br>- Delegates cancel/refund actions to Bridge.<br>- Maps errors for controllers.<br>- Ensures no secret or raw Bridge data is ever exposed.<br>- Used by controllers for SSR and JSON status endpoints.<br>- Does not persist data.<br>**Event Flows**:<br>- Called by route handlers for invoice creation, fetch, status polling, cancel, and refund actions.<br>- No event binding; pure service.<br>- Always server-side; never in client code.<br><br>**Data Ownership & Lifespan**:<br>Stateless; per-request data only.<br>**External Dependencies & Integration**:<br>BridgeClient (for all invoice CRUD, status). DTO types. |
| SubscriptionService | Handles subscription CRUD, plan lookup, invoice generation, and normalization of subscription DTOs.<br>**System Boundaries & State Flow**Stateless per-request.<br>Fetches/manages subscription data.<br>Handles generation/injection of subscription magic-links.<br>Never persists state.<br><br>**Responsibilities & Interactions**:<br>- Creates, cancels, fetches subscriptions via Bridge.<br>- Generates invoices for subscriptions (fetches magic-link, unsignedCall).<br>- Normalizes Bridge responses to subscription DTOs.<br>- Passes data to controllers for SSR rendering.<br>- Handles errors and maps to friendly messages.<br>- Ensures all data is sanitized before passing to view.<br>- No persistent data.<br>**Event Flows**:<br>- Called by MerchantRouteHandlers.<br>- Triggered by POST or GET actions on subscription pages.<br>- No event binding.<br>- Server-side only.<br><br>**Data Ownership & Lifespan**:<br>No persistent state; owns per-request data only.<br>All persistent subscription state is in Bridge.<br>**External Dependencies & Integration**:<br>BridgeClient (for subscription CRUD/invoice), DTO types. |
| StoreService | Handles merchant store CRUD, POS config, branding/profile data, and redirect rules via Bridge.<br>**System Boundaries & State Flow**Stateless per-request.<br>Fetches, updates, and normalizes store info.<br>Fetches branding/profile data for SSR renders.<br>Sanitizes branding (especially brandColor) before injection.<br>Never persists domain data.<br>**Responsibilities & Interactions**:<br>- Fetches/updates store profile and branding via Bridge.<br>- Handles POS config and redirect rules.<br>- Sanitizes all branding (regex validation for brandColor; fallback on invalid).<br>- Provides branding object to controllers for SSR.<br>- Maps errors and logs warnings on invalid branding.<br>- Never persists any data.<br>- Used by controllers for every SSR render that requires branding.<br>- Injects only sanitized, safe branding.<br>**Event Flows**:<br>- Called by any SSR controller on every render.<br>- No event binding; called on-demand.<br>- Server-side only.<br><br>**Data Ownership & Lifespan**:<br>No persistent data; per-request only. All store state lives in Bridge.<br>**External Dependencies & Integration**:<br>BridgeClient (for store CRUD/profile), DTO types. |
| BrandingService | BrandingService is responsible for actively retrieving, sanitizing, and injecting branding/profile data into all SSR views on every request. It is called synchronously by controllers for every SSR GET and error render.  Component Role:  Ensures every SSR-rendered page receives a complete, sanitized branding object that drives theming and UX consistency.  Operational Behaviors: <br>- Receives a storeId (from route params or auth context) and fetches branding from Bridge via BridgeClient. Public pages use `getPublicProfile`, merchant/admin use `getProfile` or aggregate.<br>- Extracts only required fields (`displayName`, `brandColor`, `logoUrl`, `supportEmail`, `supportUrl`).<br>- Applies strict server-side regex validation on `brandColor` (`/^#[0-9A-Fa-f]{6}$/`); if invalid or missing, sets to fallback `#111827` for safety.<br>- Logs a warning if fetch fails, is incomplete, or invalid, and injects fallback branding (`displayName: "WEBPAY", brandColor: "#111827", logoUrl: null`).<br>- Never exposes or persists secrets.<br>- Injects sanitized branding into SSR templates (including error.ejs, all partials) for header/footer and CSS theming.<br>- Provides a fallback branding object for error rendering or SSR failures.<br> Domain-Specific Logic:  Branding color must always be sanitized to prevent style injection. Fallback branding is always injected if fetch fails or is invalid.<br> Non-Boilerplate Behaviors:  Per-request, logs warnings on invalid/fallback; injects branding to every SSR view and error; never omits branding even on failure.<br> System Boundaries & State Flow:  Stateless; per-request only; no persistent storage.  Data Ownership & Lifespan:  No persistent or global state; all branding data is per-request, injected into template locals/context.<br> Integration Points:  Called by all SSR controllers and error middleware before rendering; interacts with BridgeClient and logger utility. |
| AuthService | Provides authentication/session/CSRF/rate limiting for merchant and admin routes. <br><br> Component Role:  Enforces access control for all authenticated endpoints, manages session state for users, applies and validates CSRF tokens, integrates with Express middleware to restrict route access by user type, and redirects unauthenticated or expired sessions to login. <br><br> Technological Capabilities Used:  Uses express-session for session management, csurf for CSRF token enforcement and validation, and express-rate-limit for throttling. <br><br> System Boundaries & State Flow:  Owns session state for authenticated merchant/admin users; does not own or access business domain data. Injects CSRF tokens into SSR views as required per route. <br><br> Component Responsibilities & Interactions:  <ul><li>Applies session authentication middleware to all `/merchant/*` and `/admin/*` routes.</li><li>On each request, validates active session; if missing or expired, automatically redirects user to login (for merchant/admin flows).</li><li>Applies csurf middleware to POST/PUT/PATCH on authenticated routes; validates CSRF token on submission, rejects invalid tokens by triggering error middleware for 403 response.</li><li>On CSRF token validation failure, passes error to ErrorMiddleware to render appropriate error view (error.ejs), including branding, without leaking error details.</li><li>Ensures rate limits are enforced on sensitive endpoints via express-rate-limit.</li></ul> <br> Non-standard Behaviors/Domain Logic:  <ul><li>Session expiry or invalidation triggers auto-redirection to login page (no overrides allowed).</li><li>Disables CSRF for public endpoints by route-based exemption.</li></ul> <br> Data Ownership & Lifespan:  Owns session and CSRF token per user/request in encrypted session store.<br>  External Dependencies & Integration Points:  express-session, csurf, express-rate-limit, Express routing. |
| ErrorMiddleware | ErrorMiddleware acts as the global terminal error handler for all unhandled errors in the Express middleware chain.  Component Role:  Converts all thrown or propagated errors into user-friendly SSR-rendered error pages with proper branding and HTTP status.  Operational Behaviors: <br>- Receives errors from controllers, services, or middleware (including CSRF, validation, Bridge, or runtime errors).<br>- Maps raw/technical errors to user-facing messages and codes using a custom lookup or mapping utility.<br>- Checks for existing branding prop in request context; if absent or fetch fails, calls `BrandingService.injectFallbackBranding()`.<br>- Ensures only sanitized, neutral branding is injected for all error responses.<br>- Calls SSRViewRenderer to render `error.ejs` with `{ error: {message, code}, branding }`.<br>- Ensures HTTP status code matches error type (`400`, `403`, `409`, `410`, `500`, etc).<br>- For CSRF failures, always renders 403 with user-friendly copy.<br>- For session invalidation (Bridge 401/403), destroys session before rendering error.<br>- Never exposes stack traces, secrets, or raw error objects in SSR output.<br>- No further processing after rendering.<br> Domain-Specific Logic:  Error mapping is tailored to business context. Branding is always included for brand consistency.<br> Non-Boilerplate Behaviors:  Handles error rendering for all types of SSR pages; never bypasses branding or friendly error copy.<br> System Boundaries & State Flow:  Stateless except for transient error and branding data during SSR render.  Data Ownership & Lifespan:  No persistent state; all error/context data is per-request/response.  Integration Points:  Integrated as last middleware in Express app; calls BrandingService and SSRViewRenderer. |
| SSRViewRenderer | SSRViewRenderer renders all EJS templates server-side, ensuring branding, hydration, static asset links, and partials are injected as required.  Component Role:  Produces fully SSR HTML for every page, including asset references and partials, never leaking secrets or privileged data.<br> Operational Behaviors: <br>- Receives DTOs, hydration objects, branding, and view name from controller.<br>- Calls EJS (with ejs-mate layouts) to render the target template, passing all props.<br>- Injects static asset references in all layouts/views (`/static/css/app.css`, `/static/js/[island].js`).<br>- Injects hydration object via `<script>window.__PAGE__=...</script>` when needed (calls HydrationInjector).<br>- Ensures all partials are rendered with context (e.g., `<%- include('_partials/header', { branding }) %>`).<br>- Injects sanitized branding into every partial, header/footer, base layout.<br>- In base layout, sets `<title>` from `branding.displayName` unless a title prop override is provided.<br>- Never renders stack traces or secrets.<br>- For POST forms in authenticated contexts, injects CSRF tokens using `req.csrfToken()`.<br>- Applies asset path conventions for all static files.<br>- Never mutates any business/domain state.<br> Domain-Specific Logic:  Hydration, branding, title, and asset injection are all contractually enforced for each page. CSRF forms are only protected for authenticated surfaces.<br> Non-Boilerplate Behaviors:  Handles ordering and presence of hydration and asset links. Applies branding and partials consistently across all pages.<br> System Boundaries & State Flow:  Stateless; per-render only.  Data Ownership & Lifespan:  No persistent state; props/hydration are per-render only.<br> Integration Points:  Used by all controllers, ErrorMiddleware, and branding utilities.<br> |
| MagicLinkIsland | Page-scoped client JS island for the magic-link payment page.  Operational behaviors: <br>- On DOMContentLoaded, reads hydration from `window.__PAGE__` (expects at least invoiceId, magicLink, returnUrl, connectConfig).<br>- Parses and validates `u` query parameter (base64url decode, JSON parse, expiry, function = pay-invoice, postConditionMode = deny, presence of FT PC for sBTC, etc).<br>- If `u` is invalid/expired, renders error UI, disables all wallet actions, and prevents wallet open.<br>- If valid, attempts to auto-open wallet via @stacks/connect with hydrated unsignedCall; if blocked by browser, enables Open Wallet button and binds click to manual open.<br>- On wallet broadcast, shows txid in UI, and if returnUrl is present, redirects to it with txid param.<br>- Draws QR code of the current page URL (the magic-link) using QR code library (`qrcode`) on the `#qr` canvas.<br>- Renders countdown to expiry (`quoteExpiresAt`), updating UI countdown timer.<br>- Handles Copy Link button via clipboard API and UI feedback.<br>- Integrates with StatusStripIsland for real-time payment status polling via `/status/:invoiceId`.<br>- Aborts/cleans up ongoing wallet connections, timers, and event handlers on unload.<br> Domain-specific logic: <br>- Performs local revalidation of `u` blob as defense-in-depth.<br>- Never exposes secrets; only hydrated data is used.<br>- Enforces business rules (no cancel/refund buttons, only payment action is possible).<br> Non-boilerplate: <br>- Manages UI state (auto-open, fallback button, status strip) based on validation and external state.<br>- Provides feedback for copy actions.<br>- Aborts intervals/timers on navigation/unload.<br>- No persistent state; all browser-local.<br>- Never performs Bridge calls; only uses hydrated data and WEBPAY endpoints.<br>- Only mounted on magic-link page.<br> |
| StatusStripIsland | Page-scoped client JS island for polling invoice status and updating UI.  Operational behaviors: <br>- On DOMContentLoaded, reads hydration from `window.__PAGE__` (expects at least {invoiceId}).<br>- Sets up polling interval (1000–1500ms) to fetch `/status/:invoiceId` with Accept: application/json, using fetch API.<br>- On each tick, parses InvoiceDTO and updates UI status strip: Awaiting payment → Broadcast seen → Paid ✓ → Expired/Canceled.<br>- Stops polling if invoice status becomes terminal (paid/expired/canceled), if the page becomes hidden (`document.hidden`), or on navigation/unload.<br>- On fetch/network error, shows user-friendly error and applies exponential backoff; listens to browser `online` event to resume polling.<br>- Aborts all polling and event listeners on `beforeunload` and `visibilitychange` as appropriate.<br>- Never accesses Bridge or internal APIs; only uses hydrated DTOs and `/status/:invoiceId`.<br> Domain-specific logic: <br>- Suspends/resumes polling based on document visibility for efficiency.<br>- Defines `isTerminalStatus` with logic as: paid, expired, or canceled.<br> Non-boilerplate: <br>- Integrates with other islands (magic-link, POS) to propagate terminal state.<br>- UI is updated only in status-strip area.<br>- Handles polling control and UI transitions precisely.<br>- No persistent data; all browser-local.<br>- Always aborts/cleans up timers on navigation or page hide.<br> |
| POSIsland | Client-side ES module for SSR POS page.  Operational behaviors: <br>- On DOMContentLoaded, reads window.__PAGE_ for storeId and initial defaults.<br>- Handles New Sale form submit by POSTing to `/merchant/stores/:storeId/prepare-invoice` with amount, TTL, memo; on success, transitions UI to payment card with QR, countdown, status strip, and cancel button.<br>- Draws QR of magic-link from hydrated value using QR code library.<br>- Starts countdown to invoice expiry and updates UI accordingly.<br>- Integrates with StatusStripIsland to show real-time payment status.<br>- Handles Cancel button by POSTing to `/merchant/stores/:storeId/invoices/:invoiceId/cancel/create-tx`; if unsignedCall is returned, triggers wallet signing via @stacks/connect; if fallback DTO, marks as canceled in UI.<br>- Handles Copy Link/Show QR buttons by reading from hydration and using clipboard API/QR code lib.<br>- After terminal state (paid/expired/canceled), unlocks New Sale action and resets UI state.<br>- Displays error banners/messages for validation, Bridge/network errors, disables UI as needed.<br>- Aborts/cancels all intervals, event listeners, and network calls on unload or navigation.<br>- Handles open/close UI actions for invoice/subscription detail drawer/modals locally; renders hydrated DTO details from window.__PAGE__, never from backend.<br> Domain-specific logic: <br>- POS only ever shows QR of magic-link.<br>- All validation of amount/TTL is enforced before POST.<br>- All cancel/payment flows are gated by invoice state.<br>- Drawer open/close is always browser-local, never backend.<br> Non-boilerplate: <br>- Implements UI state machine for POS flows.<br>- UI can be reset locally via New Sale button.<br>- All state is browser-local and ephemeral.<br>- Never directly accesses Bridge; all server POSTs via WEBPAY only.<br>- Drawer/modal UI is hydrated only from window.__PAGE__, never backend fetch.<br> |
| DTOsAndTypeContracts | Defines and enforces all DTO/data shapes exchanged between server, views, and client hydration.<br>**System Boundaries & State Flow**Does not own or mutate state. Purely declarative.<br>Defines canonical shapes for InvoiceDTO, Branding, hydration contracts, etc.<br>Enforces structure for all data sent to EJS templates and hydrated to islands.<br><br>**Responsibilities & Interactions**:<br>- DTO types imported by services, controllers, and islands.<br>- Ensures all data at controller/view boundary is normalized and safe.<br>- Used to validate BridgeClient/service outputs.<br>- Never processed at runtime; for static analysis/checking.<br>- Never includes secrets or privileged fields in public DTOs.<br>- Ensures contract between server and client data is strict.<br>**Event Flows**:<br>- Used throughout server and client code as static types.<br>- No event binding or runtime behavior.<br>- Shapes all data passed to EJS and hydration.<br><br>**Data Ownership & Lifespan**:<br>No data ownership; types only.<br>Defines compile-time contracts for data exchange and hydration.<br>**External Dependencies & Integration**:<br>None at runtime (TypeScript-only). |
| QRCodeUtility | QRCodeUtility is a stateless client-side utility function/library to draw QR codes in browser islands. On demand (after DOM ready and hydration available), it receives a string (URL, e.g., the magic-link) and a canvas element, and uses a browser-compatible QR code library (e.g., `qrcode`) to encode the string and render the QR into the canvas. If the URL changes (e.g., via navigation), regenerates the QR as needed. No persistent data; all operation is per-invocation. Used by MagicLinkIsland, POSIsland, and any other island needing QR rendering. Integrates: QR code library, browser DOM APIs. |
| HydrationInjector | HydrationInjector precisely constructs and injects type-safe hydration objects into SSR templates that require client-side islands.  Component Role:  Ensures client JS islands receive only contract-compliant, non-secret hydration data via `window.__PAGE__`.<br> Operational Behaviors: <br>- Called by SSR controllers for any page that includes client islands.<br>- Receives a hydration object from the controller matching documented DTO contracts.<br>- Serializes the object to JSON and injects a `<script>window.__PAGE__=...</script>` tag immediately before any island scripts in the EJS template.<br>- Guarantees that only the required, non-secret properties are included.<br>- Ensures hydration injection occurs before island JS script tags.<br>- Never injects hydration on pages/views not requiring client-side behavior.<br>- Never includes secrets or privileged fields.<br> Domain-Specific Logic:  Only fields explicitly allowed in the DTO contract are hydrated; secrets or privileged fields are never included.<br> Non-Boilerplate Behaviors:  Injection order is critical—hydration always comes before all island script tags. Hydration is only ever constructed from sanitized data at controller boundary.<br> System Boundaries & State Flow:  Stateless; operates per-request, per-render.  Data Ownership & Lifespan:  No persistent state; hydration object is constructed and injected per SSR response.<br> Integration Points:  Used by SSRViewRenderer and all SSR controllers with islands. |
| CSRFandSecurityMiddleware | Enforces CSRF, CSP, and rate limits for authenticated routes; disables CSRF on public endpoints as required.<br>**System Boundaries & State Flow**No persistent state. Applies per-request checks and headers.<br>Generates CSRF tokens for forms.<br>Sets security headers.<br>Enforces rate limiting on sensitive endpoints.<br><br>**Responsibilities & Interactions**:<br>- Applied as middleware stack in Express.<br>- Checks validity of CSRF tokens for authenticated POSTs.<br>- Injects CSRF tokens into SSR forms.<br>- Disables CSRF for public endpoints by route exclusion.<br>- Adds CSP headers globally or per-route (via helmet).<br>- Applies rate limits via express-rate-limit.<br>- Rejects invalid requests and passes to error middleware.<br>- Never accesses or persists domain data.<br>- Never exposes tokens to JS islands except in forms.<br>**Event Flows**:<br>- Bound to Express middleware chain at startup.<br>- Applies checks per incoming request.<br>- Handles rejections and passes errors up.<br><br>**Data Ownership & Lifespan**:<br>No data ownership; all tokens/security state is per-request or in session.<br>Never persisted globally.<br><br>**External Dependencies & Integration**:<br>csurf, helmet, express-rate-limit, Express. |
| StaticAssetMiddleware | Serves static files (CSS, JS, images) under `/static/*` from `/public` directory.<br>**System Boundaries & State Flow**No data ownership.<br>Maps all `/static/*` URLs to files in `/public`.<br>Serves Tailwind build output and bundled client JS.<br>Never processes or mutates files.<br><br>**Responsibilities & Interactions**:<br>- Registered in Express app at startup.<br>- On requests for `/static/*`, serves corresponding file from `/public`.<br>- Never serves files outside `/public`.<br>- Required for all client islands, CSS, and images.<br>- No logic beyond static mapping.<br><br>**Event Flows**:<br>- Bound to Express request pipeline.<br>- Only responds to `/static/*` route patterns.<br>- Never invoked by controllers.<br><br>**Data Ownership & Lifespan**:<br>No data ownership; serves files from disk on demand.<br>Never persists or mutates content.<br><br>**External Dependencies & Integration**:<br>Express static, filesystem, public asset directory. |
| AdminKeysIsland | AdminKeysIsland manages the client-side logic for one-time secret reveal and copy actions on the Admin Keys SSR view.  Component Role:  Provides secure, client-local clipboard copy functionality for API key/HMAC secret fields revealed after rotation, with precise enable/disable logic.<br> Operational Behaviors: <br>- On DOMContentLoaded, binds the Copy button next to any revealed secret (`copy-secret`) to `AdminKeysIsland.handleCopySecretClick()`.<br>- When Copy is clicked, reads the secret value from SSR-injected DOM (never from hydration except on initial POST), and uses `navigator.clipboard.writeText(secretValue)` to copy to clipboard.<br>- Ensures Copy button is enabled and visible only on initial one-time reveal view; disables or hides Copy if secrets are masked (after reload or session flag cleared).<br>- No backend or SSR interaction for copy action; purely client-side.  Domain-Specific Logic:  Copy is only allowed during initial secret reveal; never after reload. No secrets are hydrated or persisted in client JS.<br> Non-Boilerplate Behaviors:  Direct DOM access for secret value; strict control of Copy button state based on SSR view context.<br> System Boundaries & State Flow:  Purely client-side, transient DOM state; no data is persisted or sent to backend.<br> Integration Points:  SSR EJS template injects secrets and binds islands; Copy button state is controlled at SSR and island levels. |
| BrandingSettingsIsland | BrandingSettingsIsland manages client-side feedback for brand color changes in the branding/profile settings SSR view.  Component Role:  Allows admins/merchants to preview live branding changes (especially brand color) as they edit, with real-time validation.<br> Operational Behaviors: <br>- On DOMContentLoaded, binds `brandColor` input field's `onchange` and `onblur` events to `BrandingSettingsIsland.handleBrandColorInputChange()`.<br>- When triggered, reads the input value, sanitizes via regex (`#[0-9A-Fa-f]{6}`), and updates the CSS variable `--brand` in the live preview node using DOM APIs.<br>- If input is invalid or empty, resets CSS variable to fallback color `#111827`.<br>- No backend/SSR interaction; all logic and feedback is client-local.<br> Domain-Specific Logic:  Only valid color regex values are applied; invalid values never affect preview.<br> Non-Boilerplate Behaviors:  Real-time feedback; direct manipulation of preview node's style.<br> System Boundaries & State Flow:  Purely client-side, transient state in DOM only.<br> Integration Points:  SSR EJS template must provide live preview node and bind island; input value is SSR-injected initially. |
| MagicLinkValidationService | - **[Offloading Class Names]**: PublicRouteHandlers<br>- **[Originating Method Ids]**: PRH-2, PRH-7<br><br>**Delegate State Owned:**<br>- Stateless; all state is managed within each method invocation (no cross-request or persistent state).<br><br>**Delegate Responsibilities Owned:**<br>- Completely encapsulates parsing, decoding, canonical serialization, HMAC validation, signature comparison, TTL and expiry checks, function/type checks, FT post-condition checks, and network/environment matching for the magic-link (`/w/:storeId/:invoiceId?u=...`) public payment flow.<br>- Returns the validated, parsed payload and synchronizes invoice checking as needed.<br><br>**Responsibilities Removed from Parent Class:**<br>- The complex sequence of magic-link parsing, decoding, canonical JSON serialization, HMAC validation, TTL/expiry enforcement, business validation of unsignedCall fields, and network/context checks are now entirely encapsulated within this delegate.<br>- The parent (`PublicRouteHandlers`) simply delegates to this service and, on success, continues with branding and rendering.<br><br>**Delegate Public Interface:**<br>```typescript<br>async validateAndParse(<br>  u_blob: string,<br>  context: { storeId: string; invoiceId: string }<br>): Promise<{ payload: MagicLinkPayload; invoice: InvoiceDTO }>;<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In PublicRouteHandlers.handleMagicLinkGet:<br>const validated = await this.magicLinkValidationService.validateAndParse(u_blob, { storeId, invoiceId });<br>const payload = validated.payload;<br>const invoice = validated.invoice;<br>// ...proceed with branding, SSR, etc.<br>```<br><br>#### 🔁 Refactored Method: PublicRouteHandlers.handleMagicLinkGet<br><br>**Breakdown of Responsibilities After Refactoring:**<br>- The parent method now:<br>  - Extracts the `u` blob and route parameters.<br>  - Calls the delegate's `validateAndParse` method with the extracted values.<br>  - If validation fails, passes error to next middleware (status code set by the delegate).<br>  - On success, proceeds with fetching branding, cache headers, hydration, and SSR, as before.<br>  - All business and cryptographic validation of the link, signature, payload, and invoice is now owned by the delegate.<br><br>**Usage in Parent:**<br>```typescript<br>async handleMagicLinkGet(req, res, next) {<br>  const { storeId, invoiceId } = req.params;<br>  const u_blob = typeof req.query.u === "string" ? req.query.u : undefined;<br>  if (!u_blob) {<br>    const err = new Error("Missing required payment parameter.");<br>    (err as any).status = 400;<br>    return next(err);<br>  }<br><br>  try {<br>    const validated = await this.magicLinkValidationService.validateAndParse(u_blob, { storeId, invoiceId });<br>    const payload = validated.payload;<br>    const invoice = validated.invoice;<br>    // ...proceed with branding, SSR, etc.<br>  } catch (magicLinkErr: any) {<br>    let status = 400;<br>    if (magicLinkErr && typeof magicLinkErr.status === "number") {<br>      status = magicLinkErr.status;<br>    }<br>    (magicLinkErr as any).status = status;<br>    return next(magicLinkErr);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: validateAndParse<br><br>**Responsibilities:**<br>- Accepts the base64url-encoded `u` parameter and context (storeId, invoiceId).<br>- Decodes and parses the payload as JSON.<br>- Retrieves HMAC secret for the store (from BridgeClient or config).<br>- Canonically serializes `{v,storeId,invoiceId,unsignedCall,exp}` using a stable JSON serializer.<br>- Computes HMAC-SHA256 over the canonical JSON using `hmacSecret`.<br>- Compares computed HMAC (base64url) to the provided `sig` using constant-time comparison.<br>- Checks:<br>  - storeId and invoiceId in payload match route parameters.<br>  - Not expired (`exp > now`), TTL between 120 and 1800 seconds.<br>  - unsignedCall.function == "pay-invoice", postConditionMode == "deny".<br>  - At least one FT post-condition for sBTC with `condition: "eq"` and amount matching the invoice.<br>  - Invoice from BridgeClient has status "unpaid", correct amount, and quoteExpiresAt in the future.<br>  - unsignedCall.network matches deployment network.<br>- On validation failure, throws error with appropriate status (400, 403, 410).<br>- On success, returns `{ payload, invoice }`.<br><br>```typescript<br>import crypto from "crypto";<br><br>export class MagicLinkValidationService {<br>  private bridgeClient: IBridgeClient;<br>  private deploymentNetwork: string;<br><br>  constructor(bridgeClient: IBridgeClient, deploymentNetwork: string) {<br>    this.bridgeClient = bridgeClient;<br>    this.deploymentNetwork = deploymentNetwork;<br>  }<br><br>  async validateAndParse(<br>    u_blob: string,<br>    context: { storeId: string; invoiceId: string }<br>  ): Promise<{ payload: MagicLinkPayload; invoice: InvoiceDTO }> {<br>    // Step 1: base64url-decode and parse<br>    let decoded: string;<br>    let payload: MagicLinkPayload;<br>    try {<br>      decoded = this.base64UrlDecode(u_blob);<br>      payload = JSON.parse(decoded);<br>    } catch {<br>      const err = new Error("Invalid payment parameter: could not decode payload.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // Step 2: Extract and check required fields<br>    const { storeId: pStoreId, invoiceId: pInvoiceId, sig, unsignedCall, exp, v } = payload as any;<br>    if (<br>      !sig or<br>      typeof sig !== "string" or<br>      typeof pStoreId !== "string" or<br>      typeof pInvoiceId !== "string" or<br>      typeof exp !== "number" or<br>      typeof unsignedCall !== "object"<br>    ) {<br>      const err = new Error("Malformed magic-link payload.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // Step 3: Retrieve HMAC secret for store<br>    let hmacSecret: string;<br>    try {<br>      // Preferably fetch from store profile, fall back to config<br>      const storeProfile = await this.bridgeClient.getProfile(context.storeId);<br>      hmacSecret = storeProfile.hmacSecret;<br>      if (typeof hmacSecret !== "string" or !hmacSecret) throw new Error();<br>    } catch {<br>      const err = new Error("Could not retrieve HMAC secret for store.");<br>      (err as any).status = 500;<br>      throw err;<br>    }<br><br>    // Step 4: Canonical JSON serialization for HMAC (stable order)<br>    const canonicalFields = { v, storeId: pStoreId, invoiceId: pInvoiceId, unsignedCall, exp };<br>    const canonicalJson = this.stableStringify(canonicalFields);<br><br>    // Step 5: Compute HMAC-SHA256, base64url encode, constant-time compare with sig<br>    const computedSig = this.base64UrlEncode(<br>      crypto.createHmac("sha256", hmacSecret).update(canonicalJson).digest()<br>    );<br>    if (!this.constantTimeCompare(computedSig, sig)) {<br>      const err = new Error("Invalid signature for payment link.");<br>      (err as any).status = 403;<br>      throw err;<br>    }<br><br>    // Step 6: Verify storeId and invoiceId match route params<br>    if (pStoreId !== context.storeId or pInvoiceId !== context.invoiceId) {<br>      const err = new Error("Payment link does not match store or invoice.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // Step 7: TTL/expiry checks<br>    const now = Math.floor(Date.now() / 1000);<br>    if (exp <= now) {<br>      const err = new Error("Payment link has expired.");<br>      (err as any).status = 410;<br>      throw err;<br>    }<br>    const ttl = exp - now;<br>    if (ttl < 120 or ttl > 1800) {<br>      const err = new Error("Payment link TTL out of range.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // Step 8: unsignedCall checks (must be pay-invoice, postConditionMode == deny, FT post-condition for sBTC)<br>    if (<br>      unsignedCall.function !== "pay-invoice" or<br>      unsignedCall.postConditionMode !== "deny" or<br>      !Array.isArray(unsignedCall.postConditions)<br>    ) {<br>      const err = new Error("Invalid call details for payment.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // Find FT post-condition for sBTC with condition: eq<br>    const sBTCCondition = unsignedCall.postConditions.find(<br>      (pc: any) =><br>        pc.contract === "sBTC" &&<br>        pc.condition === "eq" &&<br>        typeof pc.amount === "number" &&<br>        pc.amount > 0<br>    );<br>    if (!sBTCCondition) {<br>      const err = new Error("Payment link missing required sBTC post-condition.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // Step 9: Fetch invoice and verify state<br>    let invoice: InvoiceDTO;<br>    try {<br>      invoice = await this.bridgeClient.fetchInvoice(context.invoiceId);<br>    } catch {<br>      const err = new Error("Invoice not found or could not be fetched.");<br>      (err as any).status = 404;<br>      throw err;<br>    }<br>    if (invoice.status !== "unpaid" or invoice.amountSats !== sBTCCondition.amount) {<br>      const err = new Error("Invoice is not unpaid or payment amount does not match.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br>    if (invoice.quoteExpiresAt && new Date(invoice.quoteExpiresAt).getTime() <= Date.now()) {<br>      const err = new Error("Invoice has expired.");<br>      (err as any).status = 410;<br>      throw err;<br>    }<br><br>    // Step 10: Network check<br>    if (unsignedCall.network !== this.deploymentNetwork) {<br>      const err = new Error("Payment link network does not match deployment.");<br>      (err as any).status = 400;<br>      throw err;<br>    }<br><br>    // All checks passed<br>    return { payload, invoice };<br>  }<br><br>  private base64UrlDecode(encoded: string): string {<br>    // Replace - and _ back to + and /, pad with '=' if needed<br>    const padded = encoded.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((encoded.length + 3) % 4);<br>    return Buffer.from(padded, "base64").toString("utf8");<br>  }<br><br>  private base64UrlEncode(buf: Buffer): string {<br>    return buf.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");<br>  }<br><br>  private stableStringify(obj: any): string {<br>    // Deterministically serialize object (recursive, sorted keys)<br>    if (Array.isArray(obj)) {<br>      return "[" + obj.map((x) => this.stableStringify(x)).join(",") + "]";<br>    } else if (obj && typeof obj === "object") {<br>      const keys = Object.keys(obj).sort();<br>      return "{" + keys.map((k) => JSON.stringify(k) + ":" + this.stableStringify(obj[k])).join(",") + "}";<br>    } else {<br>      return JSON.stringify(obj);<br>    }<br>  }<br><br>  private constantTimeCompare(a: string, b: string): boolean {<br>    if (a.length !== b.length) return false;<br>    let result = 0;<br>    for (let i = 0; i < a.length; i++) {<br>      result or= a.charCodeAt(i) ^ b.charCodeAt(i);<br>    }<br>    return result === 0;<br>  }<br>}<br>```<br><br>--- |
| BrandColorSanitizer | - **[Offloading Class Names]**: PublicRouteHandlers<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- Stateless utility class (no internal state).<br><br>**Delegate Responsibilities Owned:**<br>- Fully encapsulates the logic for validating and sanitizing the `brandColor` property found in store branding objects, enforcing a strict hex color regex (`/^#[0-9A-Fa-f]{6}$/`), and providing fallbacks as necessary.<br><br>**Responsibilities Removed from Parent Class:**<br>- The logic for checking, validating, and substituting the `brandColor` property using regex and providing fallback hex codes is now isolated from PublicRouteHandlers or any SSR context.<br><br>**Delegate Public Interface:**<br>```typescript<br>sanitize(brandColor: string or undefined): string;<br>```<br><br>**Example Interaction:**<br>```typescript<br>const sanitizedBrandColor = BrandColorSanitizer.sanitize(branding.brandColor);<br>```<br><br>#### 🔧 Delegate Method: sanitize<br><br>**Responsibilities:**<br>- Accepts a raw `brandColor` string (possibly undefined or malformed).<br>- Checks if it matches the regex `/^#[0-9A-Fa-f]{6}$/`.<br>- If valid, returns the color as-is.<br>- If not, returns a neutral fallback value (e.g., `#666666`) for safe theming.<br><br>```typescript<br>export class BrandColorSanitizer {<br>  static sanitize(brandColor: string or undefined): string {<br>    if (typeof brandColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(brandColor)) {<br>      return brandColor;<br>    }<br>    return '#666666'; // fallback neutral grey<br>  }<br>}<br>```<br><br>--- |
| NoCacheHeaderSetter | - **[Offloading Class Names]**: PublicRouteHandlers<br>- **[Originating Method Ids]**: PRH-6<br><br>**Delegate State Owned:**<br>- Stateless; no internal state.<br><br>**Delegate Responsibilities Owned:**<br>- Encapsulates the responsibility for setting strict no-store, no-cache headers on Express `Response` objects for payment-related SSR pages.<br><br>**Responsibilities Removed from Parent Class:**<br>- The direct manipulation of `res.setHeader('Cache-Control', ...)` and `res.setHeader('Pragma', ...)` is now handled by a reusable utility.<br><br>**Delegate Public Interface:**<br>```typescript<br>set(res: Express.Response): void;<br>```<br><br>**Example Interaction:**<br>```typescript<br>NoCacheHeaderSetter.set(res);<br>```<br><br>#### 🔧 Delegate Method: set<br><br>**Responsibilities:**<br>- Sets the HTTP response header `Cache-Control` to `no-store, max-age=0`.<br>- Sets the HTTP response header `Pragma` to `no-cache`.<br><br>```typescript<br>export class NoCacheHeaderSetter {<br>  static set(res: any): void {<br>    res.setHeader('Cache-Control', 'no-store, max-age=0');<br>    res.setHeader('Pragma', 'no-cache');<br>  }<br>}<br>```<br><br>--- |
| ExpressCSPHashManager | - **[Offloading Class Names]**: ExpressApp<br>- **[Originating Method Ids]**: EA-2<br><br>**Delegate State Owned:**<br>- None persistent; computes per-request script hashes only.<br><br>**Delegate Responsibilities Owned:**<br>- Manages the computation and injection of page-scoped CSP script hashes for SSR-rendered pages that include inline scripts or client islands.<br>- Ensures only scripts actually present in the SSR response are included as allowed sources in the CSP header.<br>- Works as an Express middleware invoked before SSR responses.<br><br>**Responsibilities Removed from Parent Class:**<br>- Detailed per-request CSP hash computation, string concatenation, and dynamic header setting logic.<br><br>**Delegate Public Interface:**<br>```typescript<br>middleware(): express.RequestHandler;<br>```<br><br>**Example Interaction:**<br>```typescript<br>app.use(ExpressCSPHashManager.middleware());<br>```<br><br>#### 🔧 Delegate Method: middleware<br><br>**Responsibilities:**<br>- For each SSR response, inspects rendered HTML for inline scripts.<br>- Computes SHA256 hashes for all inline scripts present in the response body.<br>- Adds these hashes to the Content-Security-Policy header (`script-src ... 'sha256-<hash>' ...`).<br>- Ensures only those hashes for scripts present in the page are included.<br><br>```typescript<br>import crypto from "crypto";<br><br>export class ExpressCSPHashManager {<br>  static middleware(): express.RequestHandler {<br>    return (req, res, next) => {<br>      // Intercept render to post-process HTML and CSP<br>      const originalRender = res.render;<br>      res.render = function(view, options, callback) {<br>        const self = this;<br>        originalRender.call(self, view, options, function(err, html) {<br>          if (err) {<br>            if (callback) return callback(err);<br>            else return next(err);<br>          }<br>          // Find all <script>...</script> blocks (excluding src)<br>          const scriptBlocks = [];<br>          const regex = /<script(?![^>]*src=)[^>]*>([\s\S]*?)<\/script>/gi;<br>          let match;<br>          while ((match = regex.exec(html)) !== null) {<br>            if (match[1].trim()) scriptBlocks.push(match[1]);<br>          }<br>          // Compute hashes<br>          const hashes = scriptBlocks.map(code =><br>            `'sha256-${crypto.createHash('sha256').update(code, 'utf8').digest('base64')}'`<br>          );<br>          // Build CSP header<br>          const baseCSP = "default-src 'self'; script-src 'self'";<br>          const cspHeader = hashes.length<br>            ? baseCSP + " " + hashes.join(" ")<br>            : baseCSP;<br>          res.setHeader('Content-Security-Policy', cspHeader);<br>          // Write HTML response<br>          res.send(html);<br>          if (callback) callback(null, html);<br>        });<br>      };<br>      next();<br>    };<br>  }<br>}<br>```<br><br>--- |
| BrandingSSRInjector | - **[Offloading Class Names]**: ExpressApp, PublicRouteHandlers<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- Stateless; injects branding into SSR `res.locals`, or returns fallback if not found.<br><br>**Delegate Responsibilities Owned:**<br>- Centralizes the logic to fetch, sanitize, and inject branding details (including sanitized color) into Express SSR context.<br>- Applies fallback branding if fetch or sanitize fails.<br><br>**Responsibilities Removed from Parent Class:**<br>- The code for fetching, sanitizing, and injecting branding for SSR pages.<br><br>**Delegate Public Interface:**<br>```typescript<br>async injectBranding(res: Express.Response, storeId?: string): Promise<void>;<br>```<br><br>**Example Interaction:**<br>```typescript<br>await BrandingSSRInjector.injectBranding(res, storeId);<br>```<br><br>#### 🔧 Delegate Method: injectBranding<br><br>**Responsibilities:**<br>- Accepts the Express response object and optional storeId.<br>- Attempts to fetch branding via BrandingService.<br>- Sanitizes brandColor using BrandColorSanitizer.<br>- Injects sanitized branding into `res.locals.branding`.<br>- On failure, injects fallback branding.<br><br>```typescript<br>export class BrandingSSRInjector {<br>  static async injectBranding(res: any, storeId?: string) {<br>    let branding;<br>    try {<br>      if (storeId) {<br>        branding = await res.app.locals.brandingService.fetchBranding(storeId);<br>      } else {<br>        branding = res.app.locals.brandingService.injectFallbackBranding();<br>      }<br>    } catch {<br>      branding = res.app.locals.brandingService.injectFallbackBranding();<br>    }<br>    branding.brandColor = BrandColorSanitizer.sanitize(branding.brandColor);<br>    res.locals.branding = branding;<br>  }<br>}<br>```<br>````<br><br>End of report. |
| InputValidationDelegate | - **[Offloading Class Names]**: MerchantRouteHandlers<br>- **[Originating Method Ids]**: MH-2, MH-11, MH-12<br><br>**Delegate State Owned:**<br>- None (stateless, pure validation and sanitization).<br><br>**Delegate Responsibilities Owned:**<br>- Validates and sanitizes all input fields required by merchant POST actions:<br>    - Invoice creation (amount, ttl, memo)<br>    - Subscription creation (all subscription DTO fields)<br>    - Branding/profile updates (brandColor, displayName, etc.)<br>    - General field presence and type checking<br>- Encapsulates regex-based validation for brand color.<br>- Ensures validation errors are raised as exceptions with clear messages.<br><br>**Responsibilities Removed from Parent Class:**<br>- All field-by-field input validation and sanitization previously performed in `handleMerchantPost`, `handlePrepareInvoicePost`, and `handleSaveBrandingProfile`.<br><br>**Delegate Public Interface:**<br>```typescript<br>class InputValidationDelegate {<br>  validateInvoiceInput(input: { amount: any, ttl: any, memo?: any }): { amount: number, ttl: number, memo: string };<br>  validateSubscriptionInput(dto: any): any;<br>  validateBrandingProfileInput(input: { displayName?: any, brandColor?: any, logoUrl?: any, supportEmail?: any, supportUrl?: any }): { displayName?: string, brandColor?: string, logoUrl?: string, supportEmail?: string, supportUrl?: string };<br>  sanitizeBrandColor(color: any): string;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const validated = inputValidator.validateInvoiceInput(req.body);<br>// Returns normalized { amount, ttl, memo } or throws on failure.<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handleMerchantPost<br><br>**Responsibilities After Refactoring:**<br>- No longer implements field-by-field input validation or sanitization.<br>- Delegates all validation and normalization of merchant POST payloads (e.g., invoice, branding, subscription) to `InputValidationDelegate`.<br>- Receives validated and normalized objects, using them directly for Bridge/service calls.<br><br>**Example Code:**<br>```typescript<br>const validated = this.inputValidator.validateInvoiceInput(req.body);<br>// Then use: validated.amount, validated.ttl, validated.memo<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handlePrepareInvoicePost<br><br>**Responsibilities After Refactoring:**<br>- Calls delegate to validate amount, ttl, and memo fields.<br>- Proceeds only with validated output.<br><br>**Example Code:**<br>```typescript<br>const validated = this.inputValidator.validateInvoiceInput(req.body);<br>// Use validated.amount, validated.ttl, validated.memo<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handleSaveBrandingProfile<br><br>**Responsibilities After Refactoring:**<br>- Calls delegate to validate and sanitize all branding/profile payloads.<br>- Uses sanitized values for service calls.<br><br>**Example Code:**<br>```typescript<br>const validatedProfile = this.inputValidator.validateBrandingProfileInput(req.body);<br>// Use validatedProfile directly for persistence<br>```<br><br>#### 🔧 Delegate Method: validateInvoiceInput<br><br>**Responsibility:**<br>- Checks that amount exists and is > 0 (number).<br>- Checks that ttl exists and is between 120 and 1800 (number).<br>- Normalizes memo to string (empty string allowed).<br>- Throws error with clear message if validation fails.<br><br>```typescript<br>class InputValidationDelegate {<br>  validateInvoiceInput(input: { amount: any, ttl: any, memo?: any }): { amount: number, ttl: number, memo: string } {<br>    const { amount, ttl, memo } = input;<br>    if (typeof amount !== 'number' or amount <= 0 or !isFinite(amount)) {<br>      throw new Error('Amount must be a positive number');<br>    }<br>    const ttlNum = Number(ttl);<br>    if (!Number.isInteger(ttlNum) or ttlNum < 120 or ttlNum > 1800) {<br>      throw new Error('TTL must be an integer between 120 and 1800');<br>    }<br>    return {<br>      amount,<br>      ttl: ttlNum,<br>      memo: typeof memo === 'string' ? memo : (memo === undefined ? '' : String(memo)),<br>    };<br>  }<br><br>  validateSubscriptionInput(dto: any): any {<br>    if (!dto) throw new Error('Subscription payload required');<br>    // Example: enforce amount > 0, interval, principal, etc.<br>    if (typeof dto.amount !== 'number' or dto.amount <= 0) {<br>      throw new Error('Subscription amount must be a positive number');<br>    }<br>    if (!dto.interval or typeof dto.interval !== 'string') {<br>      throw new Error('Subscription interval required');<br>    }<br>    if (!dto.principal or typeof dto.principal !== 'string') {<br>      throw new Error('Subscription principal required');<br>    }<br>    // Additional field checks can be added here as per schema.<br>    return dto;<br>  }<br><br>  validateBrandingProfileInput(input: { displayName?: any, brandColor?: any, logoUrl?: any, supportEmail?: any, supportUrl?: any }): { displayName?: string, brandColor?: string, logoUrl?: string, supportEmail?: string, supportUrl?: string } {<br>    const sanitized: any = {};<br>    if ('displayName' in input) sanitized.displayName = String(input.displayName or '').trim();<br>    if ('brandColor' in input) sanitized.brandColor = this.sanitizeBrandColor(input.brandColor);<br>    if ('logoUrl' in input) sanitized.logoUrl = String(input.logoUrl or '').trim();<br>    if ('supportEmail' in input) sanitized.supportEmail = String(input.supportEmail or '').trim();<br>    if ('supportUrl' in input) sanitized.supportUrl = String(input.supportUrl or '').trim();<br>    return sanitized;<br>  }<br><br>  sanitizeBrandColor(color: any): string {<br>    if (typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(color)) {<br>      return color;<br>    }<br>    // Fallback to default brand color.<br>    return '#4F46E5';<br>  }<br>}<br>```<br><br>--- |
| ApiKeyRevealStateManager | - **[Offloading Class Names]**: MerchantRouteHandlers<br>- **[Originating Method Ids]**: MRH-3<br><br>**Delegate State Owned:**<br>- None (all state is maintained in the request session; delegate only reads/writes session flags).<br><br>**Delegate Responsibilities Owned:**<br>- Manages display/masking of API keys and HMAC secrets for one-time reveal.<br>- Controls and updates session flag `apiKeysRevealed`.<br>- Determines if secrets should be masked and what values are injected to SSR template.<br>- Returns the data object for SSR rendering (with real or masked secrets).<br><br>**Responsibilities Removed from Parent Class:**<br>- All session flag management and secret masking logic for API keys in `handleApiKeysMaskOnReload`.<br><br>**Delegate Public Interface:**<br>```typescript<br>class ApiKeyRevealStateManager {<br>  handleApiKeysRevealAndMask(req: any, branding: any, apiKey?: string, hmacSecret?: string): { apiKey: string, hmacSecret: string, branding: any };<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const revealResult = apiKeyRevealState.handleApiKeysRevealAndMask(req, branding, apiKey, hmacSecret);<br>// Use revealResult for SSR render<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handleApiKeysMaskOnReload<br><br>**Responsibilities After Refactoring:**<br>- No longer reads/updates session flags or determines masking logic inline.<br>- Delegates all logic to `ApiKeyRevealStateManager.handleApiKeysRevealAndMask`.<br>- Renders the SSR view with the result.<br><br>**Example Code:**<br>```typescript<br>const result = this.apiKeyRevealStateManager.handleApiKeysRevealAndMask(req, branding);<br>res.render('api-keys.ejs', result);<br>```<br><br>#### 🔧 Delegate Method: handleApiKeysRevealAndMask<br><br>**Responsibility:**<br>- Checks if `req.session.apiKeysRevealed` is set.<br>    - If set, clears the flag, and returns masked secrets.<br>    - If optional `apiKey`/`hmacSecret` are passed (from rotation), returns them for one-time display, and sets flag.<br>    - Otherwise, always returns masked values.<br>- Always includes branding in return object.<br><br>```typescript<br>class ApiKeyRevealStateManager {<br>  handleApiKeysRevealAndMask(req: any, branding: any, apiKey?: string, hmacSecret?: string): { apiKey: string, hmacSecret: string, branding: any } {<br>    if (apiKey && hmacSecret) {<br>      req.session.apiKeysRevealed = true;<br>      return { apiKey, hmacSecret, branding };<br>    }<br>    if (req.session.apiKeysRevealed) {<br>      req.session.apiKeysRevealed = false;<br>      return { apiKey: '********', hmacSecret: '********', branding };<br>    }<br>    return { apiKey: '********', hmacSecret: '********', branding };<br>  }<br>}<br>```<br><br>--- |
| HydrationObjectBuilder | - **[Offloading Class Names]**: MerchantRouteHandlers<br>- **[Originating Method Ids]**: MH-1, MH-2, MH-6, MH-11<br><br>**Delegate State Owned:**<br>- None (stateless; constructs and returns hydration objects per contract).<br><br>**Delegate Responsibilities Owned:**<br>- Assembles contract-compliant hydration objects for client-side islands.<br>- Determines what fields are injected based on context (e.g., storeId, invoiceId).<br>- Ensures no secrets or sensitive data are ever included.<br><br>**Responsibilities Removed from Parent Class:**<br>- All object shape logic for hydration objects in GET/POST handlers.<br>- Responsibility for determining fields per use case.<br><br>**Delegate Public Interface:**<br>```typescript<br>class HydrationObjectBuilder {<br>  buildPosHydration(storeId: string): object;<br>  buildInvoiceHydration(invoiceId: string): object;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const hydration = hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br>const hydrationScript = hydrationInjector.inject(hydration);<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handleMerchantGet<br><br>**Responsibilities After Refactoring:**<br>- No longer constructs hydration objects inline.<br>- Delegates hydration object build for POS/islands via `HydrationObjectBuilder`.<br><br>**Example Code:**<br>```typescript<br>let hydrationScript = '';<br>if (req.path.endsWith('/pos')) {<br>  hydrationScript = this.hydrationBuilder.buildPosHydration(storeId);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handleMerchantPost<br><br>**Responsibilities After Refactoring:**<br>- Delegates construction of hydration object for new invoices, passing invoiceId.<br><br>**Example Code:**<br>```typescript<br>const hydration = this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br>const hydrationScript = this.hydrationInjector.inject(hydration);<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handleGenerateInvoiceNow<br><br>**Responsibilities After Refactoring:**<br>- Uses builder to create any required hydration for client-side actions.<br><br>**Example Code:**<br>```typescript<br>const hydration = this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.handlePrepareInvoicePost<br><br>**Responsibilities After Refactoring:**<br>- Uses builder to create hydration object for POS payment view.<br><br>**Example Code:**<br>```typescript<br>const hydration = this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br>const hydrationScript = this.hydrationInjector.inject(hydration);<br>```<br><br>#### 🔧 Delegate Method: buildPosHydration<br><br>**Responsibility:**<br>- Returns a minimal contract object containing the storeId for POS islands.<br><br>```typescript<br>class HydrationObjectBuilder {<br>  buildPosHydration(storeId: string): object {<br>    return { storeId };<br>  }<br>  buildInvoiceHydration(invoiceId: string): object {<br>    return { invoiceId };<br>  }<br>}<br>```<br><br>--- |
| BrandingContextFetcher | - **[Offloading Class Names]**: MerchantRouteHandlers<br>- **[Originating Method Ids]**: MRH-4<br><br>**Delegate State Owned:**<br>- None (stateless; fetches and normalizes branding data per call).<br><br>**Delegate Responsibilities Owned:**<br>- Handles fetching and normalizing branding objects for a given storeId after branding/profile save.<br>- Ensures fallback branding is injected on error.<br>- Centralizes Bridge call for branding/public-profile.<br><br>**Responsibilities Removed from Parent Class:**<br>- All Bridge calls and normalization logic for branding after profile save, including error fallback.<br><br>**Delegate Public Interface:**<br>```typescript<br>class BrandingContextFetcher {<br>  fetchPublicBrandingOrFallback(storeId: string, brandingService: any): Promise<any>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const branding = await brandingFetcher.fetchPublicBrandingOrFallback(storeId, this.brandingService);<br>res.locals.branding = branding;<br>```<br><br>#### 🔁 Refactored Method: MerchantRouteHandlers.refetchPublicProfileAfterSave<br><br>**Responsibilities After Refactoring:**<br>- No longer implements fetching/fallback logic inline.<br>- Awaits delegate and sets `res.locals.branding`.<br><br>**Example Code:**<br>```typescript<br>res.locals.branding = await this.brandingFetcher.fetchPublicBrandingOrFallback(storeId, this.brandingService);<br>```<br><br>#### 🔧 Delegate Method: fetchPublicBrandingOrFallback<br><br>**Responsibility:**<br>- Calls `brandingService.fetchBranding(storeId)`.<br>- If successful, returns normalized branding DTO.<br>- On error, calls `brandingService.injectFallbackBranding()` and returns that.<br><br>```typescript<br>class BrandingContextFetcher {<br>  async fetchPublicBrandingOrFallback(storeId: string, brandingService: any): Promise<any> {<br>    try {<br>      return await brandingService.fetchBranding(storeId);<br>    } catch (err) {<br>      return brandingService.injectFallbackBranding();<br>    }<br>  }<br>}<br>```<br>````<br><br>End of report. |
| StoreCreationValidator | - **[Offloading Class Names]**: AdminRouteHandlers<br>- **[Originating Method Ids]**: ARH-2<br><br>**Delegate State Owned:**<br>- None (stateless; operates per call).<br><br>**Delegate Responsibilities Owned:**<br>- Validation and sanitization of input fields for new store creation.<br>- Verification of required fields (`displayName`, `principal`).<br>- Validation of `brandColor` string against regex.<br>- Uniqueness check for `principal` against the current store list.<br>- Assembly of a sanitized DTO for downstream processing.<br><br>**Responsibilities Removed from Parent Class:**<br>- Direct server-side validation and sanitization logic for store creation, including regex validation and required field checks.<br>- Construction of the validated DTO for store creation.<br><br>**Delegate Public Interface:**<br>```typescript<br>validateAndBuildStoreDTO(<br>  input: {<br>    displayName: any;<br>    principal: any;<br>    brandColor: any;<br>    logoUrl?: any;<br>    supportEmail?: any;<br>    supportUrl?: any;<br>  },<br>  existingPrincipals: string[]<br>): {<br>  displayName: string;<br>  principal: string;<br>  brandColor: string;<br>  logoUrl?: string or null;<br>  supportEmail?: string or null;<br>  supportUrl?: string or null;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const newStoreDTO = storeCreationValidator.validateAndBuildStoreDTO(req.body, existingPrincipals);<br>```<br><br>#### 🔁 Refactored Method: AdminRouteHandlers.handleStoresPost<br><br>**Breakdown of Responsibilities After Refactoring:**<br>- The parent method now collects the raw input from `req.body` and the list of existing principals (queried from Bridge).<br>- Validation and DTO construction are fully delegated to `StoreCreationValidator`.<br>- On success, the validated DTO is sent to `bridgeClient.createStore`.<br>- All error handling, SSR rendering, and branding logic remain in the parent.<br>- The parent is free of input validation/sanitization noise.<br><br>**Interaction Example:**<br>```typescript<br>async handleStoresPost(req, res, next): Promise<void> {<br>  try {<br>    const { displayName, principal, brandColor, logoUrl, supportEmail, supportUrl } = req.body;<br>    const stores = await this.bridgeClient.listStores();<br>    const existingPrincipals = stores.map(s => s.principal);<br>    // Delegate validation and DTO construction<br>    const newStoreDTO = this.storeCreationValidator.validateAndBuildStoreDTO(<br>      { displayName, principal, brandColor, logoUrl, supportEmail, supportUrl },<br>      existingPrincipals<br>    );<br>    await this.bridgeClient.createStore(newStoreDTO);<br>    // Fetch updated store list for SSR<br>    const newStores = await this.bridgeClient.listStores();<br>    const branding = await this.brandingService.fetchBranding('');<br>    res.render('admin/stores.ejs', {<br>      branding,<br>      stores: newStores<br>    });<br>  } catch (err) {<br>    // ...<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: validateAndBuildStoreDTO<br><br>**Responsibility:**<br>- Receives raw input object and an array of existing principals.<br>- Validates `displayName` and `principal` as required non-empty strings.<br>- Validates `brandColor` using regex `/^#[0-9A-Fa-f]{6}$/`.<br>- Checks that `principal` is unique in the existing list.<br>- Returns a sanitized DTO object suitable for store creation.<br>- Throws an error with a clear message on validation failure.<br><br>**Signature:**<br>```typescript<br>validateAndBuildStoreDTO(<br>  input: {<br>    displayName: any;<br>    principal: any;<br>    brandColor: any;<br>    logoUrl?: any;<br>    supportEmail?: any;<br>    supportUrl?: any;<br>  },<br>  existingPrincipals: string[]<br>): {<br>  displayName: string;<br>  principal: string;<br>  brandColor: string;<br>  logoUrl?: string or null;<br>  supportEmail?: string or null;<br>  supportUrl?: string or null;<br>}<br>```<br><br>**Production-Ready Code:**<br>```typescript<br>export class StoreCreationValidator {<br>  private static BRAND_COLOR_REGEX = /^#[0-9A-Fa-f]{6}$/;<br><br>  /**<br>   * Validates and sanitizes store creation input.<br>   * @param input Input fields from the request body.<br>   * @param existingPrincipals Array of already in-use principals for uniqueness check.<br>   * @returns Sanitized DTO for store creation.<br>   * @throws Error with validation message if input is invalid.<br>   */<br>  public validateAndBuildStoreDTO(<br>    input: {<br>      displayName: any;<br>      principal: any;<br>      brandColor: any;<br>      logoUrl?: any;<br>      supportEmail?: any;<br>      supportUrl?: any;<br>    },<br>    existingPrincipals: string[]<br>  ): {<br>    displayName: string;<br>    principal: string;<br>    brandColor: string;<br>    logoUrl?: string or null;<br>    supportEmail?: string or null;<br>    supportUrl?: string or null;<br>  } {<br>    // Required string checks<br>    if (!input.displayName or typeof input.displayName !== 'string') {<br>      throw new Error('Display name is required and must be a string.');<br>    }<br>    if (!input.principal or typeof input.principal !== 'string') {<br>      throw new Error('Principal is required and must be a string.');<br>    }<br>    // Uniqueness check<br>    if (existingPrincipals.includes(input.principal)) {<br>      throw new Error('Principal must be unique.');<br>    }<br>    // Brand color validation<br>    if (!input.brandColor or typeof input.brandColor !== 'string' or<br>        !StoreCreationValidator.BRAND_COLOR_REGEX.test(input.brandColor)) {<br>      throw new Error('Brand color must be a valid hex color (e.g., #AABBCC).');<br>    }<br>    // Optional fields: forced to string or null<br>    const safeLogoUrl = input.logoUrl && typeof input.logoUrl === 'string' ? input.logoUrl : null;<br>    const safeSupportEmail = input.supportEmail && typeof input.supportEmail === 'string' ? input.supportEmail : null;<br>    const safeSupportUrl = input.supportUrl && typeof input.supportUrl === 'string' ? input.supportUrl : null;<br><br>    return {<br>      displayName: input.displayName.trim(),<br>      principal: input.principal.trim(),<br>      brandColor: input.brandColor,<br>      logoUrl: safeLogoUrl,<br>      supportEmail: safeSupportEmail,<br>      supportUrl: safeSupportUrl<br>    };<br>  }<br>}<br>```<br><br>--- |
| SecretFieldOmitter | - **[Offloading Class Names]**: AdminRouteHandlers<br>- **[Originating Method Ids]**: ARH-12<br><br>**Delegate State Owned:**<br>- None (stateless; operates on provided props per call).<br><br>**Delegate Responsibilities Owned:**<br>- Systematically omits any secret or non-whitelisted fields from SSR props and hydration payloads.<br>- Handles selective whitelisting of allowed fields in `unsignedCall` objects.<br>- Ensures that only contractually safe, non-sensitive fields are present in returned objects.<br><br>**Responsibilities Removed from Parent Class:**<br>- Manual iteration, field exclusion, and whitelisting logic for SSR/hydration safety.<br>- Management of the allowed/omitted secrets list.<br><br>**Delegate Public Interface:**<br>```typescript<br>omitSecretsFromProps(props: Record<string, any>): Record<string, any><br>```<br><br>**Example Interaction:**<br>```typescript<br>const safeProps = secretFieldOmitter.omitSecretsFromProps(props);<br>```<br><br>#### 🔁 Refactored Method: AdminRouteHandlers.omitSecretsFromViewPropsAndHydration<br><br>**Breakdown of Responsibilities After Refactoring:**<br>- The parent class now simply calls the delegate’s method, passing the props object.<br>- The delegate is solely responsible for identifying and omitting secret or non-whitelisted fields.<br>- The method always returns a sanitized object for SSR rendering and hydration.<br>- The parent no longer manages or updates the omit list or whitelisting logic.<br><br>**Interaction Example:**<br>```typescript<br>const safeProps = this.secretFieldOmitter.omitSecretsFromProps(props);<br>res.render(template, {<br>  branding,<br>  ...safeProps<br>});<br>```<br><br>#### 🔧 Delegate Method: omitSecretsFromProps<br><br>**Responsibility:**<br>- Receives a props object.<br>- Removes keys that match known secret fields (`apiKey`, `hmacSecret`, etc.).<br>- For nested objects like `unsignedCall`, includes only allowed fields: `contractId`, `function`, `args`, `postConditions`, `postConditionMode`, and `network`.<br>- Returns a new object sanitized for SSR and hydration.<br><br>**Signature:**<br>```typescript<br>omitSecretsFromProps(props: Record<string, any>): Record<string, any><br>```<br><br>**Production-Ready Code:**<br>```typescript<br>export class SecretFieldOmitter {<br>  private static readonly OMIT_LIST = [<br>    'apiKey',<br>    'hmacSecret',<br>    'adminPassword',<br>    'sessionToken',<br>    'jwt',<br>    'adminSecret'<br>  ];<br>  private static readonly UNSIGNED_CALL_WHITELIST = [<br>    'contractId',<br>    'function',<br>    'args',<br>    'postConditions',<br>    'postConditionMode',<br>    'network'<br>  ];<br><br>  /**<br>   * Removes all secret or non-whitelisted fields from the provided props.<br>   * @param props The raw props object intended for SSR or hydration.<br>   * @returns A new object with secrets omitted and nested whitelisting applied.<br>   */<br>  public omitSecretsFromProps(props: Record<string, any>): Record<string, any> {<br>    const filtered: Record<string, any> = {};<br>    for (const key of Object.keys(props)) {<br>      if (SecretFieldOmitter.OMIT_LIST.includes(key)) continue;<br><br>      if (key === 'unsignedCall' && typeof props[key] === 'object' && props[key]) {<br>        // Allow only whitelisted fields for unsignedCall<br>        const uc = props[key];<br>        filtered[key] = {};<br>        for (const allowedField of SecretFieldOmitter.UNSIGNED_CALL_WHITELIST) {<br>          if (Object.prototype.hasOwnProperty.call(uc, allowedField)) {<br>            filtered[key][allowedField] = uc[allowedField];<br>          }<br>        }<br>        continue;<br>      }<br>      filtered[key] = props[key];<br>    }<br>    return filtered;<br>  }<br>}<br>```<br><br>--- |
| AdminContextScopeEnforcer | - **[Offloading Class Names]**: AdminRouteHandlers<br>- **[Originating Method Ids]**: ARH-13<br><br>**Delegate State Owned:**<br>- None (stateless; only inspects input data).<br><br>**Delegate Responsibilities Owned:**<br>- Validation of admin session presence (`req.session.admin`).<br>- Verification that all DTOs being rendered belong to the admin scope.<br>- Throws or returns a safe fallback if the session is missing or data is out-of-scope.<br><br>**Responsibilities Removed from Parent Class:**<br>- Logic for verifying admin session existence and proper scoping before SSR view rendering.<br>- Responsibility for raising or logging a security exception in context failure cases.<br><br>**Delegate Public Interface:**<br>```typescript<br>enforceScope(req: Express.Request, res: Express.Response, dataScopingTargets?: any[]): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>this.adminContextScopeEnforcer.enforceScope(req, res, [stores]);<br>```<br><br>#### 🔁 Refactored Method: AdminRouteHandlers.enforceAdminContextDataScopes<br><br>**Breakdown of Responsibilities After Refactoring:**<br>- The parent class now calls the delegate method to enforce context just before SSR rendering.<br>- The delegate throws if the request is not in admin context, or if the DTOs provided are not scoped to the admin user.<br>- Parent does not directly check session fields or validate scoping logic, but may handle thrown errors as appropriate.<br><br>**Interaction Example:**<br>```typescript<br>this.adminContextScopeEnforcer.enforceScope(req, res, [props.stores]);<br>```<br><br>#### 🔧 Delegate Method: enforceScope<br><br>**Responsibility:**<br>- Checks whether `req.session` exists and has a valid `admin` field.<br>- Optionally inspects DTOs (passed as additional arguments) to verify they are correctly scoped.<br>- Throws a descriptive error if scoping is violated, or does nothing if checks pass.<br><br>**Signature:**<br>```typescript<br>enforceScope(req: Express.Request, res: Express.Response, dataScopingTargets?: any[]): void<br>```<br><br>**Production-Ready Code:**<br>```typescript<br>export class AdminContextScopeEnforcer {<br>  /**<br>   * Ensures that the current request is in admin context and, optionally,<br>   * that all DTOs provided are admin-scoped.<br>   * @param req Express request object.<br>   * @param res Express response object.<br>   * @param dataScopingTargets Optional array of DTOs to scope-check.<br>   * @throws Error if admin context is missing or scoping fails.<br>   */<br>  public enforceScope(<br>    req: Express.Request,<br>    res: Express.Response,<br>    dataScopingTargets?: any[]<br>  ): void {<br>    if (!req.session or !req.session.admin) {<br>      throw new Error('Admin context required');<br>    }<br>    if (dataScopingTargets && Array.isArray(dataScopingTargets)) {<br>      for (const target of dataScopingTargets) {<br>        if (Array.isArray(target)) {<br>          for (const dto of target) {<br>            if (!this.isAdminScopedDTO(dto, req.session.admin)) {<br>              throw new Error('DTO not admin-scoped');<br>            }<br>          }<br>        } else if (!this.isAdminScopedDTO(target, req.session.admin)) {<br>          throw new Error('DTO not admin-scoped');<br>        }<br>      }<br>    }<br>  }<br><br>  /**<br>   * Determines if a DTO is admin-scoped for the current admin session.<br>   * Implementation should be extended as needed for actual DTO contract.<br>   */<br>  private isAdminScopedDTO(dto: any, adminSession: any): boolean {<br>    // Example: check for an 'adminId' or similar property<br>    if (dto && typeof dto === 'object' && 'adminId' in dto) {<br>      return dto.adminId === adminSession.id;<br>    }<br>    // If no admin context property, assume not admin-scoped<br>    return false;<br>  }<br>}<br>```<br><br>--- |
| BrandingCssVariableInjector | - **[Offloading Class Names]**: AdminRouteHandlers<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless; operates on input branding object).<br><br>**Delegate Responsibilities Owned:**<br>- Generate a `<style>` tag string with the CSS variable `--brand` for use in SSR EJS templates.<br>- Sanitize the provided brand color input (using regex) or fallback to a default if not provided.<br>- Ensures the `<style>` block is ready for injection at the top level of `layouts/base.ejs`.<br><br>**Responsibilities Removed from Parent Class:**<br>- Inline style-tag generation for theming in SSR layout templates.<br>- Brand color sanitization for layout use.<br><br>**Delegate Public Interface:**<br>```typescript<br>generateBrandCssVariableStyle(brandColor: string or undefined, fallback: string): string<br>```<br><br>**Example Interaction:**<br>```typescript<br>const styleTag = brandingCssVariableInjector.generateBrandCssVariableStyle(branding.brandColor, '#0070f3');<br>```<br><br>#### 🔧 Delegate Method: generateBrandCssVariableStyle<br><br>**Responsibility:**<br>- Receives a brand color string and fallback value.<br>- Sanitizes brand color using regex.<br>- Returns a `<style>` string suitable for inclusion in SSR.<br><br>**Signature:**<br>```typescript<br>generateBrandCssVariableStyle(brandColor: string or undefined, fallback: string): string<br>```<br><br>**Production-Ready Code:**<br>```typescript<br>export class BrandingCssVariableInjector {<br>  private static BRAND_COLOR_REGEX = /^#[0-9A-Fa-f]{6}$/;<br><br>  /**<br>   * Generates a <style> tag string for the CSS --brand variable.<br>   * @param brandColor Optional brand color (hex).<br>   * @param fallback Fallback color if brandColor invalid.<br>   * @returns <style> tag string.<br>   */<br>  public generateBrandCssVariableStyle(brandColor: string or undefined, fallback: string): string {<br>    const safeBrand = (typeof brandColor === 'string' && BrandingCssVariableInjector.BRAND_COLOR_REGEX.test(brandColor))<br>      ? brandColor<br>      : fallback;<br>    return `<style>:root { --brand: ${safeBrand}; }</style>`;<br>  }<br>}<br>```<br><br>---<br><br>End of report.<br>```` |
| MagicLinkBlobParser | - **[Offloading Class Names]**: MagicLinkIsland<br>- **[Originating Method Ids]**: MLI-1, MLI-2, MLI-7<br><br>**Delegate State Owned:**<br>- Stateless (pure functions only).<br><br>**Delegate Responsibilities Owned:**<br>- Parsing and validating the base64url-encoded `u` magic-link blob.<br>- Checking expiry timestamps inside the blob.<br>- Validating structure and contents of the `unsignedCall` object for the "pay-invoice" function.<br>- Defensive-in-depth: Ensuring all requirements of the magic-link blob contract are met.<br><br>**Responsibilities Removed from Parent Class:**<br>- All logic for parsing, decoding, and validating the `u` blob and its subfields.<br>- All error and exception throwing for malformed, expired, or unauthorized payment link blobs.<br>- Blob structure validation, including function names, postConditionMode, and required postcondition for sBTC.<br><br>**Delegate Public Interface:**<br>- `parseAndValidate(u: string): { unsignedCall: any; expiry: number }`<br>    - Parses and validates the magic-link blob. Throws on error.<br><br>**Example Interaction:**<br>```typescript<br>// In MagicLinkIsland<br>import { MagicLinkBlobParser } from './MagicLinkBlobParser';<br><br>try {<br>  const { unsignedCall, expiry } = MagicLinkBlobParser.parseAndValidate(hydration.u);<br>  // Use unsignedCall and expiry as validated<br>} catch (err) {<br>  // Handle error UI in parent<br>}<br>```<br><br>#### 🔁 Refactored Method: MagicLinkIsland.openWallet<br>**Breakdown of responsibilities after refactoring:**<br>- Now delegates all parsing and validation of the `u` blob to `MagicLinkBlobParser.parseAndValidate`.<br>- Only handles the UI state, Connect integration, error display, and business process, receiving already-parsed objects from the delegate.<br>- Handles error messages based on exceptions thrown by the delegate.<br><br>**How the delegate is called:**<br>- Passes `hydration.u` from SSR hydration into the delegate.<br>- Receives `{ unsignedCall, expiry }` if valid, or throws an error if invalid/expired.<br><br>```typescript<br>// Inside MagicLinkIsland.openWallet<br>let unsignedCall: any;<br>try {<br>  unsignedCall = MagicLinkBlobParser.parseAndValidate(hydration.u).unsignedCall;<br>} catch (err: any) {<br>  showErrorUI(err.message or 'Malformed or expired payment link.');<br>  disableWalletUI();<br>  walletOpenInProgress = false;<br>  return;<br>}<br>// ...proceed with Connect request using unsignedCall<br>```<br><br>#### 🔁 Refactored Method: MagicLinkIsland.handleDOMContentLoaded<br>**Breakdown of responsibilities after refactoring:**<br>- Delegates all `u` param parsing/validation to the delegate.<br>- Handles only DOM event binding, UI state, and high-level orchestration.<br><br>**How the delegate is called:**<br>- Parses `hydration.u` using `MagicLinkBlobParser.parseAndValidate(hydration.u)` for validation. Errors are handled at the parent level.<br><br>```typescript<br>// Inside MagicLinkIsland.handleDOMContentLoaded<br>try {<br>  MagicLinkBlobParser.parseAndValidate(hydration.u);<br>  // If success, continue to auto-open wallet or enable button<br>} catch (err: any) {<br>  showErrorUI(err.message or 'This link is invalid or expired.');<br>  disableWalletUI();<br>  return;<br>}<br>```<br><br>#### 🔁 Refactored Method: MagicLinkIsland.handleHydration<br>**Breakdown of responsibilities after refactoring:**<br>- Handles hydration contract field presence, then delegates all `u` blob validation to the delegate.<br>- Shows error UI and disables wallet UI if the delegate throws.<br><br>**How the delegate is called:**<br>- Calls `MagicLinkBlobParser.parseAndValidate(h.u)`.<br>- Read-only usage; exceptions are caught to update UI accordingly.<br><br>```typescript<br>// Inside MagicLinkIsland.handleHydration<br>let parsed;<br>try {<br>  parsed = MagicLinkBlobParser.parseAndValidate(h.u);<br>} catch (err: any) {<br>  showErrorUI(err.message or 'This link is invalid or expired.');<br>  disableWalletUI();<br>  return;<br>}<br>// ...use parsed.expiry, etc.<br>```<br><br>#### 🔧 Delegate Method: parseAndValidate<br>**What it does:**<br>- Takes a `u` string (base64url).<br>- Decodes it, parses the JSON payload, ensures the shape matches contract.<br>- Checks that `expiry` is in the future.<br>- Ensures `unsignedCall` is present and matches required structure:<br>    - function is "pay-invoice"<br>    - postConditionMode is "deny"<br>    - At least one FT postcondition for sBTC (`assetName` matches /sb?tc/i; `Equal` condition; string amount)<br>- Throws errors with clear messages on any validation failure.<br><br>**Signature:**<br>```typescript<br>class MagicLinkBlobParser {<br>  /**<br>   * Parses and validates the magic-link blob from base64url string.<br>   * @param u base64url-encoded blob<br>   * @returns { unsignedCall: any, expiry: number }<br>   * @throws Error if malformed, expired, or invalid structure<br>   */<br>  static parseAndValidate(u: string): { unsignedCall: any; expiry: number } {<br>    // Step 1: Decode base64url (replace -/_ and pad)<br>    let base64 = u.replace(/-/g, '+').replace(/_/g, '/');<br>    while (base64.length % 4) base64 += '=';<br>    let decoded: string;<br>    try {<br>      decoded = atob(base64);<br>    } catch {<br>      throw new Error('Malformed magic-link (base64 decode failed)');<br>    }<br><br>    // Step 2: Parse JSON<br>    let payload: any;<br>    try {<br>      payload = JSON.parse(decoded);<br>    } catch {<br>      throw new Error('Malformed magic-link (JSON parse failed)');<br>    }<br><br>    // Step 3: Check structure<br>    if (<br>      typeof payload !== 'object' or<br>      typeof payload.unsignedCall !== 'object' or<br>      typeof payload.expiry !== 'number'<br>    ) {<br>      throw new Error('Malformed magic-link blob');<br>    }<br><br>    // Step 4: Expiry<br>    if (Date.now() > payload.expiry) {<br>      throw new Error('This payment link has expired.');<br>    }<br><br>    // Step 5: Validate unsignedCall<br>    const unsignedCall = payload.unsignedCall;<br>    if (<br>      unsignedCall.function !== 'pay-invoice' or<br>      unsignedCall.postConditionMode !== 'deny' or<br>      !Array.isArray(unsignedCall.postConditions)<br>    ) {<br>      throw new Error('Malformed or unauthorized payment request.');<br>    }<br><br>    // Step 6: At least one FT postcondition for sBTC<br>    const hasSBTC = unsignedCall.postConditions.some(<br>      (pc: any) =><br>        pc.conditionCode === 'Equal' &&<br>        typeof pc.amount === 'string' &&<br>        pc.assetInfo &&<br>        typeof pc.assetInfo === 'object' &&<br>        typeof pc.assetInfo.assetName === 'string' &&<br>        /sb?tc/i.test(pc.assetInfo.assetName)<br>    );<br>    if (!hasSBTC) {<br>      throw new Error('Payment request missing valid sBTC postcondition.');<br>    }<br><br>    // All checks passed<br>    return {<br>      unsignedCall,<br>      expiry: payload.expiry<br>    };<br>  }<br>}<br>```<br>--- |
| QRCodeRenderer | - **[Offloading Class Names]**: MagicLinkIsland<br>- **[Originating Method Ids]**: MLI-4, MLI-9<br><br>**Delegate State Owned:**<br>- Stateless (pure utility, no internal state).<br><br>**Delegate Responsibilities Owned:**<br>- Rendering a QR code for any given string (the magic-link) into a provided canvas element using the application's QR code library.<br>- Encapsulating all logic for QR rendering, including error handling for canvas or invalid inputs.<br><br>**Responsibilities Removed from Parent Class:**<br>- All QR code drawing logic, including invocation of the QR code library, selection of target canvas, and error management.<br><br>**Delegate Public Interface:**<br>- `draw(canvas: HTMLCanvasElement, link: string): void`<br>    - Draws a QR code for a given link string into the given canvas.<br><br>**Example Interaction:**<br>```typescript<br>import { QRCodeRenderer } from './QRCodeRenderer';<br><br>// In MagicLinkIsland.drawQRCode or handleShowQRClick<br>const qrCanvas = document.getElementById('qr') as HTMLCanvasElement;<br>if (qrCanvas && hydration && typeof hydration.magicLink === 'string') {<br>  QRCodeRenderer.draw(qrCanvas, hydration.magicLink);<br>}<br>```<br><br>#### 🔁 Refactored Method: MagicLinkIsland.drawQRCode<br>**Breakdown of responsibilities after refactoring:**<br>- Now solely responsible for DOM selection and data provision.<br>- Delegates all QR rendering, error handling, and QR code library interaction to `QRCodeRenderer.draw`.<br><br>**How the delegate is called:**<br>- Selects the `#qr` canvas and calls `QRCodeRenderer.draw(qrCanvas, hydration.magicLink)`.<br><br>```typescript<br>export function drawQRCode(): void {<br>  const qrCanvas = document.getElementById('qr') as HTMLCanvasElement;<br>  if (!qrCanvas or !hydration or typeof hydration.magicLink !== 'string') return;<br>  QRCodeRenderer.draw(qrCanvas, hydration.magicLink);<br>}<br>```<br><br>#### 🔁 Refactored Method: MagicLinkIsland.handleShowQRClick<br>**Breakdown of responsibilities after refactoring:**<br>- Handles only UI updates and event binding.<br>- Calls `drawQRCode()` as above, which now uses the delegate for actual rendering.<br><br>```typescript<br>export function handleShowQRClick(): void {<br>  drawQRCode();<br>  const qrCanvas = document.getElementById('qr');<br>  if (qrCanvas) qrCanvas.style.display = '';<br>}<br>```<br><br>#### 🔧 Delegate Method: draw<br>**What it does:**<br>- Receives a canvas element and a link string.<br>- Validates both inputs.<br>- Uses the installed QR code library (e.g., `qrcode`) to render the QR into the canvas.<br>- Handles any errors (for example, fallback UI if the library throws or canvas is missing).<br><br>**Signature:**<br>```typescript<br>class QRCodeRenderer {<br>  /**<br>   * Draws a QR code for the magic-link into the given canvas.<br>   * @param canvas HTMLCanvasElement to render into<br>   * @param link string to encode in QR code<br>   */<br>  static draw(canvas: HTMLCanvasElement, link: string): void {<br>    if (!canvas or typeof link !== 'string' or !link) return;<br>    // Assume global `QRCode` library or import as needed<br>    try {<br>      // Clear previous contents<br>      const ctx = canvas.getContext('2d');<br>      if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);<br>      // Use global QR code library (e.g., QRCode.toCanvas)<br>      // For example, if using 'qrcode' npm library in browser bundle:<br>      (window as any).QRCode.toCanvas(canvas, link, { width: 256, margin: 1 }, (err: any) => {<br>        if (err) {<br>          // Optionally, display an error message in the UI or fallback image<br>        }<br>      });<br>    } catch {<br>      // Optionally, display an error message in the UI or fallback image<br>    }<br>  }<br>}<br>```<br>---<br><br>End of report.<br>```` |
| StatusStripDomRenderer | - **[Offloading Class Names]**: StatusStripIsland<br>- **[Originating Method Ids]**: SSI-4, SSI-5, SSI-6<br><br>**Delegate State Owned:**<br>- `statusStripEl: HTMLElement or null`: Reference to the DOM element displaying current payment status.<br>- `errorBannerEl: HTMLElement or null`: Reference to the DOM element showing error messages.<br>- `currentStatus: string or null`: Last known status displayed, to prevent redundant UI updates.<br><br>**Delegate Responsibilities Owned:**<br>- Locating, creating, and updating the DOM for the status-strip area.<br>- Updating DOM content and Tailwind classes for each payment status.<br>- Displaying and hiding user-friendly error banners in the UI.<br>- Validating hydration objects for required shape.<br>- Preventing duplicate DOM changes if status hasn't changed.<br><br>**Responsibilities Removed from Parent Class:**<br>- All direct DOM manipulation logic relating to the status-strip area.<br>- All error banner creation, update, and display logic.<br>- Status-to-UI mapping and presentation logic.<br>- Hydration validation and initialization of UI state.<br><br>**Delegate Public Interface:**<br>```typescript<br>class StatusStripDomRenderer {<br>  updateStatus(status: string): void;<br>  showError(message: string): void;<br>  hideError(): void;<br>  validateAndInitHydration(h: { invoiceId: string } or undefined): boolean;<br>  getCurrentStatus(): string or null;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const domRenderer = new StatusStripDomRenderer();<br>if (!domRenderer.validateAndInitHydration(window.__PAGE__)) {<br>  domRenderer.showError("Unable to initialize payment status polling (missing hydration).");<br>  // Abort further logic in parent<br>} else {<br>  domRenderer.updateStatus('unpaid');<br>}<br>```<br><br>#### 🔁 Refactored Method: StatusStripIsland.handleStatusResponse<br><br>**Breakdown of responsibilities after refactoring:**<br>- The method delegates all DOM update logic to `StatusStripDomRenderer`.<br>- It retrieves the status from the DTO, compares with the current status by querying the delegate, and only calls `updateStatus` if different.<br>- If status is terminal, parent clears any polling intervals as before.<br>- Error banner removal after successful update is also moved to the delegate.<br><br>**How the delegate is called:**<br>- The parent instantiates (or obtains a module-level singleton) of the delegate.<br>- On new status DTO, calls `domRenderer.updateStatus(status)`.<br>- On error, calls `domRenderer.showError(...)` and `domRenderer.hideError()` as needed.<br><br>```typescript<br>export function handleStatusResponse(response: Response): void {<br>  if (!hydration) return;<br>  if (!response.ok) {<br>    domRenderer.showError('Error fetching payment status. Retrying…');<br>    return;<br>  }<br>  response.json().then((dto) => {<br>    const status: string = dto.status;<br>    if (status !== domRenderer.getCurrentStatus()) {<br>      domRenderer.updateStatus(status);<br>    }<br>    domRenderer.hideError();<br>    if (isTerminalStatus(status)) {<br>      clearPollingInterval();<br>      // Optionally set terminal marker (could be via domRenderer too)<br>    }<br>  }).catch((err) => {<br>    domRenderer.showError('Error parsing payment status. Retrying…');<br>  });<br>}<br>```<br><br>#### 🔁 Refactored Method: StatusStripIsland.handleStatusError<br><br>**Breakdown of responsibilities after refactoring:**<br>- Shows a user-friendly error using `domRenderer.showError`.<br>- Schedules retry logic (still owned by parent), but all DOM/UI for error is delegated.<br>- Error banner management is no longer handled in the parent.<br><br>**How the delegate is called:**<br>- Parent calls `domRenderer.showError('Error fetching payment status. Retrying…')` on any error.<br><br>```typescript<br>export function handleStatusError(error: any): void {<br>  domRenderer.showError('Error fetching payment status. Retrying…');<br>  // Retry and backoff logic continues as before...<br>}<br>```<br><br>#### 🔁 Refactored Method: StatusStripIsland.handleHydration<br><br>**Breakdown of responsibilities after refactoring:**<br>- Parent delegates hydration object validation and initial status-strip DOM preparation to the delegate.<br>- If validation fails, parent aborts logic and displays error via the delegate.<br><br>**How the delegate is called:**<br>- Parent calls `domRenderer.validateAndInitHydration(window.__PAGE__)`.<br><br>```typescript<br>export function handleHydration(h: { invoiceId: string }): void {<br>  if (!domRenderer.validateAndInitHydration(h)) {<br>    domRenderer.showError("Invalid status-strip configuration (missing invoiceId).");<br>    clearPollingInterval();<br>    return;<br>  }<br>  // Continue with polling setup...<br>}<br>```<br><br>#### 🔧 Delegate Method: updateStatus<br><br>**Responsibility:**<br>- Updates the text content and class list of the status-strip element to reflect the current status.<br>- Stores the current status to avoid unnecessary DOM updates.<br>- Adds a data attribute if a terminal state is reached.<br><br>**Signature:**<br>```typescript<br>updateStatus(status: string): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripDomRenderer {<br>  private statusStripEl: HTMLElement or null = null;<br>  private errorBannerEl: HTMLElement or null = null;<br>  private currentStatus: string or null = null;<br>  <br>  updateStatus(status: string): void {<br>    const el = this.getStatusStripEl();<br>    if (!el) return;<br>    if (status !== this.currentStatus) {<br>      el.textContent = this.statusToDisplay(status);<br>      el.className = `status-strip px-2 py-1 rounded border text-sm font-medium transition-colors duration-200 ${this.statusToClasses(status)}`;<br>      this.currentStatus = status;<br>    }<br>    if (this.isTerminalStatus(status)) {<br>      el.setAttribute('data-terminal', 'true');<br>    }<br>  }<br><br>  // ... (other utility methods)<br>}<br>```<br><br>#### 🔧 Delegate Method: showError<br><br>**Responsibility:**<br>- Displays a user-friendly error message in the status-strip area, creating the element if needed.<br><br>**Signature:**<br>```typescript<br>showError(message: string): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripDomRenderer {<br>  // ...<br>  showError(message: string): void {<br>    const errorEl = this.getErrorBannerEl(true);<br>    errorEl.textContent = message;<br>    errorEl.style.display = 'block';<br>  }<br>  // ...<br>}<br>```<br><br>#### 🔧 Delegate Method: hideError<br><br>**Responsibility:**<br>- Hides the error message banner, if visible.<br><br>**Signature:**<br>```typescript<br>hideError(): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripDomRenderer {<br>  // ...<br>  hideError(): void {<br>    const errorEl = this.getErrorBannerEl(false);<br>    if (errorEl) errorEl.style.display = 'none';<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: validateAndInitHydration<br><br>**Responsibility:**<br>- Validates that the hydration object has a string `invoiceId`.<br>- Prepares the status-strip DOM for polling UI.<br><br>**Signature:**<br>```typescript<br>validateAndInitHydration(h: { invoiceId: string } or undefined): boolean<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripDomRenderer {<br>  // ...<br>  validateAndInitHydration(h: { invoiceId: string } or undefined): boolean {<br>    if (!h or typeof h.invoiceId !== 'string' or !h.invoiceId) {<br>      const el = this.getStatusStripEl();<br>      if (el) el.textContent = 'Invalid status-strip configuration (missing invoiceId).';<br>      return false;<br>    }<br>    this.currentStatus = null;<br>    this.hideError();<br>    return true;<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: getCurrentStatus<br><br>**Responsibility:**<br>- Returns the last known status, or null if not set.<br><br>**Signature:**<br>```typescript<br>getCurrentStatus(): string or null<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripDomRenderer {<br>  // ...<br>  getCurrentStatus(): string or null {<br>    return this.currentStatus;<br>  }<br>}<br>```<br><br>--- |
| StatusPollingBackoffManager | - **[Offloading Class Names]**: StatusStripIsland<br>- **[Originating Method Ids]**: SSI-1, SSI-5<br><br>**Delegate State Owned:**<br>- `pollingDelay: number`: Current delay between polling attempts (ms).<br>- `minDelay: number`: Minimum allowed polling delay (ms).<br>- `maxDelay: number`: Maximum allowed polling delay (ms).<br>- `backoffFactor: number`: Exponential factor applied after an error.<br>- `intervalId: number or null`: Timer ID for polling or retry.<br>- `suspended: boolean`: Flag marking if polling is currently suspended.<br><br>**Delegate Responsibilities Owned:**<br>- Managing all timing logic for polling and exponential backoff.<br>- Managing interval/timeout lifecycles.<br>- Resuming polling on network restoration (`online` event).<br>- Suspending/resuming intervals as instructed.<br><br>**Responsibilities Removed from Parent Class:**<br>- All manual timer, interval, and backoff management for polling attempts.<br>- All scheduling and cleanup related to polling lifecycle.<br><br>**Delegate Public Interface:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  startPolling(callback: () => void): void;<br>  clearPolling(): void;<br>  backoffAndRetry(callback: () => void): void;<br>  suspend(): void;<br>  resume(callback: () => void, isTerminal: boolean): void;<br>  resetDelay(): void;<br>  getPollingDelay(): number;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const backoffManager = new StatusPollingBackoffManager();<br>backoffManager.startPolling(() => pollStatus());<br>// On error:<br>backoffManager.backoffAndRetry(() => pollStatus());<br>// On visibility change:<br>backoffManager.suspend();<br>// On resume:<br>backoffManager.resume(() => pollStatus(), isTerminalStatus(currentStatus));<br>```<br><br>#### 🔁 Refactored Method: StatusStripIsland.pollStatus<br><br>**Breakdown of responsibilities after refactoring:**<br>- The parent no longer manages interval/timer IDs or backoff delays.<br>- Instead, it calls `backoffManager.startPolling()` to initiate polling and `backoffManager.backoffAndRetry()` after errors.<br>- On terminal state, calls `backoffManager.clearPolling()`.<br>- All polling time management logic is encapsulated.<br><br>**How the delegate is called:**<br>- On successful polling, calls `backoffManager.resetDelay()` to set back to default.<br>- On error, calls `backoffManager.backoffAndRetry(...)`.<br><br>```typescript<br>export function pollStatus(): void {<br>  // ... fetch logic ...<br>  fetch(api, options)<br>    .then(response => { <br>      handleStatusResponse(response);<br>      backoffManager.resetDelay();<br>    })<br>    .catch(err => {<br>      handleStatusError(err);<br>      backoffManager.backoffAndRetry(pollStatus);<br>    });<br>}<br>```<br><br>#### 🔁 Refactored Method: StatusStripIsland.handleStatusError<br><br>**Breakdown of responsibilities after refactoring:**<br>- After displaying error in the DOM (via DomRenderer), all retry/backoff scheduling is delegated to the polling manager.<br><br>**How the delegate is called:**<br>- On error, calls `backoffManager.backoffAndRetry(pollStatus)`.<br><br>```typescript<br>export function handleStatusError(error: any): void {<br>  domRenderer.showError('Error fetching payment status. Retrying…');<br>  backoffManager.backoffAndRetry(pollStatus); // handles delay and retry<br>}<br>```<br><br>#### 🔧 Delegate Method: startPolling<br><br>**Responsibility:**<br>- Starts a repeating polling interval with current delay.<br>- Clears previous intervals before starting a new one.<br><br>**Signature:**<br>```typescript<br>startPolling(callback: () => void): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  pollingDelay: number = 1200;<br>  minDelay: number = 1000;<br>  maxDelay: number = 6000;<br>  backoffFactor: number = 1.7;<br>  intervalId: number or null = null;<br>  suspended: boolean = false;<br><br>  startPolling(callback: () => void): void {<br>    this.clearPolling();<br>    this.intervalId = window.setInterval(callback, this.pollingDelay);<br>  }<br><br>  clearPolling(): void {<br>    if (this.intervalId !== null) {<br>      clearInterval(this.intervalId);<br>      this.intervalId = null;<br>    }<br>  }<br>  // ...<br>}<br>```<br><br>#### 🔧 Delegate Method: backoffAndRetry<br><br>**Responsibility:**<br>- Clears any existing polling interval.<br>- Increases the delay exponentially (up to maximum).<br>- Schedules a one-time retry after backoff period.<br>- Does nothing if polling is suspended.<br><br>**Signature:**<br>```typescript<br>backoffAndRetry(callback: () => void): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  // ...<br>  backoffAndRetry(callback: () => void): void {<br>    if (this.suspended) return;<br>    this.clearPolling();<br>    this.pollingDelay = Math.min(this.maxDelay, Math.max(this.minDelay, Math.floor(this.pollingDelay * this.backoffFactor)));<br>    window.setTimeout(callback, this.pollingDelay);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: suspend<br><br>**Responsibility:**<br>- Sets suspended flag and clears any polling interval.<br><br>**Signature:**<br>```typescript<br>suspend(): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  // ...<br>  suspend(): void {<br>    this.suspended = true;<br>    this.clearPolling();<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: resume<br><br>**Responsibility:**<br>- Clears suspended flag.<br>- If not terminal, starts polling.<br><br>**Signature:**<br>```typescript<br>resume(callback: () => void, isTerminal: boolean): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  // ...<br>  resume(callback: () => void, isTerminal: boolean): void {<br>    this.suspended = false;<br>    if (!isTerminal && this.intervalId === null) {<br>      this.startPolling(callback);<br>    }<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: resetDelay<br><br>**Responsibility:**<br>- Resets polling delay to initial (1200ms).<br><br>**Signature:**<br>```typescript<br>resetDelay(): void<br>```<br><br>**Code:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  // ...<br>  resetDelay(): void {<br>    this.pollingDelay = 1200;<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: getPollingDelay<br><br>**Responsibility:**<br>- Returns the current polling delay.<br><br>**Signature:**<br>```typescript<br>getPollingDelay(): number<br>```<br><br>**Code:**<br>```typescript<br>class StatusPollingBackoffManager {<br>  // ...<br>  getPollingDelay(): number {<br>    return this.pollingDelay;<br>  }<br>}<br>```<br><br>--- |
| StatusStripStatusMapper | - **[Offloading Class Names]**: StatusStripIsland<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless, pure mapping class).<br><br>**Delegate Responsibilities Owned:**<br>- Mapping invoice statuses to user-facing display text.<br>- Mapping invoice statuses to Tailwind-compatible class names.<br>- Determining if a given status is terminal for polling.<br><br>**Responsibilities Removed from Parent Class:**<br>- All status-to-display and status-to-class mapping logic.<br>- Terminal status logic.<br><br>**Delegate Public Interface:**<br>```typescript<br>class StatusStripStatusMapper {<br>  static statusToDisplay(status: string): string;<br>  static statusToClasses(status: string): string;<br>  static isTerminalStatus(status: string): boolean;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const display = StatusStripStatusMapper.statusToDisplay('unpaid');<br>const classes = StatusStripStatusMapper.statusToClasses('unpaid');<br>if (StatusStripStatusMapper.isTerminalStatus('canceled')) {<br>  // ... end polling<br>}<br>```<br><br>#### 🔧 Delegate Method: statusToDisplay<br><br>**Responsibility:**<br>- Maps status string to user-facing text.<br><br>**Signature:**<br>```typescript<br>static statusToDisplay(status: string): string<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripStatusMapper {<br>  static statusToDisplay(status: string): string {<br>    switch (status) {<br>      case 'unpaid': return 'Awaiting payment';<br>      case 'paid': return 'Paid ✓';<br>      case 'partially_refunded': return 'Partially Refunded';<br>      case 'refunded': return 'Refunded';<br>      case 'canceled': return 'Canceled';<br>      case 'expired': return 'Expired';<br>      default: return 'Unknown';<br>    }<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: statusToClasses<br><br>**Responsibility:**<br>- Maps status string to Tailwind-compatible class string for UI.<br><br>**Signature:**<br>```typescript<br>static statusToClasses(status: string): string<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripStatusMapper {<br>  static statusToClasses(status: string): string {<br>    switch (status) {<br>      case 'unpaid': return 'bg-yellow-50 text-yellow-800 border-yellow-200';<br>      case 'paid': return 'bg-green-50 text-green-800 border-green-200';<br>      case 'partially_refunded':<br>      case 'refunded': return 'bg-blue-50 text-blue-800 border-blue-200';<br>      case 'canceled':<br>      case 'expired': return 'bg-gray-50 text-gray-800 border-gray-200';<br>      default: return 'bg-red-50 text-red-800 border-red-200';<br>    }<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: isTerminalStatus<br><br>**Responsibility:**<br>- Returns true if status is 'paid', 'expired', or 'canceled'.<br><br>**Signature:**<br>```typescript<br>static isTerminalStatus(status: string): boolean<br>```<br><br>**Code:**<br>```typescript<br>class StatusStripStatusMapper {<br>  static isTerminalStatus(status: string): boolean {<br>    return status === 'paid' or status === 'expired' or status === 'canceled';<br>  }<br>}<br>```<br>````<br><br>End of report. |
| DrawerContentRenderer | - **[Offloading Class Names]**: POSIsland<br>- **[Originating Method Ids]**: PI-5, PI-6<br><br>The `DrawerContentRenderer` delegate encapsulates all logic for rendering the content of invoice and subscription detail drawers in the POS UI. It owns the responsibility of fetching the correct hydrated DTO from `window.__PAGE__`, formatting its properties, rendering the HTML structure for the drawer, and binding the close button handler.<br><br>**Delegate State Owned:**<br>- No persistent state; all data is passed per-call as arguments.<br>- Receives the drawer DOM element and the target DTO identifier on each call.<br><br>**Delegate Responsibilities Owned:**<br>- Render the full detail drawer content for invoices and subscriptions.<br>- Map the correct DTO from the hydrated list using the provided ID.<br>- Generate HTML for all required fields and event history.<br>- Attach the local close handler for drawer dismissal.<br><br>**Responsibilities Removed from Parent Class:**<br>- POSIsland no longer manually fetches or renders the drawer’s DOM content.<br>- POSIsland no longer maps invoice/subscription IDs to hydrated DTOs for rendering.<br>- POSIsland no longer binds the close button handler within each render.<br><br>**Delegate Public Interface:**<br><br>```typescript<br>interface DrawerContentRenderer {<br>  renderInvoiceContent(invoiceId: string, drawer: HTMLElement, hydrated: any, onClose: () => void): void;<br>  renderSubscriptionContent(subscriptionId: string, drawer: HTMLElement, hydrated: any, onClose: () => void): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In POSIsland.openInvoiceDrawer(invoiceId):<br>DrawerContentRenderer.renderInvoiceContent(invoiceId, drawer, window.__PAGE__, closeDrawer);<br><br>// In POSIsland.openSubscriptionDrawer(subscriptionId):<br>DrawerContentRenderer.renderSubscriptionContent(subscriptionId, drawer, window.__PAGE__, closeDrawer);<br>```<br><br>#### 🔁 Refactored Method: POSIsland.openInvoiceDrawer (internal call in handleInvoiceRowClick)<br>- After refactoring, this method simply calls `DrawerContentRenderer.renderInvoiceContent` with the invoiceId, the drawer DOM element, the hydrated DTO root (`window.__PAGE__`), and a local `closeDrawer` handler.<br>- It no longer fetches or renders the invoice content directly; all content and event binding are owned by the delegate.<br><br>```typescript<br>function openInvoiceDrawer(invoiceId: string): void {<br>  currentDrawerType = 'invoice';<br>  currentDrawerId = invoiceId;<br>  const drawer = document.getElementById('detail-drawer');<br>  if (drawer) {<br>    DrawerContentRenderer.renderInvoiceContent(invoiceId, drawer, window.__PAGE__, closeDrawer);<br>    drawer.classList.add('open');<br>    drawer.style.display = '';<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: POSIsland.openSubscriptionDrawer (internal call in handleSubscriptionRowClick)<br>- Now calls `DrawerContentRenderer.renderSubscriptionContent` with the subscriptionId, drawer DOM, hydrated DTOs, and the close handler.<br>- All logic for fetching, mapping, and rendering the subscription details and event history is encapsulated in the delegate.<br><br>```typescript<br>function openSubscriptionDrawer(subscriptionId: string): void {<br>  currentDrawerType = 'subscription';<br>  currentDrawerId = subscriptionId;<br>  const drawer = document.getElementById('detail-drawer');<br>  if (drawer) {<br>    DrawerContentRenderer.renderSubscriptionContent(subscriptionId, drawer, window.__PAGE__, closeDrawer);<br>    drawer.classList.add('open');<br>    drawer.style.display = '';<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: renderInvoiceContent<br><br>**Responsibilities:**<br>- Receives the invoiceId, the drawer DOM element, the hydrated DTO object, and a close callback.<br>- Locates the invoice in the hydrated `invoiceList` by id.<br>- Renders all required invoice fields and event history into the drawer.<br>- Binds the close button to call `onClose`.<br>- Throws if the invoice cannot be found.<br><br>```typescript<br>export namespace DrawerContentRenderer {<br>  export function renderInvoiceContent(<br>    invoiceId: string,<br>    drawer: HTMLElement,<br>    hydrated: any,<br>    onClose: () => void<br>  ): void {<br>    const invoiceList = hydrated && hydrated.invoiceList;<br>    const invoice = Array.isArray(invoiceList) ? invoiceList.find((inv: any) => inv.invoiceId === invoiceId) : null;<br>    if (!invoice) throw new Error('No hydrated invoice DTO found for drawer.');<br>    drawer.innerHTML = `<br>      <div class="drawer-header"><br>        <span>Invoice #${invoice.invoiceId}</span><br>        <button type="button" id="drawer-close-btn" aria-label="Close">&times;</button><br>      </div><br>      <div class="drawer-content"><br>        <dl><br>          <dt>Status</dt><dd>${invoice.status}</dd><br>          <dt>Amount</dt><dd>${invoice.amountSats}</dd><br>          <dt>Created</dt><dd>${invoice.createdAt or ''}</dd><br>        </dl><br>        ${invoice.eventHistory ? `<div class="event-history">${renderEventHistory(invoice.eventHistory)}</div>` : ''}<br>      </div><br>    `;<br>    const closeBtn = drawer.querySelector('#drawer-close-btn');<br>    if (closeBtn) closeBtn.addEventListener('click', onClose);<br><br>    function renderEventHistory(events: Array<any>): string {<br>      return `<ul>${events<br>        .map(<br>          (evt: any) =><br>            `<li><span class="evt-kind">${evt.kind}</span> <span class="evt-ts">${evt.timestamp or ''}</span></li>`,<br>        )<br>        .join('')}</ul>`;<br>    }<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: renderSubscriptionContent<br><br>**Responsibilities:**<br>- Receives the subscriptionId, drawer DOM, hydrated object, and close callback.<br>- Locates the subscription DTO by id in the hydrated list.<br>- Generates full HTML for the subscription’s details, including plan and event history.<br>- Binds the close button to the provided handler.<br>- Throws if DTO is unavailable.<br><br>```typescript<br>export namespace DrawerContentRenderer {<br>  export function renderSubscriptionContent(<br>    subscriptionId: string,<br>    drawer: HTMLElement,<br>    hydrated: any,<br>    onClose: () => void<br>  ): void {<br>    const subscriptionList = hydrated && hydrated.subscriptionList;<br>    const subscription = Array.isArray(subscriptionList)<br>      ? subscriptionList.find((sub: any) => sub.subscriptionId === subscriptionId)<br>      : null;<br>    if (!subscription) throw new Error('No hydrated subscription DTO found for drawer.');<br>    drawer.innerHTML = `<br>      <div class="drawer-header"><br>        <span>Subscription #${subscription.subscriptionId}</span><br>        <button type="button" id="drawer-close-btn" aria-label="Close">&times;</button><br>      </div><br>      <div class="drawer-content"><br>        <dl><br>          <dt>Status</dt><dd>${subscription.status}</dd><br>          <dt>Plan</dt><dd>${subscription.planName or ''}</dd><br>          <dt>Schedule</dt><dd>${subscription.schedule or ''}</dd><br>        </dl><br>        ${subscription.eventHistory ? `<div class="event-history">${renderEventHistory(subscription.eventHistory)}</div>` : ''}<br>      </div><br>    `;<br>    const closeBtn = drawer.querySelector('#drawer-close-btn');<br>    if (closeBtn) closeBtn.addEventListener('click', onClose);<br><br>    function renderEventHistory(events: Array<any>): string {<br>      return `<ul>${events<br>        .map(<br>          (evt: any) =><br>            `<li><span class="evt-kind">${evt.kind}</span> <span class="evt-ts">${evt.timestamp or ''}</span></li>`,<br>        )<br>        .join('')}</ul>`;<br>    }<br>  }<br>}<br>```<br><br>--- |
| POSElementBinder | - **[Offloading Class Names]**: POSIsland<br>- **[Originating Method Ids]**: None<br><br>`POSElementBinder` is a delegate responsible for binding event handlers to all main POS UI elements (form, buttons, rows) and for querying those DOM nodes. It owns the responsibility of:<br>- Looking up UI elements by their selectors/IDs in the DOM.<br>- Binding the prescribed event handlers from POSIsland to those elements.<br>- Ensuring all UI event binding is performed in a single place and can be invoked on hydration.<br><br>**Delegate State Owned:**<br>- None (stateless; all bindings are idempotent and per-call).<br><br>**Delegate Responsibilities Owned:**<br>- Query all required DOM elements by ID or class.<br>- Bind the correct handler to each event (submit, click).<br>- No business logic is performed; only event registration.<br><br>**Responsibilities Removed from Parent Class:**<br>- POSIsland no longer performs direct event binding in its own method.<br>- DOM querying is centralized and isolated.<br><br>**Delegate Public Interface:**<br>```typescript<br>interface POSElementBinder {<br>  bindAllPOSEventHandlers(handlers: {<br>    onFormSubmit: (form: HTMLFormElement, event: Event) => void;<br>    onNewSaleClick: (event: MouseEvent) => void;<br>    onCopyLinkClick: (event: MouseEvent) => void;<br>    onShowQRClick: (event: MouseEvent) => void;<br>    onDrawerToggle: (event: MouseEvent) => void;<br>    onInvoiceRowClick: (event: MouseEvent) => void;<br>    onSubscriptionRowClick: (event: MouseEvent) => void;<br>  }): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>POSElementBinder.bindAllPOSEventHandlers({<br>  onFormSubmit: (form, event) => { ... },<br>  onNewSaleClick: handleNewSaleClick,<br>  onCopyLinkClick: handleCopyLinkClick,<br>  onShowQRClick: handleShowQRClick,<br>  onDrawerToggle: handleDrawerToggle,<br>  onInvoiceRowClick: handleInvoiceRowClick,<br>  onSubscriptionRowClick: handleSubscriptionRowClick<br>});<br>```<br><br>#### 🔧 Delegate Method: bindAllPOSEventHandlers<br><br>**Responsibilities:**<br>- Receives a set of handler functions for each event type.<br>- Queries all required DOM elements and attaches the corresponding handler.<br>- Ensures that form, buttons, and row elements are attached exactly once.<br>- Provides a single location for all POS UI event binding logic.<br><br>```typescript<br>export namespace POSElementBinder {<br>  export function bindAllPOSEventHandlers(handlers: {<br>    onFormSubmit: (form: HTMLFormElement, event: Event) => void;<br>    onNewSaleClick: (event: MouseEvent) => void;<br>    onCopyLinkClick: (event: MouseEvent) => void;<br>    onShowQRClick: (event: MouseEvent) => void;<br>    onDrawerToggle: (event: MouseEvent) => void;<br>    onInvoiceRowClick: (event: MouseEvent) => void;<br>    onSubscriptionRowClick: (event: MouseEvent) => void;<br>  }): void {<br>    // New sale form submit<br>    const form = document.getElementById('new-sale-form') as HTMLFormElement;<br>    if (form) {<br>      form.onsubmit = function (event: Event) {<br>        handlers.onFormSubmit(form, event);<br>      };<br>    }<br>    // New sale button<br>    const newSaleBtn = document.getElementById('new-sale');<br>    if (newSaleBtn) newSaleBtn.addEventListener('click', handlers.onNewSaleClick);<br>    // Copy link button<br>    const copyBtn = document.getElementById('copy-link');<br>    if (copyBtn) copyBtn.addEventListener('click', handlers.onCopyLinkClick);<br>    // Show QR button<br>    const showQRBtn = document.getElementById('show-qr');<br>    if (showQRBtn) showQRBtn.addEventListener('click', handlers.onShowQRClick);<br>    // Drawer toggle button<br>    const drawerToggle = document.getElementById('drawer-toggle');<br>    if (drawerToggle) drawerToggle.addEventListener('click', handlers.onDrawerToggle);<br>    // Invoice rows<br>    document.querySelectorAll<HTMLElement>('.invoice-row').forEach((row) =><br>      row.addEventListener('click', handlers.onInvoiceRowClick),<br>    );<br>    // Subscription rows<br>    document.querySelectorAll<HTMLElement>('.subscription-row').forEach((row) =><br>      row.addEventListener('click', handlers.onSubscriptionRowClick),<br>    );<br>  }<br>}<br>```<br>End of report.<br>```` |
| ApplicationBootstrapper | Orchestrates the initial startup sequence of the application. Ensures the application environment is prepared, all configuration is loaded from environment variables or config files, global Express application objects are instantiated, and all required dependency injection, service registrations, and Express middleware stacks are constructed in the correct order prior to any HTTP, event, or island logic being processed. |
| ShutdownCoordinator | Handles the graceful teardown of the application on process exit, termination signals, or fatal errors. Ensures all ongoing requests are completed, in-memory resources are released, sessions and dependent connections (if any) are closed, and the Express server is shut down cleanly. No business data is persisted, but session stores, file handles, and HTTP listeners are deallocated. |

### Component Methods definition:
| Component Name | Signature | Description | Implementation Details |
| -------------- | --------- | ----------- | ---------------------- |
| ExpressApp | csrfExemptionMiddleware(): void | Configures global CSRF protection using `csurf` middleware at application startup, but programmatically excludes specific public routes from CSRF checks. The middleware is applied to all HTTP requests except for `/checkout/:storeId` (both POST and GET), `/status/:invoiceId` (GET), `/w/:storeId/:invoiceId` (GET), and `/invoice/:invoiceId` (GET). The function must ensure that these routes are defined as CSRF-exempt either by router-level exclusion, or by using per-route checks (e.g., conditionally skipping `csurf` for matching route patterns). All other merchant and admin authenticated routes must retain CSRF protection. This configuration must be invoked before route registration and must not interfere with the expected Express `Request`, `Response`, and `NextFunction` lifecycles. |  |
| ExpressApp | helmetCSPMiddleware(): void | <br><br>**Refactored Method: helmetCSPMiddleware(): void**<br><br>This method is now solely responsible for ensuring that the application's CSP headers are correctly set for all SSR responses to protect against XSS while allowing dynamic islands and inline scripts.<br><br>Prior to refactoring, this method performed:<br>- Inline registration and configuration of Helmet’s `contentSecurityPolicy` middleware.<br>- Manual string assembly and hash computation for every inline script present in rendered SSR output.<br>- Direct header management and logic for script hash calculation.<br><br>After refactoring:<br>- All per-request logic for computing, assembling, and injecting page-scoped CSP script hashes is fully offloaded to the `ExpressCSPHashManager`.<br>- The parent method simply registers the middleware, ensuring it runs before any SSR route handler or HTML render.<br>- No CSP logic remains in the parent; all computation and header manipulation is owned by the delegate.<br><br>**Implementation Contract:**<br><br>- Call `ExpressCSPHashManager.middleware()` and register it using `app.use()` before any SSR route.<br>- No conditional logic or fallback: if the delegate is not available, surface a wiring error.<br><br>**Example Usage:**<br><br>```ts<br>public helmetCSPMiddleware(): void {<br>    // Assume ExpressCSPHashManager is imported and available<br>    this.expressApp.use(ExpressCSPHashManager.middleware());<br>}<br>```<br><br>--- |  |
| PublicRouteHandlers | handleCheckoutPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express route handler for POST `/checkout/:storeId`. It receives a JSON or form-encoded HTTP request (body parsed by Express), and manually validates that `amount_sats` is a number > 0, `ttl_seconds` is an integer in [120,1800], and `memo` is a string. Accepts optional fields: `orderId` (string), `payerPrincipal` (string), and `return` (string). If any validation fails, constructs an error (HTTP 400) and passes it to `next()` for centralized error handling. On success, it calls `BridgeClient.prepareInvoice(storeId, { amount_sats, ttl_seconds, memo, orderId?, payerPrincipal?, return? })`—this must be a server-to-server HTTP POST using the store’s `X-API-Key`. It then awaits a `{ invoice, magicLink, unsignedCall }` DTO from BridgeClient, ensuring these are normalized and sanitized for output (never leaking raw Bridge payloads or secrets). Finally, responds with HTTP 302, setting the `Location` header to the `magicLink` URL provided in the Bridge response. No SSR rendering or hydration is performed; only the redirect is sent. All Express lifecycle, request parsing, and error propagation are handled by the framework. |  |
| PublicRouteHandlers | handleMagicLinkGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleMagicLinkGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>This method is the Express GET handler for `/w/:storeId/:invoiceId` (magic-link payment page).<br><br>After refactoring, its responsibilities are:<br><br>1. Extract the `u` blob and route parameters from the request.<br>2. Delegate all magic-link decoding, canonicalization, HMAC signature checking, business validation, and expiry checks to `this.magicLinkValidationService.validateAndParse`.<br>3. On success, use validated payload and invoice for further processing.<br>4. Fetch branding and inject via `this.brandingSSRInjector.injectBranding(res, storeId)`.<br>5. Set no-cache headers via `this.noCacheHeaderSetter.set(res)`.<br>6. SSR-render the payment page with sanitized DTOs and hydration (never exposing secrets).<br>7. On any validation error, propagate the error (with appropriate status) to `next()`.<br><br>All cryptographic, business rule, and context validation logic is offloaded—parent method only orchestrates, never implements the actual checks or serialization.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleMagicLinkGet(req, res, next): Promise<void> {<br>    const { storeId, invoiceId } = req.params;<br>    const u_blob = typeof req.query.u === "string" ? req.query.u : undefined;<br>    if (!u_blob) {<br>        const err = new Error("Missing required payment parameter.");<br>        (err as any).status = 400;<br>        return next(err);<br>    }<br><br>    try {<br>        // Delegate all magic-link validation and parsing<br>        const validated = await this.magicLinkValidationService.validateAndParse(u_blob, { storeId, invoiceId });<br>        const payload = validated.payload;<br>        const invoice = validated.invoice;<br><br>        // Fetch and inject branding using the delegate<br>        await this.brandingSSRInjector.injectBranding(res, storeId);<br><br>        // Set no-cache headers via delegate<br>        this.noCacheHeaderSetter.set(res);<br><br>        // ...proceed with SSR rendering using validated and sanitized data<br>        res.render('public/magic-link.ejs', {<br>            branding: res.locals.branding,<br>            invoice,<br>            magicLink: req.originalUrl,<br>            hydration: { invoiceId, magicLink: req.originalUrl }<br>        });<br>    } catch (magicLinkErr: any) {<br>        let status = 400;<br>        if (magicLinkErr && typeof magicLinkErr.status === "number") {<br>            status = magicLinkErr.status;<br>        }<br>        (magicLinkErr as any).status = status;<br>        return next(magicLinkErr);<br>    }<br>}<br>```<br><br> |  |
| PublicRouteHandlers | handleStatusGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express GET handler for `/status/:invoiceId`, typically polled by client islands. Extracts `invoiceId` from the route parameters. Calls `BridgeClient.fetchInvoice(invoiceId)`, which performs a server-to-server fetch to `/i/:invoiceId`. The Bridge response is normalized to the canonical `InvoiceDTO` shape as defined in `/shared/types/dto.ts`, explicitly omitting any extraneous or sensitive/internal fields. The DTO is returned as JSON (`res.json()`), with no secrets or unfiltered Bridge payloads included. Express handles route matching and JSON serialization. CSRF is disabled for this route. |  |
| PublicRouteHandlers | handleInvoiceGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express GET handler for `/invoice/:invoiceId`. Extracts `invoiceId` from route params. Calls `BridgeClient.fetchInvoice(invoiceId)` to retrieve the invoice data, then extracts `storeId` from the DTO. Calls `BridgeClient.fetchPublicProfile(storeId)` to obtain store branding. Sanitizes the branding object (especially `brandColor`) using regex `/^#[0-9A-Fa-f]{6}$/`; if invalid or fetch fails, substitutes a neutral/fallback branding object. Sets headers `Cache-Control: no-store, max-age=0` and `Pragma: no-cache`. SSR-renders `invoice.ejs` with branding props, the full invoice DTO, and a hydration object `{ invoiceId }` injected as `window.__PAGE__` before client islands. The SSR page must include the status-strip island for live polling. Only prescribed data per template contract is passed to the SSR view; never secrets or extraneous fields. Express manages SSR rendering and response. |  |
| PublicRouteHandlers | handleLandingGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express GET handler for `/` (root landing). Calls `BridgeClient.fetchPublicProfile(storeId)` (storeId may be global or inferred from config) to obtain branding for the default landing page. Sanitizes branding (especially `brandColor`) via regex; if invalid, logs a warning and injects fallback/neutral branding for SSR. SSR-renders `landing.ejs` using the prescribed ejs-mate layout, injecting branding props and referencing `/static/css/app.css` for Tailwind. No client-side hydration or islands are injected on this page. All data exposed must conform to the Branding type as per domain models, with no secrets or extraneous properties. Express manages SSR and static file serving. |  |
| PublicRouteHandlers | setNoCacheHeaders(res: Express.Response): void | <br><br>**Refactored Method: setNoCacheHeaders(res: Express.Response): void**<br><br>This method sets strict no-cache HTTP headers on SSR responses for sensitive payment pages.<br><br>After refactoring, it **only** delegates to the stateless `NoCacheHeaderSetter.set(res)` utility, which handles header setting unconditionally. No header logic remains in the parent.<br><br>**Example Implementation:**<br><br>```ts<br>public setNoCacheHeaders(res: Express.Response): void {<br>    this.noCacheHeaderSetter.set(res);<br>}<br>```<br><br> |  |
| PublicRouteHandlers | handleMagicLinkGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleMagicLinkGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>This method extends the core GET handler for the magic-link route with additional business validation for store activation/deactivation.<br><br>After refactoring:<br><br>1. Extracts route and query parameters.<br>2. Delegates `validateAndParse` to `this.magicLinkValidationService` (see PRH-2).<br>3. Fetches store branding and activation state (via `this.brandingSSRInjector.injectBranding(res, storeId)`).<br>4. If the store is inactive per returned branding/state, prepares the SSR props with a deactivation message.<br>5. Sets no-cache headers via `this.noCacheHeaderSetter.set(res)`.<br>6. Renders the SSR view including the deactivation reason if needed.<br>7. All store status and business logic are performed server-side and delegated; only orchestration remains here.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleMagicLinkGet(req, res, next): Promise<void> {<br>    const { storeId, invoiceId } = req.params;<br>    const u_blob = typeof req.query.u === "string" ? req.query.u : undefined;<br>    if (!u_blob) {<br>        const err = new Error("Missing required payment parameter.");<br>        (err as any).status = 400;<br>        return next(err);<br>    }<br><br>    try {<br>        const validated = await this.magicLinkValidationService.validateAndParse(u_blob, { storeId, invoiceId });<br>        const payload = validated.payload;<br>        const invoice = validated.invoice;<br><br>        await this.brandingSSRInjector.injectBranding(res, storeId);<br><br>        this.noCacheHeaderSetter.set(res);<br><br>        // If branding or store state indicates inactive, include deactivation reason in SSR props<br>        const isInactive = res.locals.branding && res.locals.branding.active === false;<br>        const deactivationReason = isInactive ? (res.locals.branding.deactivationReason or "Store is inactive") : null;<br><br>        res.render('public/magic-link.ejs', {<br>            branding: res.locals.branding,<br>            invoice,<br>            magicLink: req.originalUrl,<br>            hydration: { invoiceId, magicLink: req.originalUrl },<br>            deactivationReason<br>        });<br>    } catch (magicLinkErr: any) {<br>        let status = 400;<br>        if (magicLinkErr && typeof magicLinkErr.status === "number") {<br>            status = magicLinkErr.status;<br>        }<br>        (magicLinkErr as any).status = status;<br>        return next(magicLinkErr);<br>    }<br>}<br>```<br><br>--- |  |
| MerchantRouteHandlers | handleMerchantGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleMerchantGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>This method handles all GET `/merchant/*` requests.<br><br>After refactoring, the steps are:<br><br>1. Ensures valid authenticated session (middleware).<br>2. Extracts `storeId` from route params or session.<br>3. Fetches store profile and branding.<br>4. Sanitizes branding (especially `brandColor`) by delegating to `this.inputValidator.sanitizeBrandColor` (or `BrandColorSanitizer` if used directly).<br>5. Injects branding into SSR template.<br>6. Sets no-cache headers (may delegate to a NoCacheHeaderSetter if present).<br>7. If hydration is needed, constructs hydration object via `this.hydrationBuilder.buildPosHydration(storeId)` or related delegate.<br>8. Renders SSR view with sanitized and contract-compliant DTOs.<br>9. Never exposes secrets in SSR/hydration.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleMerchantGet(req, res, next): Promise<void> {<br>    // ...session/middleware logic...<br>    const storeId = req.params.storeId or req.session.storeId;<br><br>    // Fetch branding/profile, then sanitize via delegate<br>    const branding = await this.brandingService.fetchBranding(storeId);<br>    branding.brandColor = this.inputValidator.sanitizeBrandColor(branding.brandColor);<br><br>    res.locals.branding = branding;<br><br>    // Set no-cache headers with delegate if present<br>    this.noCacheHeaderSetter.set(res);<br><br>    // Build hydration object if needed<br>    let hydration = {};<br>    if (req.path.endsWith('/pos')) {<br>        hydration = this.hydrationBuilder.buildPosHydration(storeId);<br>    }<br><br>    res.render('merchant/pos.ejs', {<br>        branding,<br>        hydration<br>    });<br>}<br>```<br><br> |  |
| MerchantRouteHandlers | handleMerchantPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleMerchantPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>Handles all POST/PUT/PATCH requests to `/merchant/*`.<br><br>After refactoring:<br><br>1. Validates auth and CSRF (middleware).<br>2. Delegates all field-by-field input validation and sanitization to `this.inputValidator` methods.<br>    - For invoice: `validateInvoiceInput(req.body)`<br>    - For branding/profile: `validateBrandingProfileInput(req.body)`<br>    - For subscription: `validateSubscriptionInput(req.body)`<br>3. Uses normalized/validated output from the delegate for Bridge/service calls.<br>4. Maps errors to user-friendly messages; renders SSR views accordingly.<br>5. After mutation, re-fetches updated state from Bridge and re-renders with new data.<br>6. Ensures SSR forms include CSRF via SSRViewRenderer.<br>7. Never exposes secrets or raw Bridge payloads.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleMerchantPost(req, res, next): Promise<void> {<br>    try {<br>        // Validate input for the action<br>        const { amount, ttl, memo } = this.inputValidator.validateInvoiceInput(req.body);<br><br>        // Call Bridge/service with validated input<br>        const invoice = await this.invoiceService.createInvoice(<br>            req.session.storeId,<br>            amount,<br>            ttl,<br>            memo<br>        );<br>        // Build hydration as needed<br>        const hydration = this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br><br>        res.render('merchant/invoice.ejs', {<br>            branding: res.locals.branding,<br>            invoice,<br>            hydration<br>        });<br>    } catch (err) {<br>        // Map error, pass to SSR error middleware<br>        next(err);<br>    }<br>}<br>```<br><br> |  |
| MerchantRouteHandlers | handleCancelInvoice(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST requests for invoice cancellation from dashboard, detail drawer, or POS. Ensures merchant authentication and CSRF validation (middleware). Calls `BridgeClient.cancelInvoiceCreateTx(storeId, invoiceId, apiKey)` to attempt an unsigned on-chain cancel; if response includes an unsignedCall, hydrates SSR view for client-side signing via @stacks/connect. If not, calls fallback `BridgeClient.cancelInvoiceDTO(storeId, invoiceId, apiKey)` for a DTO-based cancellation. After any successful cancellation, refetches updated invoice state or list from Bridge and SSR re-renders the view, disabling further cancel actions for the invoice. Any errors are mapped to user-friendly SSR banners/messages. All state update logic and view hydration is server-side; client JS islands are only hydrated with prescribed DTOs as-needed for wallet actions. |  |
| MerchantRouteHandlers | handleRefundInvoice(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST requests to initiate invoice refunds (from ledger or detail drawer). Ensures session and CSRF validation. Validates refund amount and memo. Calls `BridgeClient.createRefundTx(storeId, invoiceId, amount, memo, apiKey)` to request unsigned refund transaction; if unsignedCall is present, hydrates SSR view for client-side @stacks/connect signing. After broadcast, refetches updated invoice data (including `refundAmount` and status) from Bridge and SSR re-renders view to reflect new refund state. Refund button is rendered only for eligible (paid) invoices. Handles both SSR form and JS island POSTs. All output is DTO-sanitized; errors are mapped to SSR banners/messages. |  |
| MerchantRouteHandlers | handleArchiveInvoice(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST requests to archive invoices (from ledger or confirmation modal). Ensures authentication and CSRF. Calls `BridgeClient.archiveInvoice(storeId, invoiceId, apiKey)` to archive. After archive, refetches updated invoice list from Bridge and SSR re-renders the ledger, visually marking or omitting archived invoices as required. All POST routing and session management is handled by Express; Bridge integration and SSR update are performed here. |  |
| MerchantRouteHandlers | handleGenerateInvoiceNow(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleGenerateInvoiceNow(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>Handles POST requests to generate a new invoice for a subscription.<br><br>After refactoring:<br><br>1. Ensures authentication and CSRF (middleware).<br>2. Delegates all input validation to `this.inputValidator` as appropriate (e.g., subscription invoice fields).<br>3. Calls `BridgeClient.createSubscriptionInvoice` with the validated values.<br>4. On success, SSR-renders a success sheet, constructing hydration via `this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId)`.<br>5. All DTOs are sanitized prior to injection.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleGenerateInvoiceNow(req, res, next): Promise<void> {<br>    try {<br>        // Validate input via delegate<br>        const validated = this.inputValidator.validateInvoiceInput(req.body);<br><br>        // Create new subscription invoice<br>        const invoice = await this.bridgeClient.createSubscriptionInvoice(<br>            req.session.storeId,<br>            req.body.subscriptionId,<br>            validated.ttl,<br>            validated.memo,<br>            req.session.apiKey<br>        );<br><br>        const hydration = this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br><br>        res.render('merchant/invoice-success.ejs', {<br>            branding: res.locals.branding,<br>            invoice,<br>            hydration<br>        });<br>    } catch (err) {<br>        next(err);<br>    }<br>}<br>```<br><br> |  |
| MerchantRouteHandlers | handleSendEmail(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST requests from the subscriptions ledger/sheet when the merchant clicks Send Email for a subscription invoice. Ensures authentication and CSRF. Obtains the magic-link for the invoice (from payload or by calling Bridge as needed). Calls a NodeMailer-based service to send an email to the subscriber with the magic-link (never including secrets). Returns a banner/confirmation or error to the SSR view. All email logic is backend only; no email info is exposed to client JS. |  |
| MerchantRouteHandlers | handleCreateSubscription(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST requests for creating subscriptions. Ensures session and CSRF validation. Validates all input fields (amount, interval, principal, etc.) according to subscription schema. Calls `BridgeClient.createSubscription(storeId, dto, apiKey)` to create the subscription. On success, refetches the updated subscriptions list from Bridge and SSR re-renders the ledger. Any validation or Bridge errors are mapped to SSR banners. All DTOs are sanitized; no secrets are exposed. |  |
| MerchantRouteHandlers | handleCancelSubscription(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST requests for subscription cancellation. Ensures authentication and CSRF. Calls `SubscriptionService.cancelSubscription(storeId, subscriptionId)` to Bridge. If Bridge returns an unsigned call, hydrates SSR view for client-side signing. Otherwise, fallback DTO cancel is used. After cancel, refetches subscriptions from Bridge and SSR re-renders ledger to show canceled state. All output is sanitized DTO; errors are SSR-mapped. |  |
| MerchantRouteHandlers | handleManageSubscriptionGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles GET requests for managing a subscription (`/merchant/stores/:storeId/subscriptions/:subscriptionId/manage`). Ensures merchant authentication. Calls `SubscriptionService.fetchSubscriptionDetail(storeId, subscriptionId)` to Bridge for details, and fetches/sanitizes branding via `BrandingService.fetchBranding(storeId)`. Passes subscription DTO and branding to EJS SSR view, hydrating as needed for client-side interaction. All output is sanitized DTO; errors are SSR-mapped. |  |
| MerchantRouteHandlers | handlePrepareInvoicePost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handlePrepareInvoicePost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>Handles POST from POS "New Sale" form.<br><br>After refactoring:<br><br>1. Validates auth and CSRF (middleware).<br>2. Delegates all form input validation (amount, ttl, memo) to `this.inputValidator.validateInvoiceInput(req.body)`.<br>3. Calls `InvoiceService.createInvoice` with validated values.<br>4. On success, uses `this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId)` to build hydration for islands.<br>5. Renders POS payment card with validated invoice data and hydration.<br>6. On error, passes to error middleware.<br><br>**Example Implementation:**<br><br>```ts<br>public async handlePrepareInvoicePost(req, res, next): Promise<void> {<br>    try {<br>        const { amount, ttl, memo } = this.inputValidator.validateInvoiceInput(req.body);<br><br>        const invoice = await this.invoiceService.createInvoice(<br>            req.session.storeId,<br>            amount,<br>            ttl,<br>            memo<br>        );<br><br>        const hydration = this.hydrationBuilder.buildInvoiceHydration(invoice.invoiceId);<br><br>        res.render('merchant/pos-payment.ejs', {<br>            branding: res.locals.branding,<br>            invoice,<br>            hydration<br>        });<br>    } catch (err) {<br>        next(err);<br>    }<br>}<br>```<br><br> |  |
| MerchantRouteHandlers | handleSaveBrandingProfile(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleSaveBrandingProfile(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>Handles PATCH/POST requests from branding/profile settings page.<br><br>After refactoring:<br><br>1. Validates session and CSRF (middleware).<br>2. Delegates all branding/profile field validation to `this.inputValidator.validateBrandingProfileInput(req.body)`.<br>3. Calls `BrandingService.saveBrandingProfile` with the validated profile.<br>4. On success, fetches refreshed branding using `this.brandingFetcher.fetchPublicBrandingOrFallback(storeId, this.brandingService)`.<br>5. SSR re-renders with updated branding/theme.<br>6. On error, maps to SSR-friendly messages.<br>7. All output is sanitized.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleSaveBrandingProfile(req, res, next): Promise<void> {<br>    try {<br>        const validatedProfile = this.inputValidator.validateBrandingProfileInput(req.body);<br>        await this.brandingService.saveBrandingProfile(req.session.storeId, validatedProfile);<br><br>        const branding = await this.brandingFetcher.fetchPublicBrandingOrFallback(req.session.storeId, this.brandingService);<br><br>        res.render('merchant/branding.ejs', { branding });<br>    } catch (err) {<br>        next(err);<br>    }<br>}<br>```<br><br> |  |
| MerchantRouteHandlers | handleRotateApiKeys(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST to `/merchant/stores/:storeId/rotate-keys` for API key rotation. Ensures session and CSRF. Calls `StoreService.rotateApiKeys(storeId)` (Bridge endpoint). On success, injects returned `apiKey` and `hmacSecret` into the SSR template for one-time display only, tracking with session/flash; on subsequent reload, passes masked/hidden values. Ensures secrets are never hydrated or re-injected after first display. All output is sanitized; errors SSR-mapped. |  |
| MerchantRouteHandlers | handleFilterSubmit(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles GET or POST filter submissions from ledger/table views (e.g., `/merchant/stores/:storeId/invoices`). Parses filter parameters (status, date, search) from query or body. Calls appropriate BridgeClient service to fetch filtered invoices/subscriptions. Receives filtered DTOs and SSR re-renders the view with new results. No extraneous state/UI updates. Output is sanitized DTOs only. |  |
| MerchantRouteHandlers | setNoCacheHeaders(req: Express.Request, res: Express.Response, next: Express.NextFunction): void | Express middleware for all `/merchant/*` SSR routes. Before the route handler executes (prior to rendering any response), this method sets the HTTP headers `Cache-Control: no-store, max-age=0` and `Pragma: no-cache` on the response object, ensuring that SSR-rendered merchant pages are never cached by browsers or intermediaries. After setting the headers, it invokes `next()` to continue the middleware chain. No data transformation is performed. Only modifies headers on the response object. |  |
| MerchantRouteHandlers | refetchAfterAction(action: string, req: Express.Request, res: Express.Response): Promise<void> | Called after successful POST actions that mutate domain state (e.g., create, cancel, refund, archive, branding save, subscription, etc.). This method determines which resource was mutated based on `action` and current route/context. It then calls the appropriate service method (e.g., `InvoiceService.fetchInvoice`, `SubscriptionService.fetchSubscriptionDetail`, `BrandingService.fetchBranding`) to re-fetch the latest DTO from Bridge using server-to-server HTTP calls (via BridgeClient). The response is normalized to the canonical DTO shape (as defined in `/shared/types/dto.ts`). The updated DTO is then passed to the next SSR EJS template render, ensuring the UI reflects the most recent state. Handles required input validation (e.g., storeId/invoiceId/subscriptionId presence). Never passes raw Bridge payloads; only normalized DTOs. |  |
| MerchantRouteHandlers | handleApiKeysMaskOnReload(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleApiKeysMaskOnReload(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>Controls the display/masking of API keys/HMAC secrets on the API keys page.<br><br>After refactoring:<br><br>1. Delegates all logic for session flag (`apiKeysRevealed`) management and masking to `this.apiKeyRevealStateManager.handleApiKeysRevealAndMask`.<br>2. Renders the SSR view using the object returned by the delegate (with real or masked secrets as appropriate).<br>3. No session state, masking, or display logic remains in the parent.<br><br>**Example Implementation:**<br><br>```ts<br>public handleApiKeysMaskOnReload(req, res, next): void {<br>    const result = this.apiKeyRevealStateManager.handleApiKeysRevealAndMask(req, res.locals.branding);<br>    res.render('merchant/api-keys.ejs', result);<br>}<br>```<br><br> |  |
| MerchantRouteHandlers | refetchPublicProfileAfterSave(storeId: string, req: Express.Request, res: Express.Response): Promise<void> | <br><br>**Refactored Method: refetchPublicProfileAfterSave(storeId: string, req: Express.Request, res: Express.Response): Promise<void>**<br><br>After a branding/profile PATCH/POST, fetches the updated branding for SSR.<br><br>After refactoring:<br><br>1. Delegates branding fetch (and fallback on error) to `this.brandingFetcher.fetchPublicBrandingOrFallback(storeId, this.brandingService)`.<br>2. Sets `res.locals.branding` to the result.<br>3. No Bridge/fallback/normalization logic remains in the parent.<br><br>**Example Implementation:**<br><br>```ts<br>public async refetchPublicProfileAfterSave(storeId: string, req: Express.Request, res: Express.Response): Promise<void> {<br>    res.locals.branding = await this.brandingFetcher.fetchPublicBrandingOrFallback(storeId, this.brandingService);<br>}<br>```<br><br>--- |  |
| AdminRouteHandlers | handleLoginPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/login`. Parses credentials from `req.body`, validates them using custom logic (e.g., password hash comparison, or passport-local strategy as per system config). On successful validation, sets `req.session.adminUser = { id, name, email }` to establish the admin session and redirects to `/admin` via `res.redirect`. On failure, constructs a user-friendly error (never revealing stack trace or technical detail), SSR-renders `error.ejs` with sanitized branding/context and error code/message. All session and cookie logic is managed via `express-session`. No secrets or credentials are ever rendered to the client or hydrated to JS. |  |
| AdminRouteHandlers | handleStoresPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | <br><br>**Refactored Method: handleStoresPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>**<br><br>Handles POST `/admin/stores` (new store creation).<br><br>After refactoring:<br><br>1. Receives raw form data from `req.body`.<br>2. Fetches existing principals from Bridge.<br>3. Delegates all validation and DTO construction to `this.storeCreationValidator.validateAndBuildStoreDTO(req.body, existingPrincipals)`.<br>4. On success, calls Bridge to create the store using the validated DTO.<br>5. Fetches updated store list and renders SSR view with new data.<br>6. Never leaks secrets; all field validation and sanitization is offloaded.<br><br>**Example Implementation:**<br><br>```ts<br>public async handleStoresPost(req, res, next): Promise<void> {<br>    try {<br>        const stores = await this.bridgeClient.listStores();<br>        const existingPrincipals = stores.map(s => s.principal);<br><br>        // Delegate validation/DTO construction<br>        const newStoreDTO = this.storeCreationValidator.validateAndBuildStoreDTO(req.body, existingPrincipals);<br><br>        await this.bridgeClient.createStore(newStoreDTO);<br><br>        const newStores = await this.bridgeClient.listStores();<br>        const branding = await this.brandingService.fetchBranding('');<br><br>        res.render('admin/stores.ejs', {<br>            branding,<br>            stores: newStores<br>        });<br>    } catch (err) {<br>        next(err);<br>    }<br>}<br>```<br><br> |  |
| AdminRouteHandlers | handleRotateKeysPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/stores/:storeId/rotate-keys`. Proxies the request to Bridge via BridgeClient. On first POST in session, receives new `apiKey` and `hmacSecret`, injects them into the SSR EJS template for one-time reveal, and sets a session/in-memory flag marking the one-time display. On subsequent GET/POST to keys page, passes masked/hidden values for secrets (e.g., `'*'`) and omits secrets from SSR context and hydration. Ensures secrets are never leaked to client JS (window or islands). All state transitions and masking logic are server-side. |  |
| AdminRouteHandlers | handleTokenConfigPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/token`. Receives input from config form in `req.body` (contract address/name, etc.), validates and sanitizes fields as required. Proxies the validated config to Bridge (`/api/admin/set-sbtc-token`) via BridgeClient. On success, receives an unsigned call object from Bridge, and injects it into SSR view hydration (as safe JSON in `window.__PAGE__`). Renders the token config EJS view with updated state. On validation or Bridge error, renders same view with inline error messages. Ensures no secrets or privileged data are hydrated or exposed beyond unsigned call data. |  |
| AdminRouteHandlers | handleBootstrapPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/bootstrap`. Proxies the request to Bridge (`/api/admin/bootstrap`) via BridgeClient, receives unsigned call for bootstrap and hydrates it into SSR view in `window.__PAGE__`. On client POST confirmation (e.g., `/admin/bootstrap/confirm`), fetches completed bootstrap state from Bridge and SSR-renders the view again. All error handling is server-side, SSR-rendered with branding and user-friendly messages. No secrets are hydrated to client JS; only unsigned call data for wallet flows is included. |  |
| AdminRouteHandlers | handleSyncOnchainPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/stores/:storeId/sync-onchain`. Proxies request to Bridge (`/api/admin/stores/:storeId/sync-onchain`), receives an array of unsigned calls, and hydrates them into `window.__PAGE__` for client wallet flows. After client POST confirmation, fetches updated sync state from Bridge and SSR-renders the view. Ensures no secrets are included in SSR context or hydration. Handles and SSR-renders any errors from Bridge or validation as user-friendly banners. |  |
| AdminRouteHandlers | handlePollerRestartPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/poller/restart`. Proxies the request to Bridge (`/api/admin/poller/restart`), fetches updated poller status fields from Bridge (e.g., `running`, `lastRunAt`, `lagBlocks`, etc.), and SSR-renders the EJS poller view with the refreshed state. No client-side state is maintained or updated; all state propagation occurs via SSR. Maps any errors to user-friendly banners in the SSR view. |  |
| AdminRouteHandlers | handleWebhooksRetryPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express POST handler for `/admin/webhooks/retry`. Receives `webhookLogId` from body, proxies to Bridge, receives updated result/status, then fetches refreshed webhook log data from Bridge, normalizes to DTOs, and SSR-renders the webhooks EJS view with updated table. All state updates are via SSR; errors are rendered as inline SSR error banners. |  |
| AdminRouteHandlers | handleAdminGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Universal Express GET handler for all `/admin/*` routes. Inspects the path to determine which EJS template to render (e.g., `/admin` → `admin-home.ejs`, `/admin/stores` → `stores.ejs`). Fetches all required admin-scoped data from Bridge via BridgeClient (never merchant/tenant data), normalizes results to DTOs, injects sanitized branding and admin navigation into SSR props, and calls `res.render(templateName, viewProps)` using EJS-mate. All data normalization and SSR hydration occur in this method. Ensures no secrets or out-of-scope data are passed to views or hydration. |  |
| AdminRouteHandlers | handleStoreActivatePatch(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express PATCH handler for `/admin/stores/:storeId/activate` (receives `storeId` in params, `{ active: boolean }` in body). Validates input, proxies activation state change to Bridge (`patchStoreActivate`), and on success, fetches updated store state/branding from Bridge. SSR-renders the EJS view reflecting the new activation state, and, if necessary, updates messaging in related SSR views (e.g., magic-link) to show explicit deactivation reason. On validation or Bridge error, SSR-renders error or inline message. Ensures only admin-scoped data is handled, and that no secrets are ever included. |  |
| AdminRouteHandlers | handleSettingsPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Handles POST or PATCH to the admin settings form. Receives form data in `req.body` (including `brandColor`, `displayName`, etc.), validates and sanitizes all fields (e.g., `brandColor` regex). Proxies valid data to Bridge via BridgeClient. On success, SSR-renders the updated settings view; on validation or Bridge error, renders the same view with inline error messages. All state and error handling occurs server-side; no secrets are ever hydrated to the client. |  |
| AdminRouteHandlers | omitSecretsFromViewPropsAndHydration(props: object): object | <br><br>**Refactored Method: omitSecretsFromViewPropsAndHydration(props: object): object**<br><br>Ensures no secret fields are injected into SSR admin views or hydrated to client scripts.<br><br>After refactoring:<br><br>1. Delegates all field omission and whitelisting to `this.secretFieldOmitter.omitSecretsFromProps(props)`.<br>2. The returned object is always sanitized and SSR/hydration safe.<br>3. No manual key iteration, omission, or whitelisting remains in the parent.<br><br>**Example Implementation:**<br><br>```ts<br>public omitSecretsFromViewPropsAndHydration(props: Record<string, any>): Record<string, any> {<br>    return this.secretFieldOmitter.omitSecretsFromProps(props);<br>}<br>```<br><br> |  |
| AdminRouteHandlers | enforceAdminContextDataScopes(req: Express.Request, res: Express.Response): void | <br><br>**Refactored Method: enforceAdminContextDataScopes(req: Express.Request, res: Express.Response): void**<br><br>Ensures that GET/POST/PATCH SSR controllers operate only in a valid admin context and that all DTOs rendered are admin-scoped.<br><br>After refactoring:<br><br>1. Calls `this.adminContextScopeEnforcer.enforceScope(req, res, [dtoListOrProp])` as needed.<br>2. Throws on missing admin session or scope mismatch.<br>3. No manual session or context validation remains in the parent.<br><br>**Example Implementation:**<br><br>```ts<br>public enforceAdminContextDataScopes(req: Express.Request, res: Express.Response, dtos?: any[]): void {<br>    this.adminContextScopeEnforcer.enforceScope(req, res, dtos);<br>}<br>```<br><br>--- |  |
| AdminRouteHandlers | handleWebhooksGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express GET handler for `/admin/webhooks`. Parses query params (`status`, `storeId`), proxies the query to Bridge via BridgeClient, normalizes webhook log DTOs, and SSR-renders the webhooks EJS view with a table of results (status, storeId, payload, delivery status, timestamp). Errors are handled and rendered as inline banners in the SSR view. No client-side routing or state update occurs. |  |
| BridgeClient | normalizeBridgeResponse(res: any): InvoiceDTO ¦ SubscriptionDTO ¦ Branding ¦ object | Receives raw Bridge response payloads (from e.g., `prepareInvoice`, `fetchInvoice`, etc.), maps and normalizes the data into the canonical DTO shape as defined in `/shared/types/dto.ts`. Returns only the normalized DTO to the calling service/controller. No raw Bridge fields or non-contracted fields are passed further. Ensures strict typing and interface compatibility with the rest of the system. Handles any required transformation of field names, type conversions, or metadata stripping to conform to system contracts. | **HOW to implement `BridgeClient.normalizeBridgeResponse(res: any)`**:<br><br>- **Alignment**: Method is unequivocally aligned with the problem statement and architectural requirements (see DS-2-SYSTEM-5).<br>- **Purpose**: Receives a raw Bridge API response and transforms it to the canonical DTO shape defined in `/shared/types/dto.ts` (e.g., `InvoiceDTO`, `SubscriptionDTO`, `Branding`, or other contract-defined objects).<br>- **Detailed Steps**:<br>  1. **Input**: Accept the raw JSON object (response body) from Bridge. This may contain extra metadata, non-canonical keys, or fields not present in the system DTOs.<br>  2. **Determine Target DTO**: Based on the context in which this method is called (e.g., which Bridge API endpoint was hit), determine the target DTO type (e.g., `InvoiceDTO` for invoice APIs, `Branding` for profile APIs, etc.).<br>  3. **Field Mapping**:<br>     - For each field in the DTO contract:<br>       - Map/rename Bridge response fields to match DTO field names if they differ (e.g., Bridge's `amount_sats` → DTO's `amountSats` if needed).<br>       - Convert data types if necessary (e.g., timestamps to ISO strings, numbers to numbers, etc.).<br>       - Omit any fields present in Bridge response that are not part of the DTO type contract.<br>     - Example (Invoice):<br>       ```ts<br>       return {<br>         invoiceId: res.invoiceId or res.id,<br>         storeId: res.storeId,<br>         status: res.status,<br>         amountSats: res.amountSats,<br>         usdAtCreate: res.usdAtCreate,<br>         quoteExpiresAt: res.quoteExpiresAt,<br>         merchantPrincipal: res.merchantPrincipal,<br>         payer: res.payer ?? null,<br>         txId: res.txId ?? null,<br>         memo: res.memo ?? null,<br>         subscriptionId: res.subscriptionId ?? null,<br>         createdAt: res.createdAt ?? null,<br>         refundAmount: res.refundAmount ?? null,<br>         refundTxId: res.refundTxId ?? null,<br>         store: res.store<br>           ? {<br>               displayName: res.store.displayName,<br>               logoUrl: res.store.logoUrl,<br>               brandColor: res.store.brandColor<br>             }<br>           : undefined<br>       };<br>       ```<br>  4. **Strict Typing**:<br>     - Ensure all required DTO fields are present.<br>     - Provide fallbacks for optional fields as specified in the DTO type contract (e.g., `null` or `undefined`).<br>  5. **No Leakage**:<br>     - Never pass through fields not defined in the DTO contract.<br>     - Never return raw Bridge payloads or metadata (e.g., internal Bridge error messages, headers, etc.).<br>  6. **Return**: The normalized object, fully matching the DTO shape defined in `/shared/types/dto.ts`, ready for consumption by services/controllers and for injection into EJS or hydration objects.<br>- **Performance Constraints**:<br>  - The transformation must complete synchronously, must not block the event loop, and is expected to run in ≤ 1 ms per typical object.<br>- **Edge Cases**:<br>  - If required fields are missing in the Bridge response, either throw or supply the fallback as required by the DTO contract.<br>  - If the Bridge response shape is not recognized, throw an error for the calling service to handle.<br>- **Gotchas**:<br>  - Watch for case mismatches or snake_case vs camelCase field differences.<br>  - Never "accidentally" spread Bridge objects directly; explicitly map only contract fields.<br>  - Validate numeric/string fields are of the correct type.<br>- **Example Pseudocode**:<br>  ```ts<br>  function normalizeBridgeResponse(res, dtoType) {<br>    switch(dtoType) {<br>      case 'InvoiceDTO':<br>        // Map as above; only allowed fields, with type conversion/fallbacks.<br>        break;<br>      case 'Branding':<br>        // Map and sanitize branding fields only.<br>        break;<br>      // ... etc for each DTO contract<br>      default:<br>        throw new Error('Unknown DTO type for normalization');<br>    }<br>  }<br>  ```<br>- **Invariant**: The output is always a DTO matching `/shared/types/dto.ts`, and never includes extra or raw Bridge fields.<br><br>--- |
| BridgeClient | mapBridgeError(error: any): MappedBridgeError | **Purpose:** Maps any HTTP/network error from Bridge API (received as error objects - e.g., from axios/fetch, including network, 4xx, 5xx, or Bridge-provided error payloads) to a user-friendly error message and code suitable for SSR presentation. <br> **Responsibilities:** <ul><li>Receives any error thrown by BridgeClient HTTP methods.</li><li>Removes stack traces, technical details, and raw Bridge payloads.</li><li>Maps known Bridge error codes/statuses to application-specific messages (e.g., session expired, validation failed, not found, etc.), using internal mappings for user-friendliness.</li><li>Returns only sanitized MappedBridgeError: <code>{ message: string; code?: stringornumber }</code>.</li><li>Errors ready for SSR error.ejs (controller decides whether to show as banner/message or pass to error middleware).</li><li>No secrets or sensitive data must be present in the mapped error.</li></ul> | **HOW to implement `BridgeClient.mapBridgeError(error: any): MappedBridgeError`**:<br><br>- **Alignment**: Fully aligned with the system requirements (see DS-2-SYSTEM-6).<br>- **Purpose**: Converts any HTTP/network/Bridge API error to a user-friendly error shape for SSR, stripping all sensitive, technical, or raw data.<br>- **Detailed Steps**:<br>  1. **Input**: Receives an error object (could be from axios/fetch, a thrown error, or a Bridge error payload).<br>  2. **Remove Technical Details**:<br>     - Strip any stack traces (`error.stack`), raw response objects, or technical error fields.<br>     - Do not include the raw original Bridge payload or HTTP objects in output.<br>  3. **Error Code Extraction**:<br>     - If the error object includes a `response` (from axios/fetch), extract the HTTP status (e.g., 401, 403, 404, 409, 422, 500).<br>     - If a Bridge payload is present, extract its `code` and human message if available.<br>  4. **Map to User-Friendly Message**:<br>     - For known Bridge error codes or HTTP statuses, map to friendly messages:<br>       - 401/403: "Session expired, please log in again." / "Unauthorized."<br>       - 404: "Resource not found."<br>       - 409: "Invalid operation: [e.g. 'Already canceled', 'Invoice expired']"<br>       - 422: "Validation failed: [error details if safe]"<br>       - 500: "Server error. Please try again later."<br>     - Fallback: "An unexpected error occurred."<br>  5. **Safe Error Object**:<br>     - Return only `{ message: string, code?: stringornumber }`<br>     - Only include `code` if it is not sensitive or internal; otherwise, leave undefined.<br>  6. **Edge Cases**:<br>     - If the error is a simple JS Error, include only `.message` and no technical detail.<br>     - If error is empty/opaque, use the fallback message.<br>  7. **Return**: The mapped user-friendly error object, which is always safe for injection into SSR error views.<br>- **Example Pseudocode**:<br>  ```ts<br>  function mapBridgeError(error) {<br>    let code, message;<br>    if (error.response) {<br>      code = error.response.status;<br>      switch(code) {<br>        case 401:<br>        case 403:<br>          message = 'Session expired or unauthorized.';<br>          break;<br>        case 404:<br>          message = 'Resource not found.';<br>          break;<br>        case 409:<br>          message = 'Invalid operation (conflict).';<br>          break;<br>        case 422:<br>          message = 'Validation failed.';<br>          break;<br>        case 500:<br>          message = 'Server error. Please try again later.';<br>          break;<br>        default:<br>          message = error.response.data?.message or 'An unexpected error occurred.';<br>      }<br>    } else if (error.code) {<br>      code = error.code;<br>      message = error.message or 'An unexpected error occurred.';<br>    } else if (error instanceof Error) {<br>      message = error.message;<br>    } else {<br>      message = 'An unexpected error occurred.';<br>    }<br>    return { message, code };<br>  }<br>  ```<br>- **Invariant**: No secrets, stack traces, or raw/internal details are present in the returned error object.<br><br>--- |
| BridgeClient | patchStoreActivate(storeId: string, active: boolean): Promise<{ active: boolean }> | **Purpose:** Sends a PATCH request to Bridge API at `/api/admin/stores/:storeId/activate` to activate/deactivate a store.<br> **Responsibilities:** <ul><li>Validates that storeId is a non-empty string and active is a boolean.</li><li>Constructs PATCH request with proper authentication headers (admin context).</li><li>Sends `{ active: trueorfalse }` as JSON body.</li><li>Awaits Bridge response and verifies that the returned object contains <code>{ active: boolean }</code>.</li><li>If Bridge returns an error, throws with details to be caught by caller and mapped via <code>mapBridgeError</code>.</li><li>Returns the activation state (<code>{ active: trueorfalse }</code>), ready for injection in admin store view update.</li><li>Never exposes any secrets or raw Bridge errors to outside layers.</li></ul> | **HOW to implement `BridgeClient.patchStoreActivate(storeId: string, active: boolean): Promise<{ active: boolean }>`**:<br><br>- **Alignment**: Fully aligned with problem statement and requirements (see DS-3-USER-4).<br>- **Purpose**: Sends a PATCH request to Bridge API `/api/admin/stores/:storeId/activate` to change a store's activation state and returns the result.<br>- **Detailed Steps**:<br>  1. **Input Validation**:<br>     - Assert `storeId` is a non-empty string.<br>     - Assert `active` is a boolean (`true` or `false`).<br>     - If either fails, throw an error or return mapped error.<br>  2. **Construct HTTP Request**:<br>     - Endpoint: `/api/admin/stores/:storeId/activate` (interpolate `storeId`)<br>     - Method: PATCH<br>     - Body: `{ active: trueorfalse }` as JSON.<br>     - Headers:<br>       - Content-Type: application/json<br>       - Any required admin authentication headers (e.g., X-API-Key, session token), per Bridge API contract.<br>  3. **Send Request**:<br>     - Use axios, fetch, or equivalent HTTP client.<br>     - Await response.<br>  4. **Handle Response**:<br>     - If HTTP status is 200 or as per Bridge contract:<br>       - Parse the JSON response.<br>       - Validate that the returned object contains `{ active: boolean }`.<br>       - If not, throw an error to be mapped upstream.<br>     - If the response is an error status (e.g., 4xx, 5xx), throw or reject with details to be handled by the error mapping logic.<br>  5. **Return**:<br>     - The activation state object `{ active: boolean }`.<br>  6. **Edge Cases**:<br>     - If storeId does not exist, expect Bridge to return a 404; propagate error for mapping.<br>     - If not authorized, expect 401/403; propagate error for mapping.<br>     - If Bridge returns error or malformed output, throw for mapping.<br>  7. **Gotchas**:<br>     - Never include secrets or authentication tokens in returned object.<br>     - Never leak raw Bridge error payloads; let the caller map.<br>  8. **Performance**:<br>     - Should complete as fast as network and Bridge allow; should not block longer than HTTP timeout.<br>- **Example Pseudocode**:<br>  ```ts<br>  async function patchStoreActivate(storeId, active) {<br>    if (!storeId or typeof storeId !== 'string') throw new Error('Invalid storeId');<br>    if (typeof active !== 'boolean') throw new Error('Invalid active flag');<br>    const res = await axios.patch(`/api/admin/stores/${storeId}/activate`, { active }, {<br>      headers: { 'Content-Type': 'application/json', /* ...admin auth... */ }<br>    });<br>    if (!res.data or typeof res.data.active !== 'boolean') throw new Error('Malformed Bridge response');<br>    return { active: res.data.active };<br>  }<br>  ```<br>- **Invariant**: Only returns `{ active: boolean }` on success, throws on error to be mapped by the caller.<br><br>--- |
| BrandingService | fetchBranding(storeId: string): Promise<Branding> | Purpose:  Fetches, sanitizes, and returns the branding/profile object for a given storeId for SSR injection on every SSR GET, including errors.<br>  Responsibilities:  <ul><li>Determines surface type (public/merchant/admin) from calling context.</li><li>For public: calls <code>BridgeClient.getPublicProfile(storeId)</code>. For merchant/admin: <code>BridgeClient.getProfile(storeId)</code> or relevant aggregate endpoint.</li><li>Extracts <code>displayName, brandColor, logoUrl, supportEmail, supportUrl</code> from Bridge response.</li><li>Validates <code>brandColor</code> using regex <code>/^#[0-9A-Fa-f]{6}$/</code>. If invalid/missing, replaces with <code>#111827</code> (neutral fallback).</li><li>If fetch fails or any required field is missing/invalid, logs a warning (via logger or console.warn) and returns fallback branding (<code>{ displayName: "WEBPAY", brandColor: "#111827", logoUrl: null }</code>).</li><li>Returns only the sanitized Branding object, never includes secrets or extra Bridge data.</li></ul> | **HOW to implement `BrandingService.fetchBranding(storeId: string): Promise<Branding>`**:<br><br>- **Alignment**: Fully aligned with SSR branding/injection requirements (see DS-2-SYSTEM-9, DS-5-SYS-1).<br>- **Purpose**: Fetches, sanitizes, and returns a branding/profile object for SSR view injection on every SSR GET (including error pages).<br>- **Detailed Steps**:<br>  1. **Determine Surface**:<br>     - Identify if the call is for a public, merchant, or admin surface, based on calling context (route or request type):<br>       - For public surface, use `BridgeClient.getPublicProfile(storeId)`.<br>       - For merchant or admin, use `BridgeClient.getProfile(storeId)`.<br>  2. **Fetch Branding/Profile**:<br>     - Call the appropriate BridgeClient method to fetch profile data from Bridge.<br>     - Handle fetch errors (network, 4xx, 5xx) in a `try/catch`.<br>  3. **Extract Required Fields**:<br>     - Pull out: `displayName`, `brandColor`, `logoUrl`, `supportEmail`, `supportUrl`.<br>     - If any are missing, handle as invalid.<br>  4. **Sanitize brandColor**:<br>     - Apply regex `/^#[0-9A-Fa-f]{6}$/` to `brandColor`.<br>     - If invalid or missing, set `brandColor` to `#111827`.<br>  5. **Check for Incompleteness or Invalidity**:<br>     - If fetch failed, or if any required field is missing/invalid, log a warning (via logger or `console.warn`).<br>     - Return a fallback branding object: `{ displayName: "WEBPAY", brandColor: "#111827", logoUrl: null }`.<br>  6. **Return Branding Object**:<br>     - Return a sanitized object:<br>       ```ts<br>       {<br>         displayName,                // string<br>         brandColor,                 // sanitized string<br>         logoUrl: logoUrl ?? null,   // string or null<br>         supportEmail: supportEmail ?? null,<br>         supportUrl: supportUrl ?? null<br>       }<br>       ```<br>     - Never include extra fields or secrets.<br>  7. **Edge Cases**:<br>     - If Bridge returns an error or incomplete data, always return fallback.<br>     - Always guarantee a valid branding object is returned for SSR (never undefined/null).<br>  8. **Performance**:<br>     - Network-limited; ensure the method is async and does not block the event loop.<br>- **Example Pseudocode**:<br>  ```ts<br>  async function fetchBranding(storeId) {<br>    try {<br>      let profile;<br>      if (isPublicSurface()) {<br>        profile = await BridgeClient.getPublicProfile(storeId);<br>      } else {<br>        profile = await BridgeClient.getProfile(storeId);<br>      }<br>      const displayName = profile.displayName;<br>      let brandColor = profile.brandColor;<br>      if (!/^#[0-9A-Fa-f]{6}$/.test(brandColor)) brandColor = '#111827';<br>      return {<br>        displayName,<br>        brandColor,<br>        logoUrl: profile.logoUrl ?? null,<br>        supportEmail: profile.supportEmail ?? null,<br>        supportUrl: profile.supportUrl ?? null<br>      };<br>    } catch (err) {<br>      console.warn('Using fallback branding for storeId:', storeId, err);<br>      return { displayName: 'WEBPAY', brandColor: '#111827', logoUrl: null, supportEmail: null, supportUrl: null };<br>    }<br>  }<br>  ```<br>- **Invariant**: A complete, sanitized branding object is always returned for SSR.<br><br>--- |
| BrandingService | sanitizeBrandColor(brandColor: string or null or undefined): string | **Purpose:** Validates and sanitizes a brandColor string before SSR injection.<br> **Responsibilities:** <ul><li>Receives candidate brandColor (string, possibly null/undefined).</li><li>If brandColor matches regex <code>/^#[0-9A-Fa-f]{6}$/</code>, returns unchanged.</li><li>If missing or invalid, returns fallback <code>#111827</code> (neutral slate-900).</li><li>Never passes unsanitized or user-supplied color to SSR templates.</li></ul> | **HOW to implement `BrandingService.sanitizeBrandColor(brandColor: string or null or undefined): string`**:<br><br>- **Alignment**: Fully aligned with SSR branding theming requirements (see DS-2-SYSTEM-15, DS-5-SYS-10).<br>- **Purpose**: Ensures that only a valid hex brand color string is injected into SSR templates; otherwise, uses a safe fallback.<br>- **Detailed Steps**:<br>  1. **Input**: Accept a candidate `brandColor` value, possibly `null`, `undefined`, or string.<br>  2. **Regex Validation**:<br>     - Test if `brandColor` is a string and matches `/^#[0-9A-Fa-f]{6}$/`.<br>     - If so, return it unchanged.<br>  3. **Fallback**:<br>     - If missing, null, undefined, or does not match regex, return fallback `#111827` (slate-900).<br>  4. **Return**: Always return a string in `#RRGGBB` format.<br>- **Performance**:<br>  - Synchronous, ≤ 0.1 ms per call.<br>- **Edge Cases**:<br>  - Accepts only 6-digit hex prefixed by `#`.<br>  - If a malicious value is passed (e.g., `javascript:alert(1)`), it is rejected and replaced with fallback.<br>- **Example Pseudocode**:<br>  ```ts<br>  function sanitizeBrandColor(brandColor) {<br>    return (typeof brandColor === 'string' && /^#[0-9A-Fa-f]{6}$/.test(brandColor))<br>      ? brandColor<br>      : '#111827';<br>  }<br>  ```<br>- **Invariant**: Never returns an unsanitized or non-hex color value.<br><br>--- |
| BrandingService | injectFallbackBranding(): Branding | Purpose:  Returns a safe fallback branding object if Bridge fetch fails or data is invalid.<br>  Responsibilities:  <ul><li>Returns <code>{ displayName: "WEBPAY", brandColor: "#111827", logoUrl: null }</code>.</li><li>Logs a warning (via app logger or <code>console.warn</code>) every time fallback is injected for diagnostics.</li><li>Ensures every SSR view, including error.ejs, always receives valid branding.</li></ul> | **HOW to implement `BrandingService.injectFallbackBranding(): Branding`**:<br><br>- **Alignment**: Fully aligned with SSR error/fallback branding requirements (see DS-3-SYS-12, DS-5-SYS-11).<br>- **Purpose**: Supplies a safe, neutral branding object when Bridge fetch fails or data is invalid, ensuring SSR never renders without branding.<br>- **Detailed Steps**:<br>  1. **Create Fallback Branding Object**:<br>     - Always:<br>       ```ts<br>       {<br>         displayName: 'WEBPAY',<br>         brandColor: '#111827',<br>         logoUrl: null,<br>         supportEmail: null,<br>         supportUrl: null<br>       }<br>       ```<br>  2. **Log Warning**:<br>     - Use application logger or `console.warn` to record usage of fallback, including context (e.g., storeId if available, or error details if caught).<br>  3. **Return Object**:<br>     - Return the fallback branding object for SSR use (template context).<br>  4. **Edge Cases**:<br>     - Never fail or throw; always returns a valid object.<br>     - Always safe for injection into any SSR view, including `error.ejs`.<br>- **Performance**:<br>  - Synchronous, trivial.<br>- **Example Pseudocode**:<br>  ```ts<br>  function injectFallbackBranding() {<br>    console.warn('Injecting fallback branding object');<br>    return {<br>      displayName: 'WEBPAY',<br>      brandColor: '#111827',<br>      logoUrl: null,<br>      supportEmail: null,<br>      supportUrl: null<br>    };<br>  }<br>  ```<br>- **Invariant**: This method is called on branding fetch failure or validation error, guaranteeing all SSR views have branding.<br><br>---<br>End of report.<br>``` |
| AuthService | requireSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void | Purpose:  Express middleware for all <code>/merchant/*</code> routes to enforce valid/active merchant session.<br>  Responsibilities:  <ul><li>Checks <code>req.session</code> for presence and validity of merchant session data.</li><li>If session is valid, calls <code>next()</code> to proceed to route/controller.</li><li>If session is missing or expired, immediately redirects to login page (merchant login URI), ending response.</li><li>No business/data logic is performed; strictly access control.</li><li>Never mutates business data.</li></ul> |  |
| AuthService | requireAdminSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void | Purpose:  Express middleware for all <code>/admin/*</code> routes to enforce admin authentication.<br>  Responsibilities:  <ul><li>Checks <code>req.session</code> for admin session presence and validity.</li><li>If session is valid, calls <code>next()</code> to proceed to route/controller.</li><li>If session is invalid/missing, SSR-renders <code>error.ejs</code> with status 401/403, providing user-friendly message and branding from <code>BrandingService.injectFallbackBranding()</code> as needed.</li><li>Does not expose stack trace or secrets.</li><li>No client-side logic.</li></ul> |  |
| ErrorMiddleware | handleError(err: Error, req: Express.Request, res: Express.Response, next: Express.NextFunction): void | Purpose:  Global Express error handler. Converts any error (validation, Bridge API, session, CSRF, unexpected) into a user-friendly SSR-rendered error page.<br>  Responsibilities:  <ul><li>Receives any error thrown in middleware/controller/service chain.</li><li>Maps error to a sanitized message/code (removes stack traces, technical details, secrets).</li><li>Checks for branding prop in request context; if absent, injects fallback branding via <code>BrandingService.injectFallbackBranding()</code>.</li><li>Sets HTTP status appropriate to error type (400, 403, 409, 410, 500, etc).</li><li>SSR-renders <code>error.ejs</code> via <code>SSRViewRenderer</code> with <code>{ error: {message, code}, branding }</code>.</li><li>For CSRF/session errors, destroys session as required before rendering error.</li><li>Never exposes stack traces or secrets to client. Stops further processing after rendering error.</li></ul> |  |
| SSRViewRenderer | renderFormWithCSRFToken(req: Express.Request): string | Purpose:  SSR helper to render hidden CSRF token field in every POST form in merchant console EJS templates.<br>  Responsibilities:  <ul><li>Reads CSRF token via <code>req.csrfToken()</code> (attached by csurf middleware).</li><li>Returns HTML string <code>&lt;input name="_csrf" value="..."&gt;</code> for direct injection in EJS forms.</li><li>No logic of token generation or validation (handled by middleware stack).</li><li>No client-side hydration for CSRF tokens.</li></ul> |  |
| SSRViewRenderer | injectStaticAssetLinks(islands?: string[]): string | Purpose:  Ensures that layout/head of every SSR page includes correct static asset references.<br>  Responsibilities:  <ul><li>Injects <code>&lt;link rel="stylesheet" href="/static/css/app.css" /&gt;</code> into <code>&lt;head&gt;</code> (Tailwind build).</li><li>For each required client JS island (if provided), injects <code>&lt;script src="/static/js/[island].js" type="module"&gt;&lt;/script&gt;</code> (e.g., <code>magic-link.js</code>, <code>status-strip.js</code>).</li><li>Ensures all paths use <code>/static/</code> prefix, matching Express static config.</li><li>Returns concatenated HTML string for template injection.</li></ul> |  |
| SSRViewRenderer | renderPartialWithContext(partial: string, context: Record<string, any>): string | Purpose:  During EJS rendering, includes a partial template, evaluating it with the current context (e.g., branding, hydration, error, etc.).<br>  Responsibilities:  <ul><li>Resolves and loads partial template (<code>_partials/header</code>, <code>footer</code>, <code>status-strip</code>, etc.).</li><li>Renders partial with all provided context, ensuring branding and state are available for consistent SSR output.</li><li>Returns each partial's rendered HTML for inclusion in parent template.</li></ul> |  |
| SSRViewRenderer | setTitleFromBrandingOrOverride(title: string or undefined, branding: Branding): string | **Purpose:** Determines server-side page <code>&lt;title&gt;</code>.<br> **Responsibilities:** <ul><li>If <code>title</code> prop supplied by controller, uses that as document title.</li><li>Otherwise, falls back to <code>branding.displayName</code>.</li><li>Returns string for injection in <code>&lt;title&gt;</code> tag in base layout.</li></ul> |  |
| MagicLinkIsland | openWallet(): Promise<void> | <br><br>**Refactored Method: openWallet(): Promise<void>**<br><br>Handles wallet open/broadcast for the magic-link payment.<br><br>After refactoring:<br><br>1. Reads hydration object.<br>2. Delegates full parsing/validation of the `u` blob to `MagicLinkBlobParser.parseAndValidate(hydration.u)`.<br>3. On success, uses the returned `unsignedCall` for Connect wallet integration.<br>4. Shows error UI and disables wallet if delegate throws.<br>5. All blob structure and expiry checks are offloaded.<br><br>**Example Implementation:**<br><br>```js<br>async function openWallet() {<br>    let unsignedCall;<br>    try {<br>        unsignedCall = MagicLinkBlobParser.parseAndValidate(hydration.u).unsignedCall;<br>    } catch (err) {<br>        showErrorUI(err.message or 'Malformed or expired payment link.');<br>        disableWalletUI();<br>        walletOpenInProgress = false;<br>        return;<br>    }<br>    // ...proceed with Connect wallet using unsignedCall...<br>}<br>```<br><br> |  |
| MagicLinkIsland | handleDOMContentLoaded(): void | <br><br>**Refactored Method: handleDOMContentLoaded(): void**<br><br>Handles client island initialization on DOM ready.<br><br>After refactoring:<br><br>1. Reads hydration object.<br>2. Delegates all `u` param parsing/validation to `MagicLinkBlobParser.parseAndValidate(hydration.u)`.<br>3. On valid result, proceeds to auto-open wallet or enable UI.<br>4. Handles QR rendering and countdown as before.<br>5. All validation, expiry, and error reporting for the blob are offloaded.<br><br>**Example Implementation:**<br><br>```js<br>function handleDOMContentLoaded() {<br>    try {<br>        MagicLinkBlobParser.parseAndValidate(hydration.u);<br>        // Continue with wallet auto-open, enable button, etc.<br>    } catch (err) {<br>        showErrorUI(err.message or 'This link is invalid or expired.');<br>        disableWalletUI();<br>        return;<br>    }<br>    // ...draw QR code, start countdown, etc.<br>}<br>```<br><br> |  |
| MagicLinkIsland | handleBeforeUnload(): void | Purpose:  Handles browser navigation/unload to clean up magic-link island resources.<br>  Responsibilities:  <ul><li>Aborts any ongoing wallet connect attempts (if possible), countdowns, and event listeners.</li><li>Removes or disables any DOM event listeners relevant to magic-link island.</li><li>Prevents further UI updates, polling, or asynchronous operations after unload/navigation.</li><li>Ensures no memory leaks or duplicate fetches on navigation away.</li></ul> |  |
| MagicLinkIsland | drawQRCode(): void | <br><br>**Refactored Method: drawQRCode(): void**<br><br>Draws a QR code for the magic-link.<br><br>After refactoring:<br><br>1. Selects the canvas element and hydration data.<br>2. Delegates all QR code drawing to `QRCodeRenderer.draw(qrCanvas, hydration.magicLink)`.<br>3. No QR library or canvas logic remains in the method.<br><br>**Example Implementation:**<br><br>```js<br>function drawQRCode() {<br>    const qrCanvas = document.getElementById('qr');<br>    if (!qrCanvas or !hydration or typeof hydration.magicLink !== 'string') return;<br>    QRCodeRenderer.draw(qrCanvas, hydration.magicLink);<br>}<br>```<br><br> |  |
| MagicLinkIsland | handleWalletBroadcastSuccess(res: any): void | Purpose:  Handles successful wallet contract broadcast from @stacks/connect.<br>  Responsibilities:  <ul><li>Extracts <code>txid</code> (<code>res.txid</code> or <code>res.txId</code>) from result.</li><li>Updates UI with confirmation message, displays txid.</li><li>If <code>returnUrl</code> is present in hydration, redirects browser to <code>returnUrl?txid=...</code> (via <code>location.href</code>).</li><li>If no <code>returnUrl</code>, stays on confirmation page.</li></ul> |  |
| MagicLinkIsland | handleWalletBroadcastError(err: any): void | Purpose:  Handles error/rejection from wallet connect/broadcast.<br>  Responsibilities:  <ul><li>Displays appropriate error banner/message in UI (e.g., “Payment failed, please try again.”).</li><li>Re-enables/shows "Open wallet" button for manual retry.</li><li>Prevents duplicate connect calls until user retries.</li><li>Never attempts to invoke wallet with malformed/unauthorized unsignedCall data.</li></ul> |  |
| MagicLinkIsland | handleHydration(hydration: { invoiceId: string; magicLink: string; returnUrl?: string or null; connectConfig?: Record<string, unknown> }): void | <br><br>**Refactored Method: handleHydration(hydration): void**<br><br>Validates and initializes the hydration object.<br><br>After refactoring:<br><br>1. Accesses only prescribed fields from hydration.<br>2. Delegates all `u` blob parsing/validation to `MagicLinkBlobParser.parseAndValidate(hydration.u)`.<br>3. Shows error UI and disables wallet if the delegate throws.<br><br>**Example Implementation:**<br><br>```js<br>function handleHydration(hydration) {<br>    let parsed;<br>    try {<br>        parsed = MagicLinkBlobParser.parseAndValidate(hydration.u);<br>    } catch (err) {<br>        showErrorUI(err.message or 'This link is invalid or expired.');<br>        disableWalletUI();<br>        return;<br>    }<br>    // ...use parsed.expiry, etc.<br>}<br>```<br><br> |  |
| MagicLinkIsland | handleCopyLinkClick(): void | Purpose:  Handles "Copy Link" button click in magic-link UI.<br>  Responsibilities:  <ul><li>Reads <code>magicLink</code> from <code>window.__PAGE__</code>.</li><li>Calls browser Clipboard API (<code>navigator.clipboard.writeText</code>) to copy link.</li><li>On success, displays UI feedback (toast/message).</li><li>No secrets are copied; only hydrated link.</li></ul> |  |
| MagicLinkIsland | handleShowQRClick(): void | <br><br>**Refactored Method: handleShowQRClick(): void**<br><br>Handles the "Show QR" button click.<br><br>After refactoring:<br><br>1. Calls `drawQRCode()`, which in turn uses `QRCodeRenderer.draw`.<br>2. Optionally updates the UI/display as needed.<br><br>**Example Implementation:**<br><br>```js<br>function handleShowQRClick() {<br>    drawQRCode();<br>    const qrCanvas = document.getElementById('qr');<br>    if (qrCanvas) qrCanvas.style.display = '';<br>}<br>```<br><br>--- |  |
| StatusStripIsland | pollStatus(): void | <br><br>**Refactored Method: pollStatus(): void**<br><br>Initiates and manages status polling for invoice/payment status.<br><br>After refactoring:<br><br>1. Polling interval and backoff are managed by `StatusPollingBackoffManager`.<br>2. On each tick, fetches status and delegates DOM updates to `StatusStripDomRenderer`.<br>3. Calls `backoffManager.resetDelay()` on fetch success.<br>4. On error, calls `backoffManager.backoffAndRetry()` and `domRenderer.showError()`.<br><br>**Example Implementation:**<br><br>```js<br>function pollStatus() {<br>    fetch(`/status/${hydration.invoiceId}`, { headers: { Accept: 'application/json' } })<br>        .then(response => {<br>            handleStatusResponse(response);<br>            backoffManager.resetDelay();<br>        })<br>        .catch(err => {<br>            handleStatusError(err);<br>            backoffManager.backoffAndRetry(pollStatus);<br>        });<br>}<br>```<br><br> |  |
| StatusStripIsland | handleVisibilityChange(): void | Bound to the `document.visibilitychange` event. On event trigger, checks `document.hidden`. If true, suspends polling by clearing the polling interval and aborts any ongoing fetch using an `AbortController` (if present). If visibility becomes true (page visible), ensures polling resumes by re-establishing a single interval, taking care not to create duplicate intervals. Handles cleanup of intervals and prevents unnecessary polling/network activity when the page is not active. Responsible for proper lifecycle management of polling on the status-strip island. No data is fetched or manipulated beyond polling control—responsibility is to maintain efficient and correct polling behavior according to page visibility. |  |
| StatusStripIsland | handleBeforeUnload(): void | Bound to the `window.beforeunload` event. When triggered (user navigates away/unloads), aborts any ongoing polling intervals and fetches, removes all event listeners and timers related to polling and status updates, and prevents any further fetches or UI updates post-unload. All teardown logic is local to the status-strip island and ensures no memory leaks or double fetches. No data is exchanged with the backend; the method is responsible for correct cleanup of local resources and DOM state on page exit. |  |
| StatusStripIsland | handleStatusResponse(response: Response): void | <br><br>**Refactored Method: handleStatusResponse(response: Response): void**<br><br>Handles the successful fetch of invoice status.<br><br>After refactoring:<br><br>1. Extracts status from DTO.<br>2. Delegates DOM updates to `domRenderer.updateStatus(status)`.<br>3. Uses `statusMapper.isTerminalStatus(status)` to check for terminal states and stops polling if needed.<br>4. Hides error banners via `domRenderer.hideError()`.<br><br>**Example Implementation:**<br><br>```js<br>function handleStatusResponse(response) {<br>    response.json().then(dto => {<br>        const status = dto.status;<br>        if (status !== domRenderer.getCurrentStatus()) {<br>            domRenderer.updateStatus(status);<br>        }<br>        domRenderer.hideError();<br>        if (statusMapper.isTerminalStatus(status)) {<br>            backoffManager.clearPolling();<br>        }<br>    }).catch(err => {<br>        domRenderer.showError('Error parsing payment status. Retrying…');<br>    });<br>}<br>```<br><br> |  |
| StatusStripIsland | handleStatusError(error: any): void | <br><br>**Refactored Method: handleStatusError(error: any): void**<br><br>Handles polling/network errors.<br><br>After refactoring:<br><br>1. Delegates error display to `domRenderer.showError`.<br>2. Calls `backoffManager.backoffAndRetry()` to schedule retry.<br>3. All banner, DOM, and timing logic is offloaded.<br><br>**Example Implementation:**<br><br>```js<br>function handleStatusError(error) {<br>    domRenderer.showError('Error fetching payment status. Retrying…');<br>    backoffManager.backoffAndRetry(pollStatus);<br>}<br>```<br><br> |  |
| StatusStripIsland | handleHydration(hydration: { invoiceId: string }): void | <br><br>**Refactored Method: handleHydration(hydration: { invoiceId: string }): void**<br><br>Validates hydration and prepares polling.<br><br>After refactoring:<br><br>1. Delegates hydration validation to `domRenderer.validateAndInitHydration(hydration)`.<br>2. Shows error and clears polling if validation fails.<br><br>**Example Implementation:**<br><br>```js<br>function handleHydration(hydration) {<br>    if (!domRenderer.validateAndInitHydration(hydration)) {<br>        domRenderer.showError("Invalid status-strip configuration (missing invoiceId).");<br>        backoffManager.clearPolling();<br>        return;<br>    }<br>    // ...continue polling...<br>}<br>```<br><br>--- |  |
| POSIsland | handleHydration(hydration: { storeId: string; [key: string]: any }): void | Called on initial load when `window.__PAGE__` is available. Reads only prescribed fields (at minimum, `storeId: string`; may include UI defaults like `defaultTtlSeconds`, `defaultAmountSats` as per SSR hydration contract). Validates presence and shape; if missing/malformed, disables POS UI and shows an error. Does not access or expose secrets or extraneous data. Responsible for initial local state setup and enables/disables interactivity based on valid hydration. All further POS actions depend on this initialization. |  |
| POSIsland | handleCopyLinkClick(event: MouseEvent): void | Client-side handler bound to the "Copy Link" button in the POS UI. When invoked, accesses the `magicLink` string from `window.__PAGE__` (never from any other source or secrets), calls `navigator.clipboard.writeText(magicLink)` to copy to clipboard, then provides UI feedback (toast or inline message) to notify the user of success. Does not make server calls or handle secrets; uses only SSR-hydrated data. Ensures correct UX for copying links in POS flows. |  |
| POSIsland | handleShowQRClick(event: MouseEvent): void | Client-side handler for the "Show QR" button in the POS UI. When triggered, reads the `magicLink` value from `window.__PAGE__`, and uses a browser-compatible QR code library (e.g., `qrcode`) to render the QR code of the magic-link to a designated `<canvas>` element. All QR rendering is performed client-side; no server-side QR generation or secrets are involved. Ensures the QR is accurately rendered based on hydrated data for handoff or scanning. |  |
| POSIsland | handleNewSaleClick(event: MouseEvent): void | Client-side handler bound to the "New Sale" button in the POS terminal. When triggered, programmatically resets the POS UI to the "New Sale" state: clears current invoice/payment card elements, reenables and resets the new invoice creation form fields (amount, TTL, etc.) to initial values or SSR-provided defaults. No server-side requests are triggered for this UI reset. All state management is local to the client island; ensures the terminal UI flows can be looped without page reload. |  |
| POSIsland | handleInvoiceRowClick(event: MouseEvent): void | <br><br>**Refactored Method: handleInvoiceRowClick(event: MouseEvent): void**<br><br>Handles invoice row click events to show invoice detail drawer.<br><br>After refactoring:<br><br>1. Determines invoiceId from clicked row.<br>2. Calls `DrawerContentRenderer.renderInvoiceContent(invoiceId, drawerEl, window.__PAGE__, closeDrawer)`.<br>3. No DOM mapping or HTML logic remains in the parent; all rendering/event binding is delegated.<br><br>**Example Implementation:**<br><br>```js<br>function openInvoiceDrawer(invoiceId) {<br>    const drawer = document.getElementById('detail-drawer');<br>    DrawerContentRenderer.renderInvoiceContent(invoiceId, drawer, window.__PAGE__, closeDrawer);<br>}<br><br>function handleInvoiceRowClick(event) {<br>    const invoiceId = event.currentTarget.dataset.invoiceId;<br>    openInvoiceDrawer(invoiceId);<br>}<br>```<br><br> |  |
| POSIsland | handleSubscriptionRowClick(event: MouseEvent): void | <br><br>**Refactored Method: handleSubscriptionRowClick(event: MouseEvent): void**<br><br>Handles subscription row click events to show subscription detail drawer.<br><br>After refactoring:<br><br>1. Determines subscriptionId from clicked row.<br>2. Calls `DrawerContentRenderer.renderSubscriptionContent(subscriptionId, drawerEl, window.__PAGE__, closeDrawer)`.<br>3. All rendering and event binding is delegated.<br><br>**Example Implementation:**<br><br>```js<br>function openSubscriptionDrawer(subscriptionId) {<br>    const drawer = document.getElementById('detail-drawer');<br>    DrawerContentRenderer.renderSubscriptionContent(subscriptionId, drawer, window.__PAGE__, closeDrawer);<br>}<br><br>function handleSubscriptionRowClick(event) {<br>    const subscriptionId = event.currentTarget.dataset.subscriptionId;<br>    openSubscriptionDrawer(subscriptionId);<br>}<br>```<br><br>````<br><br>End of report. |  |
| POSIsland | drawQRCode(): void | Called client-side when the POS payment card is hydrated (invoice created). Reads the `magicLink` from `window.__PAGE__`, and uses a QR code library (such as browser-compatible `qrcode`) to draw the QR code on a designated `<canvas>` element in the DOM. No server-side QR rendering is performed and no secrets are used. Responsible for visual handoff/handoff for payment using the magic-link. |  |
| POSIsland | handleDrawerToggle(event: MouseEvent): void | Client-side handler for open/close UI actions for detail drawers/modals. Listens for click or custom events on drawer toggle elements. Manages drawer/modal visibility state via local/module-level variable(s). On open, renders hydrated DTO details from `window.__PAGE__`. No backend calls or global state changes; only uses SSR-hydrated data for local UI state and content. Ensures isolated, correct interaction for modal/drawer UX. |  |
| POSIsland | updateUIForTerminal(status: string): void | Called by the POS island when polling receives a terminal status (`'paid'¦'expired'¦'canceled'`). Clears the polling interval with `clearInterval(pollingIntervalId)`. Updates the POS UI to reflect the final state: for `'paid'`, displays a Paid ✓ message and enables the New Sale button; for `'expired'` or `'canceled'`, shows an appropriate banner (e.g., Not Paid/Expired) and enables New Sale. All DOM/UI updates are performed using hydrated data and browser APIs. No backend interaction occurs; polling is not resumed until a new invoice is created. Ensures correct state transitions and UX for payment completion/cancellation flows. |  |
| HydrationInjector | inject(hydrationObject: Record<string, any>): string | Called by SSR controllers for any page including client islands. Receives a hydration object matching the documented DTO contract for the surface (e.g., `{ invoiceId, magicLink, returnUrl, connectConfig? }` for magic-link; `{ invoiceId }` for invoice; `{ storeId }` for POS). Serializes the object to JSON, escaping as needed for HTML safety, and injects it into the EJS template via `<script>window.__PAGE_ = ...;</script>`, placing it immediately before any client island scripts. Ensures only required, non-secret properties are included, and never hydrates secrets or privileged fields. Responsible for per-request, per-render hydration; operates statelessly. Guarantees client islands receive only the prescribed data structure, supporting contract-compliant, secure client-side initialization. | HydrationInjector.inject(hydrationObject: Record<string, any>): string<br><br>- **Alignment with Problem Statement:** Yes, this method's description is unequivocally aligned with the requirements for SSR hydration contracts and window.__PAGE__ injection before client islands, with strict exclusion of secrets or privileged fields.<br>- **Step-by-step HOW:**<br>  1. **Input**: Accept a `hydrationObject` provided by the SSR controller. This object must already be limited to only the contract-allowed keys (e.g., `{ invoiceId, magicLink, returnUrl, connectConfig? }` for the magic-link page).<br>  2. **Validation**: Ensure that the object contains only the allowed keys per the DTO contract for the route. This can be enforced at the controller/type level; the injector does not add or remove keys.<br>  3. **Serialization**: Convert the `hydrationObject` to a JSON string using `JSON.stringify()`. (No pretty-printing; compact output.)<br>  4. **Escaping**: Escape closing `</script>` tags and any characters that would break out of the script context or introduce XSS. For most JSON payloads, direct use is safe, but extra care is required if any fields could contain untrusted markup; minimally, replace `</script>` with `<\/script>` in the output string.<br>  5. **Script Block Construction**: Build a string of the form `<script>window.__PAGE__ = ...;</script>`, with the serialized JSON as the right-hand side.<br>      - Example output: `<script>window.__PAGE__ = {"invoiceId":"inv_8x3...","magicLink":"https://...","returnUrl":null};</script>`<br>  6. **Template Injection**: Ensure that in the EJS SSR template, this script block is emitted immediately before any `<script src="/static/js/...">` tags for client JS islands. The method itself returns the script string; the controller or template is responsible for placement.<br>  7. **No Side Effects**: The method does not persist state, mutate input, or interact with any global data—it is a pure renderer.<br>  8. **No Secrets**: Never include secret values (API keys, HMAC, admin credentials) or privileged properties in the hydration object. All data must be contract-compliant and safe for client-side exposure.<br>  9. **Return Value**: Return the constructed script string to the SSR controller or template logic.<br>- **Edge Cases / Gotchas**:<br>    - If passed an empty object, injects `window.__PAGE__ = {};`.<br>    - Escaping: Must not break the script context; do not allow `</script>` in output.<br>    - Hydration object keys must exactly match the documented DTOs; do not hydrate extra fields for "future-proofing".<br>    - Never hydrate when the view has no client islands.<br>- **Performance**: O(n) in the number of keys; negligible cost per request.<br>- **Pseudocode**:<br>    ```js<br>    function inject(hydrationObject) {<br>      // Accept only allowed fields (must be enforced by controller/types)<br>      const json = JSON.stringify(hydrationObject)<br>        .replace(/<\/script>/gi, '<\\/script>');<br>      return `<script>window.__PAGE__ = ${json};</script>`;<br>    }<br>    ```<br>- **WHY**: This ensures that only the documented, non-secret hydration data is available to client islands, supporting safe SSR-first rendering and strict separation of server/client logic.<br><br>--- |
| AdminKeysIsland | handleCopySecretClick(event: MouseEvent): void | Client-side handler bound to the Copy button next to a secret in the SSR EJS template for the admin keys one-time reveal view. When triggered, reads the secret value directly from the SSR-injected DOM (never from `window.__PAGE__` unless on initial POST reveal), and calls `navigator.clipboard.writeText(secretValue)` to copy to clipboard. Copy button is enabled/visible only during initial secret reveal; if view is reloaded and secrets are masked, button is disabled/hidden. No backend or SSR interaction occurs; state is purely client-local. Responsible for secure, one-time clipboard copy with strict UI enable/disable logic. Ensures no secrets are leaked via hydration or JS beyond initial reveal. | AdminKeysIsland.handleCopySecretClick(event: MouseEvent): void<br><br>- **Alignment with Problem Statement:** Yes, this method aligns with the requirement for secure, one-time clipboard copy of secrets in admin keys view, with strict UI enable/disable logic.<br>- **Step-by-step HOW:**<br>  1. **Input**: Receives a `MouseEvent` triggered by clicking the "Copy" button (`copy-secret`) in the SSR-injected admin keys one-time reveal view.<br>  2. **DOM Query**: From the event or by id/class, locate the DOM node containing the secret value. This is typically within the SSR markup, rendered only on the initial POST reveal.<br>  3. **Secret Extraction**: Read the visible text content or input value of the secret field (never from `window.__PAGE__` unless explicitly hydrated on initial POST). If the secret is masked or hidden (e.g., after reload), the value will not be present.<br>  4. **Clipboard Operation**: Use the Clipboard API — call `navigator.clipboard.writeText(secretValue)` to copy the value to the user's clipboard.<br>  5. **Feedback (Optional)**: Optionally, provide UI feedback (e.g., tooltip, banner) indicating copy success.<br>  6. **Enable/Disable Logic**: Ensure that the Copy button is only enabled and visible on the initial one-time reveal. If secrets are masked (e.g., SSR renders "****" or blanks and no value node is present), the button must be disabled or hidden:<br>      - The island may check for the presence of the secret node/value and, if absent, immediately disable or hide the button.<br>      - No clipboard or DOM operation occurs if secret is masked or missing.<br>  7. **No Backend/SSR Interaction**: The operation is purely client-local; there are no fetches or SSR round-trips.<br>  8. **No Hydration Exposure**: Secrets must not be passed via `window.__PAGE__` except on initial POST reveal (if ever); never persist or rehydrate secrets.<br>- **Edge Cases / Gotchas**:<br>      - Clipboard errors: If `navigator.clipboard.writeText` fails (e.g., permissions), handle gracefully (e.g., show error, do not throw).<br>      - Button state: After initial POST, further reloads must not allow copy; SSR must mask secrets and not render copyable nodes/buttons, but the island double-checks.<br>      - DOM structure: If DOM structure changes, selector logic must be robust.<br>- **Performance**: Negligible (single DOM read and clipboard write).<br>- **Pseudocode**:<br>    ```js<br>    handleCopySecretClick(event) {<br>      const btn = event.currentTarget;<br>      const secretNode = document.getElementById('api-secret'); // or similar per SSR<br>      if (!secretNode or !secretNode.textContent) {<br>        btn.disabled = true; // or hide<br>        return;<br>      }<br>      const secretValue = secretNode.textContent;<br>      navigator.clipboard.writeText(secretValue).then(<br>        () => {/* Optionally show success */},<br>        () => {/* Optionally show failure */}<br>      );<br>    }<br>    ```<br>- **WHY**: The strict enable/disable logic ensures secrets are never exposed after the one-time reveal, preventing leaks and accidental exposure after reloads.<br><br>--- |
| BrandingSettingsIsland | handleBrandColorInputChange(event: Event): void | Client-side handler bound to the `brandColor` input field's `onchange` and `onblur` events in the branding/profile settings SSR view. When triggered, retrieves the new input value, sanitizes via regex (`#[0-9A-Fa-f]{6}`); if valid, updates CSS variable `--brand` in the live preview node via DOM APIs (`previewNode.style.setProperty('--brand', value)`). If invalid or empty, resets preview color to fallback (`#111827`). All logic is client-local; never interacts with backend or SSR after page load. Responsible for real-time, secure preview feedback of branding changes. Ensures only valid color values affect preview. | BrandingSettingsIsland.handleBrandColorInputChange(event: Event): void<br><br>- **Alignment with Problem Statement:** Yes, this method is unequivocally aligned with the requirement to give real-time, client-only feedback for brand color choice, with strict validation/sanitization.<br>- **Step-by-step HOW:**<br>  1. **Input**: Receives an `Event` from an `onchange` or `onblur` on the brand color input (`brandColor`) in the SSR branding/profile settings view.<br>  2. **Input Value Extraction**: Access the new input value via `event.target.value` or by querying the input node by ID (`brandColor`).<br>  3. **Sanitization**: Validate the value using the regex `#[0-9A-Fa-f]{6}` — the value must:<br>      - Start with `#`<br>      - Be followed by exactly 6 hexadecimal digits (0-9, a-f, A-F)<br>      - No trailing or leading spaces.<br>      - Example: `#FF7A00` is valid; `FF7A00` is not.<br>  4. **Valid Branch**:<br>      - If the value passes validation, locate the live preview DOM node (e.g., by id/class, as provided by SSR template).<br>      - Apply the new color by setting the CSS variable `--brand` on the preview node via `element.style.setProperty('--brand', value)`.<br>  5. **Invalid/Empty Branch**:<br>      - If the value is empty or does not match the regex, reset the preview node's `--brand` to fallback neutral color `#111827`.<br>      - This ensures invalid values never propagate to the preview.<br>  6. **No Backend/SSR Interaction**: All work is performed in the browser; no server call or SSR update.<br>  7. **No State Persistence**: Only the live preview is affected; does not store or mutate any app state.<br>  8. **UI Feedback**: Optionally, the input field may be styled to indicate invalid values, but this is outside the function's direct responsibility.<br>- **Edge Cases / Gotchas**:<br>      - User may paste long, short, or malformed values; regex must be strict.<br>      - If preview node is not found, fail silently or log an error.<br>      - If input is valid but not a color (e.g., `#GGGGGG`), regex will reject.<br>- **Performance**: Instantaneous; no async/IO.<br>- **Pseudocode**:<br>    ```js<br>    handleBrandColorInputChange(event) {<br>      const value = event.target.value.trim();<br>      const previewNode = document.getElementById('brand-preview');<br>      const valid = /^#[0-9A-Fa-f]{6}$/.test(value);<br>      if (previewNode) {<br>        if (valid) {<br>          previewNode.style.setProperty('--brand', value);<br>        } else {<br>          previewNode.style.setProperty('--brand', '#111827');<br>        }<br>      }<br>    }<br>    ```<br>- **WHY**: This ensures live branding feedback matches only valid, safe color values, preventing style injection and supporting the required instant preview for branding configuration.<br><br>---<br>End of report.<br>``` |

# File Definitions:
| File Name | Components That Must Be Implemented Within The File | Static Definitions That Must Be Implemented Within The File |
| --------- | --------------------------------------------------- | ----------------------------------------------------------- |
| /src/shared/models/dto.ts | DTOsAndTypeContracts | Branding, InvoiceDTO, MagicLinkViewProps, InvoiceViewProps, MerchantShellProps, MagicLinkPayload, SubscriptionDTO, SessionData, HydrationMagicLink, HydrationInvoice, HydrationPOS |
| /src/shared/contracts/interfaces.ts |  | IBrandingService, IErrorMiddleware, ISSRViewRenderer, IBridgeClient, IHydrationInjector, IMerchantRouteHandlers, IAdminRouteHandlers, IPublicRouteHandlers, IExpressApp, IInvoiceService, ISubscriptionService, IStoreService, IMagicLinkService, IAuthService, NoCacheHeaderSetter, BrandColorSanitizer, BrandingSSRInjector |
| /src/shared/utils/QRCodeUtility.ts | QRCodeUtility |  |
| /src/server/middleware/StaticAssetMiddleware.ts | StaticAssetMiddleware |  |
| /src/server/middleware/CSRFandSecurityMiddleware.ts | CSRFandSecurityMiddleware |  |
| /src/server/ShutdownCoordinator.ts | ShutdownCoordinator |  |
| /src/server/services/MagicLinkService.ts | MagicLinkService |  |
| /src/server/services/BridgeClient.ts | BridgeClient |  |
| /src/server/services/InvoiceService.ts | InvoiceService |  |
| /src/server/services/SubscriptionService.ts | SubscriptionService |  |
| /src/server/services/StoreService.ts | StoreService |  |
| /src/server/services/BrandingService.ts | BrandingService |  |
| /src/server/services/AuthService.ts | AuthService |  |
| /src/server/utils/HydrationInjector.ts | HydrationInjector |  |
| /src/server/views/SSRViewRenderer.ts | SSRViewRenderer |  |
| /src/client/islands/MagicLinkIsland.ts | MagicLinkIsland |  |
| /src/client/islands/helpers/MagicLinkBlobParser.ts | MagicLinkBlobParser |  |
| /src/client/islands/helpers/QRCodeRenderer.ts | QRCodeRenderer |  |
| /src/client/islands/StatusStripIsland.ts | StatusStripIsland |  |
| /src/client/islands/helpers/StatusStripDomRenderer.ts | StatusStripDomRenderer |  |
| /src/client/islands/helpers/StatusPollingBackoffManager.ts | StatusPollingBackoffManager |  |
| /src/client/islands/helpers/StatusStripStatusMapper.ts | StatusStripStatusMapper |  |
| /src/client/islands/POSIsland.ts | POSIsland |  |
| /src/client/islands/helpers/DrawerContentRenderer.ts | DrawerContentRenderer |  |
| /src/client/islands/helpers/POSElementBinder.ts | POSElementBinder |  |
| /src/client/islands/AdminKeysIsland.ts | AdminKeysIsland |  |
| /src/client/islands/BrandingSettingsIsland.ts | BrandingSettingsIsland |  |
| /src/server/middleware/ErrorMiddleware.ts | ErrorMiddleware |  |
| /src/server/controllers/MerchantRouteHandlers.ts | MerchantRouteHandlers |  |
| /src/server/controllers/merchant/InputValidationDelegate.ts | InputValidationDelegate |  |
| /src/server/controllers/merchant/ApiKeyRevealStateManager.ts | ApiKeyRevealStateManager |  |
| /src/server/controllers/merchant/HydrationObjectBuilder.ts | HydrationObjectBuilder |  |
| /src/server/controllers/merchant/BrandingContextFetcher.ts | BrandingContextFetcher |  |
| /src/server/controllers/PublicRouteHandlers.ts | PublicRouteHandlers |  |
| /src/server/services/MagicLinkValidationService.ts | MagicLinkValidationService |  |
| /src/server/utils/BrandColorSanitizer.ts | BrandColorSanitizer |  |
| /src/server/utils/NoCacheHeaderSetter.ts | NoCacheHeaderSetter |  |
| /src/server/utils/BrandingSSRInjector.ts | BrandingSSRInjector |  |
| /src/server/controllers/AdminRouteHandlers.ts | AdminRouteHandlers |  |
| /src/server/controllers/admin/StoreCreationValidator.ts | StoreCreationValidator |  |
| /src/server/controllers/admin/SecretFieldOmitter.ts | SecretFieldOmitter |  |
| /src/server/controllers/admin/AdminContextScopeEnforcer.ts | AdminContextScopeEnforcer |  |
| /src/server/controllers/admin/BrandingCssVariableInjector.ts | BrandingCssVariableInjector |  |
| /src/server/ExpressApp.ts | ExpressApp |  |
| /src/server/middleware/ExpressCSPHashManager.ts | ExpressCSPHashManager |  |
| /src/server/utils/BrandingSSRInjector.ts | BrandingSSRInjector |  |
| /src/server/ApplicationBootstrapper.ts | ApplicationBootstrapper |  |

# Static Report:
##### **Core Data Structures & Domain Models
// Branding object (used in SSR templates and theming)
export type Branding = {
  displayName: string;
  logoUrl?: string | null;
  brandColor?: string | null;
  supportEmail?: string | null;
  supportUrl?: string | null;
  // Optionally, admin/merchant may inject .active and .deactivationReason for SSR context
  active?: boolean;
  deactivationReason?: string | null;
};

// Invoice Data Transfer Object (DTO)
export type InvoiceDTO = {
  invoiceId: string;
  storeId: string;
  status: 'unpaid' | 'paid' | 'partially_refunded' | 'refunded' | 'canceled' | 'expired';
  amountSats: number;
  usdAtCreate?: string;
  quoteExpiresAt?: string; // ISO 8601
  merchantPrincipal?: string;
  payer?: string | null;
  txId?: string | null;
  memo?: string | null;
  subscriptionId?: string | null;
  createdAt?: string;
  refundAmount?: number | null;
  refundTxId?: string | null;
  store?: Pick<Branding, 'displayName' | 'logoUrl' | 'brandColor'>;
};

// Magic-link view props for SSR
export type MagicLinkViewProps = {
  branding: Branding;
  invoice: Pick<InvoiceDTO, 'invoiceId' | 'amountSats' | 'usdAtCreate' | 'quoteExpiresAt' | 'memo'>;
  magicLink: string;
  returnUrl?: string | null;
  hydration: { invoiceId: string; magicLink: string; returnUrl?: string | null; connectConfig?: Record<string, unknown> };
  deactivationReason?: string | null;
};

// Invoice SSR view props
export type InvoiceViewProps = {
  branding: Branding;
  invoice: InvoiceDTO;
  hydration: { invoiceId: string };
};

// Merchant shell props (SSR context)
export type MerchantShellProps = {
  branding: Branding;
  nav: string;
  user: { name?: string; email?: string };
};

// Magic-link payload decoded from `u` blob
export type MagicLinkPayload = {
  v: 1;
  storeId: string;
  invoiceId: string;
  unsignedCall: {
    contractId: string;
    function: "pay-invoice";
    args: string[];
    postConditions: Array<{
      type: "ft-postcondition";
      address: string;
      asset: string;
      condition: "eq";
      amount: string;
    }>;
    postConditionMode: "deny";
    network: "mainnet" | "testnet";
  };
  exp: number; // epoch seconds
  sig: string; // base64url HMAC-SHA256
};

// Subscription DTO
export type SubscriptionDTO = {
  subscriptionId: string;
  storeId: string;
  status: "active" | "cancelled";
  amountSats: number;
  intervalBlocks: number;
  subscriberPrincipal: string;
  nextDue: string; // ISO 8601
  lastBilled?: string;
  mode: "invoice";
};

// Session data for express-session
export type SessionData = {
  userId?: string;
  storeId?: string;
  adminUser?: { id: string; name?: string; email?: string };
  apiKeyReveal?: { apiKey: string; hmacSecret: string; revealed: boolean };
};

// Hydration objects (SSR → client islands)
export type HydrationMagicLink = {
  invoiceId: string;
  magicLink: string;
  returnUrl?: string | null;
  connectConfig?: Record<string, unknown>;
};

export type HydrationInvoice = {
  invoiceId: string;
};

export type HydrationPOS = {
  storeId: string;
  // Optionally add: defaultTtlSeconds?: number; defaultAmountSats?: number;
};


##### **State Store Interface
// No global or distributed state; all persistent state is in Bridge. Session state is scoped per user/session for merchant/admin.

interface SessionStore {
  getSession(req: Express.Request): SessionData | null;
  setSession(req: Express.Request, data: SessionData): void;
  destroySession(req: Express.Request): void;
}

// Hydration objects exist per SSR response, injected in HTML only.


##### **Persistence & Data Access Interfaces
// All persistent business data is stored in Bridge (external system), not in WEBPAY.
// No database schema or ORM in WEBPAY. All persistence is via HTTP API to Bridge.

interface BridgeAPI {
  prepareInvoice(storeId: string, data: object): Promise<BridgePrepareInvoiceResponse>;
  fetchInvoice(invoiceId: string): Promise<BridgeInvoiceResponse>;
  getPublicProfile(storeId: string): Promise<BridgePublicProfileResponse>;
  getProfile(storeId: string): Promise<BridgeProfileResponse>;
  // ...other methods per BridgeClient in ::CommunicationInterfaces
}


##### **Service & Component Communication Interfaces
// --- Bridge API Contracts (HTTP, JSON) ---

// POST /api/v1/stores/:storeId/prepare-invoice
POST /api/v1/stores/:storeId/prepare-invoice
Request: {
  amount_sats: number;
  ttl_seconds: number;
  memo: string;
  orderId?: string;
  payerPrincipal?: string;
  return?: string;
}
Response: {
  invoice: InvoiceDTO;
  magicLink: string;
  unsignedCall: object;
}

// GET /i/:invoiceId
GET /i/:invoiceId
Response: InvoiceDTO

// GET /api/v1/stores/:storeId/public-profile
GET /api/v1/stores/:storeId/public-profile
Response: Branding

// PATCH /api/admin/stores/:storeId/activate
PATCH /api/admin/stores/:storeId/activate
Request: { active: boolean }
Response: { active: boolean }

// ...Other Bridge endpoints per the Architectural Plan...

// --- Internal Service/Component Interfaces ---

interface IBrandingService {
  fetchBranding(storeId: string): Promise<Branding>;
  sanitizeBrandColor(brandColor: string | null | undefined): string;
  injectFallbackBranding(): Branding;
}

interface IErrorMiddleware {
  handleError(err: Error, req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
}

interface ISSRViewRenderer {
  renderFormWithCSRFToken(req: Express.Request): string;
  injectStaticAssetLinks(islands?: string[]): string;
  renderPartialWithContext(partial: string, context: Record<string, any>): string;
  setTitleFromBrandingOrOverride(title: string | undefined, branding: Branding): string;
}

interface IBridgeClient {
  prepareInvoice(storeId: string, data: object): Promise<any>;
  fetchInvoice(invoiceId: string): Promise<any>;
  getPublicProfile(storeId: string): Promise<any>;
  getProfile(storeId: string): Promise<any>;
  cancelInvoiceCreateTx(storeId: string, invoiceId: string, apiKey: string): Promise<any>;
  cancelInvoiceDTO(storeId: string, invoiceId: string, apiKey: string): Promise<any>;
  createRefundTx(storeId: string, invoiceId: string, amount: number, memo: string, apiKey: string): Promise<any>;
  archiveInvoice(storeId: string, invoiceId: string, apiKey: string): Promise<any>;
  createSubscriptionInvoice(storeId: string, subscriptionId: string, ttl_seconds: number, memo: string, apiKey: string): Promise<any>;
  createSubscription(storeId: string, dto: object, apiKey: string): Promise<any>;
  patchStoreActivate(storeId: string, active: boolean): Promise<{ active: boolean }>;
  fetchStoreProfile(storeId: string): Promise<any>;
  fetchPublicProfile(storeId: string): Promise<any>;
  normalizeBridgeResponse(res: any): any;
  mapBridgeError(error: any): { message: string; code?: string | number };
  // ...other methods as defined per Architectural Plan...
}

interface IHydrationInjector {
  inject(hydrationObject: Record<string, any>): string;
}

interface IMerchantRouteHandlers {
  handleMerchantGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleMerchantPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleCancelInvoice(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleRefundInvoice(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleArchiveInvoice(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleGenerateInvoiceNow(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleSendEmail(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleCreateSubscription(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleCancelSubscription(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleManageSubscriptionGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handlePrepareInvoicePost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleSaveBrandingProfile(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleRotateApiKeys(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleFilterSubmit(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  setNoCacheHeaders(req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
  refetchAfterAction(action: string, req: Express.Request, res: Express.Response): Promise<void>;
  handleApiKeysMaskOnReload(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  refetchPublicProfileAfterSave(storeId: string, req: Express.Request, res: Express.Response): Promise<void>;
}

interface IAdminRouteHandlers {
  handleLoginPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleStoresPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleRotateKeysPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleTokenConfigPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleBootstrapPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleSyncOnchainPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handlePollerRestartPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleWebhooksRetryPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleAdminGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleStoreActivatePatch(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleSettingsPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  omitSecretsFromViewPropsAndHydration(props: object): object;
  enforceAdminContextDataScopes(req: Express.Request, res: Express.Response): void;
  handleWebhooksGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
}

interface IPublicRouteHandlers {
  handleCheckoutPost(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleMagicLinkGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleStatusGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleInvoiceGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  handleLandingGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void>;
  setNoCacheHeaders(res: Express.Response): void;
}

interface IExpressApp {
  csrfExemptionMiddleware(): void;
  helmetCSPMiddleware(): void;
}

interface IInvoiceService {
  createInvoice(storeId: string, amount: number, ttl: number, memo: string): Promise<InvoiceDTO>;
  fetchInvoice(invoiceId: string): Promise<InvoiceDTO>;
  fetchFilteredInvoices(storeId: string, filterParams: object): Promise<InvoiceDTO[]>;
}

interface ISubscriptionService {
  createSubscription(storeId: string, dto: object, apiKey: string): Promise<SubscriptionDTO>;
  cancelSubscription(storeId: string, subscriptionId: string): Promise<SubscriptionDTO>;
  fetchSubscriptions(storeId: string): Promise<SubscriptionDTO[]>;
  fetchSubscriptionDetail(storeId: string, subscriptionId: string): Promise<SubscriptionDTO>;
  fetchFilteredSubscriptions(storeId: string, filterParams: object): Promise<SubscriptionDTO[]>;
}

interface IStoreService {
  rotateApiKeys(storeId: string): Promise<{ apiKey: string; hmacSecret: string }>;
}

interface IMagicLinkService {
  validateAndParse(u_blob: string, context: { storeId: string; invoiceId: string }): Promise<{ payload: MagicLinkPayload; invoice: InvoiceDTO }>;
}

interface IAuthService {
  requireSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
  requireAdminSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
}

// -- Additional static utility interface (from delegate helpers) --
interface NoCacheHeaderSetter {
  set(res: Express.Response): void;
}
interface BrandColorSanitizer {
  sanitize(brandColor: string | undefined): string;
}
interface BrandingSSRInjector {
  injectBranding(res: Express.Response, storeId?: string): Promise<void>;
}


##### **Configuration Management & Dependency Injection Contracts
// .env file example (at deployment root):
BRIDGE_API_URL=https://bridge.example.com
BRIDGE_API_KEY=***REDACTED***
SESSION_SECRET=***REDACTED***
NODE_ENV=production
DEPLOYMENT_NETWORK=mainnet
WEBPAY_BASE_URL=https://example.webpay.com

// config.ts (Node/config module):
export const Config = {
  bridgeApiUrl: process.env.BRIDGE_API_URL,
  bridgeApiKey: process.env.BRIDGE_API_KEY,
  sessionSecret: process.env.SESSION_SECRET,
  deploymentNetwork: process.env.DEPLOYMENT_NETWORK,
  webpayBaseUrl: process.env.WEBPAY_BASE_URL,
};

// Dependency injection setup at app bootstrap:
import { BrandingService } from './services/BrandingService';
import { BridgeClient } from './services/adapters/BridgeClient';
import { HydrationInjector } from './shared/utils/HydrationInjector';
import { MerchantRouteHandlers } from './server/controllers/merchant';
import { PublicRouteHandlers } from './server/controllers/public';
import { AdminRouteHandlers } from './server/controllers/admin';
// ...other imports as per Architectural Plan

const brandingService = new BrandingService(/* ... */);
const bridgeClient = new BridgeClient(/* ... */);
const hydrationInjector = new HydrationInjector(/* ... */);
// ...Instantiate other service singletons
// Inject dependencies as required by the plan before passing to ExpressApp or route handlers.


##### **Mandatory Dependency Injection Contracts
interface IBrandingService {
  fetchBranding(storeId: string): Promise<Branding>;
  sanitizeBrandColor(brandColor: string | null | undefined): string;
  injectFallbackBranding(): Branding;
}
// Imported by: ErrorMiddleware, MerchantRouteHandlers, AdminRouteHandlers, PublicRouteHandlers, ExpressApp, SSRViewRenderer

interface IErrorMiddleware {
  handleError(err: Error, req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
}
// Imported by: ExpressApp, MerchantRouteHandlers, AdminRouteHandlers, PublicRouteHandlers

interface ISSRViewRenderer {
  renderFormWithCSRFToken(req: Express.Request): string;
  injectStaticAssetLinks(islands?: string[]): string;
  renderPartialWithContext(partial: string, context: Record<string, any>): string;
  setTitleFromBrandingOrOverride(title: string | undefined, branding: Branding): string;
}
// Imported by: ErrorMiddleware, AdminRouteHandlers, MerchantRouteHandlers, PublicRouteHandlers

interface IBridgeClient {
  prepareInvoice(storeId: string, data: object): Promise<any>;
  fetchInvoice(invoiceId: string): Promise<any>;
  getPublicProfile(storeId: string): Promise<any>;
  getProfile(storeId: string): Promise<any>;
  cancelInvoiceCreateTx(storeId: string, invoiceId: string, apiKey: string): Promise<any>;
  cancelInvoiceDTO(storeId: string, invoiceId: string, apiKey: string): Promise<any>;
  createRefundTx(storeId: string, invoiceId: string, amount: number, memo: string, apiKey: string): Promise<any>;
  archiveInvoice(storeId: string, invoiceId: string, apiKey: string): Promise<any>;
  createSubscriptionInvoice(storeId: string, subscriptionId: string, ttl_seconds: number, memo: string, apiKey: string): Promise<any>;
  createSubscription(storeId: string, dto: object, apiKey: string): Promise<any>;
  patchStoreActivate(storeId: string, active: boolean): Promise<{ active: boolean }>;
  fetchStoreProfile(storeId: string): Promise<any>;
  fetchPublicProfile(storeId: string): Promise<any>;
  normalizeBridgeResponse(res: any): any;
  mapBridgeError(error: any): { message: string; code?: string | number };
}
// Imported by: BrandingService, InvoiceService, StoreService, SubscriptionService, MagicLinkService, AdminRouteHandlers, MerchantRouteHandlers, PublicRouteHandlers

interface IHydrationInjector {
  inject(hydrationObject: Record<string, any>): string;
}
// Imported by: SSRViewRenderer, MerchantRouteHandlers, AdminRouteHandlers, PublicRouteHandlers

interface IMerchantRouteHandlers { /* see above ::CommunicationInterfaces */ }
// Imported by: ExpressApp

interface IAdminRouteHandlers { /* see above ::CommunicationInterfaces */ }
// Imported by: ExpressApp

interface IPublicRouteHandlers { /* see above ::CommunicationInterfaces */ }
// Imported by: ExpressApp

interface IExpressApp {
  csrfExemptionMiddleware(): void;
  helmetCSPMiddleware(): void;
}
// Imported by: None

interface IInvoiceService { /* see above ::CommunicationInterfaces */ }
// Imported by: MerchantRouteHandlers

interface ISubscriptionService { /* see above ::CommunicationInterfaces */ }
// Imported by: MerchantRouteHandlers

interface IStoreService { /* see above ::CommunicationInterfaces */ }
// Imported by: MerchantRouteHandlers

interface IMagicLinkService { /* see above ::CommunicationInterfaces */ }
// Imported by: PublicRouteHandlers

interface IAuthService {
  requireSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
  requireAdminSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
}
// Imported by: MerchantRouteHandlers, AdminRouteHandlers, ExpressApp


##### **Validation & Constraint Definitions
// Branding color
brandColor: string; // must match /^#[0-9A-Fa-f]{6}$/

// Magic-link payload
interface MagicLinkPayload {
  v: 1;
  storeId: string; // must match route param
  invoiceId: string; // must match route param
  unsignedCall: {
    contractId: string;
    function: "pay-invoice";
    postConditionMode: "deny";
    postConditions: Array<{
      type: "ft-postcondition";
      address: string;
      asset: string; // must match sBTC asset
      condition: "eq";
      amount: string; // must equal invoice.amountSats
    }>;
    args: string[];
    network: "mainnet" | "testnet"; // must match deployment config
  };
  exp: number; // now <= exp <= now+1800; exp - now >= 120
  sig: string; // must match HMAC as described
}

// Invoice creation
{
  amount_sats: number; // > 0
  ttl_seconds: number; // >= 120 && <= 1800
  memo: string;
  orderId?: string;
  payerPrincipal?: string;
  return?: string;
}

// Branding input
{
  displayName: string; // required
  brandColor: string; // must match /^#[0-9A-Fa-f]{6}$/
  allowedOrigins?: string[];
  webhookUrl?: string;
}

// CSRF: All POST/PUT/PATCH to /merchant/* and /admin/* must include a valid CSRF token (from req.csrfToken()).


##### **Lifecycle Contracts
// Object persistence rules:

// - Branding, Invoice, Subscription, Store, API keys, etc.: persistent only in Bridge (external system; not in WEBPAY).
// - Session state (user, store, API key reveal): transient, per-session, via express-session.
// - Hydration objects (SSR -> client): ephemeral, per-request, never persisted.
// - Any secrets (API keys, HMAC secrets): only ever exposed one-time in SSR after rotation; never persisted or hydrated to client JS.
// - All SSR props and page state are per-request, not persisted.
// - Static asset files (CSS, JS): served from /public via express.static; not mutable at runtime.


##### **Event & Messaging Interfaces
// No internal event bus or custom publish-subscribe system is present.
// All asynchronous updates are handled via:
// - HTTP polling (e.g. client islands poll /status/:invoiceId)
// - Express route handler bindings for HTTP requests (per Architectural Plan).
// - No message bus or custom event schema.


##### **SerializationFormats
// All network and storage serialization between WEBPAY and Bridge uses JSON.

// Example: Magic-link payload serialization (u blob)
{
  "v": 1,
  "storeId": "store_abc",
  "invoiceId": "inv_8x3...",
  "unsignedCall": {
    "contractId": "SP...webpay",
    "function": "pay-invoice",
    "args": ["0x...invoiceId", "u25000"],
    "postConditions": [
      {
        "type": "ft-postcondition",
        "address": "<TX_SENDER or payerPrincipal>",
        "asset": "SP...sbtc-token::sbtc",
        "condition": "eq",
        "amount": "25000"
      }
    ],
    "postConditionMode": "deny",
    "network": "mainnet"
  },
  "exp": 1737324800,
  "sig": "<base64url HMAC-SHA256>"
}
// The above is base64url-encoded for transport in the `u` query parameter.

// All API request/response bodies: JSON only (see ::CommunicationInterfaces).

// Hydration objects (SSR → client) are injected as JSON in <script>window.__PAGE__=...</script> as per hydration contract.


##### **Error Handling & Fault Tolerance
interface ErrorMiddleware {
  handleError(err: Error, req: Express.Request, res: Express.Response, next: Express.NextFunction): void;
}

// Error handling behaviors:
// - Validation errors (400): mapped to user-friendly messages, SSR error.ejs rendered with branding.
// - Authentication/session errors (401/403): session is destroyed, SSR error.ejs rendered.
// - Bridge API errors: mapped to friendly messages via mapBridgeError.
// - SSR error views always receive sanitized branding, fallback if needed.
// - No stack traces, secrets, internal error details are rendered to the client.
// - On validation or Bridge/network error in route handler, error is passed to next() for centralized error handling.
// - Retry logic is not required for any internal operation; client-side polling islands manage their own retry/backoff.


##### **Concurrency & Synchronization Handling
// Not applicable: No concurrency required per requirements.


##### **Multi-User Environments & Authentication
interface AccessControl {
  requireSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void; // Merchant
  requireAdminSession(req: Express.Request, res: Express.Response, next: Express.NextFunction): void; // Admin
}

// - Merchant routes: require authenticated session (express-session)
// - Admin routes: require admin session (express-session)
// - Public routes: no authentication/session required
// - Session state is per-user (merchant/admin), isolated per session

End of report.
```
