{"version":3,"file":"ExpirationMonitor.js","sourceRoot":"","sources":["../../src/services/ExpirationMonitor.ts"],"names":[],"mappings":"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","sourcesContent":["// src/services/ExpirationMonitor.ts\nimport type { ISqliteStore } from '../contracts/dao';\nimport type { IStacksChainClient, IWebhookDispatcher } from '../contracts/interfaces';\nimport type { InvoiceRow } from '../contracts/domain';\nimport { Validation } from '../validation/rules';\n\ntype ChainInvoice = { status?: string };\n\nexport class ExpirationMonitor {\n  private async getInvoiceStatus(\n    chain: IStacksChainClient,\n    idHex: string,\n  ): Promise<string> {\n    const maybe = chain as unknown as {\n      readInvoiceStatus?: (id: string) => Promise<string>;\n      readInvoice?: (id: string) => Promise<unknown>;\n    };\n    try {\n      if (typeof maybe.readInvoiceStatus === 'function') {\n        return await maybe.readInvoiceStatus(idHex);\n      }\n      if (typeof maybe.readInvoice === 'function') {\n        const inv = await maybe.readInvoice(idHex);\n        const s = (inv as ChainInvoice)?.status;\n        return s ? String(s) : 'unknown';\n      }\n    } catch {}\n    return 'unknown';\n  }\n\n  async emitInvoiceExpiredWebhook(\n    invoiceId: string,\n    storeId: string,\n    deps: { store: ISqliteStore; dispatcher: IWebhookDispatcher; nowEpochSecs?: number },\n  ): Promise<boolean> {\n    if (!invoiceId || !storeId) throw new Error('invalid_args');\n\n    const already = deps.store.existsSuccessfulDeliveryFor({\n      storeId: String(storeId),\n      invoiceId: String(invoiceId),\n      eventType: 'invoice-expired',\n    });\n    if (already) return false;\n\n    const rawBody = JSON.stringify({ invoiceId, status: 'expired' as const });\n    await deps.dispatcher.dispatch({\n      storeId, invoiceId, eventType: 'invoice-expired', rawBody,\n    });\n    return true;\n  }\n\n// src/services/ExpirationMonitor.ts\nasync sweepOnchainStatuses(\n  candidateIdHexes: string[],\n  deps: { store: ISqliteStore; chain: IStacksChainClient; dispatcher: IWebhookDispatcher },\n): Promise<{ expiredIds: string[]; updated: number }> {\n  // 0) Load all invoices once; we'll filter twice (on-chain + time-based).\n  const allRows = deps.store.selectAdminInvoices() as InvoiceRow[];\n\n  // 1) ON-CHAIN sweep (existing behavior)\n  const valid = Array.from(new Set(\n    candidateIdHexes.filter((h) => typeof h === 'string' && Validation.idHex64.test(h)),\n  ));\n  const expiredHexSet = new Set<string>();\n  for (const idHex of valid) {\n    const status = (await this.getInvoiceStatus(deps.chain, idHex)).toLowerCase();\n    if (status === 'expired') expiredHexSet.add(idHex);\n  }\n  const onchainExpiredIds = Array.from(expiredHexSet);\n\n  // Build eligible rows for on-chain expired\n  const onchainEligible = allRows.filter(\n    (r) =>\n      expiredHexSet.has(r.id_hex) &&\n      r.status !== 'paid' &&\n      r.status !== 'canceled' &&\n      Number(r.expired) === 0,\n  );\n\n  // 2) TIME-BASED sweep (NEW): DTO quote has expired, regardless of chain status\n  const nowMs = Date.now();\n  const timeExpiredEligible = allRows.filter(\n    (r) =>\n      r.status === 'unpaid' &&\n      Number(r.expired) === 0 &&\n      typeof r.quote_expires_at === 'number' &&\n      nowMs > Number(r.quote_expires_at),\n  );\n\n  // 3) Combine both sets, dedupe by id_raw\n  const combinedByIdRaw = new Map<string, InvoiceRow>();\n  for (const row of [...onchainEligible, ...timeExpiredEligible]) {\n    combinedByIdRaw.set(row.id_raw, row);\n  }\n  const toMark = Array.from(combinedByIdRaw.values());\n\n  if (toMark.length === 0) {\n    return { expiredIds: onchainExpiredIds, updated: 0 };\n  }\n\n  // 4) Persist + emit webhooks\n  const idRawList = toMark.map((r) => r.id_raw);\n  const updated = deps.store.bulkMarkExpired(idRawList);\n\n  // Emit per row (exactly-once safeguard remains in emitInvoiceExpiredWebhook)\n  for (const row of toMark) {\n    // eslint-disable-next-line no-await-in-loop\n    await this.emitInvoiceExpiredWebhook(row.id_raw, row.store_id, {\n      store: deps.store,\n      dispatcher: deps.dispatcher,\n    });\n  }\n\n  return { expiredIds: onchainExpiredIds, updated };\n}\n\n}\n"]}