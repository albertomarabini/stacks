{"version":3,"file":"MerchantInputValidator.js","sourceRoot":"","sources":["../../src/delegates/MerchantInputValidator.ts"],"names":[],"mappings":"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","sourcesContent":["// src/delegates/MerchantInputValidator.ts\nimport { Validation } from '../validation/rules';\n\nexport class MerchantInputValidator {\n  validateCreateInvoiceBody(body: any): {\n    amountSats: number;\n    ttlSeconds: number;\n    memo?: string;\n    webhookUrl?: string;\n  } {\n    const amountSats = Number(body?.amount_sats);\n    const ttlSeconds = Number(body?.ttl_seconds);\n\n    if (!Number.isInteger(amountSats) || amountSats <= 0) {\n      throw new TypeError('amount_sats must be positive int');\n    }\n    if (!Number.isInteger(ttlSeconds) || ttlSeconds <= 0) {\n      throw new TypeError('ttl_seconds must be positive int');\n    }\n\n    let memo: string | undefined;\n    if (body?.memo !== undefined && body.memo !== null) {\n      const str = String(body.memo);\n      const buf = Buffer.from(str, 'utf8').subarray(0, Validation.createInvoice.memoMaxUtf8Bytes);\n      memo = buf.toString('utf8');\n    }\n\n    let webhookUrl: string | undefined;\n    if (body?.webhook_url) {\n      const url = String(body.webhook_url);\n      if (!Validation.url.test(url)) {\n        throw new TypeError('invalid webhook_url');\n      }\n      webhookUrl = url;\n    }\n\n    return { amountSats, ttlSeconds, memo, webhookUrl };\n  }\n\n  public validateRefundBody(body: Record<string, unknown>): {\n    invoiceId: string;\n    amountSats: number;\n    memo?: string;\n  } {\n    const b = body || {};\n\n    // accept snake_case or camelCase\n    const invoiceId = String(\n      (b as any).invoice_id ?? (b as any).invoiceId ?? ''\n    ).trim();\n    const amountSatsRaw = (b as any).amount_sats ?? (b as any).amountSats;\n    const amountSats = Number(amountSatsRaw);\n\n    // same memo handling (limit per Steroids)\n    const memoMax = Validation.refund.memoMaxUtf8Bytes;\n    let memo: string | undefined;\n    if (typeof (b as any).memo === 'string') {\n      const enc = new TextEncoder().encode((b as any).memo);\n      memo = new TextDecoder().decode(enc.subarray(0, memoMax));\n    }\n\n    // current project uses regexes on Validation, not methods\n    if (!invoiceId || !Validation.uuid.test(invoiceId)) {\n      throw new TypeError('invalid invoice_id');\n    }\n    if (!Number.isInteger(amountSats) || amountSats <= 0) {\n      throw new TypeError('invalid amount_sats');\n    }\n\n    // NOTICE: return **camelCase** (controller expects this)\n    return { invoiceId, amountSats, memo };\n  }\n\n\n  assertStacksPrincipal(p: string): void {\n    if (!Validation.stacksPrincipal.test(p)) {\n      throw new TypeError('invalid principal');\n    }\n  }\n\n  assertPositiveInt(n: number, name: string): void {\n    if (!Number.isInteger(n) || n <= 0) {\n      throw new TypeError(`${name} must be positive integer`);\n    }\n  }\n}\n"]}