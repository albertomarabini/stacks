{"version":3,"file":"RefundPolicyGuard.js","sourceRoot":"","sources":["../../src/delegates/RefundPolicyGuard.ts"],"names":[],"mappings":";;;AAKA,MAAa,iBAAiB;IAC5B,YAA6B,KAAsB,EAAmB,MAAqB;QAA9D,UAAK,GAAL,KAAK,CAAiB;QAAmB,WAAM,GAAN,MAAM,CAAe;IAAG,CAAC;IAE/F,KAAK,CAAC,eAAe,CACnB,KAAkB,EAClB,MAAkB,EAClB,UAAkB,EAClB,IAAa;QAEb,IAAI,MAAM,CAAC,MAAM,KAAK,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,oBAAoB,EAAE,CAAC;YACvE,MAAM,CAAC,GAAQ,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;YACrE,CAAC,CAAC,IAAI,GAAG,YAAY,CAAC;YACtB,MAAM,CAAC,CAAC;QACV,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAEtC,MAAM,eAAe,GAAG,MAAM,CAAC,aAAa,IAAI,CAAC,CAAC;QAClD,MAAM,QAAQ,GAAG,eAAe,GAAG,UAAU,CAAC;QAC9C,IAAI,QAAQ,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;YAClC,MAAM,CAAC,GAAQ,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;YAChD,CAAC,CAAC,IAAI,GAAG,eAAe,CAAC;YACzB,MAAM,CAAC,CAAC;QACV,CAAC;QAED,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;QAClF,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,MAAM,CAAC,GAAQ,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;YACtD,CAAC,CAAC,IAAI,GAAG,sBAAsB,CAAC;YAChC,MAAM,CAAC,CAAC;QACV,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;IACzE,CAAC;CACF;AAlCD,8CAkCC","sourcesContent":["// src/delegates/RefundPolicyGuard.ts\nimport type { IInvoiceIdCodec } from '../contracts/interfaces';\nimport { RefundService } from '../services/RefundService';\nimport type { MerchantRow, InvoiceRow, UnsignedContractCall } from '../contracts/domain';\n\nexport class RefundPolicyGuard {\n  constructor(private readonly codec: IInvoiceIdCodec, private readonly refund: RefundService) {}\n\n  async enforceAndBuild(\n    store: MerchantRow,\n    invRow: InvoiceRow,\n    amountSats: number,\n    memo?: string,\n  ): Promise<UnsignedContractCall> {\n    if (invRow.status !== 'paid' && invRow.status !== 'partially_refunded') {\n      const e: any = new Error('Invoice not refundable in current status');\n      e.code = 'bad_status';\n      throw e;\n    }\n\n    this.codec.assertHex64(invRow.id_hex);\n\n    const alreadyRefunded = invRow.refund_amount ?? 0;\n    const proposed = alreadyRefunded + amountSats;\n    if (proposed > invRow.amount_sats) {\n      const e: any = new Error('Refund cap exceeded');\n      e.code = 'cap_violation';\n      throw e;\n    }\n\n    const hasBalance = await this.refund.precheckBalance(store.principal, amountSats);\n    if (!hasBalance) {\n      const e: any = new Error('Insufficient sBTC balance');\n      e.code = 'insufficient_balance';\n      throw e;\n    }\n\n    return this.refund.buildRefundPayload(store, invRow, amountSats, memo);\n  }\n}\n"]}