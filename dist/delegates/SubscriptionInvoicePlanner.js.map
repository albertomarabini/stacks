{"version":3,"file":"SubscriptionInvoicePlanner.js","sourceRoot":"","sources":["../../src/delegates/SubscriptionInvoicePlanner.ts"],"names":[],"mappings":";;;;;;AAAA,8CAA8C;AAC9C,oDAA4B;AAgB5B,MAAa,0BAA0B;IACrC,YACU,KAAmB,EACnB,OAAuB,EACvB,GAAmB,EACnB,KAAsB;QAHtB,UAAK,GAAL,KAAK,CAAc;QACnB,YAAO,GAAP,OAAO,CAAgB;QACvB,QAAG,GAAH,GAAG,CAAgB;QACnB,UAAK,GAAL,KAAK,CAAiB;IAC7B,CAAC;IAEJ,KAAK,CAAC,IAAI,CAAC,YAA6B,EAAE,aAAqB;QAC7D,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;QACtD,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,KAAa,CAAC;QAClB,GAAG,CAAC;YACF,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,EAAE,CAAC;YAC7C,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,wBAAwB,CAAC,KAAK,CAAC,EAAE;QAEtD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAC9C,MAAM,KAAK,GAAG,gBAAM,CAAC,UAAU,EAAE,CAAC;QAElC,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE,CAAC;QAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEzB,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,EAAE,CAAC;QAChD,MAAM,eAAe,GAAG,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC,CAAC;QAC1E,MAAM,gBAAgB,GAAG,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC;QAEhD,MAAM,OAAO,GAAG,YAAY,CAAC,eAAe,GAAG,YAAY,CAAC,eAAe,CAAC;QAE5E,OAAO;YACL,KAAK;YACL,OAAO;YACP,KAAK;YACL,WAAW;YACX,gBAAgB;YAChB,eAAe;YACf,OAAO;SACR,CAAC;IACJ,CAAC;IAED,mBAAmB,CAAC,OAAuB,EAAE,YAA6B;QACxE,OAAO,IAAI,CAAC,SAAS,CAAC;YACpB,cAAc,EAAE,YAAY,CAAC,EAAE;YAC/B,SAAS,EAAE,OAAO,CAAC,KAAK;YACxB,UAAU,EAAE,YAAY,CAAC,WAAW;YACpC,OAAO,EAAE,OAAO,CAAC,OAAO;YACxB,UAAU,EAAE,YAAY,CAAC,UAAU;SACpC,CAAC,CAAC;IACL,CAAC;CACF;AApDD,gEAoDC","sourcesContent":["// src/delegates/SubscriptionInvoicePlanner.ts\nimport crypto from 'crypto';\nimport type { ISqliteStore } from '../contracts/dao';\nimport type { IInvoiceIdCodec, IConfigService } from '../contracts/interfaces';\nimport type { SubscriptionRow } from '../contracts/domain';\nimport { PricingService } from '../services/PricingService';\n\nexport type PlannedInvoice = {\n  idHex: string;\n  idBuf32: Uint8Array;\n  idRaw: string;\n  usdAtCreate: number;\n  quoteExpiresAtMs: number;\n  expiresAtBlocks: number;\n  nextDue: number;\n};\n\nexport class SubscriptionInvoicePlanner {\n  constructor(\n    private store: ISqliteStore,\n    private pricing: PricingService,\n    private cfg: IConfigService,\n    private codec: IInvoiceIdCodec\n  ) {}\n\n  async plan(subscription: SubscriptionRow, currentHeight: number): Promise<PlannedInvoice> {\n    const ttlSecs = Number(process.env.QUOTE_TTL_SECONDS);\n    if (!Number.isFinite(ttlSecs) || ttlSecs <= 0) {\n      throw new Error('Missing or invalid QUOTE_TTL_SECONDS.');\n    }\n\n    let idHex: string;\n    do {\n      idHex = this.codec.generateRandomBuff32Hex();\n      this.codec.assertHex64(idHex);\n    } while (!this.store.ensureInvoiceIdHexUnique(idHex));\n\n    const idBuf32 = this.codec.toBuff32Hex(idHex);\n    const idRaw = crypto.randomUUID();\n\n    const usdAtCreate = await this.pricing.getUsdPriceSnapshot();\n    const nowMs = Date.now();\n\n    const avgBlockSecs = this.cfg.getAvgBlockSecs();\n    const expiresAtBlocks = currentHeight + Math.ceil(ttlSecs / avgBlockSecs);\n    const quoteExpiresAtMs = nowMs + ttlSecs * 1000;\n\n    const nextDue = subscription.next_invoice_at + subscription.interval_blocks;\n\n    return {\n      idHex,\n      idBuf32,\n      idRaw,\n      usdAtCreate,\n      quoteExpiresAtMs,\n      expiresAtBlocks,\n      nextDue,\n    };\n  }\n\n  buildWebhookRawBody(planned: PlannedInvoice, subscription: SubscriptionRow): string {\n    return JSON.stringify({\n      subscriptionId: subscription.id,\n      invoiceId: planned.idRaw,\n      amountSats: subscription.amount_sats,\n      nextDue: planned.nextDue,\n      subscriber: subscription.subscriber,\n    });\n  }\n}\n"]}