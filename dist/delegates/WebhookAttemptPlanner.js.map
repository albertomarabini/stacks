{"version":3,"file":"WebhookAttemptPlanner.js","sourceRoot":"","sources":["../../src/delegates/WebhookAttemptPlanner.ts"],"names":[],"mappings":";;;;;;AAAA,yCAAyC;AACzC,oDAA4B;AAmC5B,MAAM,YAAY,GAAG,CAAC,CAAC;AAEvB,MAAa,qBAAqB;IAChC,oBAAoB,CAAC,KAAmB,EAAE,GAAc;QACtD,MAAM,EAAE,GAAG,gBAAM,CAAC,UAAU,EAAE,CAAC;QAC/B,MAAM,GAAG,GAAkB;YACzB,EAAE;YACF,QAAQ,EAAE,GAAG,CAAC,OAAO;YACrB,UAAU,EAAE,GAAG,CAAC,SAAS;YACzB,eAAe,EAAE,GAAG,CAAC,cAAc;YACnC,UAAU,EAAE,GAAG,CAAC,SAAgB;YAChC,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,WAAW,EAAE,SAAS;YACtB,OAAO,EAAE,CAAC;YACV,QAAQ,EAAE,GAAG,CAAC,QAAQ;YACtB,eAAe,EAAE,GAAG,CAAC,GAAG;SACzB,CAAC;QACF,KAAK,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC;QAChC,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,WAAW,CAAC,KAAmB,EAAE,YAAoB,EAAE,MAAc;QACnE,KAAK,CAAC,0BAA0B,CAAC,YAAY,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC,CAAC;IACrF,CAAC;IAED,KAAK,CAAC,wBAAwB,CAC5B,KAAmB,EACnB,GAAe,EACf,YAAqB;QAErB,KAAK,CAAC,0BAA0B,CAAC,GAAG,CAAC,YAAY,EAAE;YACjD,OAAO,EAAE,CAAC;YACV,UAAU,EAAE,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS;SACxE,CAAC,CAAC;QACH,IAAI,GAAG,CAAC,QAAQ,IAAI,YAAY;YAAE,OAAO;QACzC,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;YAChC,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,SAAS,EAAE,GAAG,CAAC,SAAS;YACxB,cAAc,EAAE,GAAG,CAAC,cAAc;YAClC,SAAS,EAAE,GAAG,CAAC,SAAS;YACxB,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,QAAQ,EAAE,GAAG,CAAC,QAAQ;YACtB,GAAG,EAAE,GAAG,CAAC,GAAG;SACb,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,eAAe,CAAC,KAAmB,EAAE,GAAY;QACrD,MAAM,WAAW,GAAG,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC;QACrC,IAAI,WAAW,GAAG,YAAY;YAAE,OAAO;QACvC,MAAM,EAAE,GAAG,gBAAM,CAAC,UAAU,EAAE,CAAC;QAC/B,MAAM,GAAG,GAAkB;YACzB,EAAE;YACF,QAAQ,EAAE,GAAG,CAAC,OAAO;YACrB,UAAU,EAAE,GAAG,CAAC,SAAS;YACzB,eAAe,EAAE,GAAG,CAAC,cAAc;YACnC,UAAU,EAAE,GAAG,CAAC,SAAgB;YAChC,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,WAAW,EAAE,SAAS;YACtB,OAAO,EAAE,CAAC;YACV,QAAQ,EAAE,WAAW;YACrB,eAAe,EAAE,GAAG,CAAC,GAAG;SACzB,CAAC;QACF,KAAK,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC;IAClC,CAAC;CACF;AA9DD,sDA8DC;AAED,kBAAe,qBAAqB,CAAC","sourcesContent":["// src/delegates/WebhookAttemptPlanner.ts\nimport crypto from 'crypto';\nimport type { ISqliteStore } from '../contracts/dao';\nimport type { WebhookLogRow } from '../contracts/domain';\n\ntype RecordCtx = {\n  storeId: string;\n  invoiceId?: string;\n  subscriptionId?: string;\n  eventType: string;\n  rawBody: string;\n  attempts: number;\n  now: number; // epoch seconds\n};\n\ntype FailureCtx = {\n  attemptLogId: string;\n  attempts: number;\n  storeId: string;\n  invoiceId?: string;\n  subscriptionId?: string;\n  eventType: string;\n  rawBody: string;\n  now: number; // epoch seconds\n};\n\ntype PlanCtx = {\n  storeId: string;\n  invoiceId?: string;\n  subscriptionId?: string;\n  eventType: string;\n  rawBody: string;\n  attempts: number;\n  now: number; // epoch seconds\n};\n\nconst MAX_ATTEMPTS = 5;\n\nexport class WebhookAttemptPlanner {\n  recordInitialAttempt(store: ISqliteStore, ctx: RecordCtx): string {\n    const id = crypto.randomUUID();\n    const row: WebhookLogRow = {\n      id,\n      store_id: ctx.storeId,\n      invoice_id: ctx.invoiceId,\n      subscription_id: ctx.subscriptionId,\n      event_type: ctx.eventType as any,\n      payload: ctx.rawBody,\n      status_code: undefined,\n      success: 0,\n      attempts: ctx.attempts,\n      last_attempt_at: ctx.now,\n    };\n    store.insertWebhookAttempt(row);\n    return id;\n  }\n\n  markSuccess(store: ISqliteStore, attemptLogId: string, status: number): void {\n    store.updateWebhookAttemptStatus(attemptLogId, { success: 1, statusCode: status });\n  }\n\n  async handleFailureAndPlanNext(\n    store: ISqliteStore,\n    ctx: FailureCtx,\n    statusOrNull?: number,\n  ): Promise<void> {\n    store.updateWebhookAttemptStatus(ctx.attemptLogId, {\n      success: 0,\n      statusCode: typeof statusOrNull === 'number' ? statusOrNull : undefined,\n    });\n    if (ctx.attempts >= MAX_ATTEMPTS) return;\n    await this.planNextAttempt(store, {\n      storeId: ctx.storeId,\n      invoiceId: ctx.invoiceId,\n      subscriptionId: ctx.subscriptionId,\n      eventType: ctx.eventType,\n      rawBody: ctx.rawBody,\n      attempts: ctx.attempts,\n      now: ctx.now,\n    });\n  }\n\n  async planNextAttempt(store: ISqliteStore, ctx: PlanCtx): Promise<void> {\n    const nextAttempt = ctx.attempts + 1;\n    if (nextAttempt > MAX_ATTEMPTS) return;\n    const id = crypto.randomUUID();\n    const row: WebhookLogRow = {\n      id,\n      store_id: ctx.storeId,\n      invoice_id: ctx.invoiceId,\n      subscription_id: ctx.subscriptionId,\n      event_type: ctx.eventType as any,\n      payload: ctx.rawBody,\n      status_code: undefined,\n      success: 0,\n      attempts: nextAttempt,\n      last_attempt_at: ctx.now,\n    };\n    store.insertWebhookAttempt(row);\n  }\n}\n\nexport default WebhookAttemptPlanner;\n"]}