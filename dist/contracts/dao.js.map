{"version":3,"file":"dao.js","sourceRoot":"","sources":["../../src/contracts/dao.ts"],"names":[],"mappings":"","sourcesContent":["// src/contracts/dao.ts\nimport {\n  MerchantRow,\n  InvoiceRow,\n  SubscriptionRow,\n  WebhookLogRow,\n  InvoiceStatus,\n  WebhookEventType,\n  SubscriptionMode,\n} from '../contracts/domain';\n\nexport interface ISqliteStore {\n  migrate(): void;\n\n  // Merchants\n  findActiveByApiKey(apiKey: string): MerchantRow | undefined;\n  insertMerchant(row: MerchantRow): void;\n  updateMerchantActive(storeId: string, active: boolean): number;\n  // updateMerchantKeysTx(storeId: string, apiKey: string, hmacSecret: string): void;\n  updateStxPrivateKey(storeId: string, stx_private_key: string): void;\n  listMerchantsProjection(): Omit<MerchantRow, 'stx_private_key' | 'hmac_secret'>[];\n  // rotateKeysPersist(storeId: string, apiKey: string, hmacSecret: string, now: number):number;\n  markKeysRevealedOnce(storeId: string, expectVersion: number, now: number):boolean;\n  getMerchantById(storeId: string): MerchantRow | undefined;\n  getInvoiceStatusByHex(idHex: string): InvoiceStatus | undefined;\n  updateMerchantProfile(\n    storeId: string,\n    patch: Partial<Pick<\n      MerchantRow,\n      | 'name'\n      | 'display_name'\n      | 'logo_url'\n      | 'brand_color'\n      | 'webhook_url'\n      | 'support_email'\n      | 'support_url'\n      | 'allowed_origins'\n      | 'principal'\n\n    >>\n  ): void;\n\n  // Invoices\n  invoices: {\n    insert(row: InvoiceRow): void;\n    findByStoreAndIdRaw(storeId: string, idRaw: string): InvoiceRow | undefined;\n  };\n  getInvoiceById(idRaw: string): InvoiceRow | undefined;\n  getInvoiceWithStore(idRaw: string): (InvoiceRow & { store: MerchantRow }) | undefined;\n  listInvoicesByStore(\n    storeId: string,\n    opts?: { status?: InvoiceStatus; orderByCreatedDesc?: boolean },\n  ): InvoiceRow[];\n  markInvoicePaid(idHex: string, payer: string, txId: string, tx?: unknown): void;\n  upsertInvoiceRefund(idHex: string, amountSats: number, refundTxId: string, tx?: unknown): void;\n  markInvoiceCanceled(idHexOrIdRaw: string, tx?: unknown): void;\n  updateInvoiceStatus(idRaw: string, status: InvoiceStatus, expired?: 0 | 1): void;\n  ensureInvoiceIdHexUnique(idHex: string): boolean;\n  invoiceExists(idHex: string): boolean;\n  bulkMarkExpired(idRawList: string[]): number;\n  selectInvoicesByStatuses(\n    statuses: InvoiceStatus[],\n    limit: number,\n    storeId?: string\n  ): Pick<InvoiceRow, 'id_hex' | 'status' | 'refund_amount' | 'merchant_principal'>[];\n\n  // Subscriptions\n  insertSubscription(row: SubscriptionRow): void;\n  getSubscriptionByIdForStore(id: string, storeId: string): SubscriptionRow | undefined;\n  getActiveSubscription(id: string, storeId: string): SubscriptionRow | undefined;\n  updateSubscriptionMode(id: string, storeId: string, mode: SubscriptionMode): void;\n  deactivateSubscription(id: string, storeId: string, tx?: unknown): void;\n  setSubscriptionActive(input: { idHex: string; active: 0 | 1 }): void;\n  upsertSubscriptionByHex(input: {\n    idHex: string;\n    storeId: string;\n    merchantPrincipal: string;\n    subscriber: string;\n    amountSats: number;\n    intervalBlocks: number;\n    active: 1;\n  }): void;\n  advanceSubscriptionSchedule(id: string): void;\n  updateSubscriptionLastPaid(input: { subscriptionId: string; lastPaidInvoiceId: string }): void;\n  subscriptionExists(idHex: string): boolean;\n  selectDueSubscriptions(currentHeight: number): SubscriptionRow[];\n  getStoreIdByPrincipal(merchantPrincipal: string): string | undefined;\n\n  // Webhooks\n  insertWebhookAttempt(row: WebhookLogRow): string;\n  updateWebhookAttemptStatus(id: string, patch: { success: 0 | 1; statusCode?: number }): void;\n  listWebhooksForStore(storeId: string): WebhookLogRow[];\n  listAdminWebhooks(storeId?: string, failedOnly?: boolean): WebhookLogRow[];\n  getWebhookLogById(id: string): WebhookLogRow | undefined;\n  existsSuccessfulDeliveryFor(ctx: {\n    storeId: string;\n    invoiceId?: string;\n    subscriptionId?: string;\n    eventType: WebhookEventType;\n  }): boolean;\n  selectDueWebhookRetries(): WebhookLogRow[];\n  getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[];\n\n  // Admin queries\n  selectAdminInvoices(statuses?: InvoiceStatus[], storeId?: string): InvoiceRow[];\n\n  // Optional cursor persistence\n  getPollerCursor():\n    | { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string }\n    | null;\n  savePollerCursor(cursor: {\n    lastRunAt: number;\n    lastHeight: number;\n    lastTxId?: string;\n    lastBlockHash?: string;\n  }): void;\n}\n"]}