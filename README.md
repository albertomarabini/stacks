

# Architectural Plan:
| Component Name | Description |
| -------------- | ----------- |
| SbtcPaymentContract | Component Role: On-chain immutable payment/registry engine for invoices and subscriptions; canonical source of truth and event emitter. System Boundaries & State Flow: Owns merchants/invoices/subscriptions maps; owns admin and sBTC token principals in data-vars; mutates only via public contract-calls; read-only functions never mutate. Component Responsibilities & Interactions: - set admin once: enforce one-time bootstrap-admin; reject further attempts. - set sBTC token: accept trait-typed (contract-of ft-trait) principal; store in data-var; used for all transfers. - maintain merchant registry: register-merchant and set-merchant-active (admin-only); later checks block inactive merchants from creating/accepting invoices. - create invoices: validate merchant is registered & active; ensure unique id; persist amount, memo, optional expires-at; initialize paid=false, canceled=false, refund-amount=0; emit invoice-created. - accept payments: validate exists, unpaid, not canceled, not expired, merchant still active, sBTC set; transfer exact amount using external SIP-010 transfer? from payer to merchant; set paid=true, payer=(some tx-sender); emit invoice-paid; prevent replays. - refunds: only invoice’s merchant; require paid and payer present; enforce cumulative cap (refund-amount + amount ≤ original amount); transfer sBTC back to payer; update refund-amount; emit invoice-refunded. - cancel invoices: merchant or admin may cancel only when unpaid; set canceled=true; emit invoice-canceled. - subscriptions: create-subscription (caller==merchant; active merchant; interval>0; unique id) with next-due=block-height+interval; emit subscription-created. pay-subscription (caller=subscriber; active; block-height ≥ next-due) transfers exact amount to merchant; advance next-due; emit subscription-paid. cancel-subscription by merchant/admin sets active=false; emit subscription-canceled. - expiry helper: mark-expired(id) prints invoice-expired if block-height ≥ expires-at; no state change. - read-only functions: get-invoice, is-paid, get-subscription, next-due, get-sbtc, get-admin; get-invoice-status implements strict precedence: not-found → paid → canceled → expired (block-height ≥ expires-at) → unpaid; backend consumes this to gate wallet payload building and reconciliation. Data Ownership & Lifespan: Persistent on-chain until redeploy. External Dependencies: External sBTC SIP-010 contract via trait-typed transfer?; off-chain poller consumes print logs as events. |
| StacksChainClient | Component Role: Provide deterministic read-only contract state, chain tip, block headers, and contract-call event feeds to backend services; centralize CV encoding/decoding. System Boundaries & State Flow: Stateless per call; returns decoded JS shapes to callers; memoizes network config at process start. Component Responsibilities & Interactions: - callReadOnlyFunction for contract read-onlys: get-invoice-status, get-invoice, is-paid, get-subscription, next-due, get-sbtc, get-admin; decode CVs and map to backend enums/strings. - Fetch chain tip (height/hash) for poller metrics and confirmations math. - Fetch contract-call events from fromHeight; filter/sort done by caller; return raw events with args for ID extraction. - Fetch block headers/parents for reorg detection. - Expose helper: isMerchantRegisteredOnChain(principal) if admin sync needs it. Data Ownership & Lifespan: None; returns data to consumers. External Dependencies & Integration Points: PaymentPoller, ExpirationMonitor, PublicApiController, AdminApiController Chain Config, SubscriptionScheduler. |
| ContractCallBuilder | Component Role: Build unsigned wallet-ready contract-call payloads for all supported on-chain actions. System Boundaries & State Flow: Pure builder; no signing/broadcast; composes function name, args, post-conditions, network, and anchor mode. Component Responsibilities & Interactions: - Build pay-invoice with two fungible post-conditions (payer sent ≥ amountSats; merchant received ≥ amountSats) and PostConditionMode.Deny. - Build refund-invoice with merchant outgoing cap post-condition (merchant sent ≥ amountSats) to prevent over-send in wallet. - Build create-invoice, cancel-invoice, create-subscription, pay-subscription, cancel-subscription payloads. - Build admin helper payloads: bootstrap-admin, set-sbtc-token, register-merchant, set-merchant-active. - Validate and encode arguments (bufferCV for 32-byte IDs via InvoiceIdCodec; principalCVs; uintCVs; optional memo). Data Ownership & Lifespan: Stateless; returns ephemeral payload objects to controllers/UI. External Dependencies & Integration Points: AssetInfoFactory for sBTC asset info; PostConditionFactory for post-conditions; ConfigService for network/contract IDs; @stacks/transactions CV builders. |
| AssetInfoFactory | Component Role: Provide canonical sBTC asset descriptors for post-conditions. System Boundaries & State Flow: Stateless; derives asset info from configured token contract once and reuses. Component Responsibilities & Interactions: - Produce asset info for sBTC fungible token used by post-conditions (payer/merchant/refund). - Validate presence of SBTC_CONTRACT_ADDRESS/NAME; surface errors to callers. Data Ownership & Lifespan: Cached per process for reuse. External Dependencies & Integration Points: ConfigService for contract identifiers; @stacks/transactions createAssetInfo. |
| InvoiceIdCodec | Component Role: Validate and convert invoice/subscription IDs between 64-hex and 32-byte buffers. System Boundaries & State Flow: Stateless validation/conversion utilities. Component Responsibilities & Interactions: - assertHex64(idHex) and isValidHex64(idHex) to enforce 64-char hex with round-trip to (buff 32). - toBuff32(idHex) and hexFromBuff32(buf32) for encoding/decoding; used in payload building and read-only calls. - generateRandomBuff32() for new IDs. - Guard DB inserts/updates: ensure id_hex round-trips before persistence. Data Ownership & Lifespan: None; pure helpers. External Dependencies & Integration Points: Node Buffer. |
| ConfigService | Centralized environment and runtime configuration provider.<br>**System Boundaries & State Flow**Produces config snapshot (contract addresses/names, network, intervals, confirmations).<br>**Responsibilities & Interactions**:<br>Methods: getNetwork(), getContractId(), getSbtcContractId(), getPollingConfig(), getAvgBlockSecs(), getPriceApiUrl().<br>**Event Flows**:<br>Initialized at process start; read by all components.<br>**Data Ownership & Lifespan**:<br>Process-lifetime immutable snapshot (read-only after boot).<br>**External Dependencies & Integration**:<br>Environment variables. |
| SqliteStore | Component Role: Synchronous persistence layer for merchants, invoices, subscriptions, and webhook_logs; provide exact queries and atomic updates required by controllers, schedulers, and the poller, including subscription upsert and lifecycle updates referenced by the poller’s subscription processing flow. System Boundaries & State Flow: Executes DDL/DML synchronously using prepared statements and transactions; enforces hex64 id constraints and immutability of critical columns; exposes optimized selectors and updates for poller and webhook retry flows. Component Responsibilities & Interactions: - Migrations/Indexes: create tables and indices idempotently (invoices, merchants, subscriptions, webhook_logs); enforce CHECKs for 64-hex and positive amounts/intervals; unique indices for id_hex and merchant principal/API key. - Merchant lookups: findActiveByApiKey(apiKey); list all (admin); activate/deactivate; rotate keys with projection that never returns secrets outside rotate response. - Invoices: insert with immutable id_hex/merchant_principal/amount_sats; list/get by store; mark paid with payer/txid; mark canceled; update refund totals and status; mark expired with idempotence guards. - Webhooks: insert attempt; update attempt result; list by store/admin; select due retries; existence/idempotence checks for expired webhooks; durable attempts count and last_attempt_at. - Subscriptions (extended for Event Model): insert new; update mode; deactivate; advance schedule; upsertSubscriptionByHex({ idHex, storeId, merchantPrincipal, subscriber, amountSats, intervalBlocks, active }): insert-or-update preserving existing mode; setSubscriptionActive({ idHex, active }); updateSubscriptionLastPaid({ subscriptionId, lastPaidInvoiceId }); getStoreIdByPrincipal(merchantPrincipal) to map chain merchant to local store for poller linkage. - Admin queries: selectAdminInvoices with filters; listAdminWebhooks; return projections without api_key/hmac_secret. Data Ownership & Lifespan: Durable rows in SQLite; all updates performed in transactions when part of multi-step flows; no in-memory long-lived state. External Dependencies & Integration Points: - PaymentPoller (paid/refund/cancel/subscription-created/subscription-canceled/subscription-paid updates; store principal→storeId resolution). - WebhookDispatcher/WebhookRetryScheduler (attempt rows, due retries). - MerchantApiController/AdminApiController (CRUD operations with projection rules). Domain-Specific or Custom Logic: - Enforce DS-3-35 immutability of invoices.id_hex/merchant_principal/amount_sats by excluding from UPDATE statements and guarding in code. - Guarantee id_hex round-trip validation before INSERT/UPDATE; reject invalid 64-hex. - Preserve subscription mode on upsert to avoid overwriting merchant intent when processing on-chain events. Non-Boilerplate Behaviors: - Provide getStoreIdByPrincipal to bridge on-chain merchant principal to multi-tenant store context. - Use single-transaction upsert paths when poller applies multiple related updates. |
| PublicApiController | Component Role: Serve public invoice JSON, build wallet-ready pay-invoice payloads, and expose store public profile; enforce public CORS and rate limits. System Boundaries & State Flow: Stateless per request; reads SQLite and on-chain read-only status; no writes. Responsibilities & Interactions: - Read invoice+store row, validate id_hex (64 hex, buff32 round-trip), map to camelCase, augment with on-chain status via StacksChainClient.getInvoiceStatus; compute expired based on DB TTL or on-chain "expired". - Create wallet payload for pay-invoice only when invoice is found, unpaid, not canceled, not expired, and merchant is active; attach two fungible post-conditions (payer sent ≥ amountSats; merchant received ≥ amountSats); return unsigned payload JSON. - Return public store profile fields for checkout branding. - Map errors to HTTP for /create-tx: 400 invalid id; 404 not found; 409 paid/expired/canceled; 422 merchant inactive; 426 wrong network. - Do not leak secrets; camelCase responses. Integration: Uses SqliteStore for reads, StacksChainClient for read-only calls, ContractCallBuilder and PostConditionFactory via AssetInfoFactory for payload build, InvoiceIdCodec for validation. |
| MerchantApiController | Handles authenticated, store-scoped operations: create/list/get invoices; cancel unpaid; build refund payloads; subscriptions CRUD/mode; generate invoices from subscriptions; list webhooks; store profile read/update; rotate keys. Adds direct subscription payment payload builder. Validates principals, amounts, intervals, idHex 64-hex round-trip, subscription mode/state, current height vs next_invoice_at, and equality of payer/subscriber for direct mode. Enforces per-store isolation via middleware. Returns unsigned payloads for wallet via @stacks/connect. |
| AdminApiController | Component Role: Handle admin-only operations for stores, chain registry helpers, chain config, poller control, webhook inspection/retry, and invoice cancel; return unsigned wallet payloads for contract calls where applicable. System Boundaries & State Flow: Stateless per request; reads/writes SQLite via SqliteStore; delegates to PollerAdminBridge/WebhookDispatcher; never logs or returns secrets except in rotate response (once). Component Responsibilities & Interactions: - Get poller status: fetch in-memory metrics via PollerAdminBridge.getState() and return exact telemetry shape. - Restart poller: call PollerAdminBridge.restart() to tear down and recreate internal timer, preserving cursor; return { running }. - List webhooks: validate query params, conditionally filter by storeId and status='failed', order by last_attempt_at desc; return rows without secrets. - Retry webhook: validate webhookLogId UUID; load row; if success already exists for same context, return 200; else enqueue retry with WebhookDispatcher.enqueueRetryIfNotInflight(row) and return 202. - Maintain existing endpoints (Stores CRUD/activate, rotate keys, sync on-chain, set sBTC token, invoices list/cancel, webhooks list/retry) with projection/redaction rules. Data Ownership & Lifespan: No persistent admin state; all mutations are DB updates or in-memory poller control. External Dependencies & Integration Points: AdminAuth middleware; SqliteStore; WebhookDispatcher; PollerAdminBridge; @stacks/transactions for unsigned helper calls. |
| AdminStaticServer | Component Role: Serve Admin Console SPA assets only after AdminAuth passes; stream index.html for SPA entry. System Boundaries & State Flow: Stateless; serves files from disk under /admin. Responsibilities & Interactions: - serve static assets for /admin/* after AdminAuth; set appropriate caching headers (express defaults). - serve SPA index.html on GET /admin after AdminAuth using res.sendFile. Data Ownership & Lifespan: None. External Dependencies: express.static; filesystem paths. |
| StoreApiAuth | Component Role: Authenticate merchant-scoped API requests by X-API-Key and bind store context. System Boundaries & State Flow: Stateless middleware; reads merchants table and attaches req.store on success. Component Responsibilities & Interactions: - Verify presence and validity of X-API-Key; only allow active merchants. - On success, attach merchant row to req.store for downstream handlers; on failure 401 with no body. Data Ownership & Lifespan: No persistence; per-request augmentation. External Dependencies & Integration Points: SqliteStore for merchant lookup; Express middleware chain. |
| CrossTenantMask | Component Role: Enforce tenant isolation across store-scoped routes by masking mismatches with 404. System Boundaries & State Flow: Stateless middleware comparing req.params.storeId to req.store.id. Responsibilities & Interactions: - enforce(req,res,next): if mismatch, return 404 and do not call next(); otherwise delegate. Integration: Applied after StoreApiAuth on all /api/v1/stores/:storeId/* routes via HttpApiServer bindings. |
| AdminAuth | Component Role: Enforce admin-only access to Admin Console SPA and Admin API; accept Bearer ADMIN_TOKEN or Basic ADMIN_USER/ADMIN_PASS; deny others. System Boundaries & State Flow: Stateless middleware; validates Authorization header; never persists secrets. Responsibilities & Interactions: - parse Authorization; accept “Bearer <ADMIN_TOKEN>” or “Basic <base64(user:pass)>” matching env; perform constant-time compares; on success call next(). - on failure, respond 401 'Unauthorized' without leaking details; do not log secrets. - ensure middleware ordering precedes static asset serving and admin routes. Data Ownership & Lifespan: None. External Dependencies: Express middleware chain; Node Buffer for Basic decode; process.env. |
| CorsPolicy | Component Role: Enforce dynamic CORS for public endpoints using store-scoped allowlists and respond to preflight with required headers. System Boundaries & State Flow: Stateless; reads allowed_origins from DB via invoice or store. Component Responsibilities & Interactions: - Validate origin for /i/:invoiceId against invoice’s store allowlist. - Validate origin for /create-tx against invoiceId supplied in query (if present). - Validate origin for /api/v1/stores/:storeId/public-profile against store allowlist. - On allow, set ACAO to Origin and include Access-Control-Allow-Headers: Content-Type, X-API-Key, X-Webhook-Timestamp, X-Webhook-Signature; methods per route (GET/POST/OPTIONS). - On deny, omit ACAO to block browser access. Data Ownership & Lifespan: None. External Dependencies & Integration Points: cors middleware; SqliteStore for allowlist lookup. |
| RateLimitPolicy | Component Role: Provide route-scoped rate limiters and handlers for public and merchant endpoints. System Boundaries & State Flow: In-memory counters per window; no DB. Responsibilities & Interactions: - publicInvoiceViewLimiter/publicProfileLimiter/publicCreateTxLimiter: throttle GET /i/:invoiceId, GET /api/v1/stores/:storeId/public-profile, POST /create-tx; respond 429 with JSON and stop chain. - createInvoiceLimiter: throttle POST /api/v1/stores/:storeId/invoices. - subInvoiceLimiter: throttle POST /api/v1/stores/:storeId/subscriptions/:id/invoice with keyGenerator combining req.store.id and X-API-Key; respond 429 {error:'rate_limited'}. Integration: Bound before handlers in HttpApiServer; custom handler JSON bodies. |
| PricingService | Provides BTC/USD snapshot at invoice creation with simple TTL cache.<br>**System Boundaries & State Flow**Fetches USD price from external API; returns numeric snapshot used for display.<br>**Responsibilities & Interactions**:<br>Methods: getUsdPriceSnapshot(); cache invalidation by TTL. Used by InvoiceService and SubscriptionService.<br>**Event Flows**:<br>Event origin: service calls from controllers; Binding: direct call.<br>**Data Ownership & Lifespan**:<br>Ephemeral cache in memory; numeric snapshots persisted into invoices rows.<br>**External Dependencies & Integration**:<br>Pricing API endpoint (e.g., CoinGecko). |
| InvoiceService | Core invoice domain logic: create invoice on-chain then persist, cancel unpaid, compute expiry blocks.<br>**System Boundaries & State Flow**Writes invoices rows with immutable id_hex/amount/merchant; reads current block height; computes expiresAtBlock and quote TTL; updates status.<br>**Responsibilities & Interactions**:<br>- createInvoice(store, amount, ttlSeconds, memo?, webhookUrl?): generates id, builds create-invoice payload, optionally broadcasts in POC, inserts DB row with USD snapshot and TTL. - cancelUnpaid(store, invoice): builds cancel payload and updates DB on success.<br>**Event Flows**:<br>Event origin: HTTP (merchant); Binding: invoked by MerchantApiController.<br>**Data Ownership & Lifespan**:<br>Owns no long-term state; persists invoices via SqliteStore.<br>**External Dependencies & Integration**:<br>Stacks API (height), ContractCallBuilder, PricingService. |
| RefundService | Component Role: Validate and build unsigned refund-invoice contract-call payloads; pre-check merchant sBTC balance; enforce refund caps. System Boundaries & State Flow: Stateless builder; reads DB row via controller; no persistence. Responsibilities & Interactions: - precheckBalance(merchantPrincipal, amountSats): fetch current sBTC balance for merchant via StacksChainClient/token API; return boolean. - buildRefundPayload(store, invoice, amountSats, memo?): assert invoice.id_hex is hex64 and buff32; enforce refund_total + amountSats ≤ invoice.amount_sats; construct refund post-condition capping merchant outgoing ≤ amountSats; build unsigned payload for refund-invoice with memo optional. - Surface insufficient_balance to controller when balance < amountSats to avoid wallet failures. Integration: Uses StacksChainClient for balance, ContractCallBuilder + PostConditionFactory + AssetInfoFactory for payload; InvoiceIdCodec for conversions. |
| SubscriptionService | Manages subscriptions, mode, invoicing, and cancel actions.<br>**System Boundaries & State Flow**Persists subscriptions; computes next_invoice_at; switches mode; builds unsigned calls as needed; cancels active subscriptions on-chain then updates DB.<br>**Responsibilities & Interactions**:<br>- createSubscription(store, body): validates and persists; optionally returns unsigned create-subscription payload. - generateInvoiceForSubscription(sub): creates on-chain invoice and DB row; advances schedule. - setMode(sub, mode): updates DB; if direct and missing on-chain sub, returns unsigned create-subscription. - cancel(sub): builds cancel payload, broadcasts in POC, updates DB.<br>**Event Flows**:<br>Event origin: HTTP (merchant) and Scheduler tick; Binding: called by MerchantApiController and SubscriptionScheduler.<br>**Data Ownership & Lifespan**:<br>Owns no long-term state; writes to DB via SqliteStore.<br>**External Dependencies & Integration**:<br>StacksChainClient (height), ContractCallBuilder, PricingService (for invoice generation). |
| WebhookDispatcher | Component Role: Build and send HMAC-signed outbound webhooks for invoice/subscription lifecycle events, record durable logs, and orchestrate retries with exponential backoff; verify inbound HMAC for optional inbound endpoints. System Boundaries & State Flow: Stateless between calls; writes durable attempt rows to SQLite; reads merchant webhook URL, HMAC secret, and invoice override URL; holds short-lived replay and inflight de-dup caches in memory. Component Responsibilities & Interactions: - Resolve destination URL with precedence: invoice.webhook_url override else merchants.webhook_url; if none, no-op. - Compose raw JSON payload (camelCase) for events paid/refunded/subscription/expired; do not mutate or re-stringify if provided as rawBody. - Compute HMAC headers per attempt: ts=unix seconds; signature v1=HMAC_SHA256(hmac_secret, `${ts}.${rawBody}`); enforce timing-safe compares for inbound verification. - Insert webhook_logs attempt row before send; on send completion update success/status_code; on failure schedule backoff with attempts capped at 5. - Enqueue retries via WebhookRetryScheduler with de-dup of inflight contexts. - Expose verifyWebhookSignature middleware: enforce 300s clock skew, timing-safe signature compare, 10-minute replay cache keyed by signature, express.raw parser for exact bytes. - Coordinate with AdminApiController for manual retry: validate target row, de-duplicate, increment attempts and dispatch. Data Ownership & Lifespan: No long-term ownership; persists each attempt and status; maintains ephemeral inflight Set and replay cache Map. External Dependencies & Integration Points: - SqliteStore: read merchant config/override URL/HMAC; insert/update webhook_logs; existence/idempotence checks. - WebhookRetryScheduler: enqueue retry flows; computes next wake. - PaymentPoller and SubscriptionScheduler: event publishers that invoke dispatch. - AdminApiController: manual retry entrypoint. |
| WebhookRetryScheduler | Component Role: Periodically scan and re-dispatch failed webhook attempts using exponential backoff with attempt caps and durable state; bootstrap pending retries at process start. System Boundaries & State Flow: Maintains a Node timer handle; reads due attempts from DB; uses in-memory de-dup inflight set when enqueueing; no long-term ownership beyond scheduling. Component Responsibilities & Interactions: - Bootstrap on process start: scan for due rows and enqueue them; avoid double-registration. - On each wake, compute due attempts where (now - last_attempt_at) >= nextBackoff(attempts) and attempts < 5; call WebhookDispatcher.dispatch for each. - After a failed dispatch, rely on dispatcher.planRetry() to insert the next attempt with updated last_attempt_at and attempts+1; scheduler will pick it up on a later wake. - Manually enqueue on admin retry: de-dup inflight, bump attempts and update last_attempt_at, then dispatch asynchronously. Data Ownership & Lifespan: No persistent state; durable retry data resides in webhook_logs. External Dependencies & Integration Points: SqliteStore for selecting due attempts; WebhookDispatcher for sending; HttpApiServer.start() to register timer. |
| PaymentPoller | Component Role: Continuously scan Stacks API for contract-call events, reconcile DB state with on-chain truth under confirmations and reorg safety, trigger webhooks, detect expirations, and expose telemetry and restart controls. System Boundaries & State Flow: Holds an in-memory cursor { lastHeight, lastTxId, lastBlockHash } and metrics { running, lastRunAt, lagBlocks, lastBlockHash }; persists only DB state changes; resets running flag in finally after each tick; does not create or hold durable queues. Component Responsibilities & Interactions: - Guard reentrancy: on tick entry, short-circuit if running; otherwise set metrics.running=true; always clear in finally. - Read chain tip: fetch tip height/hash at start of tick for confirmations math and lag computation. - Fetch events: query Stacks API for contract-call events from cursor+1 to tip; normalize and sort deterministically by (block_height ASC, tx_index ASC). - Dispatch at tick-start: route normalized events to specialized handlers, including processSubscriptionEvents for subscription-created, subscription-canceled, and subscription-paid linkages, before general invoice updates; advance in-memory cursor progress after processing the confirmed batch. - Confirmations gate: compute confirmations = tipHeight - event.block_height + 1; process only when confirmations ≥ MIN_CONFIRMATIONS. - Process payments: for invoice-paid, mark invoice paid (payer, txid), dispatch paid webhook; idempotently ignore repeats. - Process refunds: for refund-invoice, increment refund totals, set refund txid/time; set status=refunded when fully; dispatch refunded webhook. - Process explicit subscription lifecycle: for create-subscription, normalize idHex (exact 64 hex), resolve storeId via SqliteStore.getStoreIdByPrincipal(merchantPrincipal), UPSERT via SqliteStore.upsertSubscriptionByHex({ idHex, storeId, merchantPrincipal, subscriber, amountSats, intervalBlocks, active: 1 }) preserving existing mode; dispatch subscription-created webhook. For subscription-canceled, set active=0 via SqliteStore.setSubscriptionActive and dispatch subscription-canceled webhook. For subscription-paid linkage, when an invoice-paid is tied to a subscription, call SqliteStore.updateSubscriptionLastPaid and dispatch subscription-paid webhook. - Handle cancel-invoice: mark canceled, dispatch invoice-canceled webhook if configured. - Detect expirations: sweep DB TTL and on-chain get-invoice-status 'expired' via ExpirationMonitor; mark expired and emit invoice-expired webhook exactly once per invoice. - Reorg safety: compare parent hashes across cursor advancement; on mismatch or tip regression, rewind up to REORG_WINDOW_BLOCKS and reprocess; do not advance cursor for the offending tick. - Cursor advance and metrics: after successful batch, update in-memory cursor, compute lagBlocks, record lastRunAt; expose telemetry for admin. - Restart control: support restart preserving cursor, re-register interval, reflect running state; expose getState() via PollerAdminBridge. Data Ownership & Lifespan: Only in-memory cursor and metrics; all durable states (invoices, refunds, subscriptions, webhook logs) are persisted in SQLite by invoking SqliteStore methods inside transactions. External Dependencies & Integration Points: - StacksChainClient (tip/events/block headers/read-only status). - SqliteStore (atomic updates for invoices/subscriptions/webhook logs). - WebhookDispatcher (paid/refunded/subscription/expired). - ExpirationMonitor (DB/on-chain expirations). - PollerAdminBridge (admin status/restart). Domain-Specific or Custom Logic: - Enforce deterministic ordering and single-flight execution per tick. - Preserve subscription mode on upsert to avoid overwriting merchant intent. - Normalize subscription IDs to exact 64-hex; skip invalid IDs. - Gate all event applications by confirmations ≥ MIN_CONFIRMATIONS; only advance cursor after processing confirmed events. Non-Boilerplate Behaviors: - Explicit tick-start dispatch that routes normalized events into processSubscriptionEvents before general handlers to ensure correct subscription state upserts/cancels; idempotent webhook emission with durable logs; reorg-aware rewind with parent hash checks. |
| SubscriptionScheduler | Component Role: Generate per-period invoices in "invoice" mode for due subscriptions and notify merchants; compute expiry windows in blocks and seconds; skip inactive or "direct" mode subscriptions. System Boundaries & State Flow: Holds a Node timer; stateless across ticks besides interval handle; persists generated invoices and schedule bumps transactionally; dispatches subscription-invoice-created webhook after persistence. Component Responsibilities & Interactions: - Bootstrap scheduler once at process start only if required env present (AVG_BLOCK_SECONDS, QUOTE_TTL_SECONDS, POLL_INTERVAL_SECS); compute intervalMs and register setInterval. - On tick: fetch current tip height; select due subscriptions where active=1 AND mode='invoice' AND next_invoice_at <= currentHeight. - For each due subscription: generate id_raw + id_hex (validate 64-hex round-trip); fetch USD snapshot; compute quote_expires_at = now + QUOTE_TTL_SECONDS; compute expiresAtBlocks = currentHeight + ceil(QUOTE_TTL_SECONDS/AVG_BLOCK_SECONDS). - Build and broadcast create-invoice contract-call; on broadcast success only: insert invoice row (link subscription_id), advance schedule (last_billed_at=now, next_invoice_at += interval_blocks) in a single transaction; dispatch webhook { subscriptionId, invoiceId, amountSats, nextDue, subscriber }. - Log and skip persistence on broadcast failure; continue with others. Data Ownership & Lifespan: No long-lived in-memory state beyond timer handle; DB holds subscriptions and invoices. External Dependencies & Integration Points: StacksChainClient.getTip; ContractCallBuilder for create-invoice payload; PricingService; SqliteStore; WebhookDispatcher. |
| CheckoutFrontend | Renders public invoice UI, applies branding, opens wallet with payload, and manages timers and polling. Implements countdown scheduler tick every 1s to update UI and highlight near expiry; on expiry, sets UI to Expired and disables payment actions without network calls. Implements status poll every 15–30s while Unpaid with in-flight guard using AbortController; stops on terminal states (Paid/Expired/Canceled). Keeps wallet actions disabled post-broadcast and handles user rejection gracefully. |
| MerchantDashboardFrontend | Component Role: Merchant SPA for invoices/subscriptions/settings/webhooks; orchestrates wallet flows for refunds; adapts camelCase⇄snake_case; authenticates via X-API-Key. System Boundaries & State Flow: Client-side React state; server authoritative; uses refetchKey to trigger reloads; intercepts 401/403 to gate UI. Responsibilities & Interactions: - load data on mount and route changes: fetch invoices, invoice detail, subscriptions, store profile, webhook logs with X-API-Key. - render exact fields from backend (amountSats, usdAtCreate, status, memo, payer, txId, quoteExpiresAt, refundAmount, refundTxId, subscriptionId, magicLink). - create invoices/subscriptions; generate invoice from subscription; cancel unpaid invoices/subscriptions; update store settings; rotate keys (one-time secrets modal). - manage refunds: open modal, validate caps client-side to preempt errors; call backend to build unsigned refund payload; open wallet; onFinish set local refundPending and trigger refetch; onCancel show non-fatal toast. - switch subscription mode: POST mode ('invoice'or'direct'); patch local state then refetch. - implement HTTP response interceptor: on 401/403 set auth error state and prompt for valid API key; clear on success. - apply camelCase responses and send snake_case bodies; ensure headers include X-API-Key. Data Ownership & Lifespan: Transient React state; optimistic flags (e.g., refundPending) reconciled after refetch. External Dependencies: fetch/axios, @stacks/connect openContractCall, c32check (optional), QR libs for checkout link (informational). |
| AdminConsoleFrontend | Component Role: Single-user admin SPA for store ops, on-chain registry sync, chain config, poller control, webhooks, and invoice cancel; invokes wallet for unsigned admin calls. System Boundaries & State Flow: Client-side state; admin APIs authoritative; Authorization header set on every request; shows one-time secrets on rotation. Responsibilities & Interactions: - create store via form; append projection to UI; handle 400/409. - activate/deactivate store via toggle; patch UI state; rollback on error. - rotate keys; display {apiKey,hmacSecret} once in modal; clear from memory on close. - sync on-chain: request helper; iterate returned calls (register-merchant and set-merchant-active) and openContractCall for each; after confirmations, mark “On-chain synced”. - set sBTC token: request helper, openContractCall; after confirm, refresh get-sbtc display; surface persistent warning banner if poller reports SIP-010 transfer failures. - poller control: restart via button; update status card; debounce. - webhook retry: POST retry; on 202 refresh table; debounce row clicks. - cancel invoice: POST admin cancel; update status to canceled; optionally build & sign on-chain cancel-invoice via helper; show error if already paid. - bootstrap admin: build bootstrap-admin helper; openContractCall; after confirmation verify get-admin; hide/disable bootstrap button and show immutability warning. Data Ownership & Lifespan: Transient SPA state; never persists secrets beyond modal lifetime. External Dependencies: fetch API, @stacks/connect openContractCall, admin auth header management. |
| HealthController | Component Role: Minimal readiness endpoint; returns OK without touching state. System Boundaries & State Flow: Stateless; no dependencies. Responsibilities & Interactions: - handle GET / by sending 200 'OK'; used by health checks. Data Ownership & Lifespan: None. External Dependencies: Express routing. |
| HttpApiServer | Component Role: Compose Express app, bind all public/merchant/admin routes, CORS preflights, rate limits, auth middleware, static admin SPA, and bootstrap background schedulers (poller and webhook retry; subscription scheduler). System Boundaries & State Flow: Stateless orchestrator; initializes route graph and starts schedulers at process start; no durable state. Component Responsibilities & Interactions: - Wire all endpoints (public, merchant, admin) with proper middleware order: CORS, rate limiting, auth, body parsers. - Serve Admin Console SPA behind AdminAuth. - Mount inbound webhook verification (express.raw) before JSON parsers for exact HMAC input. - On start: bootstrap PaymentPoller once; bootstrap WebhookRetryScheduler; bootstrap SubscriptionScheduler with env guards. Data Ownership & Lifespan: None; delegates to controllers and schedulers. External Dependencies & Integration Points: Express; cors; express-rate-limit; express.static; express.json/raw; AdminAuth; StoreApiAuth; CrossTenantMask; controllers; schedulers. |
| PostConditionFactory | Component Role: Centralize fungible post-condition construction for wallet calls. System Boundaries & State Flow: Stateless helpers returning arrays of post-conditions. Responsibilities & Interactions: - forPayInvoice(payerPrincipal, merchantPrincipal, amountSats, sbtcAsset): create two post-conditions: Origin (payer) sent ≥ amountSats; Merchant (standard principal) received ≥ amountSats. - forRefund(merchantPrincipal, amountSats, sbtcAsset): create a merchant-sent ≤ amountSats post-condition to hard-cap outgoing during refund. Integration: Used by ContractCallBuilder for pay-invoice and refund-invoice payloads; AssetInfoFactory supplies sBTC asset info. |
| PollerAdminBridge | Exposes poller metrics and restart control to admin API.<br>**System Boundaries & State Flow**Provides getState() and restart() used by AdminApiController.<br>**Responsibilities & Interactions**:<br>Thin facade around Poller to avoid direct coupling in controller.<br>**Event Flows**:<br>Event origin: Admin API calls; Binding: method calls.<br>**Data Ownership & Lifespan**:<br>Stateless facade; delegates to Poller’s in-memory state.<br>**External Dependencies & Integration**:<br>None. |
| ExpirationMonitor | Component Role: Identify and mark expired invoices via DB TTL and on-chain read-only status, and emit single-shot invoice-expired webhooks. System Boundaries & State Flow: Stateless service invoked each poller cycle; performs DB updates in transactions; uses WebhookDispatcher to notify; idempotence via DB checks and webhook_logs existence predicates. Component Responsibilities & Interactions: - Sweep DB TTL expirations: select unpaid, not-canceled, not already expired invoices where quote_expires_at < now; mark status='expired', expired=1 atomically; after commit, dispatch 'invoice-expired' webhook if configured and not already successfully delivered. - Sweep on-chain expirations: call get-invoice-status per candidate id; collect 'expired' statuses; bulk mark expired for rows not in terminal states; emit webhooks idempotently. - Provide emit helper composing payload { invoiceId, status:'expired' } with HMAC headers via dispatcher. Data Ownership & Lifespan: No long-lived state; DB invariants ensure idempotence. External Dependencies & Integration Points: SqliteStore for selects/updates; StacksChainClient callReadOnly; WebhookDispatcher for outbound; invoked by PaymentPoller each tick. |
| PricingCache | Lightweight in-memory cache wrapper for BTC/USD pricing within TTL window.<br>**System Boundaries & State Flow**Stores last fetched price and timestamp; invalidates by TTL.<br>**Responsibilities & Interactions**:<br>get(), set(), isExpired(). Used by PricingService.<br>**Event Flows**:<br>Called from PricingService; no direct external events.<br>**Data Ownership & Lifespan**:<br>Process-lifetime volatile cache.<br>**External Dependencies & Integration**:<br>None. |
| Component Name | Extended Behavioral Responsibilities, Dependencies, Component Description |
| InvoiceStatusResolver | - **[Offloading Class Names]**: PublicApiController<br>- **[Originating Method Ids]**: PAC-GET-INVOICE<br><br>Delegate State Owned:<br>- chain: IStacksChainClient instance to perform read-only status queries.<br>- idGuard: InvoiceIdGuard instance to ensure id_hex integrity.<br><br>Delegate Responsibilities Owned:<br>- Execute on-chain read-only calls to get invoice status with zero side effects.<br>- Compute final display status using strict precedence rules combining on-chain status and local TTL (ms-based).<br>- Encapsulate all logic for status derivation away from the controller.<br><br>Responsibilities Removed from Parent Class:<br>- On-chain status fetching and precedence computation between DB TTL and get-invoice-status.<br>- Validation of id_hex before invoking read-only calls.<br><br>Delegate Public Interface:<br>```<br>export type OnchainInvoiceStatus = 'not-found' or 'paid' or 'canceled' or 'expired' or 'unpaid';<br><br>export interface IStacksChainClient {<br>  readInvoiceStatus(idHex: string): Promise<OnchainInvoiceStatus>;<br>}<br><br>export type PublicStatus = 'paid' or 'canceled' or 'expired' or 'unpaid' or 'pending';<br><br>export interface InvoiceIdGuardLike {<br>  validateHexIdOrThrow(idHex: string): void;<br>}<br><br>export interface InvoiceRowMinimal {<br>  id_hex: string;<br>  status: PublicStatus;<br>  quote_expires_at: number; // ms epoch<br>}<br><br>export class InvoiceStatusResolver {<br>  constructor(<br>    private chain: IStacksChainClient,<br>    private idGuard: InvoiceIdGuardLike<br>  ) {}<br><br>  readOnchainStatus(idHex: string): Promise<OnchainInvoiceStatus>;<br><br>  computeDisplayStatus(row: InvoiceRowMinimal, onchain: OnchainInvoiceStatus, nowMs: number): PublicStatus;<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>const resolver = new InvoiceStatusResolver(chainClient, idGuard);<br>// Controller usage<br>const onchain = await resolver.readOnchainStatus(row.id_hex);<br>const status = resolver.computeDisplayStatus(row, onchain, Date.now());<br>```<br><br>#### 🔁 Refactored Method: PublicApiController.getInvoice<br>- After refactoring, the controller:<br>  - Loads the invoice row as before.<br>  - Delegates id_hex validation and on-chain status retrieval to InvoiceStatusResolver.<br>  - Delegates status precedence logic (combining TTL and on-chain) to InvoiceStatusResolver.<br>  - Builds the DTO and returns it.<br><br>```typescript<br>// Inside PublicApiController constructor<br>this.idGuard = new InvoiceIdGuard(this.codec);<br>this.statusResolver = new InvoiceStatusResolver(this.chain, this.idGuard);<br>this.profileProjector = new StorePublicProfileProjector();<br>this.txAssembler = new PayInvoiceTxAssembler(this.builder, this.aif, this.cfg, this.chain, this.idGuard, Validation.nonPayableStatuses);<br><br>// Refactored body of getInvoice(req, res)<br>async getInvoice(req: Request, res: Response): Promise<void> {<br>  const idRaw = req.params.invoiceId;<br>  const row = this.store.getInvoiceWithStore(idRaw);<br>  if (!row) {<br>    res.status(HttpStatusMap.notFound).json(PublicErrors.notFound);<br>    return;<br>  }<br><br>  try {<br>    // Ensures 64-hex and 32-byte round-trip before any chain call<br>    this.idGuard.validateHexIdOrThrow(row.id_hex);<br>  } catch {<br>    res.status(HttpStatusMap.invalidPayload).json(PublicErrors.invalidId);<br>    return;<br>  }<br><br>  const onchain = await this.statusResolver.readOnchainStatus(row.id_hex);<br>  const status = this.statusResolver.computeDisplayStatus(<br>    { id_hex: row.id_hex, status: row.status, quote_expires_at: row.quote_expires_at },<br>    onchain,<br>    Date.now()<br>  );<br><br>  const storeProfile = this.profileProjector.project(row.store);<br>  const dto: PublicInvoiceDTO = {<br>    invoiceId: row.id_raw,<br>    idHex: row.id_hex,<br>    storeId: row.store_id,<br>    amountSats: row.amount_sats,<br>    usdAtCreate: row.usd_at_create,<br>    quoteExpiresAt: row.quote_expires_at,<br>    merchantPrincipal: row.merchant_principal,<br>    status,<br>    payer: row.payer ?? undefined,<br>    txId: row.txid ?? undefined,<br>    memo: row.memo ?? undefined,<br>    subscriptionId: row.subscription_id ?? undefined,<br>    createdAt: row.created_at,<br>    refundAmount: row.refund_amount ? row.refund_amount : undefined,<br>    refundTxId: row.refund_txid ?? undefined,<br>    store: storeProfile,<br>  };<br><br>  res.json(dto);<br>}<br>```<br><br>#### 🔧 Delegate Method: readOnchainStatus<br>- Responsibility: Perform read-only call with validated id_hex; zero side effects.<br>- Signature: readOnchainStatus(idHex: string): Promise<OnchainInvoiceStatus><br>- Behavior:<br>  - Uses InvoiceIdGuard to assert idHex format.<br>  - Calls IStacksChainClient.readInvoiceStatus and returns the deterministic result.<br><br>```typescript<br>export class InvoiceStatusResolver {<br>  constructor(<br>    private chain: IStacksChainClient,<br>    private idGuard: InvoiceIdGuardLike<br>  ) {}<br><br>  async readOnchainStatus(idHex: string): Promise<OnchainInvoiceStatus> {<br>    this.idGuard.validateHexIdOrThrow(idHex);<br>    const status = await this.chain.readInvoiceStatus(idHex);<br>    return status;<br>  }<br><br>  computeDisplayStatus(row: InvoiceRowMinimal, onchain: OnchainInvoiceStatus, nowMs: number): PublicStatus {<br>    // Precedence for display: on-chain paid → on-chain canceled → TTL expired or on-chain expired → fallback to DB status<br>    if (onchain === 'paid') return 'paid';<br>    if (onchain === 'canceled') return 'canceled';<br>    if (nowMs > row.quote_expires_at or onchain === 'expired') return 'expired';<br>    // Fallback: use DB status when on-chain says unpaid/not-found<br>    return row.status;<br>  }<br>}<br>```<br><br>--- |
| StorePublicProfileProjector | - **[Offloading Class Names]**: PublicApiController<br>- **[Originating Method Ids]**: PAC-GET-STORE-PROFILE<br><br>Delegate State Owned:<br>- None.<br><br>Delegate Responsibilities Owned:<br>- Map store DB projection (snake_case fields) into StorePublicProfileDTO (camelCase) safely, omitting secrets by construction.<br><br>Responsibilities Removed from Parent Class:<br>- Manual DTO shaping for store public profile in controller methods.<br><br>Delegate Public Interface:<br>```<br>export type StoreLike = {<br>  display_name?: string or null;<br>  logo_url?: string or null;<br>  brand_color?: string or null;<br>  support_email?: string or null;<br>  support_url?: string or null;<br>};<br><br>export type StorePublicProfileDTO = {<br>  displayName?: string;<br>  logoUrl?: string;<br>  brandColor?: string;<br>  supportEmail?: string;<br>  supportUrl?: string;<br>};<br><br>export class StorePublicProfileProjector {<br>  project(store: StoreLike): StorePublicProfileDTO;<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>const projector = new StorePublicProfileProjector();<br>const profile = projector.project(storeRow);<br>```<br><br>#### 🔁 Refactored Method: PublicApiController.getStorePublicProfile<br>- After refactoring, the controller:<br>  - Finds the store projection.<br>  - Delegates the DTO mapping to the projector.<br><br>```typescript<br>// Inside PublicApiController constructor<br>this.profileProjector = new StorePublicProfileProjector();<br><br>// Refactored body of getStorePublicProfile(req, res)<br>async getStorePublicProfile(req: Request, res: Response): Promise<void> {<br>  const storeId = req.params.storeId;<br>  const rows = this.store.listMerchantsProjection();<br>  const m = rows.find((r) => r.id === storeId);<br>  if (!m) {<br>    res.status(HttpStatusMap.notFound).json(PublicErrors.notFound);<br>    return;<br>  }<br><br>  const profile = this.profileProjector.project(m);<br>  res.json(profile);<br>}<br>```<br><br>#### 🔧 Delegate Method: project<br>- Responsibility: Convert DB snake_case public fields to camelCase DTO, preserving undefined for missing values.<br>- Signature: project(store: StoreLike): StorePublicProfileDTO<br>- Behavior:<br>  - Maps each known field; does not include any secrets.<br><br>```typescript<br>export class StorePublicProfileProjector {<br>  project(store: StoreLike): StorePublicProfileDTO {<br>    return {<br>      displayName: store.display_name ?? undefined,<br>      logoUrl: store.logo_url ?? undefined,<br>      brandColor: store.brand_color ?? undefined,<br>      supportEmail: store.support_email ?? undefined,<br>      supportUrl: store.support_url ?? undefined,<br>    };<br>  }<br>}<br>```<br><br>--- |
| PayInvoiceTxAssembler | - **[Offloading Class Names]**: PublicApiController<br>- **[Originating Method Ids]**: PAC-CREATE-TX<br><br>Delegate State Owned:<br>- builder: IContractCallBuilder for constructing unsigned payloads.<br>- aif: IAssetInfoFactory for asset info validation.<br>- cfg: IConfigService for sBTC contract ID discovery.<br>- chain: IStacksChainClient to gate via read-only get-invoice-status.<br>- idGuard: InvoiceIdGuard to validate id_hex before chain calls.<br>- nonPayableStatuses: Set<string> of DB statuses considered non-payable.<br><br>Delegate Responsibilities Owned:<br>- Full create-tx gating: id_hex validation, merchant active check, TTL check, on-chain status check, sBTC token configuration validation.<br>- Effective payer principal selection fallback.<br>- Building unsigned pay-invoice payload using provided builder.<br><br>Responsibilities Removed from Parent Class:<br>- All decision logic and validation to determine if a create-tx may be built.<br>- All payload construction details and configuration checks.<br><br>Delegate Public Interface:<br>```<br>export interface IContractCallBuilder {<br>  buildPayInvoice(args: {<br>    idHex: string;<br>    amountSats: number;<br>    payerPrincipal: string;<br>    merchantPrincipal: string;<br>  }): any; // Unsigned payload JSON<br>}<br><br>export interface IAssetInfoFactory {<br>  getSbtcAssetInfo(): { contractId: string; assetName: string };<br>}<br><br>export interface IConfigService {<br>  getSbtcContractId(): string or null;<br>}<br><br>export interface InvoiceRowForTx {<br>  id_hex: string;<br>  amount_sats: number;<br>  merchant_principal: string;<br>  status: string;<br>  quote_expires_at: number; // ms epoch<br>  store: { active: number or boolean };<br>}<br><br>export class HttpError extends Error {<br>  constructor(public status: number, public code: string, message?: string) {<br>    super(message ?? code);<br>  }<br>}<br><br>export class PayInvoiceTxAssembler {<br>  constructor(<br>    private builder: IContractCallBuilder,<br>    private aif: IAssetInfoFactory,<br>    private cfg: IConfigService,<br>    private chain: IStacksChainClient,<br>    private idGuard: InvoiceIdGuardLike,<br>    private nonPayableStatuses: Set<string><br>  ) {}<br><br>  buildUnsignedPayInvoice(row: InvoiceRowForTx, payerPrincipal?: string): Promise<any>;<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>const assembler = new PayInvoiceTxAssembler(builder, aif, cfg, chain, idGuard, Validation.nonPayableStatuses);<br>const payload = await assembler.buildUnsignedPayInvoice(row, req.body?.payerPrincipal);<br>```<br><br>#### 🔁 Refactored Method: PublicApiController.createTx<br>- After refactoring, the controller:<br>  - Fetches the invoice row by invoiceId.<br>  - Delegates all validation and payload building to PayInvoiceTxAssembler.<br>  - Maps HttpError codes to API error bodies and statuses.<br><br>```typescript<br>// Inside PublicApiController constructor<br>this.txAssembler = new PayInvoiceTxAssembler(this.builder, this.aif, this.cfg, this.chain, this.idGuard, Validation.nonPayableStatuses);<br><br>// Refactored body of createTx(req, res)<br>async createTx(req: Request, res: Response): Promise<void> {<br>  const { invoiceId, payerPrincipal } = req.body or {};<br>  if (!invoiceId) {<br>    res.status(HttpStatusMap.invalidPayload).json(PublicErrors.missingIdentifier);<br>    return;<br>  }<br><br>  const row = this.store.getInvoiceWithStore(String(invoiceId));<br>  if (!row) {<br>    res.status(HttpStatusMap.notFound).json(PublicErrors.notFound);<br>    return;<br>  }<br><br>  try {<br>    const payload = await this.txAssembler.buildUnsignedPayInvoice(row, payerPrincipal);<br>    res.json(payload);<br>  } catch (e: any) {<br>    if (e instanceof HttpError) {<br>      // Map error codes to API error bodies per policy<br>      if (e.code === 'merchant-inactive') {<br>        res.status(e.status).json(PublicErrors.invalidState);<br>      } else if (e.code === 'expired') {<br>        res.status(e.status).json(PublicErrors.expired);<br>      } else if (e.code === 'missing-token') {<br>        res.status(e.status).json(PublicErrors.missingSbtcToken);<br>      } else if (e.code === 'invalid-id') {<br>        res.status(e.status).json(PublicErrors.invalidId);<br>      } else {<br>        res.status(HttpStatusMap.conflict).json(PublicErrors.invalidState);<br>      }<br>      return;<br>    }<br>    // Fallback<br>    res.status(HttpStatusMap.conflict).json(PublicErrors.invalidState);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: buildUnsignedPayInvoice<br>- Responsibility: Centralize all create-tx preconditions and build the unsigned payload.<br>- Signature: buildUnsignedPayInvoice(row: InvoiceRowForTx, payerPrincipal?: string): Promise<any><br>- Behavior:<br>  - Validate merchant active (422).<br>  - Validate id_hex (400 invalid-id).<br>  - Read on-chain status (read-only), combine with TTL; if expired or non-payable, throw 409 accordingly.<br>  - Validate sBTC token configuration via cfg and aif (422).<br>  - Select effective payer principal (fallback to merchantPrincipal per existing compromise).<br>  - Build and return unsigned payload JSON.<br><br>```typescript<br>export class PayInvoiceTxAssembler {<br>  constructor(<br>    private builder: IContractCallBuilder,<br>    private aif: IAssetInfoFactory,<br>    private cfg: IConfigService,<br>    private chain: IStacksChainClient,<br>    private idGuard: InvoiceIdGuardLike,<br>    private nonPayableStatuses: Set<string><br>  ) {}<br><br>  async buildUnsignedPayInvoice(row: InvoiceRowForTx, payerPrincipal?: string): Promise<any> {<br>    // 422: Merchant inactive<br>    const isActive = typeof row.store.active === 'boolean' ? row.store.active : row.store.active === 1;<br>    if (!isActive) {<br>      throw new HttpError(422, 'merchant-inactive');<br>    }<br><br>    // 400: invalid id<br>    try {<br>      this.idGuard.validateHexIdOrThrow(row.id_hex);<br>    } catch {<br>      throw new HttpError(400, 'invalid-id');<br>    }<br><br>    // Gate via on-chain + TTL<br>    const onchain = await this.chain.readInvoiceStatus(row.id_hex);<br>    const ttlExpired = Date.now() > row.quote_expires_at;<br>    if (ttlExpired or onchain === 'expired') {<br>      throw new HttpError(409, 'expired');<br>    }<br>    if (onchain === 'paid' or onchain === 'canceled' or this.nonPayableStatuses.has(row.status)) {<br>      throw new HttpError(409, 'invalid-state');<br>    }<br><br>    // Ensure sBTC token configured<br>    const tokenId = this.cfg.getSbtcContractId();<br>    if (!tokenId) {<br>      throw new HttpError(422, 'missing-token');<br>    }<br>    // Surface misconfiguration early<br>    this.aif.getSbtcAssetInfo();<br><br>    const effectivePayer =<br>      typeof payerPrincipal === 'string' && payerPrincipal.length > 0<br>        ? payerPrincipal<br>        : row.merchant_principal;<br><br>    // Build unsigned payload via builder<br>    return this.builder.buildPayInvoice({<br>      idHex: row.id_hex,<br>      amountSats: row.amount_sats,<br>      payerPrincipal: effectivePayer,<br>      merchantPrincipal: row.merchant_principal,<br>    });<br>  }<br>}<br>```<br><br>--- |
| InvoiceIdGuard | - **[Offloading Class Names]**: PublicApiController<br>- **[Originating Method Ids]**: None<br><br>Delegate State Owned:<br>- codec: IInvoiceIdCodec for hex integrity and 32-byte round-trip enforcement.<br><br>Delegate Responsibilities Owned:<br>- Centralize validation of 64-hex invoice IDs and 32-byte round-trip prior to any chain operation.<br><br>Responsibilities Removed from Parent Class:<br>- Inline id_hex validation using codec scattered across methods.<br><br>Delegate Public Interface:<br>```<br>export interface IInvoiceIdCodec {<br>  assertHex64(hex: string): void; // throws on invalid<br>}<br><br>export class InvoiceIdGuard {<br>  constructor(private codec: IInvoiceIdCodec) {}<br>  validateHexIdOrThrow(idHex: string): void;<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>const idGuard = new InvoiceIdGuard(codec);<br>idGuard.validateHexIdOrThrow(row.id_hex);<br>```<br><br>#### 🔧 Delegate Method: validateHexIdOrThrow<br>- Responsibility: Ensure the id_hex is a 64-char hex that round-trips to a 32-byte buffer.<br>- Signature: validateHexIdOrThrow(idHex: string): void<br>- Behavior:<br>  - Calls codec.assertHex64 and lets it throw on invalid inputs.<br><br>```typescript<br>export class InvoiceIdGuard {<br>  constructor(private codec: IInvoiceIdCodec) {}<br><br>  validateHexIdOrThrow(idHex: string): void {<br>    this.codec.assertHex64(idHex);<br>  }<br>}<br>```<br><br>End of report. |
| ClarityCvAdapter | - **[Offloading Class Names]**: StacksChainClient<br>- **[Originating Method Ids]**: SCC-READ-SBTC-TOKEN, SCC-READ-SUBSCRIPTION<br><br>Delegate State Owned:<br>- None.<br><br>Delegate Responsibilities Owned:<br>- Validate and transform 64-hex subscription/invoice IDs into exact 32-byte buffers for Clarity buffer arguments.<br>- Decode Clarity values returned by read-only functions into precise JS shapes expected by the backend:<br>  - Optional contract principal from get-sbtc<br>  - Optional subscription tuple from get-subscription<br><br>Responsibilities Removed from Parent Class:<br>- CV decoding/parsing logic for get-sbtc and get-subscription.<br>- Hex ID validation and 32-byte buffer guarding.<br><br>Delegate Public Interface:<br>- guardHex32(idHex: string): Buffer<br>- decodeOptionalContractPrincipal(cv: import('@stacks/transactions').ClarityValue): { contractAddress: string; contractName: string } or undefined<br>- decodeOptionalSubscriptionTuple(cv: import('@stacks/transactions').ClarityValue, idHex: string): OnChainSubscription or undefined<br><br>Example Interaction:<br>```typescript<br>// Inside StacksChainClient<br>const cvAdapter = new ClarityCvAdapter();<br>// ...<br>const idBuf = cvAdapter.guardHex32(idHex);<br>// ...<br>const token = cvAdapter.decodeOptionalContractPrincipal(cv);<br>// ...<br>const sub = cvAdapter.decodeOptionalSubscriptionTuple(cv, idHex);<br>```<br><br>#### 🔁 Refactored Method: StacksChainClient.readSbtcToken<br>Breakdown after refactoring:<br>- Invokes the contract read-only function to fetch the Clarity value.<br>- Delegates optional contract-principal decoding to ClarityCvAdapter.decodeOptionalContractPrincipal.<br>- Returns the decoded value or undefined as per SL-6-12.<br><br>How it’s called and used:<br>- StacksChainClient now concentrates on making the read-only call; decoding is handled by the delegate.<br><br>```typescript<br>// snippet inside src/clients/StacksChainClient.ts<br>import { ClarityCvAdapter } from '../delegates/ClarityCvAdapter';<br><br>export class StacksChainClient {<br>  private readonly cvAdapter = new ClarityCvAdapter();<br>  // ...<br><br>  async readSbtcToken(): Promise<{ contractAddress: string; contractName: string } or undefined> {<br>    const cv = await callReadOnlyFunction({<br>      contractAddress: this.contractAddress,<br>      contractName: this.contractName,<br>      functionName: 'get-sbtc',<br>      functionArgs: [],<br>      network: this.network,<br>    });<br>    return this.cvAdapter.decodeOptionalContractPrincipal(cv);<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: StacksChainClient.readSubscription<br>Breakdown after refactoring:<br>- Validates idHex and obtains a 32-byte Buffer via ClarityCvAdapter.guardHex32.<br>- Calls read-only get-subscription with bufferCV(idBuf).<br>- Delegates tuple decoding to ClarityCvAdapter.decodeOptionalSubscriptionTuple.<br>- Returns OnChainSubscription or undefined.<br><br>How it’s called and used:<br>- StacksChainClient enforces the read-only call and uses the delegate for decoding and ID validation.<br><br>```typescript<br>// snippet inside src/clients/StacksChainClient.ts<br>import { bufferCV, callReadOnlyFunction } from '@stacks/transactions';<br>import { ClarityCvAdapter } from '../delegates/ClarityCvAdapter';<br>import { OnChainSubscription } from '../models/domain';<br><br>export class StacksChainClient {<br>  private readonly cvAdapter = new ClarityCvAdapter();<br>  // ...<br><br>  async readSubscription(idHex: string): Promise<OnChainSubscription or undefined> {<br>    const idBuf = this.cvAdapter.guardHex32(idHex);<br>    const cv = await callReadOnlyFunction({<br>      contractAddress: this.contractAddress,<br>      contractName: this.contractName,<br>      functionName: 'get-subscription',<br>      functionArgs: [bufferCV(idBuf)],<br>      network: this.network,<br>    });<br>    return this.cvAdapter.decodeOptionalSubscriptionTuple(cv, idHex);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: guardHex32<br>Responsibility:<br>- Validates that idHex is exactly 64 hex chars and round-trips to a 32-byte Buffer.<br><br>```typescript<br>// src/delegates/ClarityCvAdapter.ts<br>import { ClarityValue, cvToJSON, cvToString } from '@stacks/transactions';<br>import { OnChainSubscription } from '../models/domain';<br><br>export class ClarityCvAdapter {<br>  guardHex32(idHex: string): Buffer {<br>    if (typeof idHex !== 'string' or idHex.length !== 64) {<br>      throw new Error('idHex must be 64 hex chars');<br>    }<br>    const buf = Buffer.from(idHex, 'hex');<br>    if (buf.length !== 32 or buf.toString('hex') !== idHex.toLowerCase()) {<br>      throw new Error('idHex must decode to 32 bytes and round-trip');<br>    }<br>    return buf;<br>  }<br><br>  decodeOptionalContractPrincipal(cv: ClarityValue): { contractAddress: string; contractName: string } or undefined {<br>    const asString = cvToString(cv);<br>    if (asString === 'none' or asString === '(none)') return undefined;<br>    const m = asString.match(/\(some\s+([A-Z0-9]{1,}\.[a-zA-Z0-9\-_]+)\)/);<br>    if (m && m[1]) {<br>      const [contractAddress, contractName] = m[1].split('.');<br>      return { contractAddress, contractName };<br>    }<br>    const j: any = cvToJSON(cv);<br>    if (j?.type === 'some' && j?.value) {<br>      const inner = j.value;<br>      const contractAddress = inner.address ?? inner.contractAddress;<br>      const contractName = inner.contractName ?? inner.name;<br>      if (contractAddress && contractName) return { contractAddress, contractName };<br>    }<br>    throw new Error(`Unexpected optional contract-principal shape: ${asString}`);<br>  }<br><br>  decodeOptionalSubscriptionTuple(cv: ClarityValue, idHex: string): OnChainSubscription or undefined {<br>    const j: any = cvToJSON(cv);<br>    if (j.type === 'none') return undefined;<br>    const t: any = j.value;<br>    const merchant = String(t['merchant']);<br>    const subscriber = String(t['subscriber']);<br>    const amountSats = BigInt(t['amount']);<br>    const intervalBlocks = BigInt(t['interval']);<br>    const active = Boolean(t['active']);<br>    const nextDue = BigInt(t['next-due']);<br>    return { idHex, merchant, subscriber, amountSats, intervalBlocks, active, nextDue };<br>  }<br>}<br><br>export default ClarityCvAdapter;<br>```<br><br>--- |
| WebhookSignatureService | - **[Offloading Class Names]**: WebhookDispatcher<br>- **[Originating Method Ids]**: WD-VERIFY-WEBHOOK-SIGNATURE, WD-1<br><br>Delegate State Owned:<br>- replayCache: Map<string, number> // signature header → firstSeenEpochSecs<br>- maxSkewSeconds: number<br>- replayTtlSeconds: number<br><br>Delegate Responsibilities Owned:<br>- Compute outbound HMAC SHA-256 signature for webhook bodies using `${ts}.${rawBody}` format.<br>- Build outbound headers: X-Webhook-Timestamp and X-Webhook-Signature.<br>- Verify inbound headers against secret:<br>  - Validate presence<br>  - Enforce max clock skew<br>  - Prevent replay within TTL<br>  - Timing-safe signature compare<br>  - Record signature in replay cache<br><br>Responsibilities Removed from Parent Class:<br>- All HMAC math, header building, and replay cache logic for inbound verification and outbound signing.<br><br>Delegate Public Interface:<br>- buildOutboundHeaders(secret: string, rawBody: string, nowEpochSecs: number): { headers: Record<string, string>; signatureHex: string; timestamp: number }<br>- verifyInbound(tsHeader: string or undefined, sigHeader: string or undefined, rawBody: string, secret: string, nowEpochSecs: number): { ok: true } or { ok: false; status: 401 or 409 }<br><br>Example Interaction:<br>```typescript<br>// Inside WebhookDispatcher.dispatch()<br>const { headers } = this.sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now);<br>// Inside WebhookDispatcher.verifyWebhookSignature()<br>const decision = this.sigSvc.verifyInbound(tsHeader, sigHeader, rawBody, secret, now);<br>```<br><br>#### 🔁 Refactored Method: WebhookDispatcher.verifyWebhookSignature<br>Breakdown after refactoring:<br>- Parent reads headers and raw body, resolves secret from store.<br>- Delegates verification (presence, skew, replay, timing-safe compare) to WebhookSignatureService.verifyInbound.<br>- Maps decision to 200/401/409 and calls next() if ok.<br><br>```typescript<br>// snippet inside src/webhooks/WebhookDispatcher.ts<br>import { WebhookSignatureService } from '../delegates/WebhookSignatureService';<br><br>export class WebhookDispatcher {<br>  private readonly sigSvc = new WebhookSignatureService();<br><br>  verifyWebhookSignature(req: Request, res: Response, next: NextFunction): void {<br>    const tsHeader = req.header('X-Webhook-Timestamp') or req.header('x-webhook-timestamp');<br>    const sigHeader = req.header('X-Webhook-Signature') or req.header('x-webhook-signature');<br>    const rawBody = typeof req.body === 'string' ? req.body : Buffer.isBuffer(req.body) ? req.body.toString('utf8') : '';<br>    if (!tsHeader or !sigHeader) {<br>      res.status(401).end();<br>      return;<br>    }<br>    const secret: string = (this.store as any).getStoreHmacSecretForInbound(req);<br>    const now = Math.floor(Date.now() / 1000);<br>    const decision = this.sigSvc.verifyInbound(tsHeader, sigHeader, rawBody, secret, now);<br>    if (!decision.ok) {<br>      res.status(decision.status).end();<br>      return;<br>    }<br>    next();<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: WebhookDispatcher.dispatch<br>Breakdown after refactoring:<br>- Persists attempt row (see AttemptPlanner delegate in next section for full attempt handling).<br>- Delegates HMAC signature and header construction to WebhookSignatureService.buildOutboundHeaders.<br>- Sends HTTP request with returned headers.<br><br>```typescript<br>// snippet inside src/webhooks/WebhookDispatcher.ts<br>import { WebhookSignatureService } from '../delegates/WebhookSignatureService';<br><br>export class WebhookDispatcher {<br>  private readonly sigSvc = new WebhookSignatureService();<br>  // ...<br><br>  async dispatch(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts?: number }): Promise<void> {<br>    const dest = await this.resolveDestinationAndSecret(ctx.storeId, ctx.invoiceId);<br>    if (!dest.url) return;<br><br>    const attemptNumber = ctx.attempts ? ctx.attempts : 1;<br>    const now = Math.floor(Date.now() / 1000);<br><br>    // Persist attempt row before send (see AttemptPlanner delegate below for factoring this out)<br>    const attemptId = crypto.randomUUID();<br>    this.store.insertWebhookAttempt({<br>      id: attemptId,<br>      store_id: ctx.storeId,<br>      invoice_id: ctx.invoiceId,<br>      subscription_id: ctx.subscriptionId,<br>      event_type: ctx.eventType as any,<br>      payload: ctx.rawBody,<br>      status_code: null as any,<br>      success: 0,<br>      attempts: attemptNumber,<br>      last_attempt_at: now,<br>    });<br><br>    const { headers } = this.sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now);<br><br>    try {<br>      const resp = await axios.post(dest.url, ctx.rawBody, { headers, timeout: 10000 });<br>      if (resp.status >= 200 && resp.status < 300) {<br>        await this.onHttpSuccess({ attemptLogId: attemptId, status: resp.status });<br>      } else {<br>        await this.onHttpFailure({ attemptLogId: attemptId, attempts: attemptNumber, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType as any, rawBody: ctx.rawBody }, resp.status);<br>      }<br>    } catch (err: any) {<br>      const status = err?.response?.status as number or undefined;<br>      await this.onHttpFailure({ attemptLogId: attemptId, attempts: attemptNumber, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType as any, rawBody: ctx.rawBody }, status);<br>    }<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: buildOutboundHeaders<br>Responsibility:<br>- Deterministically compute signature and return headers dictionary with timestamp and signature.<br><br>```typescript<br>// src/delegates/WebhookSignatureService.ts<br>import crypto from 'crypto';<br><br>export class WebhookSignatureService {<br>  constructor(private readonly maxSkewSeconds: number = 300, private readonly replayTtlSeconds: number = 600) {}<br><br>  private replayCache = new Map<string, number>();<br><br>  buildOutboundHeaders(secret: string, rawBody: string, nowEpochSecs: number): { headers: Record<string, string>; signatureHex: string; timestamp: number } {<br>    const signatureHex = crypto.createHmac('sha256', secret).update(`${nowEpochSecs}.${rawBody}`).digest('hex');<br>    return {<br>      signatureHex,<br>      timestamp: nowEpochSecs,<br>      headers: {<br>        'Content-Type': 'application/json',<br>        'X-Webhook-Timestamp': String(nowEpochSecs),<br>        'X-Webhook-Signature': `v1=${signatureHex}`,<br>      },<br>    };<br>  }<br><br>  verifyInbound(tsHeader: string or undefined, sigHeader: string or undefined, rawBody: string, secret: string, nowEpochSecs: number): { ok: true } or { ok: false; status: 401 or 409 } {<br>    if (!tsHeader or !sigHeader) return { ok: false, status: 401 };<br>    const ts = Number(tsHeader);<br>    if (!Number.isFinite(ts) or Math.abs(nowEpochSecs - ts) > this.maxSkewSeconds) return { ok: false, status: 401 };<br><br>    // Replay protection<br>    const seenAt = this.replayCache.get(sigHeader);<br>    if (seenAt && nowEpochSecs - seenAt <= this.replayTtlSeconds) return { ok: false, status: 409 };<br><br>    const presented = sigHeader.startsWith('v1=') ? sigHeader.slice(3) : sigHeader;<br>    const expected = crypto.createHmac('sha256', secret).update(`${ts}.${rawBody}`).digest('hex');<br><br>    const a = Buffer.from(expected, 'hex');<br>    const b = Buffer.from(presented, 'hex');<br>    if (a.length !== b.length or !crypto.timingSafeEqual(a, b)) return { ok: false, status: 401 };<br><br>    this.replayCache.set(sigHeader, nowEpochSecs);<br>    // prune expired<br>    for (const [sig, firstSeen] of this.replayCache.entries()) {<br>      if (nowEpochSecs - firstSeen > this.replayTtlSeconds) this.replayCache.delete(sig);<br>    }<br>    return { ok: true };<br>  }<br>}<br><br>export default WebhookSignatureService;<br>```<br><br>--- |
| WebhookAttemptPlanner | - **[Offloading Class Names]**: WebhookDispatcher<br>- **[Originating Method Ids]**: WD-1, WD-3, WD-4<br><br>Delegate State Owned:<br>- None (stateless; writes/updates persisted rows via ISqliteStore).<br><br>Delegate Responsibilities Owned:<br>- Insert initial webhook_logs attempt rows before network I/O.<br>- Update attempt success/failure status codes.<br>- Compute capped exponential backoff (attempts up to 5) and plan next attempts by inserting rows without sending.<br><br>Responsibilities Removed from Parent Class:<br>- All DB operations for attempt rows and backoff planning for WD-1, WD-3, WD-4.<br><br>Delegate Public Interface:<br>- recordInitialAttempt(store: ISqliteStore, ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts: number; now: number }): string<br>- markSuccess(store: ISqliteStore, attemptLogId: string, status: number): void<br>- handleFailureAndPlanNext(store: ISqliteStore, ctx: { attemptLogId: string; attempts: number; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; now: number }): void<br>- planNextAttempt(store: ISqliteStore, ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts: number; now: number }): void<br><br>Example Interaction:<br>```typescript<br>// In WebhookDispatcher.dispatch()<br>const attemptId = this.attempts.recordInitialAttempt(this.store, { storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType, rawBody: ctx.rawBody, attempts: attemptNumber, now });<br>// In WebhookDispatcher.onHttpFailure()<br>await this.attempts.handleFailureAndPlanNext(this.store, { attemptLogId: ctx.attemptLogId, attempts: ctx.attempts, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType, rawBody: ctx.rawBody, now: Math.floor(Date.now()/1000) });<br>```<br><br>#### 🔁 Refactored Method: WebhookDispatcher.dispatch<br>Breakdown after refactoring:<br>- Delegates initial attempt persistence to WebhookAttemptPlanner.recordInitialAttempt.<br>- Delegates success/failure DB updates to attempt planner methods used by onHttpSuccess/onHttpFailure.<br><br>```typescript<br>// snippet inside src/webhooks/WebhookDispatcher.ts<br>import { WebhookAttemptPlanner } from '../delegates/WebhookAttemptPlanner';<br><br>export class WebhookDispatcher {<br>  private readonly attempts = new WebhookAttemptPlanner();<br>  // ...<br><br>  async dispatch(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts?: number }): Promise<void> {<br>    const dest = await this.resolveDestinationAndSecret(ctx.storeId, ctx.invoiceId);<br>    if (!dest.url) return;<br><br>    const attemptNumber = ctx.attempts ? ctx.attempts : 1;<br>    const now = Math.floor(Date.now() / 1000);<br>    const attemptId = this.attempts.recordInitialAttempt(this.store, {<br>      storeId: ctx.storeId,<br>      invoiceId: ctx.invoiceId,<br>      subscriptionId: ctx.subscriptionId,<br>      eventType: ctx.eventType,<br>      rawBody: ctx.rawBody,<br>      attempts: attemptNumber,<br>      now,<br>    });<br><br>    const { headers } = this.sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now);<br><br>    try {<br>      const resp = await axios.post(dest.url, ctx.rawBody, { headers, timeout: 10000 });<br>      if (resp.status >= 200 && resp.status < 300) {<br>        await this.onHttpSuccess({ attemptLogId: attemptId, status: resp.status });<br>      } else {<br>        await this.onHttpFailure({ attemptLogId: attemptId, attempts: attemptNumber, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType as any, rawBody: ctx.rawBody }, resp.status);<br>      }<br>    } catch (err: any) {<br>      const status = err?.response?.status as number or undefined;<br>      await this.onHttpFailure({ attemptLogId: attemptId, attempts: attemptNumber, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType as any, rawBody: ctx.rawBody }, status);<br>    }<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: WebhookDispatcher.onHttpFailure<br>Breakdown after refactoring:<br>- Delegates failure status update and next-attempt planning to WebhookAttemptPlanner.handleFailureAndPlanNext.<br><br>```typescript<br>// snippet inside src/webhooks/WebhookDispatcher.ts<br>async onHttpFailure(<br>  ctx: { attemptLogId: string; attempts: number; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: any; rawBody: string },<br>  statusOrNull?: number,<br>): Promise<void> {<br>  const now = Math.floor(Date.now() / 1000);<br>  await this.attempts.handleFailureAndPlanNext(this.store, {<br>    attemptLogId: ctx.attemptLogId,<br>    attempts: ctx.attempts,<br>    storeId: ctx.storeId,<br>    invoiceId: ctx.invoiceId,<br>    subscriptionId: ctx.subscriptionId,<br>    eventType: ctx.eventType,<br>    rawBody: ctx.rawBody,<br>    now,<br>  }, statusOrNull);<br>}<br>```<br><br>#### 🔁 Refactored Method: WebhookDispatcher.planRetry<br>Breakdown after refactoring:<br>- Delegates row insertion for the next attempt to WebhookAttemptPlanner.planNextAttempt with capped backoff logic.<br><br>```typescript<br>// snippet inside src/webhooks/WebhookDispatcher.ts<br>async planRetry(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: any; rawBody: string; attempts: number }): Promise<void> {<br>  const now = Math.floor(Date.now() / 1000);<br>  await this.attempts.planNextAttempt(this.store, { ...ctx, now });<br>}<br>```<br><br>#### 🔧 Delegate Method: recordInitialAttempt<br>Responsibility:<br>- Insert an initial attempt row into webhook_logs; returns the attempt id.<br><br>```typescript<br>// src/delegates/WebhookAttemptPlanner.ts<br>import crypto from 'crypto';<br>import { ISqliteStore } from '../contracts/dao';<br>import { WebhookLogRow } from '../models/domain';<br>import { RetryPolicy } from '../errors/policies';<br><br>export class WebhookAttemptPlanner {<br>  recordInitialAttempt(<br>    store: ISqliteStore,<br>    ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts: number; now: number },<br>  ): string {<br>    const id = crypto.randomUUID();<br>    const row: WebhookLogRow = {<br>      id,<br>      store_id: ctx.storeId,<br>      invoice_id: ctx.invoiceId,<br>      subscription_id: ctx.subscriptionId,<br>      event_type: ctx.eventType as any,<br>      payload: ctx.rawBody,<br>      status_code: null as any,<br>      success: 0,<br>      attempts: ctx.attempts,<br>      last_attempt_at: ctx.now,<br>    };<br>    store.insertWebhookAttempt(row);<br>    return id;<br>  }<br><br>  markSuccess(store: ISqliteStore, attemptLogId: string, status: number): void {<br>    store.updateWebhookAttemptStatus(attemptLogId, { success: 1, statusCode: status });<br>  }<br><br>  async handleFailureAndPlanNext(<br>    store: ISqliteStore,<br>    ctx: { attemptLogId: string; attempts: number; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; now: number },<br>    statusOrNull?: number,<br>  ): Promise<void> {<br>    store.updateWebhookAttemptStatus(ctx.attemptLogId, {<br>      success: 0,<br>      statusCode: typeof statusOrNull === 'number' ? statusOrNull : undefined,<br>    });<br>    if (ctx.attempts >= RetryPolicy.maxAttempts) return;<br>    await this.planNextAttempt(store, {<br>      storeId: ctx.storeId,<br>      invoiceId: ctx.invoiceId,<br>      subscriptionId: ctx.subscriptionId,<br>      eventType: ctx.eventType,<br>      rawBody: ctx.rawBody,<br>      attempts: ctx.attempts,<br>      now: ctx.now,<br>    });<br>  }<br><br>  async planNextAttempt(<br>    store: ISqliteStore,<br>    ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts: number; now: number },<br>  ): Promise<void> {<br>    const nextAttempt = ctx.attempts + 1;<br>    if (nextAttempt > RetryPolicy.maxAttempts) return;<br>    const id = crypto.randomUUID();<br>    const row: WebhookLogRow = {<br>      id,<br>      store_id: ctx.storeId,<br>      invoice_id: ctx.invoiceId,<br>      subscription_id: ctx.subscriptionId,<br>      event_type: ctx.eventType as any,<br>      payload: ctx.rawBody,<br>      status_code: null as any,<br>      success: 0,<br>      attempts: nextAttempt,<br>      last_attempt_at: ctx.now,<br>    };<br>    store.insertWebhookAttempt(row);<br>  }<br>}<br><br>export default WebhookAttemptPlanner;<br>```<br><br>#### 🔧 Delegate Method: handleFailureAndPlanNext (used by WD-3)<br>Responsibility:<br>- Update failure status for the current attempt.<br>- If attempts < 5, insert a planned retry attempt row with attempts+1 and same payload/context.<br><br>```typescript<br>// Included in WebhookAttemptPlanner above as handleFailureAndPlanNext<br>```<br><br>#### 🔧 Delegate Method: planNextAttempt (used by WD-4)<br>Responsibility:<br>- Compute nextAttempt = attempts + 1; cap at RetryPolicy.maxAttempts (5).<br>- Insert a webhook_logs row preserving exact rawBody for signature stability.<br><br>```typescript<br>// Included in WebhookAttemptPlanner above as planNextAttempt<br>```<br><br>End of report. |
| PostConditionsComposer | - **[Offloading Class Names]**: ContractCallBuilder<br>- **[Originating Method Ids]**: CCB-BUILD-REFUND-INVOICE, CCB-BUILD-PAY-SUBSCRIPTION<br><br>Delegate State Owned:<br>- None (stateless, pure composition of post-conditions)<br><br>Delegate Responsibilities Owned:<br>- Build correct sBTC fungible post-conditions for:<br>  - Refund flows (merchant outgoing cap)<br>  - Pay flows (payer sent ≥ amount, merchant received ≥ amount)<br>- Resolve sBTC asset info using AssetInfoFactory<br>- Compose the postConditionMode and postConditions payload expected by the parent<br><br>Responsibilities Removed from Parent Class:<br>- Direct handling of asset info retrieval and post-condition array construction in refund and pay builder methods<br><br>Delegate Public Interface:<br>- forRefund(merchantPrincipal: string, amountSats: number): { postConditionMode: 'deny'; postConditions: any[] }<br>- forPay(payerPrincipal: string, merchantPrincipal: string, amountSats: number): { postConditionMode: 'deny'; postConditions: any[] }<br><br>Example Interaction:<br>```typescript<br>// Inside ContractCallBuilder method<br>const pcs = new PostConditionsComposer(this.aif, this.pcf).forPay(args.subscriber, args.merchant, args.amountSats);<br>return this.baseCall('pay-subscription', [bufferCV(idBuf)], pcs);<br>```<br><br>#### 🔁 Refactored Method: ContractCallBuilder.buildRefundInvoice<br>Breakdown after refactoring:<br>- Validates idHex and amount<br>- Encodes [id, amount, optionalMemo] as CVs<br>- Delegates post-condition composition to PostConditionsComposer.forRefund<br>- Calls baseCall with Deny mode and returned post-conditions<br><br>```typescript<br>buildRefundInvoice(args: {<br>  idHex: string;<br>  amountSats: number;<br>  memo?: string;<br>  merchantPrincipal: string;<br>}): UnsignedContractCall {<br>  this.codec.assertHex64(args.idHex);<br>  this.assertPositiveInt(args.amountSats, 'amountSats');<br>  // Validate principal via CV construction<br>  void standardPrincipalCV(args.merchantPrincipal);<br><br>  const idBuf = this.codec.toBuff32Hex(args.idHex);<br><br>  const memoOpt = new OptionalBuff34Encoder().encodeOptionalUtf8ToBuff34(args.memo);<br>  const pcs = new PostConditionsComposer(this.aif, this.pcf).forRefund(<br>    args.merchantPrincipal,<br>    args.amountSats<br>  );<br><br>  const functionArgs = [bufferCV(idBuf), uintCV(args.amountSats), memoOpt];<br>  return this.baseCall('refund-invoice', functionArgs, pcs);<br>}<br>```<br><br>#### 🔁 Refactored Method: ContractCallBuilder.buildPaySubscription<br>Breakdown after refactoring:<br>- Validates idHex and amount<br>- Encodes [id] as CV<br>- Delegates post-condition composition to PostConditionsComposer.forPay<br>- Calls baseCall with Deny mode and returned post-conditions<br><br>```typescript<br>buildPaySubscription(args: {<br>  idHex: string;<br>  amountSats: number;<br>  subscriber: string;<br>  merchant: string;<br>}): UnsignedContractCall {<br>  this.codec.assertHex64(args.idHex);<br>  this.assertPositiveInt(args.amountSats, 'amountSats');<br>  void standardPrincipalCV(args.subscriber);<br>  void standardPrincipalCV(args.merchant);<br><br>  const idBuf = this.codec.toBuff32Hex(args.idHex);<br>  const pcs = new PostConditionsComposer(this.aif, this.pcf).forPay(<br>    args.subscriber,<br>    args.merchant,<br>    args.amountSats<br>  );<br><br>  const functionArgs = [bufferCV(idBuf)];<br>  return this.baseCall('pay-subscription', functionArgs, pcs);<br>}<br>```<br><br>#### 🔧 Delegate Method: forRefund<br>- Responsibility: Compose a Deny-mode post-condition array capping merchant outgoing sBTC to amountSats.<br>- Signature: forRefund(merchantPrincipal: string, amountSats: number): { postConditionMode: 'deny'; postConditions: any[] }<br>```typescript<br>import type { IAssetInfoFactory, IPostConditionFactory } from '../contracts/interfaces';<br><br>export class PostConditionsComposer {<br>  constructor(<br>    private aif: IAssetInfoFactory,<br>    private pcf: IPostConditionFactory<br>  ) {}<br><br>  forRefund(merchantPrincipal: string, amountSats: number): { postConditionMode: 'deny'; postConditions: any[] } {<br>    const asset = this.aif.getSbtcAssetInfo();<br>    const postConditions = this.pcf.forRefund(merchantPrincipal, amountSats, asset);<br>    return {<br>      postConditionMode: 'deny',<br>      postConditions,<br>    };<br>  }<br><br>  forPay(<br>    payerPrincipal: string,<br>    merchantPrincipal: string,<br>    amountSats: number<br>  ): { postConditionMode: 'deny'; postConditions: any[] } {<br>    const asset = this.aif.getSbtcAssetInfo();<br>    const postConditions = this.pcf.forPayInvoice(payerPrincipal, merchantPrincipal, amountSats, asset);<br>    return {<br>      postConditionMode: 'deny',<br>      postConditions,<br>    };<br>  }<br>}<br>```<br><br>--- |
| OptionalBuff34Encoder | - **[Offloading Class Names]**: ContractCallBuilder<br>- **[Originating Method Ids]**: CCB-BUILD-CREATE-INVOICE, CCB-BUILD-REFUND-INVOICE, CCB-BUILD-REGISTER-MERCHANT<br><br>Delegate State Owned:<br>- None<br><br>Delegate Responsibilities Owned:<br>- Encode optional UTF-8 strings into Clarity optional (buff 34)<br>- Enforce max byte length 34 with UTF-8 truncation<br>- Provide a single, consistent encoding path for memo/name optional args<br><br>Responsibilities Removed from Parent Class:<br>- Inline memo/name optional encoding logic inside builder methods<br><br>Delegate Public Interface:<br>- encodeOptionalUtf8ToBuff34(input?: string or null): import('@stacks/transactions').ClarityValue<br><br>Example Interaction:<br>```typescript<br>const memoOpt = new OptionalBuff34Encoder().encodeOptionalUtf8ToBuff34(args.memo);<br>```<br><br>#### 🔁 Refactored Method: ContractCallBuilder.buildCreateInvoice<br>Breakdown after refactoring:<br>- Validates idHex, amount, and optional expiresAtBlock<br>- Encodes id and amount as CVs<br>- Delegates optional memo encoding to OptionalBuff34Encoder<br>- Calls baseCall without post-conditions<br><br>```typescript<br>buildCreateInvoice(args: {<br>  idHex: string;<br>  amountSats: number;<br>  memo?: string;<br>  expiresAtBlock?: number;<br>}): UnsignedContractCall {<br>  this.codec.assertHex64(args.idHex);<br>  this.assertPositiveInt(args.amountSats, 'amountSats');<br>  if (args.expiresAtBlock !== undefined) {<br>    this.assertNonNegativeInt(args.expiresAtBlock, 'expiresAtBlock');<br>  }<br><br>  const idBuf = this.codec.toBuff32Hex(args.idHex);<br>  const memoOpt = new OptionalBuff34Encoder().encodeOptionalUtf8ToBuff34(args.memo);<br><br>  const functionArgs = [<br>    bufferCV(idBuf),<br>    uintCV(args.amountSats),<br>    memoOpt,<br>    args.expiresAtBlock !== undefined ? someCV(uintCV(args.expiresAtBlock)) : noneCV(),<br>  ];<br><br>  return this.baseCall('create-invoice', functionArgs);<br>}<br>```<br><br>#### 🔁 Refactored Method: ContractCallBuilder.buildRegisterMerchant<br>Breakdown after refactoring:<br>- Validates merchant principal by CV construction<br>- Delegates optional name encoding to OptionalBuff34Encoder<br>- Calls baseCall without post-conditions<br><br>```typescript<br>buildRegisterMerchant(args: { merchant: string; name?: string }): UnsignedContractCall {<br>  const merchantCv = standardPrincipalCV(args.merchant);<br>  const nameOpt = new OptionalBuff34Encoder().encodeOptionalUtf8ToBuff34(args.name);<br>  const functionArgs = [merchantCv, nameOpt];<br>  return this.baseCall('register-merchant', functionArgs);<br>}<br>```<br><br>#### 🔧 Delegate Method: encodeOptionalUtf8ToBuff34<br>- Responsibility: Convert optional UTF-8 string into some(buffer 34) or none CV.<br>- Signature: encodeOptionalUtf8ToBuff34(input?: string or null): ClarityValue<br>- Behavior:<br>  - If input is undefined, null, or empty string, return noneCV()<br>  - Otherwise, UTF-8 encode and truncate to max 34 bytes, return someCV(bufferCV(truncated))<br><br>```typescript<br>import type { ClarityValue } from '@stacks/transactions';<br>import { bufferCV, someCV, noneCV } from '@stacks/transactions';<br><br>export class OptionalBuff34Encoder {<br>  encodeOptionalUtf8ToBuff34(input?: string or null): ClarityValue {<br>    if (input === undefined or input === null or input === '') {<br>      return noneCV();<br>    }<br>    const buf = Buffer.from(input, 'utf8').subarray(0, 34);<br>    return someCV(bufferCV(buf));<br>  }<br>}<br>```<br><br>--- |
| SubscriptionInvoicePlanner | - **[Offloading Class Names]**: SubscriptionScheduler<br>- **[Originating Method Ids]**: SUBS-2<br><br>Delegate State Owned:<br>- None (stateless across calls)<br><br>Delegate Responsibilities Owned:<br>- Generate unique on-chain invoice identifiers:<br>  - idHex (64-hex for buff32)<br>  - idBuf32 (Uint8Array)<br>  - idRaw (UUID string)<br>  - Ensure idHex uniqueness via ISqliteStore.ensureInvoiceIdHexUnique<br>- Compute quote expiry timestamps and block-based expiry:<br>  - quoteExpiresAtMs = now + QUOTE_TTL_SECONDS * 1000<br>  - expiresAtBlocks = currentHeight + ceil(QUOTE_TTL_SECONDS / AVG_BLOCK_SECONDS)<br>- Fetch USD price snapshot at creation<br>- Compute nextDue = subscription.next_invoice_at + subscription.interval_blocks<br>- Build webhook raw body JSON for “subscription” event<br><br>Responsibilities Removed from Parent Class:<br>- Inline generation of ids and uniqueness loop<br>- Computation of expiry windows and nextDue<br>- Construction of webhook payload JSON string<br><br>Delegate Public Interface:<br>- plan(subscription: SubscriptionRow, currentHeight: number): Promise<PlannedInvoice><br>- buildWebhookRawBody(planned: PlannedInvoice, subscription: SubscriptionRow): string<br><br>Example Interaction:<br>```typescript<br>const planner = new SubscriptionInvoicePlanner(this.store, this.pricing, this.cfg, this.codec);<br>const planned = await planner.plan(sub, ctx.currentHeight);<br>await this.broadcastCreateInvoiceTx({<br>  idBuf32: planned.idBuf32,<br>  amountSats: sub.amount_sats,<br>  expiresAtBlocks: planned.expiresAtBlocks,<br>});<br>this.store.invoices.insert({<br>  id_raw: planned.idRaw,<br>  id_hex: planned.idHex,<br>  store_id: sub.store_id,<br>  amount_sats: sub.amount_sats,<br>  usd_at_create: planned.usdAtCreate,<br>  quote_expires_at: planned.quoteExpiresAtMs,<br>  merchant_principal: sub.merchant_principal,<br>  status: 'unpaid',<br>  payer: undefined,<br>  txid: undefined,<br>  memo: undefined,<br>  webhook_url: undefined,<br>  created_at: Math.floor(Date.now() / 1000),<br>  refunded_at: undefined,<br>  refund_amount: 0,<br>  refund_txid: undefined,<br>  subscription_id: sub.id,<br>  refund_count: 0,<br>  expired: 0,<br>});<br>this.store.advanceSubscriptionSchedule(sub.id);<br>const rawBody = planner.buildWebhookRawBody(planned, sub);<br>await this.dispatcher.dispatch({<br>  storeId: sub.store_id,<br>  subscriptionId: sub.id,<br>  invoiceId: planned.idRaw,<br>  eventType: 'subscription',<br>  rawBody,<br>});<br>```<br><br>#### 🔁 Refactored Method: SubscriptionScheduler.onSubscriptionInvoiceCreated<br>Breakdown after refactoring:<br>- Delegates all planning computations (ids, expiries, usd snapshot, nextDue) and webhook payload building to SubscriptionInvoicePlanner<br>- Retains broadcasting via existing SUBS-BCAST-INV-1<br>- Retains persistence and schedule advancement (transactional sequence remains in parent)<br><br>```typescript<br>async onSubscriptionInvoiceCreated(ctx: { subscription: SubscriptionRow; currentHeight: number }): Promise<void> {<br>  const sub = ctx.subscription;<br><br>  const planner = new SubscriptionInvoicePlanner(this.store, this.pricing, this.cfg, this.codec);<br>  const planned = await planner.plan(sub, ctx.currentHeight);<br><br>  await this.broadcastCreateInvoiceTx({<br>    idBuf32: planned.idBuf32,<br>    amountSats: sub.amount_sats,<br>    memo: undefined,<br>    expiresAtBlocks: planned.expiresAtBlocks,<br>  });<br><br>  const nowSecs = Math.floor(Date.now() / 1000);<br>  this.store.invoices.insert({<br>    id_raw: planned.idRaw,<br>    id_hex: planned.idHex,<br>    store_id: sub.store_id,<br>    amount_sats: sub.amount_sats,<br>    usd_at_create: planned.usdAtCreate,<br>    quote_expires_at: planned.quoteExpiresAtMs,<br>    merchant_principal: sub.merchant_principal,<br>    status: 'unpaid',<br>    payer: undefined,<br>    txid: undefined,<br>    memo: undefined,<br>    webhook_url: undefined,<br>    created_at: nowSecs,<br>    refunded_at: undefined,<br>    refund_amount: 0,<br>    refund_txid: undefined,<br>    subscription_id: sub.id,<br>    refund_count: 0,<br>    expired: 0,<br>  });<br>  this.store.advanceSubscriptionSchedule(sub.id);<br><br>  const rawBody = planner.buildWebhookRawBody(planned, sub);<br>  await this.dispatcher.dispatch({<br>    storeId: sub.store_id,<br>    subscriptionId: sub.id,<br>    invoiceId: planned.idRaw,<br>    eventType: 'subscription',<br>    rawBody,<br>  });<br>}<br>```<br><br>#### 🔧 Delegate Method: plan<br>- Responsibility: Produce a complete, unique, and validated invoice planning artifact with ids, expiry windows, USD snapshot, and nextDue.<br>- Signature: plan(subscription: SubscriptionRow, currentHeight: number): Promise<PlannedInvoice><br><br>```typescript<br>import crypto from 'crypto';<br>import type { ISqliteStore } from '../contracts/dao';<br>import type { IInvoiceIdCodec, IConfigService } from '../contracts/interfaces';<br>import type { SubscriptionRow } from '../models/domain';<br>import { PricingService } from '../services/PricingService';<br><br>export type PlannedInvoice = {<br>  idHex: string;<br>  idBuf32: Uint8Array;<br>  idRaw: string;<br>  usdAtCreate: number;<br>  quoteExpiresAtMs: number;<br>  expiresAtBlocks: number;<br>  nextDue: number;<br>};<br><br>export class SubscriptionInvoicePlanner {<br>  constructor(<br>    private store: ISqliteStore,<br>    private pricing: PricingService,<br>    private cfg: IConfigService,<br>    private codec: IInvoiceIdCodec<br>  ) {}<br><br>  async plan(subscription: SubscriptionRow, currentHeight: number): Promise<PlannedInvoice> {<br>    const ttlSecs = Number(process.env.QUOTE_TTL_SECONDS);<br>    if (!Number.isFinite(ttlSecs) or ttlSecs <= 0) {<br>      throw new Error('Missing or invalid QUOTE_TTL_SECONDS.');<br>    }<br><br>    let idHex: string;<br>    do {<br>      idHex = this.codec.generateRandomBuff32Hex();<br>      this.codec.assertHex64(idHex);<br>    } while (!this.store.ensureInvoiceIdHexUnique(idHex));<br><br>    const idBuf32 = this.codec.toBuff32Hex(idHex);<br>    const idRaw = crypto.randomUUID();<br><br>    const usdAtCreate = await this.pricing.getUsdPriceSnapshot();<br>    const nowMs = Date.now();<br><br>    const avgBlockSecs = this.cfg.getAvgBlockSecs();<br>    const expiresAtBlocks = currentHeight + Math.ceil(ttlSecs / avgBlockSecs);<br>    const quoteExpiresAtMs = nowMs + ttlSecs * 1000;<br><br>    const nextDue = subscription.next_invoice_at + subscription.interval_blocks;<br><br>    return {<br>      idHex,<br>      idBuf32,<br>      idRaw,<br>      usdAtCreate,<br>      quoteExpiresAtMs,<br>      expiresAtBlocks,<br>      nextDue,<br>    };<br>  }<br><br>  buildWebhookRawBody(planned: PlannedInvoice, subscription: SubscriptionRow): string {<br>    return JSON.stringify({<br>      subscriptionId: subscription.id,<br>      invoiceId: planned.idRaw,<br>      amountSats: subscription.amount_sats,<br>      nextDue: planned.nextDue,<br>      subscriber: subscription.subscriber,<br>    });<br>  }<br>}<br>```<br><br>End of report. |
| WebhookRetryQueryComposer | - **[Offloading Class Names]**: SqliteStore<br>- **[Originating Method Ids]**: SS-1, SS-2, SS-EXISTS-SUCCESSFUL-DELIVERY-FOR, SS-HAS-EXP-WH-1<br><br>Delegate State Owned:<br>- maxAttempts: number — upper limit of retry attempts enforced by queries.<br>- backoffSeconds: number[] — per-attempt backoff in seconds. Index equals attempts value; values beyond the array length use the last element.<br><br>Delegate Responsibilities Owned:<br>- Compose deterministic SQL for webhook retry selection with backoff and deduplication by logical context.<br>- Compose parameterized SQL for time-parametric attempt selection.<br>- Build strict context predicates to check for successful deliveries (prevents double retries or duplicate “expired” events).<br>- Provide single source of truth for retry/backoff policy across DAO methods.<br><br>Responsibilities Removed from Parent Class:<br>- Hardcoded CASE expression logic for backoff windows.<br>- Context predicate assembly for “exists successful delivery” and “has successful expired webhook”.<br><br>Delegate Public Interface:<br>```typescript<br>export type ComposedQuery = { sql: string; params: any[] };<br><br>export type WebhookEventType =<br>  or 'paid'<br>  or 'refunded'<br>  or 'subscription'<br>  or 'subscription-created'<br>  or 'subscription-paid'<br>  or 'subscription-canceled'<br>  or 'invoice-expired';<br><br>export interface WebhookRetryQueryComposerOptions {<br>  maxAttempts: number;<br>  backoffSeconds: number[]; // e.g., [0, 60, 120, 240, 480, 960]<br>}<br><br>export class WebhookRetryQueryComposer {<br>  private readonly maxAttempts: number;<br>  private readonly backoffSeconds: number[];<br><br>  constructor(opts: WebhookRetryQueryComposerOptions) {<br>    if (!opts or !Array.isArray(opts.backoffSeconds) or opts.backoffSeconds.length === 0) {<br>      throw new Error('backoffSeconds must be a non-empty array');<br>    }<br>    if (typeof opts.maxAttempts !== 'number' or opts.maxAttempts <= 0) {<br>      throw new Error('maxAttempts must be a positive number');<br>    }<br>    this.maxAttempts = opts.maxAttempts;<br>    this.backoffSeconds = opts.backoffSeconds;<br>  }<br><br>  composeSelectDueRetriesSQL(): ComposedQuery {<br>    const backoffCase = this.buildCaseExpr('w.attempts');<br>    const sql = `<br>      SELECT *<br>      FROM webhook_logs w<br>      WHERE w.success = 0<br>        AND w.attempts < ${ this.maxAttempts }<br>        AND (<br>          (strftime('%s','now') - w.last_attempt_at) >= ${ backoffCase }<br>        )<br>        AND w.last_attempt_at = (<br>          SELECT MAX(w2.last_attempt_at)<br>          FROM webhook_logs w2<br>          WHERE w2.store_id = w.store_id<br>            AND COALESCE(w2.invoice_id, '') = COALESCE(w.invoice_id, '')<br>            AND COALESCE(w2.subscription_id, '') = COALESCE(w.subscription_id, '')<br>            AND w2.event_type = w.event_type<br>        )<br>      ORDER BY w.last_attempt_at ASC<br>    `;<br>    return { sql, params: [] };<br>  }<br><br>  composeGetDueAttemptsSQL(nowEpochSecs: number): ComposedQuery {<br>    const backoffCase = this.buildCaseExpr('attempts');<br>    const sql = `<br>      SELECT *<br>      FROM webhook_logs<br>      WHERE success = 0<br>        AND attempts < ${ this.maxAttempts }<br>        AND (? - last_attempt_at) >= ${ backoffCase }<br>      ORDER BY last_attempt_at ASC<br>    `;<br>    return { sql, params: [nowEpochSecs] };<br>  }<br><br>  composeExistsSuccessfulDeliverySQL(ctx: {<br>    storeId: string;<br>    invoiceId?: string;<br>    subscriptionId?: string;<br>    eventType: WebhookEventType;<br>  }): ComposedQuery {<br>    const sql = `<br>      SELECT 1<br>      FROM webhook_logs<br>      WHERE store_id = ?<br>        AND event_type = ?<br>        AND (invoice_id IS ? OR invoice_id = ?)<br>        AND (subscription_id IS ? OR subscription_id = ?)<br>        AND success = 1<br>      LIMIT 1<br>    `;<br>    const params = [<br>      ctx.storeId,<br>      ctx.eventType,<br>      ctx.invoiceId ?? null,<br>      ctx.invoiceId ?? null,<br>      ctx.subscriptionId ?? null,<br>      ctx.subscriptionId ?? null,<br>    ];<br>    return { sql, params };<br>  }<br><br>  composeHasSuccessfulExpiredWebhookSQL(storeId: string, invoiceId: string): ComposedQuery {<br>    const sql = `<br>      SELECT 1<br>      FROM webhook_logs<br>      WHERE store_id = ?<br>        AND invoice_id = ?<br>        AND event_type = 'invoice-expired'<br>        AND success = 1<br>      LIMIT 1<br>    `;<br>    return { sql, params: [storeId, invoiceId] };<br>  }<br><br>  private buildCaseExpr(attemptsColumn: string): string {<br>    // Map attempts → backoffSeconds CASE; anything >= length uses last value<br>    const whens = this.backoffSeconds<br>      .map((sec, idx) => `WHEN ${ idx } THEN ${ sec }`)<br>      .join(' ');<br>    const last = this.backoffSeconds[this.backoffSeconds.length - 1];<br>    return `CASE ${ attemptsColumn } ${ whens } ELSE ${ last } END`;<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Inside SqliteStore constructor<br>private readonly webhookRetryComposer = new WebhookRetryQueryComposer({<br>  maxAttempts: 5,<br>  backoffSeconds: [0, 60, 120, 240, 480, 960],<br>});<br><br>// Usage in methods (see refactored methods below)<br>const { sql, params } = this.webhookRetryComposer.composeGetDueAttemptsSQL(nowEpochSecs);<br>const rows = this.db.prepare(sql).all(...params);<br>```<br><br>#### 🔁 Refactored Method: SqliteStore.selectDueWebhookRetries<br>Breakdown after refactor:<br>- SqliteStore delegates retry/backoff SQL composition and dedup logic to WebhookRetryQueryComposer.<br>- Parent only executes the composed SQL and returns rows.<br><br>```typescript<br>// Before: inline CASE logic and dedup subquery in SqliteStore<br>// After: delegate-composed SQL<br>selectDueWebhookRetries(): WebhookLogRow[] {<br>  const { sql } = this.webhookRetryComposer.composeSelectDueRetriesSQL();<br>  const rows = this.db.prepare(sql).all() as WebhookLogRow[];<br>  return rows;<br>}<br>```<br><br>#### 🔧 Delegate Method: composeSelectDueRetriesSQL<br>```typescript<br>composeSelectDueRetriesSQL(): ComposedQuery {<br>  const backoffCase = this.buildCaseExpr('w.attempts');<br>  const sql = `<br>    SELECT *<br>    FROM webhook_logs w<br>    WHERE w.success = 0<br>      AND w.attempts < ${ this.maxAttempts }<br>      AND (<br>        (strftime('%s','now') - w.last_attempt_at) >= ${ backoffCase }<br>      )<br>      AND w.last_attempt_at = (<br>        SELECT MAX(w2.last_attempt_at)<br>        FROM webhook_logs w2<br>        WHERE w2.store_id = w.store_id<br>          AND COALESCE(w2.invoice_id, '') = COALESCE(w.invoice_id, '')<br>          AND COALESCE(w2.subscription_id, '') = COALESCE(w.subscription_id, '')<br>          AND w2.event_type = w.event_type<br>      )<br>    ORDER BY w.last_attempt_at ASC<br>  `;<br>  return { sql, params: [] };<br>}<br>```<br><br>#### 🔁 Refactored Method: SqliteStore.getDueWebhookAttempts<br>Breakdown after refactor:<br>- Delegate provides parameterized SQL based on nowEpochSecs and policy state.<br>- Parent binds parameters and executes.<br><br>```typescript<br>getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[] {<br>  const { sql, params } = this.webhookRetryComposer.composeGetDueAttemptsSQL(nowEpochSecs);<br>  const rows = this.db.prepare(sql).all(...params) as WebhookLogRow[];<br>  return rows;<br>}<br>```<br><br>#### 🔧 Delegate Method: composeGetDueAttemptsSQL<br>```typescript<br>composeGetDueAttemptsSQL(nowEpochSecs: number): ComposedQuery {<br>  const backoffCase = this.buildCaseExpr('attempts');<br>  const sql = `<br>    SELECT *<br>    FROM webhook_logs<br>    WHERE success = 0<br>      AND attempts < ${ this.maxAttempts }<br>      AND (? - last_attempt_at) >= ${ backoffCase }<br>    ORDER BY last_attempt_at ASC<br>  `;<br>  return { sql, params: [nowEpochSecs] };<br>}<br>```<br><br>#### 🔁 Refactored Method: SqliteStore.existsSuccessfulDeliveryFor<br>Breakdown after refactor:<br>- Delegate builds strict event-context predicate and params.<br>- Parent executes and returns boolean.<br><br>```typescript<br>existsSuccessfulDeliveryFor(ctx: {<br>  storeId: string;<br>  invoiceId?: string;<br>  subscriptionId?: string;<br>  eventType: WebhookEventType or 'invoice-expired';<br>}): boolean {<br>  const { sql, params } = this.webhookRetryComposer.composeExistsSuccessfulDeliverySQL({<br>    storeId: ctx.storeId,<br>    invoiceId: ctx.invoiceId,<br>    subscriptionId: ctx.subscriptionId,<br>    eventType: ctx.eventType as WebhookEventType,<br>  });<br>  const row = this.db.prepare(sql).get(...params) as { 1: number } or undefined;<br>  return !!row;<br>}<br>```<br><br>#### 🔧 Delegate Method: composeExistsSuccessfulDeliverySQL<br>```typescript<br>composeExistsSuccessfulDeliverySQL(ctx: {<br>  storeId: string;<br>  invoiceId?: string;<br>  subscriptionId?: string;<br>  eventType: WebhookEventType;<br>}): ComposedQuery {<br>  const sql = `<br>    SELECT 1<br>    FROM webhook_logs<br>    WHERE store_id = ?<br>      AND event_type = ?<br>      AND (invoice_id IS ? OR invoice_id = ?)<br>      AND (subscription_id IS ? OR subscription_id = ?)<br>      AND success = 1<br>    LIMIT 1<br>  `;<br>  const params = [<br>    ctx.storeId,<br>    ctx.eventType,<br>    ctx.invoiceId ?? null,<br>    ctx.invoiceId ?? null,<br>    ctx.subscriptionId ?? null,<br>    ctx.subscriptionId ?? null,<br>  ];<br>  return { sql, params };<br>}<br>```<br><br>#### 🔁 Refactored Method: SqliteStore.hasSuccessfulExpiredWebhook<br>Breakdown after refactor:<br>- Delegate composes a static check specialized to event_type='invoice-expired'.<br>- Parent executes and casts to boolean.<br><br>```typescript<br>hasSuccessfulExpiredWebhook(storeId: string, invoiceId: string): boolean {<br>  const { sql, params } = this.webhookRetryComposer.composeHasSuccessfulExpiredWebhookSQL(storeId, invoiceId);<br>  const row = this.db.prepare(sql).get(...params) as { 1: number } or undefined;<br>  return !!row;<br>}<br>```<br><br>#### 🔧 Delegate Method: composeHasSuccessfulExpiredWebhookSQL<br>```typescript<br>composeHasSuccessfulExpiredWebhookSQL(storeId: string, invoiceId: string): ComposedQuery {<br>  const sql = `<br>    SELECT 1<br>    FROM webhook_logs<br>    WHERE store_id = ?<br>      AND invoice_id = ?<br>      AND event_type = 'invoice-expired'<br>      AND success = 1<br>    LIMIT 1<br>  `;<br>  return { sql, params: [storeId, invoiceId] };<br>}<br>```<br><br>--- |
| MerchantProjectionPolicy | - **[Offloading Class Names]**: SqliteStore<br>- **[Originating Method Ids]**: SS-LIST-MERCHANTS-PROJ<br><br>Delegate State Owned:<br>- None.<br><br>Delegate Responsibilities Owned:<br>- Provide a canonical SELECT projection that omits secret fields (api_key, hmac_secret) per SL-6-19.<br>- Map raw DB rows into the exact Omit<MerchantRow, 'api_key' or 'hmac_secret'> shape, preserving nullability semantics.<br><br>Responsibilities Removed from Parent Class:<br>- Manual maintenance of projection column lists across queries.<br>- Post-selection mapping to redact secrets.<br><br>Delegate Public Interface:<br>```typescript<br>import { MerchantRow } from '../models/domain';<br><br>export class MerchantProjectionPolicy {<br>  getListProjectionSQL(): string {<br>    return `<br>      SELECT<br>        id,<br>        principal,<br>        name,<br>        display_name,<br>        logo_url,<br>        brand_color,<br>        webhook_url,<br>        active,<br>        support_email,<br>        support_url,<br>        allowed_origins,<br>        created_at<br>      FROM merchants<br>      ORDER BY created_at DESC<br>    `;<br>  }<br><br>  mapListRow(raw: any): Omit<MerchantRow, 'api_key' or 'hmac_secret'> {<br>    return {<br>      id: raw.id as string,<br>      principal: raw.principal as string,<br>      name: raw.name ?? undefined,<br>      display_name: raw.display_name ?? undefined,<br>      logo_url: raw.logo_url ?? undefined,<br>      brand_color: raw.brand_color ?? undefined,<br>      webhook_url: raw.webhook_url ?? undefined,<br>      active: Number(raw.active) === 1,<br>      support_email: raw.support_email ?? undefined,<br>      support_url: raw.support_url ?? undefined,<br>      allowed_origins: raw.allowed_origins ?? undefined,<br>      created_at: Number(raw.created_at),<br>    };<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Inside SqliteStore constructor<br>private readonly merchantProjection = new MerchantProjectionPolicy();<br><br>// Use in listMerchantsProjection()<br>const sql = this.merchantProjection.getListProjectionSQL();<br>const rows = this.db.prepare(sql).all();<br>return rows.map(r => this.merchantProjection.mapListRow(r));<br>```<br><br>#### 🔁 Refactored Method: SqliteStore.listMerchantsProjection<br>Breakdown after refactor:<br>- Parent delegates the SELECT columns and row mapping/redaction policy.<br>- Parent only executes and maps results.<br><br>```typescript<br>listMerchantsProjection(): Omit<MerchantRow, 'api_key' or 'hmac_secret'>[] {<br>  const sql = this.merchantProjection.getListProjectionSQL();<br>  const dbRows = this.db.prepare(sql).all() as any[];<br>  return dbRows.map(r => this.merchantProjection.mapListRow(r));<br>}<br>```<br><br>#### 🔧 Delegate Method: getListProjectionSQL<br>```typescript<br>getListProjectionSQL(): string {<br>  return `<br>    SELECT<br>      id,<br>      principal,<br>      name,<br>      display_name,<br>      logo_url,<br>      brand_color,<br>      webhook_url,<br>      active,<br>      support_email,<br>      support_url,<br>      allowed_origins,<br>      created_at<br>    FROM merchants<br>    ORDER BY created_at DESC<br>  `;<br>}<br>```<br><br>#### 🔧 Delegate Method: mapListRow<br>```typescript<br>mapListRow(raw: any): Omit<MerchantRow, 'api_key' or 'hmac_secret'> {<br>  return {<br>    id: raw.id,<br>    principal: raw.principal,<br>    name: raw.name ?? undefined,<br>    display_name: raw.display_name ?? undefined,<br>    logo_url: raw.logo_url ?? undefined,<br>    brand_color: raw.brand_color ?? undefined,<br>    webhook_url: raw.webhook_url ?? undefined,<br>    active: Number(raw.active) === 1,<br>    support_email: raw.support_email ?? undefined,<br>    support_url: raw.support_url ?? undefined,<br>    allowed_origins: raw.allowed_origins ?? undefined,<br>    created_at: Number(raw.created_at),<br>  };<br>}<br>```<br><br>--- |
| SqlInListBuilder | - **[Offloading Class Names]**: SqliteStore<br>- **[Originating Method Ids]**: SS-BULK-EXP-1<br><br>Delegate State Owned:<br>- None.<br><br>Delegate Responsibilities Owned:<br>- Build safe SQL IN-clause fragments and corresponding parameter arrays for a non-empty in-memory list.<br>- Validate the value list is non-empty and of the expected primitive type.<br><br>Responsibilities Removed from Parent Class:<br>- Manual placeholder string assembly and parameter list alignment for IN (...) updates.<br><br>Delegate Public Interface:<br>```typescript<br>export class SqlInListBuilder {<br>  buildInClause(column: string, values: Array<string or number>): { clause: string; params: Array<string or number> } {<br>    if (!Array.isArray(values) or values.length === 0) {<br>      throw new Error('values must be a non-empty array');<br>    }<br>    const placeholders = values.map(() => '?').join(',');<br>    return {<br>      clause: `${ column } IN (${ placeholders })`,<br>      params: values,<br>    };<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Inside SqliteStore constructor<br>private readonly inListBuilder = new SqlInListBuilder();<br><br>// Use in bulkMarkExpired()<br>const { clause, params } = this.inListBuilder.buildInClause('id_raw', idRawList);<br>const stmt = this.db.prepare(`UPDATE invoices SET status='expired', expired=1 WHERE ${ clause }`);<br>const info = stmt.run(...params);<br>return info.changes;<br>```<br><br>#### 🔁 Refactored Method: SqliteStore.bulkMarkExpired<br>Breakdown after refactor:<br>- Delegate builds IN-clause and parameters.<br>- Parent composes UPDATE statement and executes in a single step.<br><br>```typescript<br>bulkMarkExpired(idRawList: string[]): number {<br>  if (!idRawList.length) return 0;<br>  const { clause, params } = this.inListBuilder.buildInClause('id_raw', idRawList);<br>  const stmt = this.db.prepare(`UPDATE invoices SET status = 'expired', expired = 1 WHERE ${ clause }`);<br>  const info = stmt.run(...params);<br>  return info.changes;<br>}<br>```<br><br>#### 🔧 Delegate Method: buildInClause<br>```typescript<br>buildInClause(column: string, values: Array<string or number>): { clause: string; params: Array<string or number> } {<br>  if (!Array.isArray(values) or values.length === 0) {<br>    throw new Error('values must be a non-empty array');<br>  }<br>  const placeholders = values.map(() => '?').join(',');<br>  return {<br>    clause: `${ column } IN (${ placeholders })`,<br>    params: values,<br>  };<br>}<br>```<br><br>End of report. |
| ApiCaseAndDtoMapper | - **[Offloading Class Names]**: MerchantApiController<br>- **[Originating Method Ids]**: MAC-GET-INVOICE, MAC-LIST-INVOICES, MAC-GET-STORE-PROFILE, MAC-LIST-WEBHOOKS<br><br>Delegate State Owned:<br>- None (pure mapping/formatting delegate).<br><br>Delegate Responsibilities Owned:<br>- Convert DB rows (snake_case) into API response DTOs (camelCase) for invoices, webhooks, and store private profile as required by DS-5-22.<br>- Provide utility case adapters toCamel and toSnake for payload normalization when needed.<br><br>Responsibilities Removed from Parent Class:<br>- Inline DTO shaping: invoiceRowToDto, webhookRowToDto, and store private profile mapping.<br><br>Delegate Public Interface:<br>- invoiceToPublicDto(row: InvoiceRow): PublicInvoiceDTO<br>- webhookToDto(row: WebhookLogRow): {<br>  id: string; storeId: string; invoiceId?: string or null; subscriptionId?: string or null; eventType: string; payload: string; statusCode: number or null; success: boolean; attempts: number; lastAttemptAt: number or null;<br>}<br>- storeToPrivateProfile(row: MerchantRow): StorePrivateProfileDTO<br>- toCamel<T = any>(input: any): T<br>- toSnake<T = Record<string, any>>(input: any): T<br><br>Example Interaction:<br>```typescript<br>// Example code snippet clearly illustrating parent-delegate interaction<br>const dto = this.dtoMapper.invoiceToPublicDto(row);<br>res.json(dto);<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.getInvoice<br>- After refactoring, the method fetches the row and delegates DTO shaping to ApiCaseAndDtoMapper.invoiceToPublicDto. It no longer constructs the DTO inline.<br><br>```typescript<br>async getInvoice(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const idRaw = String(req.params.invoiceId);<br>  const row = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, idRaw);<br>  if (!row) {<br>    res.status(HttpStatusMap.notFound).end();<br>    return;<br>  }<br>  const dto = this.dtoMapper.invoiceToPublicDto(row);<br>  res.json(dto);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.listInvoices<br>- After refactoring, the method keeps validation/selection logic but maps rows using ApiCaseAndDtoMapper.invoiceToPublicDto.<br><br>```typescript<br>async listInvoices(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const statusQ = req.query.status ? String(req.query.status) : undefined;<br>  const allowed: InvoiceStatus[] = ['unpaid', 'paid', 'partially_refunded', 'refunded', 'canceled', 'expired'];<br>  if (statusQ && !allowed.includes(statusQ as InvoiceStatus)) {<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.bad_status);<br>    return;<br>  }<br>  const rows = this.store.listInvoicesByStore(sreq.store.id, {<br>    status: statusQ as InvoiceStatus or undefined,<br>    orderByCreatedDesc: true,<br>  });<br>  res.json(rows.map((r) => this.dtoMapper.invoiceToPublicDto(r)));<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.getStoreProfile<br>- After refactoring, the method uses ApiCaseAndDtoMapper.storeToPrivateProfile to project the private profile DTO.<br><br>```typescript<br>async getStoreProfile(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const dto = this.dtoMapper.storeToPrivateProfile(sreq.store);<br>  res.json(dto);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.listWebhooks<br>- After refactoring, the method maps webhook rows using ApiCaseAndDtoMapper.webhookToDto.<br><br>```typescript<br>async listWebhooks(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const rows = this.store.listWebhooksForStore(sreq.store.id);<br>  res.json(rows.map((w) => this.dtoMapper.webhookToDto(w)));<br>}<br>```<br><br>#### 🔧 Delegate Method: invoiceToPublicDto<br>- Responsibility: Map InvoiceRow (snake_case fields) to PublicInvoiceDTO (camelCase), without leaking secrets.<br><br>```typescript<br>import { InvoiceRow, PublicInvoiceDTO, MerchantRow, WebhookLogRow, StorePrivateProfileDTO } from '../models/domain';<br><br>export class ApiCaseAndDtoMapper {<br>  invoiceToPublicDto(r: InvoiceRow): PublicInvoiceDTO {<br>    return {<br>      invoiceId: r.id_raw,<br>      idHex: r.id_hex,<br>      storeId: r.store_id,<br>      amountSats: r.amount_sats,<br>      usdAtCreate: r.usd_at_create,<br>      quoteExpiresAt: r.quote_expires_at,<br>      merchantPrincipal: r.merchant_principal,<br>      status: r.status,<br>      payer: r.payer,<br>      txId: r.txid,<br>      memo: r.memo,<br>      subscriptionId: r.subscription_id,<br>      createdAt: r.created_at,<br>      refundAmount: r.refund_amount,<br>      refundTxId: r.refund_txid,<br>      store: undefined,<br>    };<br>  }<br><br>  webhookToDto(w: WebhookLogRow) {<br>    return {<br>      id: w.id,<br>      storeId: w.store_id,<br>      invoiceId: w.invoice_id,<br>      subscriptionId: w.subscription_id,<br>      eventType: w.event_type,<br>      payload: w.payload,<br>      statusCode: w.status_code,<br>      success: w.success === 1,<br>      attempts: w.attempts,<br>      lastAttemptAt: w.last_attempt_at,<br>    };<br>  }<br><br>  storeToPrivateProfile(row: MerchantRow): StorePrivateProfileDTO {<br>    return {<br>      name: row.name,<br>      displayName: row.display_name,<br>      logoUrl: row.logo_url,<br>      brandColor: row.brand_color,<br>      webhookUrl: row.webhook_url,<br>      supportEmail: row.support_email,<br>      supportUrl: row.support_url,<br>      allowedOrigins: row.allowed_origins ? row.allowed_origins.split(',').map(s => s.trim()).filter(Boolean) : [],<br>      principal: row.principal,<br>      active: !!row.active,<br>    };<br>  }<br><br>  toCamel<T = any>(input: any): T {<br>    if (input === null or typeof input !== 'object') return input;<br>    if (Array.isArray(input)) return input.map(v => this.toCamel(v)) as any;<br>    const out: Record<string, any> = {};<br>    for (const [k, v] of Object.entries(input)) {<br>      const camel = k.replace(/_([a-z])/g, (_, c) => c.toUpperCase());<br>      out[camel] = this.toCamel(v);<br>    }<br>    return out as T;<br>  }<br><br>  toSnake<T extends Record<string, any> = Record<string, any>>(input: any): T {<br>    if (input === null or typeof input !== 'object') return input;<br>    if (Array.isArray(input)) return input.map(v => this.toSnake(v)) as any;<br>    const out: Record<string, any> = {};<br>    for (const [k, v] of Object.entries(input)) {<br>      const snake = k.replace(/[A-Z]/g, c => `_${c.toLowerCase()}`);<br>      out[snake] = this.toSnake(v);<br>    }<br>    return out as T;<br>  }<br>}<br>```<br><br>--- |
| MerchantInputValidator | - **[Offloading Class Names]**: MerchantApiController<br>- **[Originating Method Ids]**: MAC-VALIDATE-CREATE-INVOICE-BODY, MAC-VALIDATE-REFUND-BODY, MAC-CREATE-SUBSCRIPTION<br><br>Delegate State Owned:<br>- None (pure validation/normalization logic).<br><br>Delegate Responsibilities Owned:<br>- Validate and normalize create-invoice body (snake_case in → normalized values) enforcing SL-1-12/13 invariants where applicable and DS-5-22 key policy.<br>- Validate and normalize refund body.<br>- Reusable assertions for principals and positive integers for controller flows like subscription creation.<br><br>Responsibilities Removed from Parent Class:<br>- Inline validation methods validateCreateInvoiceBody, validateRefundBody.<br>- Private assertion helpers assertStacksPrincipal and assertPositiveInt.<br><br>Delegate Public Interface:<br>- validateCreateInvoiceBody(body: any): { amountSats: number; ttlSeconds: number; memo?: string; webhookUrl?: string }<br>- validateRefundBody(body: any): { invoiceId: string; amountSats: number; memo?: string }<br>- assertStacksPrincipal(p: string): void<br>- assertPositiveInt(n: number, name: string): void<br><br>Example Interaction:<br>```typescript<br>const normalized = this.inputValidator.validateCreateInvoiceBody(req.body);<br>const refundReq = this.inputValidator.validateRefundBody(req.body);<br>this.inputValidator.assertStacksPrincipal(subscriber);<br>this.inputValidator.assertPositiveInt(intervalBlocks, 'interval_blocks');<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.validateCreateInvoiceBody<br>- Responsibility after refactor: Proxy to MerchantInputValidator.validateCreateInvoiceBody to perform all checks and normalization; return the delegate’s result.<br><br>```typescript<br>validateCreateInvoiceBody(body: any) {<br>  return this.inputValidator.validateCreateInvoiceBody(body);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.validateRefundBody<br>- Responsibility after refactor: Proxy to MerchantInputValidator.validateRefundBody.<br><br>```typescript<br>validateRefundBody(body: any) {<br>  return this.inputValidator.validateRefundBody(body);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.createSubscription<br>- Responsibility after refactor: Replace inline assertions with MerchantInputValidator.assertStacksPrincipal and assertPositiveInt. Signature and response schema unchanged.<br><br>```typescript<br>async createSubscription(req: Request, res: Response): Promise<void> {<br>  try {<br>    const sreq = req as AuthedRequest;<br>    const body = req.body or {};<br>    const subscriber: string = String(body.subscriber);<br>    const amountSats = Number(body.amount_sats);<br>    const intervalBlocks = Number(body.interval_blocks);<br>    const mode: 'invoice' or 'direct' or undefined = body.mode ? String(body.mode) as any : undefined;<br><br>    this.inputValidator.assertStacksPrincipal(subscriber);<br>    this.inputValidator.assertPositiveInt(amountSats, 'amount_sats');<br>    this.inputValidator.assertPositiveInt(intervalBlocks, 'interval_blocks');<br>    if (mode && !['invoice', 'direct'].includes(mode)) {<br>      res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>      return;<br>    }<br><br>    const { row, unsignedCall } = await this.subs.createSubscription(<br>      { id: sreq.store.id, principal: sreq.store.principal },<br>      { subscriber, amountSats, intervalBlocks, mode }<br>    );<br><br>    res.json({<br>      id: row.id,<br>      idHex: row.id_hex,<br>      storeId: row.store_id,<br>      merchantPrincipal: row.merchant_principal,<br>      subscriber: row.subscriber,<br>      amountSats: row.amount_sats,<br>      intervalBlocks: row.interval_blocks,<br>      active: row.active === 1,<br>      createdAt: row.created_at,<br>      lastBilledAt: row.last_billed_at,<br>      nextInvoiceAt: row.next_invoice_at,<br>      lastPaidInvoiceId: row.last_paid_invoice_id,<br>      mode: row.mode,<br>      unsignedCall,<br>    });<br>  } catch {<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: validateCreateInvoiceBody<br>- Responsibility: Enforce amount_sats>0, ttl_seconds>0, optional memo UTF-8 ≤34 bytes, optional webhook_url valid URL. Return normalized camelCase values.<br><br>```typescript<br>import { Validation } from '../validation/rules';<br><br>export class MerchantInputValidator {<br>  validateCreateInvoiceBody(body: any): { amountSats: number; ttlSeconds: number; memo?: string; webhookUrl?: string } {<br>    const amountSats = Number(body?.amount_sats);<br>    const ttlSeconds = Number(body?.ttl_seconds);<br>    if (!Number.isInteger(amountSats) or amountSats <= 0) throw new TypeError('amount_sats must be positive int');<br>    if (!Number.isInteger(ttlSeconds) or ttlSeconds <= 0) throw new TypeError('ttl_seconds must be positive int');<br><br>    let memo: string or undefined;<br>    if (body?.memo !== undefined && body.memo !== null) {<br>      const str = String(body.memo);<br>      const buf = Buffer.from(str, 'utf8').subarray(0, Validation.createInvoice.memoMaxUtf8Bytes);<br>      memo = buf.toString('utf8');<br>    }<br><br>    let webhookUrl: string or undefined;<br>    if (body?.webhook_url) {<br>      const url = String(body.webhook_url);<br>      if (!Validation.url.test(url)) throw new TypeError('invalid webhook_url');<br>      webhookUrl = url;<br>    }<br>    return { amountSats, ttlSeconds, memo, webhookUrl };<br>  }<br><br>  validateRefundBody(body: any): { invoiceId: string; amountSats: number; memo?: string } {<br>    const invoiceId = String(body?.invoice_id or '');<br>    if (!Validation.uuid.test(invoiceId)) throw new TypeError('invalid invoice_id');<br>    const amountSats = Number(body?.amount_sats);<br>    if (!Number.isInteger(amountSats) or amountSats <= 0) throw new TypeError('invalid amount_sats');<br><br>    let memo: string or undefined;<br>    if (body?.memo !== undefined && body.memo !== null) {<br>      const str = String(body.memo);<br>      const buf = Buffer.from(str, 'utf8').subarray(0, Validation.createRefund.memoMaxUtf8Bytes);<br>      memo = buf.toString('utf8');<br>    }<br>    return { invoiceId, amountSats, memo };<br>  }<br><br>  assertStacksPrincipal(p: string): void {<br>    if (!Validation.stacksPrincipal.test(p)) {<br>      throw new TypeError('invalid principal');<br>    }<br>  }<br><br>  assertPositiveInt(n: number, name: string): void {<br>    if (!Number.isInteger(n) or n <= 0) throw new TypeError(`${name} must be positive integer`);<br>  }<br>}<br>```<br><br>--- |
| DirectSubscriptionPaymentTxBuilder | - **[Offloading Class Names]**: MerchantApiController<br>- **[Originating Method Ids]**: MAC-BUILD-DIRECT-SUB-PAY-TX<br><br>Delegate State Owned:<br>- None (stateless assembly of unsigned payload with deterministic checks).<br><br>Delegate Responsibilities Owned:<br>- Validate subscription invariants for direct mode payment:<br>  - Subscription must be active and in 'direct' mode.<br>  - id_hex is valid 64-hex via codec.<br>  - Payer principal equals stored subscriber.<br>  - Current block height ≥ next_invoice_at.<br>  - sBTC token configured on-chain.<br>- Build unsigned pay-subscription contract call using IContractCallBuilder.<br><br>Responsibilities Removed from Parent Class:<br>- Inline checks and payload assembly in buildDirectSubscriptionPaymentTx.<br><br>Delegate Public Interface:<br>- assemble(sub: SubscriptionRow, payerPrincipal: string, merchantPrincipal: string): Promise<UnsignedContractCall><br><br>Example Interaction:<br>```typescript<br>const payload = await this.directSubPayBuilder.assemble(sub, payerPrincipal, sreq.store.principal);<br>res.json(payload);<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.buildDirectSubscriptionPaymentTx<br>- After refactoring, the method resolves subscription and inputs, delegates enforcement+assembly to DirectSubscriptionPaymentTxBuilder. It maps delegate error codes to HTTP responses consistently with current behavior.<br><br>```typescript<br>async buildDirectSubscriptionPaymentTx(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const id = String(req.params.id);<br>  const sub = this.store.getSubscriptionByIdForStore(id, sreq.store.id);<br>  if (!sub) {<br>    res.status(HttpStatusMap.notFound).end();<br>    return;<br>  }<br><br>  const payerPrincipal = String(req.body?.payerPrincipal or '');<br><br>  try {<br>    const payload = await this.directSubPayBuilder.assemble(sub, payerPrincipal, sreq.store.principal);<br>    res.json(payload);<br>  } catch (err: any) {<br>    const code = err?.code as string;<br>    if (code === 'bad_status' or code === 'invalid_payer' or code === 'too_early') {<br>      res.status(HttpStatusMap.conflict).json(MerchantAdminErrors.bad_status);<br>      return;<br>    }<br>    if (code === 'missing_token') {<br>      res.status(HttpStatusMap.unprocessable).json(PublicErrors.missingSbtcToken);<br>      return;<br>    }<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: assemble<br>- Responsibility: Execute all required checks against subscription and chain state; build and return unsigned payload or throw structured errors.<br><br>```typescript<br>import { IStacksChainClient, IContractCallBuilder, IInvoiceIdCodec } from '../contracts/interfaces';<br>import { SubscriptionRow, UnsignedContractCall } from '../models/domain';<br><br>export class DirectSubscriptionPaymentTxBuilder {<br>  constructor(<br>    private chain: IStacksChainClient,<br>    private builder: IContractCallBuilder,<br>    private codec: IInvoiceIdCodec<br>  ) {}<br><br>  async assemble(sub: SubscriptionRow, payerPrincipal: string, merchantPrincipal: string): Promise<UnsignedContractCall> {<br>    if (sub.active !== 1 or sub.mode !== 'direct') {<br>      const e: any = new Error('Subscription not payable in direct mode');<br>      e.code = 'bad_status';<br>      throw e;<br>    }<br><br>    this.codec.assertHex64(sub.id_hex);<br><br>    if (payerPrincipal !== sub.subscriber) {<br>      const e: any = new Error('Payer must equal subscriber');<br>      e.code = 'invalid_payer';<br>      throw e;<br>    }<br><br>    const tip = await this.chain.getTip();<br>    if (tip.height < sub.next_invoice_at) {<br>      const e: any = new Error('Current height below next invoice at');<br>      e.code = 'too_early';<br>      throw e;<br>    }<br><br>    const token = await this.chain.readSbtcToken();<br>    if (!token) {<br>      const e: any = new Error('sBTC token not set');<br>      e.code = 'missing_token';<br>      throw e;<br>    }<br><br>    return this.builder.buildPaySubscription({<br>      idHex: sub.id_hex,<br>      amountSats: sub.amount_sats,<br>      subscriber: payerPrincipal,<br>      merchant: merchantPrincipal,<br>    });<br>  }<br>}<br>```<br><br>--- |
| RefundPolicyGuard | - **[Offloading Class Names]**: MerchantApiController<br>- **[Originating Method Ids]**: MAC-BUILD-REFUND<br><br>Delegate State Owned:<br>- None (policy checks + orchestration of refund payload).<br><br>Delegate Responsibilities Owned:<br>- Enforce refund policy:<br>  - Invoice status must be 'paid' or 'partially_refunded'.<br>  - id_hex must be valid 64-hex (round-trip enforced upstream by codec).<br>  - Requested amount + already refunded ≤ original amount.<br>  - Merchant sBTC balance pre-check must succeed before building payload.<br>- Build unsigned refund payload using RefundService.<br><br>Responsibilities Removed from Parent Class:<br>- Inline cap calculation, status gating, and pre-balance checks within buildRefund.<br><br>Delegate Public Interface:<br>- enforceAndBuild(store: MerchantRow, invRow: InvoiceRow, amountSats: number, memo?: string): Promise<UnsignedContractCall><br><br>Example Interaction:<br>```typescript<br>const { invoiceId, amountSats, memo } = this.inputValidator.validateRefundBody(req.body);<br>const payload = await this.refundPolicy.enforceAndBuild(sreq.store, invRow, amountSats, memo);<br>res.json(payload);<br>```<br><br>#### 🔁 Refactored Method: MerchantApiController.buildRefund<br>- After refactoring, the method handles request body normalization and invoice lookup; the delegate performs policy checks and payload building. HTTP error mapping remains identical.<br><br>```typescript<br>async buildRefund(req: Request, res: Response): Promise<void> {<br>  try {<br>    const sreq = req as AuthedRequest;<br>    const { invoiceId, amountSats, memo } = this.inputValidator.validateRefundBody(req.body);<br>    const invRow = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, invoiceId);<br>    if (!invRow) {<br>      res.status(HttpStatusMap.notFound).end();<br>      return;<br>    }<br>    try {<br>      const payload = await this.refundPolicy.enforceAndBuild(sreq.store, invRow, amountSats, memo);<br>      res.json(payload);<br>    } catch (err: any) {<br>      const code = err?.code as string;<br>      if (code === 'bad_status' or code === 'cap_violation') {<br>        res.status(HttpStatusMap.conflict).json(MerchantAdminErrors.bad_status);<br>        return;<br>      }<br>      if (code === 'insufficient_balance') {<br>        res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.insufficient_balance);<br>        return;<br>      }<br>      res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>    }<br>  } catch {<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: enforceAndBuild<br>- Responsibility: Perform status and cap checks, pre-check merchant balance via RefundService, and build the unsigned refund payload.<br><br>```typescript<br>import { MerchantRow, InvoiceRow, UnsignedContractCall } from '../models/domain';<br>import { IInvoiceIdCodec } from '../contracts/interfaces';<br>import { RefundService } from '../services/RefundService';<br><br>export class RefundPolicyGuard {<br>  constructor(<br>    private codec: IInvoiceIdCodec,<br>    private refund: RefundService<br>  ) {}<br><br>  async enforceAndBuild(store: MerchantRow, invRow: InvoiceRow, amountSats: number, memo?: string): Promise<UnsignedContractCall> {<br>    if (invRow.status !== 'paid' && invRow.status !== 'partially_refunded') {<br>      const e: any = new Error('Invoice not refundable in current status');<br>      e.code = 'bad_status';<br>      throw e;<br>    }<br><br>    this.codec.assertHex64(invRow.id_hex);<br><br>    const alreadyRefunded = invRow.refund_amount ?? 0;<br>    const proposed = alreadyRefunded + amountSats;<br>    if (proposed > invRow.amount_sats) {<br>      const e: any = new Error('Refund cap exceeded');<br>      e.code = 'cap_violation';<br>      throw e;<br>    }<br><br>    const hasBalance = await this.refund.precheckBalance(store.principal, amountSats);<br>    if (!hasBalance) {<br>      const e: any = new Error('Insufficient sBTC balance');<br>      e.code = 'insufficient_balance';<br>      throw e;<br>    }<br><br>    return this.refund.buildRefundPayload(store, invRow, amountSats, memo);<br>    }<br>}<br>```<br><br>End of report. |
| AdminParamGuard | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-CREATE-STORE, AAC-LIST-STORES, AAC-ROTATE-KEYS-ADMIN, AAC-SYNC-ONCHAIN, AAC-SET-SBTC-TOKEN, AAC-CANCEL-INVOICE-ADMIN, AAC-ACTIVATE-STORE, AAC-LIST-ADMIN-INVOICES, AAC-RETRY-WEBHOOK, AAC-LIST-WEBHOOKS-ADMIN<br><br>Delegate State Owned:<br>- None (stateless input validator and parser).<br><br>Delegate Responsibilities Owned:<br>- UUID validation for path/JSON parameters.<br>- Stacks principal/address validation.<br>- Parsing and validation of invoice status filters, returning only allowed values.<br><br>Responsibilities Removed from Parent Class:<br>- Inline regex validation and manual parsing logic inside controller methods.<br><br>Delegate Public Interface:<br>- assertUuid(id: string): void<br>- assertStacksPrincipal(principal: string): void<br>- parseInvoiceStatuses(input: string or string[] or undefined): Array<'unpaid' or 'paid' or 'partially_refunded' or 'refunded' or 'canceled' or 'expired'><br><br>Example Interaction:<br>```typescript<br>const guard = new AdminParamGuard();<br>guard.assertUuid(req.params.storeId);<br>const statuses = guard.parseInvoiceStatuses(req.query.status as any);<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.listAdminInvoices<br>- After refactoring, the controller delegates query param validation (statuses parsing and storeId UUID check) to AdminParamGuard and focuses on DAO invocation and response formatting.<br>- Data flow:<br>  - Input: req.query.status (string or CSV or array), req.query.storeId (optional UUID string)<br>  - Validation: guard.parseInvoiceStatuses(...), guard.assertUuid(...)<br>  - Output: 200 JSON with camelCase DTOs (mapping handled by AdminDtoProjector in its own section)<br><br>```typescript<br>async listAdminInvoices(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const statuses = guard.parseInvoiceStatuses(req.query.status as any);<br>  const storeId = req.query.storeId ? String(req.query.storeId) : undefined;<br>  if (storeId) guard.assertUuid(storeId);<br><br>  const rows = this.store.selectAdminInvoices(statuses.length ? (statuses as any) : undefined, storeId);<br>  const projector = new AdminDtoProjector();<br>  res.json(rows.map(r => projector.invoiceToDto(r)));<br>}<br>```<br><br>#### 🔧 Delegate Method: assertUuid<br>- Responsibility: Validate that a string is a UUID v1–v5 per RFC 4122 variant format. Throws TypeError on invalid input.<br>- Signature: assertUuid(id: string): void<br>```typescript<br>export class AdminParamGuard {<br>  assertUuid(id: string): void {<br>    const re =<br>      /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;<br>    if (!re.test(id)) {<br>      throw new TypeError('Invalid UUID');<br>    }<br>  }<br><br>  assertStacksPrincipal(p: string): void {<br>    if (typeof p !== 'string' or p.length < 2 or p[0] !== 'S') {<br>      throw new TypeError('Invalid Stacks principal/address');<br>    }<br>  }<br><br>  parseInvoiceStatuses(input: string or string[] or undefined): Array<<br>    'unpaid' or 'paid' or 'partially_refunded' or 'refunded' or 'canceled' or 'expired'<br>  > {<br>    const allowed = new Set([<br>      'unpaid',<br>      'paid',<br>      'partially_refunded',<br>      'refunded',<br>      'canceled',<br>      'expired',<br>    ]);<br>    if (!input) return [];<br>    const arr = Array.isArray(input)<br>      ? input<br>      : String(input)<br>          .split(',')<br>          .map((s) => s.trim())<br>          .filter((s) => s.length > 0);<br>    const out: string[] = [];<br>    for (const s of arr) {<br>      if (allowed.has(s)) out.push(s);<br>    }<br>    return out as any;<br>  }<br>}<br>```<br><br>--- |
| AdminDtoProjector | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-LIST-STORES, AAC-LIST-ADMIN-INVOICES, AAC-LIST-WEBHOOKS-ADMIN<br><br>Delegate State Owned:<br>- None (pure mapping functions).<br><br>Delegate Responsibilities Owned:<br>- Convert DB rows (snake_case) to admin API camelCase DTOs:<br>  - Merchant projection row → Merchant DTO without secrets.<br>  - Invoice row → Invoice DTO.<br>  - Webhook log row → Webhook DTO.<br>- Ensure no secret fields are emitted (api_key, hmac_secret).<br><br>Responsibilities Removed from Parent Class:<br>- Inline object mapping from DB rows to response DTO shapes.<br><br>Delegate Public Interface:<br>- merchantToDto(r: MerchantProjectionRow): MerchantDto<br>- invoiceToDto(r: InvoiceRow): AdminInvoiceDto<br>- webhookToDto(r: WebhookLogRow): AdminWebhookDto<br><br>Example Interaction:<br>```typescript<br>const projector = new AdminDtoProjector();<br>const merchants = this.store.listMerchantsProjection().map(r => projector.merchantToDto(r));<br>res.json(merchants);<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.listStores<br>- Controller now delegates projection mapping to AdminDtoProjector, keeping the method focused on DAO call and HTTP response.<br>```typescript<br>async listStores(_req: Request, res: Response): Promise<void> {<br>  const rows = this.store.listMerchantsProjection();<br>  const projector = new AdminDtoProjector();<br>  res.json(rows.map(r => projector.merchantToDto(r)));<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.listWebhooks<br>- Controller delegates DTO mapping for webhook rows to AdminDtoProjector.<br>```typescript<br>async listWebhooks(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const q = req.query or {};<br>  const storeId = q.storeId ? String(q.storeId) : undefined;<br>  if (storeId) guard.assertUuid(storeId);<br>  const failedOnly = String(q.status ?? 'all') === 'failed';<br><br>  const rows = this.store.listAdminWebhooks(storeId, failedOnly);<br>  const projector = new AdminDtoProjector();<br>  res.json(rows.map(w => projector.webhookToDto(w)));<br>}<br>```<br><br>#### 🔧 Delegate Method: merchantToDto<br>- Responsibility: Convert merchant projection row to camelCase DTO without secrets.<br>- Signature: merchantToDto(r: MerchantProjectionRow): MerchantDto<br>```typescript<br>import { InvoiceRow, WebhookLogRow } from '../models/domain';<br><br>export type MerchantProjectionRow = {<br>  id: string;<br>  principal: string;<br>  name?: string or null;<br>  display_name?: string or null;<br>  logo_url?: string or null;<br>  brand_color?: string or null;<br>  webhook_url?: string or null;<br>  active: number;<br>  support_email?: string or null;<br>  support_url?: string or null;<br>  allowed_origins?: string or null;<br>  created_at: number;<br>};<br><br>export type MerchantDto = {<br>  id: string;<br>  principal: string;<br>  name?: string;<br>  displayName?: string;<br>  logoUrl?: string;<br>  brandColor?: string;<br>  webhookUrl?: string;<br>  active: boolean;<br>  supportEmail?: string;<br>  supportUrl?: string;<br>  allowedOrigins?: string;<br>  createdAt: number;<br>};<br><br>export type AdminInvoiceDto = {<br>  idRaw: string;<br>  idHex: string;<br>  storeId: string;<br>  amountSats: number;<br>  usdAtCreate: number;<br>  quoteExpiresAt: number;<br>  merchantPrincipal: string;<br>  status: string;<br>  payer?: string;<br>  txId?: string;<br>  memo?: string;<br>  webhookUrl?: string;<br>  createdAt: number;<br>  refundedAt?: number;<br>  refundAmount: number;<br>  refundTxId?: string;<br>  subscriptionId?: string;<br>  refundCount: number;<br>  expired: number;<br>};<br><br>export type AdminWebhookDto = {<br>  id: string;<br>  storeId: string;<br>  invoiceId?: string;<br>  subscriptionId?: string;<br>  eventType: string;<br>  payload: string;<br>  statusCode?: number;<br>  success: boolean;<br>  attempts: number;<br>  lastAttemptAt: number;<br>};<br><br>export class AdminDtoProjector {<br>  merchantToDto(r: MerchantProjectionRow): MerchantDto {<br>    return {<br>      id: r.id,<br>      principal: r.principal,<br>      name: r.name ?? undefined,<br>      displayName: r.display_name ?? undefined,<br>      logoUrl: r.logo_url ?? undefined,<br>      brandColor: r.brand_color ?? undefined,<br>      webhookUrl: r.webhook_url ?? undefined,<br>      active: !!r.active,<br>      supportEmail: r.support_email ?? undefined,<br>      supportUrl: r.support_url ?? undefined,<br>      allowedOrigins: r.allowed_origins ?? undefined,<br>      createdAt: r.created_at,<br>    };<br>  }<br><br>  invoiceToDto(r: InvoiceRow): AdminInvoiceDto {<br>    return {<br>      idRaw: r.id_raw,<br>      idHex: r.id_hex,<br>      storeId: r.store_id,<br>      amountSats: r.amount_sats,<br>      usdAtCreate: r.usd_at_create,<br>      quoteExpiresAt: r.quote_expires_at,<br>      merchantPrincipal: r.merchant_principal,<br>      status: r.status,<br>      payer: r.payer ?? undefined,<br>      txId: r.txid ?? undefined,<br>      memo: r.memo ?? undefined,<br>      webhookUrl: r.webhook_url ?? undefined,<br>      createdAt: r.created_at,<br>      refundedAt: r.refunded_at ?? undefined,<br>      refundAmount: r.refund_amount,<br>      refundTxId: r.refund_txid ?? undefined,<br>      subscriptionId: r.subscription_id ?? undefined,<br>      refundCount: r.refund_count,<br>      expired: r.expired,<br>    };<br>  }<br><br>  webhookToDto(w: WebhookLogRow): AdminWebhookDto {<br>    return {<br>      id: w.id,<br>      storeId: w.store_id,<br>      invoiceId: w.invoice_id ?? undefined,<br>      subscriptionId: w.subscription_id ?? undefined,<br>      eventType: w.event_type,<br>      payload: w.payload,<br>      statusCode: w.status_code ?? undefined,<br>      success: !!w.success,<br>      attempts: w.attempts,<br>      lastAttemptAt: w.last_attempt_at,<br>    };<br>  }<br>}<br>```<br><br>--- |
| MerchantKeyRotationService | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-ROTATE-KEYS-ADMIN<br><br>Delegate State Owned:<br>- None (stateless; uses DAO and crypto per call).<br><br>Delegate Responsibilities Owned:<br>- Ensure target merchant exists.<br>- Generate cryptographically secure apiKey and hmacSecret.<br>- Perform atomic key rotation via SqliteStore.updateMerchantKeysTx.<br>- Return new secrets exactly once to caller.<br><br>Responsibilities Removed from Parent Class:<br>- Secret generation and transactional update details inside the controller.<br><br>Delegate Public Interface:<br>- rotate(store: ISqliteStore, storeId: string): { ok: true; apiKey: string; hmacSecret: string } or { ok: false; notFound: true }<br><br>Example Interaction:<br>```typescript<br>const result = new MerchantKeyRotationService().rotate(this.store, storeId);<br>if (!result.ok) { res.status(404).end(); return; }<br>res.json({ apiKey: result.apiKey, hmacSecret: result.hmacSecret });<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.rotateKeys<br>- Controller now:<br>  - Validates storeId via AdminParamGuard.assertUuid<br>  - Delegates rotation to MerchantKeyRotationService<br>  - Handles 404 or 200 responses without touching secret generation or DB details<br>```typescript<br>async rotateKeys(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const storeId = String(req.params.storeId);<br>  guard.assertUuid(storeId);<br><br>  const svc = new MerchantKeyRotationService();<br>  const result = svc.rotate(this.store, storeId);<br>  if (!result.ok) {<br>    res.status(404).end();<br>    return;<br>  }<br>  res.json({ apiKey: result.apiKey, hmacSecret: result.hmacSecret });<br>}<br>```<br><br>#### 🔧 Delegate Method: rotate<br>- Responsibility: Full rotation workflow encapsulation.<br>- Signature: rotate(store: ISqliteStore, storeId: string): { ok: true; apiKey: string; hmacSecret: string } or { ok: false; notFound: true }<br>```typescript<br>import crypto from 'crypto';<br>import { ISqliteStore } from '../contracts/dao';<br><br>export class MerchantKeyRotationService {<br>  rotate(store: ISqliteStore, storeId: string):<br>    or { ok: true; apiKey: string; hmacSecret: string }<br>    or { ok: false; notFound: true } {<br>    const exists = store.listMerchantsProjection().some((m: any) => m.id === storeId);<br>    if (!exists) return { ok: false, notFound: true };<br><br>    const apiKey = crypto.randomBytes(32).toString('hex');<br>    const hmacSecret = crypto.randomBytes(32).toString('hex');<br>    store.updateMerchantKeysTx(storeId, apiKey, hmacSecret);<br>    return { ok: true, apiKey, hmacSecret };<br>  }<br>}<br>```<br><br>--- |
| MerchantOnchainSyncPlanner | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-SYNC-ONCHAIN<br><br>Delegate State Owned:<br>- None (stateless planner; composes unsigned calls per request).<br><br>Delegate Responsibilities Owned:<br>- Load merchant projection by storeId; 404 if missing.<br>- Detect on-chain merchant registration via StacksChainClient.isMerchantRegisteredOnChain (duck-typed).<br>- Build unsigned calls using IContractCallBuilder:<br>  - If not registered: buildRegisterMerchant with name as optional.<br>  - Always: buildSetMerchantActive with merchant active flag.<br>- Return array of UnsignedContractCall for client signing.<br><br>Responsibilities Removed from Parent Class:<br>- Conditional planning logic to compose unsigned payloads for on-chain sync.<br><br>Delegate Public Interface:<br>- planForStore(store: ISqliteStore, chain: IStacksChainClient, builder: IContractCallBuilder, storeId: string): Promise<{ notFound: true } or { calls: UnsignedContractCall[] }><br><br>Example Interaction:<br>```typescript<br>const planner = new MerchantOnchainSyncPlanner();<br>const plan = await planner.planForStore(this.store, this.chain, this.builder, storeId);<br>if ('notFound' in plan) { res.status(404).end(); return; }<br>res.json({ calls: plan.calls });<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.syncOnchain<br>- Controller now:<br>  - Validates storeId UUID via AdminParamGuard<br>  - Delegates planning to MerchantOnchainSyncPlanner<br>  - Returns { calls } JSON with unsigned payloads<br>```typescript<br>async syncOnchain(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const storeId = String(req.params.storeId);<br>  guard.assertUuid(storeId);<br><br>  const planner = new MerchantOnchainSyncPlanner();<br>  const result = await planner.planForStore(this.store, this.chain, this.builder, storeId);<br>  if ('notFound' in result) {<br>    res.status(404).end();<br>    return;<br>  }<br>  res.json({ calls: result.calls });<br>}<br>```<br><br>#### 🔧 Delegate Method: planForStore<br>- Responsibility: Build the minimal set of unsigned calls to reconcile on-chain merchant state for a given store.<br>- Signature: planForStore(store: ISqliteStore, chain: IStacksChainClient, builder: IContractCallBuilder, storeId: string): Promise<{ notFound: true } or { calls: UnsignedContractCall[] }><br>```typescript<br>import { ISqliteStore } from '../contracts/dao';<br>import { IStacksChainClient, IContractCallBuilder } from '../contracts/interfaces';<br>import { UnsignedContractCall } from '../models/domain';<br><br>export class MerchantOnchainSyncPlanner {<br>  async planForStore(<br>    store: ISqliteStore,<br>    chain: IStacksChainClient,<br>    builder: IContractCallBuilder,<br>    storeId: string<br>  ): Promise<{ notFound: true } or { calls: UnsignedContractCall[] }> {<br>    const merchant = store.listMerchantsProjection().find((m: any) => m.id === storeId);<br>    if (!merchant) return { notFound: true };<br><br>    const principal: string = merchant.principal;<br>    const isRegistered: boolean = await (chain as any).isMerchantRegisteredOnChain(principal);<br><br>    const calls: UnsignedContractCall[] = [];<br>    if (!isRegistered) {<br>      calls.push(<br>        builder.buildRegisterMerchant({<br>          merchant: principal,<br>          name: merchant.name ?? undefined,<br>        }),<br>      );<br>    }<br>    calls.push(<br>      builder.buildSetMerchantActive({<br>        merchant: principal,<br>        active: !!merchant.active,<br>      }),<br>    );<br><br>    return { calls };<br>  }<br>}<br>```<br><br>--- |
| WebhookAdminRetryService | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-RETRY-WEBHOOK<br><br>Delegate State Owned:<br>- None (stateless; uses DAO and dispatcher per call).<br><br>Delegate Responsibilities Owned:<br>- Load webhook log row by ID; indicate not-found if missing.<br>- Idempotence: Check if a successful delivery exists for the same context; short-circuit if yes.<br>- Enqueue retry if not already in-flight via dispatcher.enqueueRetryIfNotInflight(row) using duck-typing.<br>- Return a discriminated result indicating path taken.<br><br>Responsibilities Removed from Parent Class:<br>- Idempotence checks and dispatch interaction details.<br><br>Delegate Public Interface:<br>- retry(store: ISqliteStore, dispatcher: IWebhookDispatcher, webhookLogId: string): Promise<{ type: 'not-found' } or { type: 'already-delivered' } or { type: 'enqueued'; enqueued: boolean }><br><br>Example Interaction:<br>```typescript<br>const svc = new WebhookAdminRetryService();<br>const outcome = await svc.retry(this.store, this.dispatcher, webhookLogId);<br>if (outcome.type === 'not-found') { res.status(404).end(); return; }<br>if (outcome.type === 'already-delivered') { res.status(200).json({ alreadyDelivered: true }); return; }<br>res.status(202).json({ enqueued: outcome.enqueued });<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.retryWebhook<br>- Controller:<br>  - Validates webhookLogId via AdminParamGuard.assertUuid<br>  - Delegates idempotent retry to WebhookAdminRetryService<br>  - Maps outcomes to HTTP responses (404, 200, 202)<br>```typescript<br>async retryWebhook(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const body = req.body or {};<br>  const webhookLogId = String(body.webhookLogId ?? '');<br>  guard.assertUuid(webhookLogId);<br><br>  const svc = new WebhookAdminRetryService();<br>  const outcome = await svc.retry(this.store, this.dispatcher, webhookLogId);<br><br>  if (outcome.type === 'not-found') {<br>    res.status(404).end();<br>    return;<br>  }<br>  if (outcome.type === 'already-delivered') {<br>    res.status(200).json({ alreadyDelivered: true });<br>    return;<br>  }<br>  res.status(202).json({ enqueued: outcome.enqueued });<br>}<br>```<br><br>#### 🔧 Delegate Method: retry<br>- Responsibility: Encapsulate all logic to safely and idempotently enqueue a webhook retry.<br>- Signature: retry(store: ISqliteStore, dispatcher: IWebhookDispatcher, webhookLogId: string): Promise<{ type: 'not-found' } or { type: 'already-delivered' } or { type: 'enqueued'; enqueued: boolean }><br>```typescript<br>import { ISqliteStore } from '../contracts/dao';<br>import { IWebhookDispatcher } from '../contracts/webhooks';<br>import { WebhookLogRow } from '../models/domain';<br><br>export class WebhookAdminRetryService {<br>  async retry(<br>    store: ISqliteStore,<br>    dispatcher: IWebhookDispatcher,<br>    webhookLogId: string<br>  ): Promise<{ type: 'not-found' } or { type: 'already-delivered' } or { type: 'enqueued'; enqueued: boolean }> {<br>    const row = store.getWebhookLogById(webhookLogId);<br>    if (!row) return { type: 'not-found' };<br><br>    const successExists = store.existsSuccessfulDeliveryFor({<br>      storeId: row.store_id,<br>      invoiceId: row.invoice_id ?? undefined,<br>      subscriptionId: row.subscription_id ?? undefined,<br>      eventType: row.event_type as any,<br>    });<br>    if (successExists) return { type: 'already-delivered' };<br><br>    const enqueued = await (dispatcher as any).enqueueRetryIfNotInflight(row as WebhookLogRow);<br>    return { type: 'enqueued', enqueued: !!enqueued };<br>  }<br>}<br>```<br><br>--- |
| MerchantCreationService | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-CREATE-STORE<br><br>Delegate State Owned:<br>- None (stateless factory; uses crypto and DAO per call).<br><br>Delegate Responsibilities Owned:<br>- Generate id (UUID), apiKey, hmacSecret, createdAt.<br>- Build merchant insert object from request body with exact snake_case fields.<br>- Insert merchant via DAO.<br>- Map SQLITE_CONSTRAINT to a conflict outcome without throwing to the controller.<br>- Return non-secret projection for response.<br><br>Responsibilities Removed from Parent Class:<br>- Secret/id generation and DB insert error mapping.<br><br>Delegate Public Interface:<br>- create(store: ISqliteStore, body: any): Promise<{ status: 'created'; dto: MerchantDto } or { status: 'conflict' }><br><br>Example Interaction:<br>```typescript<br>const svc = new MerchantCreationService();<br>const result = await svc.create(this.store, req.body or {});<br>if (result.status === 'conflict') { res.status(409).end(); return; }<br>res.status(201).json(result.dto);<br>```<br><br>#### 🔁 Refactored Method: AdminApiController.createStore<br>- Controller:<br>  - Validates principal via AdminParamGuard.assertStacksPrincipal<br>  - Delegates creation to MerchantCreationService<br>  - Responds 201 with non-secret projection or 409 on unique constraint violations<br>```typescript<br>async createStore(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const principal = String((req.body or {}).principal ?? '');<br>  guard.assertStacksPrincipal(principal);<br><br>  const svc = new MerchantCreationService();<br>  const result = await svc.create(this.store, { ...req.body, principal });<br><br>  if (result.status === 'conflict') {<br>    res.status(409).end();<br>    return;<br>  }<br>  res.status(201).json(result.dto);<br>}<br>```<br><br>#### 🔧 Delegate Method: create<br>- Responsibility: End-to-end merchant creation with secure secrets and error mapping to conflict.<br>- Signature: create(store: ISqliteStore, body: any): Promise<{ status: 'created'; dto: MerchantDto } or { status: 'conflict' }><br>```typescript<br>import crypto from 'crypto';<br>import { ISqliteStore } from '../contracts/dao';<br>import { MerchantDto } from './AdminDtoProjector';<br><br>export class MerchantCreationService {<br>  async create(<br>    store: ISqliteStore,<br>    body: any<br>  ): Promise<{ status: 'created'; dto: MerchantDto } or { status: 'conflict' }> {<br>    const id = crypto.randomUUID();<br>    const createdAt = Math.floor(Date.now() / 1000);<br>    const apiKey = crypto.randomBytes(32).toString('hex');<br>    const hmacSecret = crypto.randomBytes(32).toString('hex');<br><br>    const insertRow: any = {<br>      id,<br>      principal: String(body.principal),<br>      name: body.name ?? undefined,<br>      display_name: body.displayName ?? undefined,<br>      logo_url: body.logoUrl ?? undefined,<br>      brand_color: body.brandColor ?? undefined,<br>      webhook_url: body.webhookUrl ?? undefined,<br>      hmac_secret: hmacSecret,<br>      api_key: apiKey,<br>      active: 1,<br>      support_email: body.supportEmail ?? undefined,<br>      support_url: body.supportUrl ?? undefined,<br>      allowed_origins: body.allowedOrigins ?? undefined,<br>      created_at: createdAt,<br>    };<br><br>    try {<br>      store.insertMerchant(insertRow);<br>    } catch (e: any) {<br>      if (e && (e.code === 'SQLITE_CONSTRAINT' or e.errno === 19)) {<br>        return { status: 'conflict' };<br>      }<br>      throw e;<br>    }<br><br>    const dto: MerchantDto = {<br>      id,<br>      principal: insertRow.principal,<br>      name: insertRow.name ?? undefined,<br>      displayName: insertRow.display_name ?? undefined,<br>      logoUrl: insertRow.logo_url ?? undefined,<br>      brandColor: insertRow.brand_color ?? undefined,<br>      webhookUrl: insertRow.webhook_url ?? undefined,<br>      active: true,<br>      supportEmail: insertRow.support_email ?? undefined,<br>      supportUrl: insertRow.support_url ?? undefined,<br>      allowedOrigins: insertRow.allowed_origins ?? undefined,<br>      createdAt,<br>    };<br><br>    return { status: 'created', dto };<br>  }<br>}<br>```<br><br>--- |
| Additional Controller Usages of AdminParamGuard | - **[Offloading Class Names]**: AdminApiController<br>- **[Originating Method Ids]**: AAC-SET-SBTC-TOKEN, AAC-ACTIVATE-STORE, AAC-CANCEL-INVOICE-ADMIN<br><br>Delegate State Owned:<br>- None.<br><br>Delegate Responsibilities Owned:<br>- Centralized validation in lightweight methods.<br><br>Responsibilities Removed from Parent Class:<br>- Repeated regex checks and boolean parsing validation noise.<br><br>Delegate Public Interface:<br>- See AdminParamGuard above.<br><br>Example Interaction:<br>```typescript<br>// AAC-SET-SBTC-TOKEN<br>async setSbtcToken(req: Request, res: Response): Promise<void> {<br>  const guard = new AdminParamGuard();<br>  const body = req.body or {};<br>  const contractAddress = String(body.contractAddress ?? '');<br>  const contractName = String(body.contractName ?? '');<br>  guard.assertStacksPrincipal(contractAddress);<br>  if (!contractName) { res.status(400).end(); return; }<br>  const call = this.builder.buildSetSbtcToken({ contractAddress, contractName });<br>  res.json({ call });<br>}<br>```<br><br>End of report. |
| ContractCallEventNormalizer | - **[Offloading Class Names]**: PaymentPoller<br>- **[Originating Method Ids]**: PP-FETCH-FILTER-1<br><br>Delegate State Owned:<br>- None (stateless; pure transformation based on inputs).<br><br>Delegate Responsibilities Owned:<br>- Fetch contract-call events from the Stacks API starting at a given height.<br>- Normalize Extended API events into NormalizedEvent objects.<br>- Validate and coerce ids to exact 64-hex (lowercase).<br>- Filter by known function names relevant to payments/subscriptions.<br>- Drop unknown invoice/subscription ids based on SQLite presence policies (invoices must exist; subscriptions are upserted).<br><br>Responsibilities Removed from Parent Class:<br>- Parsing and normalizing Stacks contract-call event payloads.<br>- Deterministic sorting and arg decoding (buffer hex, repr numbers/principals).<br>- DB-based existence filtering during normalization.<br><br>Delegate Public Interface:<br>```typescript<br>export type NormalizedEventType =<br>  or 'invoice-paid'<br>  or 'refund-invoice'<br>  or 'invoice-canceled'<br>  or 'create-subscription'<br>  or 'cancel-subscription'<br>  or 'pay-subscription';<br><br>export type NormalizedEvent = {<br>  type: NormalizedEventType;<br>  idHex: string;<br>  block_height: number;<br>  tx_id: string;<br>  tx_index: number;<br>  sender?: string;<br>  merchantPrincipal?: string;<br>  subscriber?: string;<br>  amountSats?: number;<br>  intervalBlocks?: number;<br>  refundAmountSats?: number;<br>};<br><br>export interface IStacksChainClient {<br>  getContractCallEvents(args: { fromHeight: number }): Promise<any[]>;<br>}<br><br>export interface ISqliteStore {<br>  invoiceExists(idHex: string): boolean;<br>}<br>```<br><br>```typescript<br>export class ContractCallEventNormalizer {<br>  async fetchAndFilterEvents(<br>    fromHeight: number,<br>    chain: IStacksChainClient,<br>    store: ISqliteStore,<br>  ): Promise<NormalizedEvent[]> {<br>    const raw = await chain.getContractCallEvents({ fromHeight });<br><br>    const allowed = new Set<string>([<br>      'pay-invoice',<br>      'refund-invoice',<br>      'cancel-invoice',<br>      'create-subscription',<br>      'cancel-subscription',<br>      'pay-subscription',<br>    ]);<br><br>    const normalizeHex64 = (arg: any): string => {<br>      const hex = String(arg?.hex ?? '').replace(/^0x/, '');<br>      return hex.toLowerCase();<br>    };<br><br>    const parseUInt = (arg: any): number => {<br>      const repr: string = String(arg?.repr ?? '');<br>      if (repr.startsWith('u')) return Number(repr.slice(1));<br>      return Number(repr);<br>    };<br><br>    const parsePrincipal = (arg: any): string => {<br>      return String(arg?.repr ?? '');<br>    };<br><br>    const out: NormalizedEvent[] = [];<br><br>    for (const tx of raw) {<br>      const fn = String(tx?.contract_call?.function_name ?? '');<br>      if (!allowed.has(fn)) continue;<br><br>      const args: any[] = tx?.contract_call?.function_args ?? [];<br>      const block_height: number = Number(tx.block_height);<br>      const tx_id: string = String(tx.tx_id);<br>      const tx_index: number = Number(tx.tx_index ?? 0);<br>      const sender: string = String(tx.sender_address ?? '');<br><br>      const idHex = args[0] ? normalizeHex64(args[0]) : '';<br>      if (!/^[0-9a-f]{64}$/.test(idHex)) continue;<br><br>      if (fn === 'pay-invoice') {<br>        if (store.invoiceExists(idHex)) {<br>          out.push({ type: 'invoice-paid', idHex, block_height, tx_id, tx_index, sender });<br>        }<br>        continue;<br>      }<br><br>      if (fn === 'refund-invoice') {<br>        if (store.invoiceExists(idHex)) {<br>          const refundAmountSats = parseUInt(args[1]);<br>          out.push({ type: 'refund-invoice', idHex, block_height, tx_id, tx_index, refundAmountSats });<br>        }<br>        continue;<br>      }<br><br>      if (fn === 'cancel-invoice') {<br>        if (store.invoiceExists(idHex)) {<br>          out.push({ type: 'invoice-canceled', idHex, block_height, tx_id, tx_index });<br>        }<br>        continue;<br>      }<br><br>      if (fn === 'create-subscription') {<br>        const merchantPrincipal = parsePrincipal(args[1]);<br>        const subscriber = parsePrincipal(args[2]);<br>        const amountSats = parseUInt(args[3]);<br>        const intervalBlocks = parseUInt(args[4]);<br>        out.push({<br>          type: 'create-subscription',<br>          idHex,<br>          block_height,<br>          tx_id,<br>          tx_index,<br>          merchantPrincipal,<br>          subscriber,<br>          amountSats,<br>          intervalBlocks,<br>        });<br>        continue;<br>      }<br><br>      if (fn === 'cancel-subscription') {<br>        out.push({ type: 'cancel-subscription', idHex, block_height, tx_id, tx_index });<br>        continue;<br>      }<br><br>      if (fn === 'pay-subscription') {<br>        out.push({ type: 'pay-subscription', idHex, block_height, tx_id, tx_index, sender });<br>        continue;<br>      }<br>    }<br><br>    out.sort((a, b) => {<br>      if (a.block_height !== b.block_height) return a.block_height - b.block_height;<br>      return a.tx_index - b.tx_index;<br>    });<br><br>    return out;<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// PaymentPoller.fetchAndFilterEvents refactored to delegate<br>async fetchAndFilterEvents(fromHeight: number): Promise<NormalizedEvent[]> {<br>  return this.eventNormalizer.fetchAndFilterEvents(fromHeight, this.chain, this.store);<br>}<br>```<br><br>#### 🔁 Refactored Method: PaymentPoller.fetchAndFilterEvents<br>- After refactoring, PaymentPoller delegates fetching, normalization, validation, and filtering to ContractCallEventNormalizer.fetchAndFilterEvents.<br>- PaymentPoller passes fromHeight, chain client, and store; receives a sorted NormalizedEvent[].<br>- PaymentPoller no longer implements arg decoding, idHex validation, or DB existence checks.<br><br>#### 🔧 Delegate Method: fetchAndFilterEvents<br>- Responsibility: Performs the end-to-end event retrieval and normalization as specified by PP-FETCH-FILTER-1.<br>- Signature: fetchAndFilterEvents(fromHeight: number, chain: IStacksChainClient, store: ISqliteStore): Promise<NormalizedEvent[]><br>- Returns: NormalizedEvent[] sorted deterministically, invalid or unknown dropped as required.<br><br>--- |
| ReorgGuard | - **[Offloading Class Names]**: PaymentPoller<br>- **[Originating Method Ids]**: PP-7, PP-8, PP-PLAN-REWIND-1<br><br>Delegate State Owned:<br>- None (stateless computations given inputs).<br><br>Delegate Responsibilities Owned:<br>- Detect potential reorgs or tip regressions by comparing parent hashes and heights.<br>- Compute rewind target height using configured window.<br><br>Responsibilities Removed from Parent Class:<br>- Header fetch and parent-hash comparison logic for reorg detection.<br>- Rewind target calculation logic.<br><br>Delegate Public Interface:<br>```typescript<br>export interface IStacksChainClient {<br>  getBlockHeader(height: number): Promise<{ block_hash: string; parent_block_hash: string }>;<br>}<br><br>export type CursorSnapshot = { lastHeight: number; lastBlockHash?: string };<br>```<br><br>```typescript<br>export class ReorgGuard {<br>  async detectReorg(<br>    firstBlockToProcessHeight: number,<br>    tipHeight: number,<br>    cursor: CursorSnapshot,<br>    chain: IStacksChainClient,<br>  ): Promise<boolean> {<br>    if (tipHeight < cursor.lastHeight) return true;<br>    if (cursor.lastHeight === 0) return false;<br>    const header = await chain.getBlockHeader(firstBlockToProcessHeight);<br>    const parent = header.parent_block_hash;<br>    return parent !== cursor.lastBlockHash;<br>  }<br><br>  computeRewindTarget(cursor: CursorSnapshot, reorgWindowBlocks: number): number {<br>    const back = Math.max(0, cursor.lastHeight - reorgWindowBlocks);<br>    return back;<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// PaymentPoller.detectReorg refactored to delegate<br>async detectReorg(firstBlockToProcessHeight: number, tipHeight: number): Promise<boolean> {<br>  return this.reorgGuard.detectReorg(<br>    firstBlockToProcessHeight,<br>    tipHeight,<br>    { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash },<br>    this.chain,<br>  );<br>}<br><br>// PaymentPoller.planRewindWindow refactored to delegate computation<br>planRewindWindow(): void {<br>  const { reorgWindowBlocks } = this.cfg.getPollingConfig();<br>  const target = this.reorgGuard.computeRewindTarget(<br>    { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash },<br>    reorgWindowBlocks,<br>  );<br>  this.planRewind(target);<br>}<br>```<br><br>#### 🔁 Refactored Method: PaymentPoller.detectReorg<br>- Now calls reorgGuard.detectReorg with the first block to process, tip height, cursor snapshot, and chain.<br>- Returns the boolean result directly; no DB or state mutations.<br><br>#### 🔁 Refactored Method: PaymentPoller.planRewindWindow<br>- Now computes the rewind target via reorgGuard.computeRewindTarget and forwards it to existing planRewind.<br><br>#### 🔁 Refactored Method: PaymentPoller.planRewind<br>- Unchanged signature and behavior; this method remains to set in-memory plan. It’s invoked by planRewindWindow after ReorgGuard computes target.<br><br>#### 🔧 Delegate Method: detectReorg<br>- Responsibility: Implements PP-7 comparison rules.<br>- Signature/Return: see interface above.<br>- Behavior: Uses chain.getBlockHeader to compare parent hash against cursor.lastBlockHash; checks tip regression.<br><br>#### 🔧 Delegate Method: computeRewindTarget<br>- Responsibility: Implements PP-8/PP-PLAN-REWIND-1 rewind window calculation.<br>- Returns: number (height to rewind to).<br><br>--- |
| SubscriptionLifecycleProcessor | - **[Offloading Class Names]**: PaymentPoller<br>- **[Originating Method Ids]**: PP-16<br><br>Delegate State Owned:<br>- None (stateless; uses provided dependencies).<br><br>Delegate Responsibilities Owned:<br>- Process subscription lifecycle events before general invoice handling.<br>- Confirmations gating.<br>- UPSERT/create subscription rows and state transitions (active flag).<br>- Optional on-chain read-only to enrich webhook payloads (nextDue).<br>- Dispatch subscription webhooks with exact camelCase payload shapes.<br><br>Responsibilities Removed from Parent Class:<br>- Iteration/filtering of subscription events and confirmations checks.<br>- DB mutations for subscription create/cancel/paid and payload building.<br>- On-chain read-only enrichment for nextDue.<br><br>Delegate Public Interface:<br>```typescript<br>export interface ISqliteStore {<br>  getStoreIdByPrincipal(merchantPrincipal: string): string or undefined;<br>  upsertSubscriptionByHex(input: {<br>    idHex: string;<br>    storeId: string;<br>    merchantPrincipal: string;<br>    subscriber: string;<br>    amountSats: number;<br>    intervalBlocks: number;<br>    active: number;<br>  }): void;<br>  setSubscriptionActive(input: { idHex: string; active: number }): void;<br>  updateSubscriptionLastPaid(input: { subscriptionId: string; lastPaidInvoiceId: string }): void;<br>}<br><br>export interface IStacksChainClient {<br>  readSubscription(idHex: string): Promise<<br>    or {<br>        merchant: string;<br>        amountSats: string or number;<br>        nextDue: string or number;<br>      }<br>    or undefined<br>  >;<br>}<br><br>export interface IWebhookDispatcher {<br>  dispatch(args: {<br>    storeId: string;<br>    subscriptionId: string;<br>    eventType: 'subscription-created' or 'subscription-canceled' or 'subscription-paid';<br>    rawBody: string;<br>  }): Promise<void>;<br>}<br>```<br><br>```typescript<br>export class SubscriptionLifecycleProcessor {<br>  constructor(<br>    private store: ISqliteStore,<br>    private chain: IStacksChainClient,<br>    private dispatcher: IWebhookDispatcher,<br>  ) {}<br><br>  async processBatch(<br>    batch: NormalizedEvent[],<br>    tipHeight: number,<br>    minConfirmations: number,<br>  ): Promise<void> {<br>    // create-subscription<br>    for (const e of batch) {<br>      if (e.type !== 'create-subscription') continue;<br>      const conf = tipHeight - e.block_height + 1;<br>      if (conf < minConfirmations) continue;<br><br>      const storeId = this.store.getStoreIdByPrincipal(e.merchantPrincipal!);<br>      if (!storeId) continue;<br><br>      this.store.upsertSubscriptionByHex({<br>        idHex: e.idHex,<br>        storeId,<br>        merchantPrincipal: e.merchantPrincipal!,<br>        subscriber: e.subscriber!,<br>        amountSats: e.amountSats!,<br>        intervalBlocks: e.intervalBlocks!,<br>        active: 1,<br>      });<br><br>      const onchain = await this.chain.readSubscription(e.idHex);<br>      const nextDue = onchain?.nextDue ? Number(onchain.nextDue) : 0;<br><br>      const rawBody = JSON.stringify({<br>        subscriptionId: e.idHex,<br>        merchant: e.merchantPrincipal!,<br>        subscriber: e.subscriber!,<br>        amountSats: e.amountSats!,<br>        intervalBlocks: e.intervalBlocks!,<br>        nextDue,<br>      });<br><br>      await this.dispatcher.dispatch({<br>        storeId,<br>        subscriptionId: e.idHex,<br>        eventType: 'subscription-created',<br>        rawBody,<br>      });<br>    }<br><br>    // cancel-subscription<br>    for (const e of batch) {<br>      if (e.type !== 'cancel-subscription') continue;<br>      const conf = tipHeight - e.block_height + 1;<br>      if (conf < minConfirmations) continue;<br><br>      this.store.setSubscriptionActive({ idHex: e.idHex, active: 0 });<br><br>      const onchain = await this.chain.readSubscription(e.idHex);<br>      const storeId = onchain ? this.store.getStoreIdByPrincipal(onchain.merchant) : undefined;<br>      if (!storeId) continue;<br><br>      const rawBody = JSON.stringify({ subscriptionId: e.idHex });<br><br>      await this.dispatcher.dispatch({<br>        storeId,<br>        subscriptionId: e.idHex,<br>        eventType: 'subscription-canceled',<br>        rawBody,<br>      });<br>    }<br><br>    // pay-subscription<br>    for (const e of batch) {<br>      if (e.type !== 'pay-subscription') continue;<br>      const conf = tipHeight - e.block_height + 1;<br>      if (conf < minConfirmations) continue;<br><br>      const onchain = await this.chain.readSubscription(e.idHex);<br>      const amountSats = onchain ? Number(onchain.amountSats) : 0;<br>      const nextDue = onchain ? Number(onchain.nextDue) : 0;<br>      const merchant = onchain?.merchant;<br>      const storeId = merchant ? this.store.getStoreIdByPrincipal(merchant) : undefined;<br>      if (!storeId) continue;<br><br>      // DB linkage update (idempotency handled in DAO)<br>      this.store.updateSubscriptionLastPaid({ subscriptionId: e.idHex, lastPaidInvoiceId: '' });<br><br>      const rawBody = JSON.stringify({<br>        subscriptionId: e.idHex,<br>        subscriber: e.sender!,<br>        amountSats,<br>        txId: e.tx_id,<br>        nextDue,<br>      });<br><br>      await this.dispatcher.dispatch({<br>        storeId,<br>        subscriptionId: e.idHex,<br>        eventType: 'subscription-paid',<br>        rawBody,<br>      });<br>    }<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// PaymentPoller.processSubscriptionEvents refactored to delegate<br>async processSubscriptionEvents(<br>  eventBatch: NormalizedEvent[],<br>  tipHeight: number,<br>  minConfirmations: number,<br>): Promise<void> {<br>  await this.subscriptionProcessor.processBatch(eventBatch, tipHeight, minConfirmations);<br>}<br>```<br><br>#### 🔁 Refactored Method: PaymentPoller.processSubscriptionEvents<br>- Now calls subscriptionProcessor.processBatch with the full batch and gating parameters.<br>- PaymentPoller no longer loops or handles per-type subscription logic directly.<br>- All DB updates and webhook dispatch for create/cancel/pay subscription events are encapsulated in the delegate.<br><br>#### 🔧 Delegate Method: processBatch<br>- Responsibility: Implements PP-16 end-to-end for subscription lifecycle.<br>- Signature/Return: See code. Applies confirmations gate, performs UPSERTs and state flips, enriches payloads, and dispatches webhooks.<br><br>--- |
| InvoiceEventApplier | - **[Offloading Class Names]**: PaymentPoller<br>- **[Originating Method Ids]**: PP-6, PP-10, PP-11, PP-15<br><br>Delegate State Owned:<br>- None (stateless; uses provided DAOs/clients to apply effects).<br><br>Delegate Responsibilities Owned:<br>- Apply confirmed invoice events (paid/refunded/canceled) to the database.<br>- Compose exact webhook payloads in camelCase using DB-sourced values.<br>- Dispatch corresponding webhooks.<br>- Provide single entry points usable from both processEvent and specialized handlers.<br><br>Responsibilities Removed from Parent Class:<br>- DB mutations and payload building for invoice-paid, refund-invoice, invoice-canceled.<br>- Re-fetching necessary invoice rows to obtain storeId, amountSats, invoiceId UUID.<br><br>Delegate Public Interface:<br>```typescript<br>export interface ISqliteStore {<br>  markInvoicePaid(idHex: string, payer: string, txId: string): void;<br>  upsertInvoiceRefund(idHex: string, refundAmountSats: number, txId: string): void;<br>  markInvoiceCanceled(idHex: string): void;<br>  selectAdminInvoices(statuses: string[]): Array<{<br>    id_hex: string;<br>    id_raw: string;<br>    store_id: string;<br>    amount_sats: number;<br>  }>;<br>}<br><br>export interface IWebhookDispatcher {<br>  dispatch(args: {<br>    storeId: string;<br>    invoiceId: string;<br>    eventType: 'paid' or 'refunded' or 'invoice-canceled';<br>    rawBody: string;<br>  }): Promise<void>;<br>}<br>```<br><br>```typescript<br>export class InvoiceEventApplier {<br>  constructor(private store: ISqliteStore, private dispatcher: IWebhookDispatcher) {}<br><br>  async handlePaid(e: NormalizedEvent): Promise<void> {<br>    this.store.markInvoicePaid(e.idHex, e.sender!, e.tx_id);<br><br>    const rows = this.store.selectAdminInvoices(['paid']);<br>    const row = rows.find((r) => r.id_hex === e.idHex);<br>    if (!row) return;<br><br>    const rawBody = JSON.stringify({<br>      invoiceId: row.id_raw,<br>      status: 'paid',<br>      txId: e.tx_id,<br>      payer: e.sender!,<br>      amountSats: row.amount_sats,<br>    });<br><br>    await this.dispatcher.dispatch({<br>      storeId: row.store_id,<br>      invoiceId: row.id_raw,<br>      eventType: 'paid',<br>      rawBody,<br>    });<br>  }<br><br>  async handleRefund(e: NormalizedEvent): Promise<void> {<br>    const refundAmount = e.refundAmountSats!;<br>    this.store.upsertInvoiceRefund(e.idHex, refundAmount, e.tx_id);<br><br>    const rows = this.store.selectAdminInvoices(['refunded', 'partially_refunded', 'paid']);<br>    const row = rows.find((r) => r.id_hex === e.idHex);<br>    if (!row) return;<br><br>    const rawBody = JSON.stringify({<br>      invoiceId: row.id_raw,<br>      status: 'refunded',<br>      refundTxId: e.tx_id,<br>      refundAmount: refundAmount,<br>    });<br><br>    await this.dispatcher.dispatch({<br>      storeId: row.store_id,<br>      invoiceId: row.id_raw,<br>      eventType: 'refunded',<br>      rawBody,<br>    });<br>  }<br><br>  async handleCanceled(e: NormalizedEvent): Promise<void> {<br>    this.store.markInvoiceCanceled(e.idHex);<br><br>    const rows = this.store.selectAdminInvoices(['canceled']);<br>    const row = rows.find((r) => r.id_hex === e.idHex);<br>    if (!row) return;<br><br>    const rawBody = JSON.stringify({<br>      invoiceId: row.id_raw,<br>    });<br><br>    await this.dispatcher.dispatch({<br>      storeId: row.store_id,<br>      invoiceId: row.id_raw,<br>      eventType: 'invoice-canceled',<br>      rawBody,<br>    });<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// PaymentPoller.processEvent refactored to delegate for invoice events<br>private async processEvent(<br>  e: NormalizedEvent,<br>  tipHeight: number,<br>  minConfirmations: number,<br>): Promise<void> {<br>  const confirmations = tipHeight - e.block_height + 1;<br>  if (confirmations < minConfirmations) return;<br><br>  if (e.type === 'invoice-paid') {<br>    await this.invoiceApplier.handlePaid(e);<br>    return;<br>  }<br>  if (e.type === 'refund-invoice') {<br>    await this.invoiceApplier.handleRefund(e);<br>    return;<br>  }<br>  if (e.type === 'invoice-canceled') {<br>    await this.invoiceApplier.handleCanceled(e);<br>    return;<br>  }<br>}<br><br>// PaymentPoller.onInvoicePaidConfirmed refactored to delegate<br>private async onInvoicePaidConfirmed(event: NormalizedEvent): Promise<void> {<br>  await this.invoiceApplier.handlePaid(event);<br>}<br><br>// PaymentPoller.onRefundConfirmed refactored to delegate<br>private async onRefundConfirmed(event: NormalizedEvent): Promise<void> {<br>  await this.invoiceApplier.handleRefund(event);<br>}<br><br>// PaymentPoller.onInvoiceCanceled refactored to delegate<br>private async onInvoiceCanceled(event: NormalizedEvent): Promise<void> {<br>  await this.invoiceApplier.handleCanceled(event);<br>}<br>```<br><br>#### 🔁 Refactored Method: PaymentPoller.processEvent<br>- After confirmations gating and routing by type:<br>  - Delegates to invoiceApplier.handlePaid for 'invoice-paid'.<br>  - Delegates to invoiceApplier.handleRefund for 'refund-invoice'.<br>  - Delegates to invoiceApplier.handleCanceled for 'invoice-canceled'.<br>- Subscription types remain excluded (handled in processSubscriptionEvents).<br><br>#### 🔁 Refactored Method: PaymentPoller.onInvoicePaidConfirmed<br>- Now directly calls invoiceApplier.handlePaid with the NormalizedEvent.<br><br>#### 🔁 Refactored Method: PaymentPoller.onRefundConfirmed<br>- Now directly calls invoiceApplier.handleRefund with the NormalizedEvent.<br><br>#### 🔁 Refactored Method: PaymentPoller.onInvoiceCanceled<br>- Now directly calls invoiceApplier.handleCanceled with the NormalizedEvent.<br><br>#### 🔧 Delegate Method: handlePaid<br>- Responsibility: Applies DB update markInvoicePaid; composes exact webhook payload with camelCase fields; dispatches 'paid'.<br><br>#### 🔧 Delegate Method: handleRefund<br>- Responsibility: UPSERTs refund and dispatches 'refunded' payload including refundTxId and refundAmount.<br><br>#### 🔧 Delegate Method: handleCanceled<br>- Responsibility: Marks invoice canceled and dispatches 'invoice-canceled' payload containing invoiceId only.<br><br>---<br><br>```typescript<br>// Integration wiring example inside PaymentPoller constructor or initializer<br>import { ContractCallEventNormalizer } from './delegates/ContractCallEventNormalizer';<br>import { ReorgGuard } from './delegates/ReorgGuard';<br>import { SubscriptionLifecycleProcessor } from './delegates/SubscriptionLifecycleProcessor';<br>import { InvoiceEventApplier } from './delegates/InvoiceEventApplier';<br><br>class PaymentPoller {<br>  private eventNormalizer = new ContractCallEventNormalizer();<br>  private reorgGuard = new ReorgGuard();<br>  private subscriptionProcessor = new SubscriptionLifecycleProcessor(this.store, this.chain, this.dispatcher);<br>  private invoiceApplier = new InvoiceEventApplier(this.store, this.dispatcher);<br><br>  // ... rest of PaymentPoller stays as per Architectural Plan, calling delegates as shown above<br>}<br>```<br><br>End of report. |
| InvoiceCountdownDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-START-COUNTDOWN, CFF-UPDATE-COUNTDOWN, CFF-RENDER-COUNTDOWN, CFF-1<br><br>Delegate State Owned:<br>- quoteExpiresAtMs: number or null<br>- highlightThresholdMs: number<br>- intervalId: number or undefined<br>- expiredHandled: boolean<br>- now: () => number (injected clock for deterministic timing)<br>- onTick: ((timeLeftMs: number) => void) or null<br>- onExpire: (() => void) or null<br><br>Delegate Responsibilities Owned:<br>- Manage countdown interval lifecycle (start/stop/force tick).<br>- Compute remaining time; invoke onTick callback each second.<br>- Trigger single-shot onExpire callback when time reaches zero.<br>- Maintain highlight/expiry internal state to avoid duplicate expirations.<br><br>Responsibilities Removed from Parent Class:<br>- Interval management for countdown.<br>- Time math and highlighting trigger logic.<br>- Expiry transition trigger and deduplication.<br><br>Delegate Public Interface:<br>```typescript<br>export type CountdownTick = (timeLeftMs: number) => void;<br><br>export class InvoiceCountdownDelegate {<br>  private quoteExpiresAtMs: number or null = null;<br>  private readonly highlightThresholdMs: number;<br>  private intervalId: number or undefined;<br>  private expiredHandled = false;<br>  private readonly now: () => number;<br>  private onTick: CountdownTick or null = null;<br>  private onExpire: (() => void) or null = null;<br><br>  constructor(opts?: { highlightThresholdMs?: number; now?: () => number }) {<br>    this.highlightThresholdMs = opts?.highlightThresholdMs ?? 60_000;<br>    this.now = opts?.now ?? (() => Date.now());<br>  }<br><br>  start(quoteExpiresAtMs: number, onTick: CountdownTick, onExpire: () => void): void {<br>    this.stop();<br>    this.quoteExpiresAtMs = quoteExpiresAtMs;<br>    this.onTick = onTick;<br>    this.onExpire = onExpire;<br>    this.expiredHandled = false;<br>    this.intervalId = window.setInterval(() => this.tick(), 1000);<br>    this.tick();<br>  }<br><br>  stop(): void {<br>    if (this.intervalId !== undefined) {<br>      window.clearInterval(this.intervalId);<br>      this.intervalId = undefined;<br>    }<br>    this.onTick = null;<br>    this.onExpire = null;<br>    this.quoteExpiresAtMs = null;<br>    this.expiredHandled = false;<br>  }<br><br>  forceTick(): void {<br>    this.tick();<br>  }<br><br>  private computeTimeLeftMs(): number {<br>    if (this.quoteExpiresAtMs === null) return 0;<br>    return Math.max(0, this.quoteExpiresAtMs - this.now());<br>  }<br><br>  private tick(): void {<br>    if (this.quoteExpiresAtMs === null) return;<br>    const timeLeftMs = this.computeTimeLeftMs();<br>    if (this.onTick) this.onTick(timeLeftMs);<br><br>    // Expiration gate<br>    if (timeLeftMs <= 0 && !this.expiredHandled) {<br>      this.expiredHandled = true;<br>      if (this.onExpire) this.onExpire();<br>      // stop interval; visual countdown no longer runs<br>      if (this.intervalId !== undefined) {<br>        window.clearInterval(this.intervalId);<br>        this.intervalId = undefined;<br>      }<br>    }<br>  }<br><br>  expireNow(): void {<br>    if (!this.expiredHandled) {<br>      this.expiredHandled = true;<br>      if (this.onExpire) this.onExpire();<br>      if (this.intervalId !== undefined) {<br>        window.clearInterval(this.intervalId);<br>        this.intervalId = undefined;<br>      }<br>    }<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const countdown = new InvoiceCountdownDelegate({ highlightThresholdMs: HIGHLIGHT_THRESHOLD_MS });<br>countdown.start(invoice.quoteExpiresAt, (ms) => CheckoutFrontend.renderCountdown(ms), () => {<br>  CheckoutFrontend.setStatusBadge('expired');<br>  CheckoutFrontend.disablePaymentActions();<br>  show('#expiredView');<br>});<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.startCountdown<br>Breakdown after refactor:<br>- The parent no longer sets intervals directly. It instantiates/uses InvoiceCountdownDelegate.start to schedule ticks and bind two callbacks: renderCountdown and a one-shot expiry handler that updates status badge, disables actions, and shows expired view.<br><br>```typescript<br>// Wrapper maintaining the same signature<br>startCountdown(quoteExpiresAtMs: number): void {<br>  this._countdown = this._countdown ?? new InvoiceCountdownDelegate({ highlightThresholdMs: HIGHLIGHT_THRESHOLD_MS });<br>  this._countdown.start(<br>    quoteExpiresAtMs,<br>    (timeLeftMs) => this.renderCountdown(timeLeftMs),<br>    () => {<br>      this.setStatusBadge('expired');<br>      this.disablePaymentActions();<br>      show('#expiredView');<br>    }<br>  );<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.updateCountdown<br>- Delegates the tick computation and callback dispatch to the countdown delegate; no direct time math remains in parent.<br><br>```typescript<br>updateCountdown(): void {<br>  if (!this._countdown) return;<br>  this._countdown.forceTick();<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.renderCountdown<br>- Continues to perform the pure DOM rendering for countdown; still called, but now receives values from the delegate via onTick.<br><br>```typescript<br>renderCountdown(timeLeftMs: number): void {<br>  const node = document.querySelector('#countdown') as HTMLElement or null;<br>  if (!node) return;<br>  const totalSeconds = Math.floor(timeLeftMs / 1000);<br>  const m = Math.floor(totalSeconds / 60);<br>  const s = totalSeconds % 60;<br>  node.textContent = `${m}:${s.toString().padStart(2, '0')}`;<br>  if (timeLeftMs <= HIGHLIGHT_THRESHOLD_MS) node.classList.add('expiring');<br>  else node.classList.remove('expiring');<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.handleExpiry<br>- No local state transitions or interval clearing; calls delegate to trigger the one-shot expiry path bound in start().<br><br>```typescript<br>handleExpiry(): void {<br>  if (!this._countdown) return;<br>  this._countdown.expireNow();<br>}<br>```<br><br>#### 🔧 Delegate Method: start<br>- Starts the interval, stores callbacks, emits initial tick immediately.<br><br>```typescript<br>// See class above; method included for clarity<br>start(quoteExpiresAtMs: number, onTick: CountdownTick, onExpire: () => void): void { /* ...as implemented above... */ }<br>```<br><br>#### 🔧 Delegate Method: forceTick<br>- Forces an immediate tick; used by parent updateCountdown() wrapper.<br><br>```typescript<br>forceTick(): void { /* ...as implemented above... */ }<br>```<br><br>#### 🔧 Delegate Method: expireNow<br>- Immediately triggers onExpire path if not yet handled; used by parent handleExpiry().<br><br>```typescript<br>expireNow(): void { /* ...as implemented above... */ }<br>```<br><br>--- |
| InvoiceStatusPollerDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-START-POLL, CFF-2<br><br>Delegate State Owned:<br>- invoiceId: string or null<br>- intervalMs: number<br>- intervalId: number or undefined<br>- abort: AbortController or null<br>- isPolling: boolean<br><br>Delegate Responsibilities Owned:<br>- Guarded polling loop (avoid overlapping requests).<br>- Abort in-flight fetches if a new tick fires.<br>- Manage interval lifecycle (start/stop/tick) independent of parent UI.<br><br>Responsibilities Removed from Parent Class:<br>- AbortController and interval ownership for status polling.<br>- In-flight request guard and overlap prevention.<br><br>Delegate Public Interface:<br>```typescript<br>export type InvoiceFetcher = (invoiceId: string, signal: AbortSignal) => Promise<PublicInvoiceDTO>;<br>export type InvoiceHandler = (dto: PublicInvoiceDTO) => void;<br><br>export class InvoiceStatusPollerDelegate {<br>  private invoiceId: string or null = null;<br>  private intervalMs = 15000;<br>  private intervalId: number or undefined;<br>  private abort: AbortController or null = null;<br>  private fetcher: InvoiceFetcher or null = null;<br>  private handler: InvoiceHandler or null = null;<br><br>  start(invoiceId: string, intervalMs: number, fetcher: InvoiceFetcher, handler: InvoiceHandler): void {<br>    this.stop();<br>    this.invoiceId = invoiceId;<br>    this.intervalMs = intervalMs;<br>    this.fetcher = fetcher;<br>    this.handler = handler;<br>    this.intervalId = window.setInterval(() => void this.tick(), this.intervalMs);<br>  }<br><br>  async tick(): Promise<void> {<br>    if (!this.invoiceId or !this.fetcher or !this.handler) return;<br>    if (this.abort) this.abort.abort();<br>    this.abort = new AbortController();<br>    try {<br>      const dto = await this.fetcher(this.invoiceId, this.abort.signal);<br>      this.handler(dto);<br>    } catch {<br>      // Silent failure; next tick will try again.<br>    }<br>  }<br><br>  stop(): void {<br>    if (this.intervalId !== undefined) {<br>      window.clearInterval(this.intervalId);<br>      this.intervalId = undefined;<br>    }<br>    if (this.abort) {<br>      this.abort.abort();<br>      this.abort = null;<br>    }<br>    this.invoiceId = null;<br>    this.fetcher = null;<br>    this.handler = null;<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const poller = new InvoiceStatusPollerDelegate();<br>poller.start(<br>  invoice.invoiceId,<br>  15000,<br>  (id, signal) => apiClient.fetchInvoiceJson(id, { signal }),<br>  (dto) => CheckoutFrontend.handlePoll(dto)<br>);<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.startPoll<br>- Starts the poller delegate with invoiceId, chosen interval, a fetcher bound to PublicCheckoutApiClient, and a handler bound to handlePoll.<br><br>```typescript<br>startPoll(invoiceId: string, intervalMs: number = 15000): void {<br>  this._poller = this._poller ?? new InvoiceStatusPollerDelegate();<br>  const client = this._api ?? new PublicCheckoutApiClient();<br>  this._poller.start(<br>    invoiceId,<br>    intervalMs,<br>    (id, signal) => client.fetchInvoiceJson(id, { signal }),<br>    (dto) => this.handlePoll(dto)<br>  );<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.pollStatus<br>- Executes a single guarded poll cycle via delegate.tick().<br><br>```typescript<br>async pollStatus(): Promise<void> {<br>  if (!this._poller) return;<br>  await this._poller.tick();<br>}<br>```<br><br>#### 🔧 Delegate Method: start<br>- Initializes interval and binds fetcher/handler; owns AbortController.<br><br>```typescript<br>start(invoiceId: string, intervalMs: number, fetcher: InvoiceFetcher, handler: InvoiceHandler): void { /* ...as implemented above... */ }<br>```<br><br>#### 🔧 Delegate Method: tick<br>- Aborts previous request if any; fetches fresh invoice; forwards to handler.<br><br>```typescript<br>async tick(): Promise<void> { /* ...as implemented above... */ }<br>```<br><br>--- |
| WalletContractCallDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-ON-OPEN-WALLET, CFF-GET-STACKS-PROVIDER, CFF-INVOKE-WALLET-OPEN-CONTRACT-CALL, CFF-ON-TX-FINISH, CFF-DISABLE-OPEN-WALLET, CFF-ON-TX-CANCEL<br><br>Delegate State Owned:<br>- None (stateless utility interacting with global wallet API and DOM)<br><br>Delegate Responsibilities Owned:<br>- Detect Stacks wallet provider presence.<br>- Open unsigned contract call payload via openContractCall.<br>- Handle wallet callbacks (finish/cancel) and apply minimal UI actions through provided callbacks.<br>- Disable the Open Wallet button via DOM.<br><br>Responsibilities Removed from Parent Class:<br>- Direct global provider detection and wallet open call wiring.<br>- Callback handling for success/cancel and related UI toggles.<br><br>Delegate Public Interface:<br>```typescript<br>export type BannerFn = (message: string, type?: 'info' or 'success' or 'error') => void;<br><br>export class WalletContractCallDelegate {<br>  getProvider(): (Window & typeof globalThis)['StacksProvider'] or null {<br>    return (window as any).StacksProvider or null;<br>  }<br><br>  async openUnsignedContractCall(<br>    payload: Record<string, any>,<br>    onFinish: (tx?: unknown) => void,<br>    onCancel: () => void<br>  ): Promise<void> {<br>    const openContractCall = (window as any).openContractCall;<br>    await openContractCall({ ...payload, onFinish, onCancel });<br>  }<br><br>  onFinish(notify: BannerFn, afterFinish: () => void, _tx?: unknown): void {<br>    notify('Payment submitted', 'success');<br>    afterFinish();<br>  }<br><br>  onCancel(notify: BannerFn): void {<br>    notify('User rejected transaction', 'info');<br>  }<br><br>  disableOpenWallet(selector = '#openWallet'): void {<br>    const btn = document.querySelector(selector) as HTMLButtonElement or null;<br>    if (btn) btn.disabled = true;<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const wallet = new WalletContractCallDelegate();<br>const provider = wallet.getProvider();<br>if (!provider) { CheckoutFrontend.banner('Wallet not connected', 'error'); return; }<br>await wallet.openUnsignedContractCall(payload, (tx) => wallet.onFinish(CheckoutFrontend.banner.bind(CheckoutFrontend), () => wallet.disableOpenWallet()), () => wallet.onCancel(CheckoutFrontend.banner.bind(CheckoutFrontend)));<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.onOpenWallet<br>- Delegates provider detection and, upon success, proceeds to requestCreateTx and handleCreateTxResponse as before.<br><br>```typescript<br>async onOpenWallet(): Promise<void> {<br>  const wallet = this._wallet ?? new WalletContractCallDelegate();<br>  const provider = wallet.getProvider();<br>  if (!provider) {<br>    this.banner('Wallet not connected', 'error');<br>    return;<br>  }<br>  if (!state.invoice) return;<br>  const res = await this.requestCreateTx(state.invoice.invoiceId);<br>  await this.handleCreateTxResponse(res);<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.getStacksProvider<br>- Now a thin wrapper over the delegate.<br><br>```typescript<br>getStacksProvider(): (Window & typeof globalThis)['StacksProvider'] or null {<br>  const wallet = this._wallet ?? new WalletContractCallDelegate();<br>  return wallet.getProvider();<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.invokeWalletOpenContractCall<br>- Opens the unsigned call via delegate, wiring callbacks to parent methods.<br><br>```typescript<br>async invokeWalletOpenContractCall(payload: UnsignedContractCall): Promise<void> {<br>  const wallet = this._wallet ?? new WalletContractCallDelegate();<br>  await wallet.openUnsignedContractCall(<br>    payload,<br>    (tx) => this.onTxFinish(tx),<br>    () => this.onTxCancel()<br>  );<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.onTxFinish<br>- Delegates banner display and disabling of the Open Wallet button.<br><br>```typescript<br>onTxFinish(tx?: unknown): void {<br>  const wallet = this._wallet ?? new WalletContractCallDelegate();<br>  wallet.onFinish(this.banner.bind(this), () => this.disableOpenWallet(), tx);<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.disableOpenWallet<br>- Simply calls the delegate DOM utility.<br><br>```typescript<br>disableOpenWallet(): void {<br>  const wallet = this._wallet ?? new WalletContractCallDelegate();<br>  wallet.disableOpenWallet('#openWallet');<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.onTxCancel<br>- Delegates informational banner.<br><br>```typescript<br>onTxCancel(): void {<br>  const wallet = this._wallet ?? new WalletContractCallDelegate();<br>  wallet.onCancel(this.banner.bind(this));<br>}<br>```<br><br>#### 🔧 Delegate Method: openUnsignedContractCall<br>- Performs the wallet open call with given callbacks.<br><br>```typescript<br>async openUnsignedContractCall(<br>  payload: Record<string, any>,<br>  onFinish: (tx?: unknown) => void,<br>  onCancel: () => void<br>): Promise<void> { /* ...as implemented above... */ }<br>```<br><br>--- |
| StoreBrandingDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-APPLY-BRANDING, CFF-UPDATE-HEADER<br><br>Delegate State Owned:<br>- None (applies values directly to DOM)<br><br>Delegate Responsibilities Owned:<br>- Apply brand color to document root.<br>- Update store header name and logo elements according to provided profile.<br><br>Responsibilities Removed from Parent Class:<br>- CSS custom property mapping and header DOM manipulation.<br><br>Delegate Public Interface:<br>```typescript<br>export class StoreBrandingDelegate {<br>  applyBranding(profile: StorePublicProfileDTO): void {<br>    if (profile.brandColor) {<br>      document.documentElement.style.setProperty('--accent', profile.brandColor);<br>    }<br>    this.updateHeader(profile.displayName, profile.logoUrl);<br>  }<br><br>  updateHeader(displayName?: string, logoUrl?: string): void {<br>    const nameEl = document.querySelector('#storeName') as HTMLElement or null;<br>    const logoEl = document.querySelector('#storeLogo') as HTMLImageElement or null;<br><br>    if (nameEl) nameEl.textContent = displayName or '';<br><br>    if (logoUrl && logoEl) {<br>      logoEl.src = logoUrl;<br>      logoEl.alt = displayName ? `${displayName} logo` : 'Store logo';<br>      logoEl.removeAttribute('hidden');<br>    } else if (logoEl) {<br>      logoEl.removeAttribute('src');<br>      logoEl.alt = 'Store logo';<br>      logoEl.setAttribute('hidden', 'true');<br>    }<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const branding = new StoreBrandingDelegate();<br>branding.applyBranding(invoice.store ?? profile);<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.applyBranding<br>- Fully delegates to StoreBrandingDelegate.applyBranding.<br><br>```typescript<br>applyBranding(profile: StorePublicProfileDTO): void {<br>  this._branding = this._branding ?? new StoreBrandingDelegate();<br>  this._branding.applyBranding(profile);<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.updateHeader<br>- Fully delegates to StoreBrandingDelegate.updateHeader.<br><br>```typescript<br>updateHeader(displayName?: string, logoUrl?: string): void {<br>  this._branding = this._branding ?? new StoreBrandingDelegate();<br>  this._branding.updateHeader(displayName, logoUrl);<br>}<br>```<br><br>#### 🔧 Delegate Method: applyBranding<br>- Applies CSS accent and calls updateHeader.<br><br>```typescript<br>applyBranding(profile: StorePublicProfileDTO): void { /* ...as implemented above... */ }<br>```<br><br>--- |
| StatusBadgeDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-SET-STATUS-BADGE<br><br>Delegate State Owned:<br>- None<br><br>Delegate Responsibilities Owned:<br>- Map InvoiceStatus values to badge DOM classes and text consistently.<br><br>Responsibilities Removed from Parent Class:<br>- UI mapping logic for status badge styling and label.<br><br>Delegate Public Interface:<br>```typescript<br>export class StatusBadgeDelegate {<br>  setStatusBadge(status: InvoiceStatus, selector = '#statusBadge'): void {<br>    const badge = document.querySelector(selector) as HTMLElement or null;<br>    if (!badge) return;<br><br>    badge.className = 'badge';<br>    switch (status) {<br>      case 'unpaid':<br>        badge.classList.add('badge-unpaid'); badge.textContent = 'Unpaid'; break;<br>      case 'paid':<br>        badge.classList.add('badge-paid'); badge.textContent = 'Paid'; break;<br>      case 'partially_refunded':<br>        badge.classList.add('badge-partial'); badge.textContent = 'Partially Refunded'; break;<br>      case 'refunded':<br>        badge.classList.add('badge-refunded'); badge.textContent = 'Refunded'; break;<br>      case 'canceled':<br>        badge.classList.add('badge-canceled'); badge.textContent = 'Canceled'; break;<br>      case 'expired':<br>        badge.classList.add('badge-expired'); badge.textContent = 'Expired'; break;<br>    }<br>    badge.setAttribute('aria-live', 'polite');<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const badge = new StatusBadgeDelegate();<br>badge.setStatusBadge(invoice.status);<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.setStatusBadge<br>- Delegates badge application to the StatusBadgeDelegate.<br><br>```typescript<br>setStatusBadge(status: InvoiceStatus): void {<br>  this._badge = this._badge ?? new StatusBadgeDelegate();<br>  this._badge.setStatusBadge(status, '#statusBadge');<br>}<br>```<br><br>#### 🔧 Delegate Method: setStatusBadge<br>- Applies the correct class and text mapping.<br><br>```typescript<br>setStatusBadge(status: InvoiceStatus, selector = '#statusBadge'): void { /* ...as implemented above... */ }<br>```<br><br>--- |
| PaymentActionsDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-DISABLE-PAYMENT-ACTIONS<br><br>Delegate State Owned:<br>- None<br><br>Delegate Responsibilities Owned:<br>- Disable Open Wallet button and QR interactions.<br>- Hide the payment actions container.<br><br>Responsibilities Removed from Parent Class:<br>- Direct DOM toggling for disabling payment interactions.<br><br>Delegate Public Interface:<br>```typescript<br>export class PaymentActionsDelegate {<br>  disablePaymentActions(opts?: { openWalletSelector?: string; qrSelector?: string; actionsSelector?: string }): void {<br>    const openSel = opts?.openWalletSelector ?? '#openWallet';<br>    const qrSel = opts?.qrSelector ?? '#qrCanvas';<br>    const actionsSel = opts?.actionsSelector ?? '#actions';<br><br>    const btn = document.querySelector(openSel) as HTMLButtonElement or null;<br>    if (btn) btn.disabled = true;<br><br>    const qr = document.querySelector(qrSel) as HTMLElement or null;<br>    if (qr) qr.classList.add('disabled');<br><br>    const actions = document.querySelector(actionsSel) as HTMLElement or null;<br>    if (actions) actions.setAttribute('hidden', 'true');<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const actions = new PaymentActionsDelegate();<br>actions.disablePaymentActions();<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.disablePaymentActions<br>- Delegates fully to PaymentActionsDelegate.<br><br>```typescript<br>disablePaymentActions(): void {<br>  this._actions = this._actions ?? new PaymentActionsDelegate();<br>  this._actions.disablePaymentActions();<br>}<br>```<br><br>#### 🔧 Delegate Method: disablePaymentActions<br>- Performs the DOM changes to lock out payment UI.<br><br>```typescript<br>disablePaymentActions(opts?: { openWalletSelector?: string; qrSelector?: string; actionsSelector?: string }): void { /* ...as implemented above... */ }<br>```<br><br>--- |
| PublicCheckoutApiClient | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-FETCH-INVOICE-JSON, CFF-FETCH-STORE-PUBLIC-PROFILE<br><br>Delegate State Owned:<br>- None<br><br>Delegate Responsibilities Owned:<br>- Perform public GET requests for invoice JSON and store public profile.<br>- Enforce Accept headers and propagate AbortSignal.<br>- Map non-OK responses to thrown errors with status for invoice request; return empty profile on profile error.<br><br>Responsibilities Removed from Parent Class:<br>- Networking details for fetching invoice and profile.<br><br>Delegate Public Interface:<br>```typescript<br>export class PublicCheckoutApiClient {<br>  async fetchInvoiceJson(invoiceId: string, opts?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> {<br>    const res = await fetch(`/i/${encodeURIComponent(invoiceId)}`, {<br>      headers: { Accept: 'application/json' },<br>      signal: opts?.signal,<br>    });<br>    if (!res.ok) {<br>      const err: any = new Error(`HTTP ${res.status}`);<br>      err.status = res.status;<br>      throw err;<br>    }<br>    return (await res.json()) as PublicInvoiceDTO;<br>  }<br><br>  async fetchStorePublicProfile(storeId: string, opts?: { signal?: AbortSignal }): Promise<StorePublicProfileDTO> {<br>    const res = await fetch(`/api/v1/stores/${encodeURIComponent(storeId)}/public-profile`, {<br>      headers: { Accept: 'application/json' },<br>      signal: opts?.signal,<br>    });<br>    if (!res.ok) return {};<br>    return (await res.json()) as StorePublicProfileDTO;<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const api = new PublicCheckoutApiClient();<br>const invoice = await api.fetchInvoiceJson(invoiceId);<br>const profile = await api.fetchStorePublicProfile(storeId);<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.fetchInvoiceJson<br>- Delegates to PublicCheckoutApiClient; maintains signature and error propagation.<br><br>```typescript<br>async fetchInvoiceJson(invoiceId: string, opts?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> {<br>  this._api = this._api ?? new PublicCheckoutApiClient();<br>  return this._api.fetchInvoiceJson(invoiceId, opts);<br>}<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.fetchStorePublicProfile<br>- Delegates to PublicCheckoutApiClient.<br><br>```typescript<br>async fetchStorePublicProfile(storeId: string, opts?: { signal?: AbortSignal }): Promise<StorePublicProfileDTO> {<br>  this._api = this._api ?? new PublicCheckoutApiClient();<br>  return this._api.fetchStorePublicProfile(storeId, opts);<br>}<br>```<br><br>#### 🔧 Delegate Method: fetchInvoiceJson<br>- Performs GET and throws error with status on non-OK.<br><br>```typescript<br>async fetchInvoiceJson(invoiceId: string, opts?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> { /* ...as implemented above... */ }<br>```<br><br>--- |
| QrRenderDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-RENDER-QR<br><br>Delegate State Owned:<br>- None<br><br>Delegate Responsibilities Owned:<br>- Render a lightweight QR placeholder into a canvas using an invoice magic link string (no external libs).<br><br>Responsibilities Removed from Parent Class:<br>- Canvas drawing and link computation for QR placeholder.<br><br>Delegate Public Interface:<br>```typescript<br>export class QrRenderDelegate {<br>  renderInvoiceLink(canvasSelector: string, invoiceId: string): void {<br>    const canvas = document.querySelector(canvasSelector) as HTMLCanvasElement or null;<br>    if (!canvas) return;<br>    const ctx = canvas.getContext('2d');<br>    if (!ctx) return;<br><br>    ctx.clearRect(0, 0, canvas.width, canvas.height);<br>    const link = `${location.protocol}//${location.host}/i/${encodeURIComponent(invoiceId)}`;<br>    ctx.fillStyle = '#000000';<br>    ctx.font = '14px monospace';<br>    ctx.fillText('Scan link:', 10, 20);<br>    ctx.fillText(link, 10, 40);<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const qr = new QrRenderDelegate();<br>qr.renderInvoiceLink('#qrCanvas', invoice.invoiceId);<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.renderQr<br>- Delegates canvas drawing to QrRenderDelegate.<br><br>```typescript<br>renderQr(invoiceId: string): void {<br>  this._qr = this._qr ?? new QrRenderDelegate();<br>  this._qr.renderInvoiceLink('#qrCanvas', invoiceId);<br>}<br>```<br><br>#### 🔧 Delegate Method: renderInvoiceLink<br>- Draws the placeholder link text into the canvas.<br><br>```typescript<br>renderInvoiceLink(canvasSelector: string, invoiceId: string): void { /* ...as implemented above... */ }<br>```<br><br>--- |
| BannerDelegate | - **[Offloading Class Names]**: CheckoutFrontend<br>- **[Originating Method Ids]**: CFF-BANNER<br><br>Delegate State Owned:<br>- None<br><br>Delegate Responsibilities Owned:<br>- Apply banner message, type classes, and visibility.<br><br>Responsibilities Removed from Parent Class:<br>- DOM manipulation for banners.<br><br>Delegate Public Interface:<br>```typescript<br>export class BannerDelegate {<br>  show(message: string, type: 'info' or 'success' or 'error' = 'info', selector = '#banner'): void {<br>    const node = document.querySelector(selector) as HTMLElement or null;<br>    if (!node) return;<br>    node.textContent = message;<br>    node.className = 'banner';<br>    node.classList.add(`banner-${type}`);<br>    node.removeAttribute('hidden');<br>  }<br>}<br>```<br><br>Example Interaction:<br>```typescript<br>// Parent-delegate interaction<br>const banner = new BannerDelegate();<br>banner.show('Wallet not connected', 'error');<br>```<br><br>#### 🔁 Refactored Method: CheckoutFrontend.banner<br>- Delegates to BannerDelegate.show.<br><br>```typescript<br>banner(message: string, type: 'info' or 'success' or 'error' = 'info'): void {<br>  this._banner = this._banner ?? new BannerDelegate();<br>  this._banner.show(message, type, '#banner');<br>}<br>```<br><br>#### 🔧 Delegate Method: show<br>- Applies message and type class, makes banner visible.<br><br>```typescript<br>show(message: string, type: 'info' or 'success' or 'error' = 'info', selector = '#banner'): void { /* ...as implemented above... */ }<br>```<br><br>End of report. |
| RequestShapeAdapter | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-TO-SNAKE<br><br>Delegate State Owned:<br>- None (stateless utility).<br><br>Delegate Responsibilities Owned:<br>- Convert camelCase keys to snake_case for all backend write APIs, preserving values as-is.<br><br>Responsibilities Removed from Parent Class:<br>- Direct implementation of camelCase→snake_case conversion.<br><br>Delegate Public Interface:<br>- toSnake<T>(camel: T): Record<string, any><br><br>Example Interaction:<br>```typescript<br>// Parent usage inside MerchantDashboardFrontend.handleCreateInvoice<br>const body = requestShapeAdapter.toSnake({ amountSats, ttlSeconds, memo, webhookUrl });<br>await http.requestJson<PublicInvoiceDTO>(`/api/v1/stores/${state.storeId}/invoices`, {<br>  method: 'POST',<br>  headers: http.buildHeaders(true),<br>  body: JSON.stringify(body),<br>}, MerchantDashboardFrontend.onErrorAuthGate);<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.toSnake<br>- After refactoring, the parent delegates the key transformation to RequestShapeAdapter.toSnake.<br>- The method signature remains the same and simply forwards to the delegate.<br><br>```typescript<br>// In MerchantDashboardFrontend<br>toSnake<T extends Record<string, any>>(camel: T): Record<string, any> {<br>  return requestShapeAdapter.toSnake(camel);<br>}<br>```<br><br>#### 🔧 Delegate Method: toSnake<br>- Responsibility: Convert object keys from camelCase to snake_case without altering values or types.<br>- Signature: toSnake<T>(camel: T): Record<string, any><br>- Return: New object with snake_case keys mapped 1:1 to original values.<br><br>```typescript<br>// RequestShapeAdapter.ts<br>export class RequestShapeAdapter {<br>  public toSnake<T extends Record<string, any>>(camel: T): Record<string, any> {<br>    const out: Record<string, any> = {};<br>    for (const [key, value] of Object.entries(camel)) {<br>      const snake = key<br>        .replace(/([A-Z])/g, '_$1')<br>        .replace(/__/g, '_')<br>        .toLowerCase();<br>      out[snake] = value;<br>    }<br>    return out;<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const requestShapeAdapter = new RequestShapeAdapter();<br>```<br><br>--- |
| MerchantApiHttpClient | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-FETCH-INVOICES, MDF-FETCH-INVOICE, MDF-FETCH-SUBSCRIPTIONS, MDF-FETCH-STORE-PROFILE, MDF-HANDLE-CREATE-INVOICE, MDF-ON-CANCEL-INVOICE<br><br>Delegate State Owned:<br>- storeId: string<br>- apiKey: string<br><br>Delegate Responsibilities Owned:<br>- Build headers with X-API-Key and optional JSON content-type.<br>- Perform JSON HTTP requests (GET/POST/PATCH) with centralized 401/403 auth-gate callback.<br>- Return parsed JSON (or undefined when expectJson=false).<br><br>Responsibilities Removed from Parent Class:<br>- Header construction and repetitive fetch/JSON handling.<br>- Inline auth-gate checks on every request.<br><br>Delegate Public Interface:<br>- setContext(ctx: { storeId: string; apiKey: string }): void<br>- buildHeaders(hasJson: boolean, overrideApiKey?: string): HeadersInit<br>- requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T><br><br>Example Interaction:<br>```typescript<br>http.setContext({ storeId: state.storeId, apiKey: state.apiKey });<br>const invoices = await http.requestJson<PublicInvoiceDTO[]>(<br>  `/api/v1/stores/${state.storeId}/invoices`,<br>  { headers: http.buildHeaders(false) },<br>  MerchantDashboardFrontend.onErrorAuthGate<br>);<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.handleCreateInvoice<br>- Breakdown:<br>  - Prevent default<br>  - Validate inputs<br>  - Build snake_case body via RequestShapeAdapter<br>  - Use MerchantApiHttpClient.requestJson to POST and parse a PublicInvoiceDTO<br>  - Update list and bump refetchKey<br><br>```typescript<br>async handleCreateInvoice(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  const fd = new FormData(e.currentTarget);<br>  const amountSats = parseInt(String(fd.get('amountSats') ?? '0'), 10);<br>  const ttlSeconds = parseInt(String(fd.get('ttlSeconds') ?? '0'), 10);<br>  const memo = fd.get('memo') ? String(fd.get('memo')) : undefined;<br>  const webhookUrl = fd.get('webhookUrl') ? String(fd.get('webhookUrl')) : undefined;<br>  if (!Number.isInteger(amountSats) or amountSats <= 0) throw new Error('amount_sats must be > 0');<br>  if (!Number.isInteger(ttlSeconds) or ttlSeconds <= 0) throw new Error('ttl_seconds must be > 0');<br>  if (memo) {<br>    const bytes = new TextEncoder().encode(memo);<br>    if (bytes.length > 34) throw new Error('memo must be ≤ 34 bytes (UTF-8).');<br>  }<br><br>  http.setContext({ storeId: state.storeId, apiKey: state.apiKey });<br>  const body = requestShapeAdapter.toSnake({ amountSats, ttlSeconds, memo, webhookUrl });<br>  const created = await http.requestJson<PublicInvoiceDTO>(<br>    `/api/v1/stores/${state.storeId}/invoices`,<br>    { method: 'POST', headers: http.buildHeaders(true), body: JSON.stringify(body) },<br>    this.onErrorAuthGate,<br>  );<br><br>  this.updateInvoicesList(created);<br>  state.refetchKey++;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.onCancelInvoice<br>- Breakdown:<br>  - POST cancel using http.requestJson with expectJson=false<br>  - Update local status, bump refetch key<br><br>```typescript<br>async onCancelInvoice(invoiceId: string): Promise<void> {<br>  http.setContext({ storeId: state.storeId, apiKey: state.apiKey });<br>  await http.requestJson<void>(<br>    `/api/v1/stores/${state.storeId}/invoices/${invoiceId}/cancel`,<br>    { method: 'POST', headers: http.buildHeaders(false), // no JSON body<br>      // mark the request as not expecting JSON by omitting body and interpreting void result<br>      // we can also include expectJson: false to skip parsing<br>      // but the delegate handles this flag explicitly (see implementation)<br>      // note: including it explicitly for clarity:<br>      expectJson: false as any,<br>    } as any,<br>    this.onErrorAuthGate,<br>  );<br>  this.setInvoiceStatus(invoiceId, 'canceled');<br>  state.refetchKey++;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.fetchInvoices<br>- Breakdown:<br>  - GET via http.requestJson with optional status query<br>  - Update in-memory master and filtered lists and sort<br><br>```typescript<br>async fetchInvoices(<br>  storeId: string,<br>  apiKey: string,<br>  options?: { status?: InvoiceStatus; signal?: AbortSignal },<br>): Promise<PublicInvoiceDTO[]> {<br>  http.setContext({ storeId, apiKey });<br>  const q = options?.status ? `?status=${encodeURIComponent(options.status)}` : '';<br>  const rows = await http.requestJson<PublicInvoiceDTO[]>(<br>    `/api/v1/stores/${storeId}/invoices${q}`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  state.invoices = rows;<br>  state.filteredInvoices = rows;<br>  this.sortInvoicesByCreatedAt(state.sortDirection);<br>  return rows;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.fetchInvoice<br>- Breakdown:<br>  - GET via http.requestJson<br>  - Store into invoiceDetail<br><br>```typescript<br>async fetchInvoice(<br>  storeId: string,<br>  invoiceId: string,<br>  apiKey: string,<br>  options?: { signal?: AbortSignal },<br>): Promise<PublicInvoiceDTO> {<br>  http.setContext({ storeId, apiKey });<br>  const dto = await http.requestJson<PublicInvoiceDTO>(<br>    `/api/v1/stores/${storeId}/invoices/${invoiceId}`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  state.invoiceDetail = dto;<br>  return dto;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.fetchSubscriptions<br>- Breakdown:<br>  - GET via http.requestJson<br>  - Replace local subscriptions list<br><br>```typescript<br>async fetchSubscriptions(<br>  storeId: string,<br>  apiKey: string,<br>  options?: { signal?: AbortSignal },<br>): Promise<Array<{ id: string; subscriber: string; amountSats: number; intervalBlocks: number; active: boolean; nextInvoiceAt: number; lastBilledAt?: number; mode: SubscriptionMode }>> {<br>  http.setContext({ storeId, apiKey });<br>  const rows = await http.requestJson<Array<{ id: string; subscriber: string; amountSats: number; intervalBlocks: number; active: boolean; nextInvoiceAt: number; lastBilledAt?: number; mode: SubscriptionMode }>>(<br>    `/api/v1/stores/${storeId}/subscriptions`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  state.subscriptions = rows;<br>  return rows;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.fetchStoreProfile<br>- Breakdown:<br>  - GET via http.requestJson<br>  - Apply profile to state<br><br>```typescript<br>async fetchStoreProfile(<br>  storeId: string,<br>  apiKey: string,<br>  options?: { signal?: AbortSignal },<br>): Promise<StorePrivateProfileDTO> {<br>  http.setContext({ storeId, apiKey });<br>  const profile = await http.requestJson<StorePrivateProfileDTO>(<br>    `/api/v1/stores/${storeId}/profile`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  this.setProfile(profile);<br>  return profile;<br>}<br>```<br><br>#### 🔧 Delegate Method: setContext, buildHeaders, requestJson<br>- Responsibility: Centralize context, headers, auth-gate, and JSON parsing.<br>- Signatures:<br>  - setContext(ctx: { storeId: string; apiKey: string }): void<br>  - buildHeaders(hasJson: boolean, overrideApiKey?: string): HeadersInit<br>  - requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T><br><br>```typescript<br>// MerchantApiHttpClient.ts<br>export class MerchantApiHttpClient {<br>  private storeId = '';<br>  private apiKey = '';<br><br>  public setContext(ctx: { storeId: string; apiKey: string }): void {<br>    this.storeId = ctx.storeId;<br>    this.apiKey = ctx.apiKey;<br>  }<br><br>  public buildHeaders(hasJson: boolean, overrideApiKey?: string): HeadersInit {<br>    return {<br>      ...(hasJson ? { 'Content-Type': 'application/json' } : {}),<br>      'X-API-Key': overrideApiKey ?? this.apiKey,<br>    };<br>  }<br><br>  public async requestJson<T>(<br>    url: string,<br>    init: RequestInit & { expectJson?: boolean } = {},<br>    onAuthError: (e: unknown) => never,<br>  ): Promise<T> {<br>    const res = await fetch(url, init);<br>    if (res.status === 401 or res.status === 403) {<br>      onAuthError(res);<br>    }<br>    if ((init as any).expectJson === false) {<br>      return undefined as unknown as T;<br>    }<br>    const data = (await res.json()) as T;<br>    return data;<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const http = new MerchantApiHttpClient();<br>```<br><br>--- |
| RefundFlowCoordinator | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-OPEN-REFUND-DIALOG, MDF-HANDLE-REFUND-SUBMIT, MDF-INVOKE-WALLET-OPEN-CONTRACT-CALL, MDF-ON-REFUND-TX-FINISH, MDF-ON-REFUND-TX-CANCEL, MDF-CLOSE-REFUND-DIALOG<br><br>Delegate State Owned:<br>- refundDialog: { open: boolean; invoice?: PublicInvoiceDTO; amountSats?: number; memo?: string; error?: string or null; submitting: boolean; pending: boolean }<br><br>Delegate Responsibilities Owned:<br>- Initialize and clear refund dialog state.<br>- Validate refund amount and memo byte length caps.<br>- POST refund creation and handle specific backend error { error: 'insufficient_balance' }.<br>- Invoke wallet openContractCall and wire finish/cancel callbacks.<br><br>Responsibilities Removed from Parent Class:<br>- All validations and error mapping for refund submit.<br>- Wallet invocation wiring and dialog state transitions.<br><br>Delegate Public Interface:<br>- openDialog(invoice: PublicInvoiceDTO): RefundDialogState<br>- closeDialog(): RefundDialogState<br>- submit(formEl: HTMLFormElement, dialog: RefundDialogState, storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never, toSnake: (v: any) => any): Promise<{ newState: RefundDialogState; unsignedCall?: UnsignedContractCall }><br>- invokeWallet(payload: UnsignedContractCall, handlers: { onFinish: (tx?: unknown) => void; onCancel: () => void }): void<br>- onFinish(dialog: RefundDialogState): { newState: RefundDialogState; shouldRefetch: boolean }<br>- onCancel(dialog: RefundDialogState): RefundDialogState<br><br>Example Interaction:<br>```typescript<br>// Parent: open dialog<br>state.refundDialog = refundFlow.openDialog(invoice);<br><br>// Parent: handle submit<br>const result = await refundFlow.submit(e.currentTarget as HTMLFormElement, state.refundDialog, state.storeId, http, this.onErrorAuthGate, requestShapeAdapter.toSnake);<br>state.refundDialog = result.newState;<br>if (result.unsignedCall) {<br>  refundFlow.invokeWallet(result.unsignedCall, {<br>    onFinish: (tx) => this.onRefundTxFinish(tx),<br>    onCancel: () => this.onRefundTxCancel(),<br>  });<br>}<br><br>// Parent: finish/cancel wiring<br>onRefundTxFinish(tx?: unknown): void {<br>  const out = refundFlow.onFinish(state.refundDialog);<br>  state.refundDialog = out.newState;<br>  if (out.shouldRefetch) state.refetchKey++;<br>}<br>onRefundTxCancel(): void {<br>  state.refundDialog = refundFlow.onCancel(state.refundDialog);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.openRefundDialog<br>- Now calls refundFlow.openDialog(invoice) and assigns returned state.<br><br>```typescript<br>openRefundDialog(invoice: PublicInvoiceDTO): void {<br>  state.refundDialog = refundFlow.openDialog(invoice);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.handleRefundSubmit<br>- Prevents default; delegates validation, POST, and returns unsigned call for wallet invocation.<br><br>```typescript<br>async handleRefundSubmit(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  const { newState, unsignedCall } = await refundFlow.submit(<br>    e.currentTarget as HTMLFormElement,<br>    state.refundDialog,<br>    state.storeId,<br>    http,<br>    this.onErrorAuthGate,<br>    requestShapeAdapter.toSnake.bind(requestShapeAdapter),<br>  );<br>  state.refundDialog = newState;<br>  if (unsignedCall) {<br>    refundFlow.invokeWallet(unsignedCall, {<br>      onFinish: (tx?: unknown) => this.onRefundTxFinish(tx),<br>      onCancel: () => this.onRefundTxCancel(),<br>    });<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.invokeWalletOpenContractCall<br>- Delegates to refundFlow.invokeWallet for consistent wiring.<br><br>```typescript<br>async invokeWalletOpenContractCall(payload: UnsignedContractCall): Promise<void> {<br>  refundFlow.invokeWallet(payload, {<br>    onFinish: (tx?: unknown) => this.onRefundTxFinish(tx),<br>    onCancel: () => this.onRefundTxCancel(),<br>  });<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.onRefundTxFinish<br>- Uses refundFlow.onFinish to update dialog state and trigger refetch.<br><br>```typescript<br>onRefundTxFinish(_tx?: unknown): void {<br>  const out = refundFlow.onFinish(state.refundDialog);<br>  state.refundDialog = out.newState;<br>  if (out.shouldRefetch) state.refetchKey++;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.onRefundTxCancel<br>- Uses refundFlow.onCancel.<br><br>```typescript<br>onRefundTxCancel(): void {<br>  state.refundDialog = refundFlow.onCancel(state.refundDialog);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.closeRefundDialog<br>- Calls refundFlow.closeDialog().<br><br>```typescript<br>closeRefundDialog(): void {<br>  state.refundDialog = refundFlow.closeDialog();<br>}<br>```<br><br>#### 🔧 Delegate Methods: openDialog, closeDialog, submit, invokeWallet, onFinish, onCancel<br>- Full implementation reflects validations, posting, specific error handling, and wallet invocation.<br><br>```typescript<br>// RefundFlowCoordinator.ts<br>export type InvoiceStatus = 'unpaid' or 'paid' or 'partially_refunded' or 'refunded' or 'canceled' or 'expired';<br>export type SubscriptionMode = 'invoice' or 'direct';<br><br>export interface PublicInvoiceDTO {<br>  invoiceId: string;<br>  idHex: string;<br>  storeId: string;<br>  amountSats: number;<br>  usdAtCreate: number;<br>  quoteExpiresAt: number;<br>  merchantPrincipal: string;<br>  status: InvoiceStatus;<br>  payer?: string;<br>  txId?: string;<br>  memo?: string;<br>  subscriptionId?: string;<br>  createdAt: number;<br>  refundAmount?: number;<br>  refundTxId?: string;<br>  magicLink?: string;<br>}<br><br>export interface UnsignedContractCall {<br>  contractAddress: string;<br>  contractName: string;<br>  functionName: string;<br>  functionArgs: any[];<br>  postConditions?: any[];<br>  postConditionMode?: any;<br>  network?: any;<br>  anchorMode?: any;<br>}<br><br>export type RefundDialogState = {<br>  open: boolean;<br>  invoice?: PublicInvoiceDTO;<br>  amountSats?: number;<br>  memo?: string;<br>  error?: string or null;<br>  submitting: boolean;<br>  pending: boolean;<br>};<br><br>export class RefundFlowCoordinator {<br>  public openDialog(invoice: PublicInvoiceDTO): RefundDialogState {<br>    return {<br>      open: true,<br>      invoice,<br>      amountSats: undefined,<br>      memo: undefined,<br>      error: null,<br>      submitting: false,<br>      pending: false,<br>    };<br>  }<br><br>  public closeDialog(): RefundDialogState {<br>    return { open: false, submitting: false, pending: false };<br>  }<br><br>  public async submit(<br>    formEl: HTMLFormElement,<br>    dialog: RefundDialogState,<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean, overrideApiKey?: string): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>    toSnake: (v: any) => any,<br>  ): Promise<{ newState: RefundDialogState; unsignedCall?: UnsignedContractCall }> {<br>    if (!dialog.invoice) throw new Error('No invoice selected for refund.');<br>    const fd = new FormData(formEl);<br>    const amountSats = parseInt(String(fd.get('amountSats') ?? '0'), 10);<br>    const memo = fd.get('memo') ? String(fd.get('memo')) : undefined;<br><br>    const refunded = dialog.invoice.refundAmount ?? 0;<br>    const cap = dialog.invoice.amountSats - refunded;<br><br>    if (!Number.isInteger(amountSats) or amountSats <= 0) {<br>      return { newState: { ...dialog, error: 'Amount must be > 0.' } };<br>    }<br>    if (amountSats > cap) {<br>      return { newState: { ...dialog, error: `Amount exceeds refundable cap (${cap}).` } };<br>    }<br>    if (memo) {<br>      const bytes = new TextEncoder().encode(memo);<br>      if (bytes.length > 34) {<br>        return { newState: { ...dialog, error: 'Memo must be ≤ 34 bytes.' } };<br>      }<br>    }<br><br>    const body = toSnake({ invoiceId: dialog.invoice.invoiceId, amountSats, memo });<br><br>    // Perform POST; handle insufficient_balance response shape explicitly<br>    const res = await fetch(`/api/v1/stores/${encodeURIComponent(storeId)}/refunds`, {<br>      method: 'POST',<br>      headers: http.buildHeaders(true),<br>      body: JSON.stringify(body),<br>    });<br><br>    if (res.status === 401 or res.status === 403) onAuthError(res);<br><br>    let json: any = {};<br>    try {<br>      json = await res.json();<br>    } catch {<br>      // ignore non-JSON cases<br>    }<br>    if (json?.error === 'insufficient_balance') {<br>      return { newState: { ...dialog, error: 'Insufficient merchant sBTC balance.' } };<br>    }<br><br>    const unsignedCall = json as UnsignedContractCall;<br>    const newState: RefundDialogState = { ...dialog, submitting: true, error: null };<br>    return { newState, unsignedCall };<br>  }<br><br>  public invokeWallet(<br>    payload: UnsignedContractCall,<br>    handlers: { onFinish: (tx?: unknown) => void; onCancel: () => void },<br>  ): void {<br>    const anyWin = window as any;<br>    if (!anyWin or typeof anyWin.openContractCall !== 'function') {<br>      throw new Error('openContractCall is not available on window.');<br>    }<br>    anyWin.openContractCall({<br>      ...payload,<br>      onFinish: handlers.onFinish,<br>      onCancel: handlers.onCancel,<br>    });<br>  }<br><br>  public onFinish(dialog: RefundDialogState): { newState: RefundDialogState; shouldRefetch: boolean } {<br>    return { newState: { ...dialog, pending: true }, shouldRefetch: true };<br>  }<br><br>  public onCancel(dialog: RefundDialogState): RefundDialogState {<br>    return { ...dialog, submitting: false };<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const refundFlow = new RefundFlowCoordinator();<br>```<br><br>--- |
| InvoiceListViewModel | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-UPDATE-INVOICES-LIST, MDF-SET-INVOICE-STATUS, MDF-APPLY-INVOICE-STATUS-FILTER, MDF-SORT-INVOICES-BY-CREATED-AT, MDF-TOGGLE-SORT, MDF-EXPORT-CSV, MDF-TO-CSV, MDF-SET-FILTERED-INVOICES<br><br>Delegate State Owned:<br>- invoices: PublicInvoiceDTO[]<br>- filteredInvoices: PublicInvoiceDTO[]<br>- sortDirection: 'asc' or 'desc'<br><br>Delegate Responsibilities Owned:<br>- Maintain invoices master list and filtered/sorted view.<br>- Update invoice status locally.<br>- Apply status filters and stable sorting by createdAt.<br>- Build and trigger CSV export with required headers.<br><br>Responsibilities Removed from Parent Class:<br>- Direct management of list mutations, sorting, filtering, and CSV export formatting.<br><br>Delegate Public Interface:<br>- setData(invoices: PublicInvoiceDTO[], filtered: PublicInvoiceDTO[], sortDir: 'asc'or'desc'): void<br>- updateAfterCreate(created: PublicInvoiceDTO): { invoices: PublicInvoiceDTO[]; filtered: PublicInvoiceDTO[] }<br>- setStatus(invoiceId: string, status: InvoiceStatus): { invoices: PublicInvoiceDTO[]; filtered: PublicInvoiceDTO[] }<br>- applyFilter(value: InvoiceStatus or 'all'): { filtered: PublicInvoiceDTO[] }<br>- sortByCreatedAt(direction: 'asc' or 'desc'): { filtered: PublicInvoiceDTO[] }<br>- toggleSort(): 'asc' or 'desc'<br>- toCsv(rows: Array<{ invoiceId: string; amountSats: number; usdAtCreate: number; status: InvoiceStatus; txId?: string; createdAt: number; refundAmount?: number; refundTxId?: string }>): string<br>- exportCsv(rows: Array<{ ...same as above... }>): void<br><br>Example Interaction:<br>```typescript<br>listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>const { invoices, filtered } = listVm.updateAfterCreate(created);<br>state.invoices = invoices;<br>state.filteredInvoices = filtered;<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.updateInvoicesList<br>- Now delegates list prepend/dedupe/sync to InvoiceListViewModel.<br><br>```typescript<br>updateInvoicesList(created: PublicInvoiceDTO): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.updateAfterCreate(created);<br>  state.invoices = invoices;<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.setInvoiceStatus<br>- Delegates status mutation and returns updated lists.<br><br>```typescript<br>setInvoiceStatus(invoiceId: string, status: InvoiceStatus): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.setStatus(invoiceId, status);<br>  state.invoices = invoices;<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.applyInvoiceStatusFilter<br>- Delegates filter logic and preserves current sort.<br><br>```typescript<br>applyInvoiceStatusFilter(value: InvoiceStatus or 'all'): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { filtered } = listVm.applyFilter(value);<br>  state.filteredInvoices = filtered;<br>  const sorted = listVm.sortByCreatedAt(state.sortDirection).filtered;<br>  state.filteredInvoices = sorted;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.sortInvoicesByCreatedAt<br>- Delegates sorting by createdAt.<br><br>```typescript<br>sortInvoicesByCreatedAt(direction: 'asc' or 'desc'): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { filtered } = listVm.sortByCreatedAt(direction);<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.toggleSort<br>- Uses delegate to flip sort direction and reapply.<br><br>```typescript<br>toggleSort(field: 'createdAt'): void {<br>  if (field !== 'createdAt') return;<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const newDir = listVm.toggleSort();<br>  state.sortDirection = newDir;<br>  state.filteredInvoices = listVm.sortByCreatedAt(newDir).filtered;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.toCsv<br>- Delegates CSV formatting.<br><br>```typescript<br>toCsv(rows: Array<{ invoiceId: string; amountSats: number; usdAtCreate: number; status: InvoiceStatus; txId?: string; createdAt: number; refundAmount?: number or string; refundTxId?: string }>): string {<br>  return listVm.toCsv(rows as any);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.exportCsv<br>- Delegates CSV generation and file download.<br><br>```typescript<br>exportCsv(): void {<br>  const rows = state.filteredInvoices.map((i) => ({<br>    invoiceId: i.invoiceId,<br>    amountSats: i.amountSats,<br>    usdAtCreate: i.usdAtCreate,<br>    status: i.status,<br>    txId: i.txId ?? '',<br>    createdAt: i.createdAt,<br>    refundAmount: i.refundAmount ?? '',<br>    refundTxId: i.refundTxId ?? '',<br>  }));<br>  listVm.exportCsv(rows as any);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.setFilteredInvoices<br>- Assigns the list but is typically managed by apply/filter/sort in delegate.<br><br>```typescript<br>setFilteredInvoices(list: PublicInvoiceDTO[]): void {<br>  state.filteredInvoices = list;<br>}<br>```<br><br>#### 🔧 Delegate Implementation<br>```typescript<br>// InvoiceListViewModel.ts<br>type InvoiceStatus = 'unpaid' or 'paid' or 'partially_refunded' or 'refunded' or 'canceled' or 'expired';<br><br>interface PublicInvoiceDTO {<br>  invoiceId: string;<br>  amountSats: number;<br>  usdAtCreate: number;<br>  status: InvoiceStatus;<br>  txId?: string;<br>  createdAt: number;<br>  refundAmount?: number;<br>  refundTxId?: string;<br>}<br><br>export class InvoiceListViewModel {<br>  private invoices: PublicInvoiceDTO[] = [];<br>  private filtered: PublicInvoiceDTO[] = [];<br>  private sortDirection: 'asc' or 'desc' = 'desc';<br><br>  public setData(invoices: PublicInvoiceDTO[], filtered: PublicInvoiceDTO[], sortDir: 'asc' or 'desc'): void {<br>    this.invoices = [...invoices];<br>    this.filtered = [...filtered];<br>    this.sortDirection = sortDir;<br>  }<br><br>  public updateAfterCreate(created: PublicInvoiceDTO): { invoices: PublicInvoiceDTO[]; filtered: PublicInvoiceDTO[] } {<br>    const exists = this.invoices.find((i) => i.invoiceId === created.invoiceId);<br>    const nextInvoices = exists<br>      ? this.invoices.map((i) => (i.invoiceId === created.invoiceId ? created : i))<br>      : [created, ...this.invoices];<br>    const nextFiltered = [created, ...this.filtered];<br>    return { invoices: nextInvoices, filtered: this.sort(nextFiltered, this.sortDirection) };<br>    }<br><br>  public setStatus(invoiceId: string, status: InvoiceStatus): { invoices: PublicInvoiceDTO[]; filtered: PublicInvoiceDTO[] } {<br>    const mapStatus = (arr: PublicInvoiceDTO[]) => arr.map((i) => (i.invoiceId === invoiceId ? { ...i, status } : i));<br>    const invoices = mapStatus(this.invoices);<br>    const filtered = mapStatus(this.filtered);<br>    return { invoices, filtered };<br>  }<br><br>  public applyFilter(value: InvoiceStatus or 'all'): { filtered: PublicInvoiceDTO[] } {<br>    const filtered = value === 'all' ? [...this.invoices] : this.invoices.filter((i) => i.status === value);<br>    return { filtered: this.sort(filtered, this.sortDirection) };<br>  }<br><br>  public sortByCreatedAt(direction: 'asc' or 'desc'): { filtered: PublicInvoiceDTO[] } {<br>    this.sortDirection = direction;<br>    return { filtered: this.sort([...this.filtered], direction) };<br>  }<br><br>  public toggleSort(): 'asc' or 'desc' {<br>    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';<br>    return this.sortDirection;<br>  }<br><br>  public toCsv(rows: Array<{ invoiceId: string; amountSats: number; usdAtCreate: number; status: InvoiceStatus; txId?: string; createdAt: number; refundAmount?: number or string; refundTxId?: string }>): string {<br>    const headers = ['invoiceId', 'amountSats', 'usdAtCreate', 'status', 'txId', 'createdAt', 'refundAmount', 'refundTxId'];<br>    const escape = (v: unknown) => {<br>      const s = v === undefined or v === null ? '' : String(v);<br>      return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;<br>    };<br>    const lines = [<br>      headers.join(','),<br>      ...rows.map((r) =><br>        [<br>          escape(r.invoiceId),<br>          escape(r.amountSats),<br>          escape(r.usdAtCreate),<br>          escape(r.status),<br>          escape(r.txId ?? ''),<br>          escape(r.createdAt),<br>          escape(r.refundAmount ?? ''),<br>          escape(r.refundTxId ?? ''),<br>        ].join(','),<br>      ),<br>    ];<br>    return lines.join('\n');<br>  }<br><br>  public exportCsv(rows: Array<{ invoiceId: string; amountSats: number; usdAtCreate: number; status: InvoiceStatus; txId?: string; createdAt: number; refundAmount?: number or string; refundTxId?: string }>): void {<br>    const csv = this.toCsv(rows);<br>    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });<br>    const url = URL.createObjectURL(blob);<br>    const a = document.createElement('a');<br>    a.href = url;<br>    a.download = 'invoices.csv';<br>    document.body.appendChild(a);<br>    a.click();<br>    document.body.removeChild(a);<br>    URL.revokeObjectURL(url);<br>  }<br><br>  private sort(arr: PublicInvoiceDTO[], direction: 'asc' or 'desc'): PublicInvoiceDTO[] {<br>    const mult = direction === 'asc' ? 1 : -1;<br>    return arr.sort((a, b) => (a.createdAt - b.createdAt) * mult);<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const listVm = new InvoiceListViewModel();<br>```<br><br>--- |
| SubscriptionsCoordinator | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-HANDLE-CREATE-SUBSCRIPTION, MDF-VALIDATE-PRINCIPAL, MDF-GENERATE-INVOICE-FOR-SUB, MDF-ASSOC-INVOICE-TO-SUB, MDF-CANCEL-SUBSCRIPTION, MDF-SET-SUBSCRIPTION-ACTIVE, MDF-SET-SUBSCRIPTION-MODE<br><br>Delegate State Owned:<br>- subscriptions: Array<{ id: string; subscriber: string; amountSats: number; intervalBlocks: number; active: boolean; nextInvoiceAt: number; lastBilledAt?: number; mode: SubscriptionMode }><br><br>Delegate Responsibilities Owned:<br>- Validate Stacks principal format.<br>- Create/cancel subscriptions via HTTP and update local state mapping.<br>- Generate invoice for subscription and associate minimal linkage.<br>- Update subscription mode via HTTP and patch local item.<br><br>Responsibilities Removed from Parent Class:<br>- Principal validation and all subscription-specific HTTP/state logic.<br><br>Delegate Public Interface:<br>- setData(subs: Array<{ ... }>): void<br>- validatePrincipal(address: string): boolean<br>- create(formEl: HTMLFormElement, storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never, toSnake: (v: any) => any): Promise<{ newList: Array<{ ... }> }><br>- generateInvoice(id: string, storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never): Promise<{ invoice: PublicInvoiceDTO }><br>- associateInvoiceToSub(subId: string, invoice: PublicInvoiceDTO): Array<{ ... }><br>- cancel(id: string, storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never): Promise<Array<{ ... }>><br>- setActive(id: string, active: boolean): Array<{ ... }><br>- setMode(storeId: string, subId: string, mode: SubscriptionMode, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never): Promise<{ newList: Array<{ ... }>; confirmed: { id: string; mode: SubscriptionMode } }><br><br>Example Interaction:<br>```typescript<br>subsCoord.setData(state.subscriptions);<br>const out = await subsCoord.create(e.currentTarget as HTMLFormElement, state.storeId, http, this.onErrorAuthGate, requestShapeAdapter.toSnake.bind(requestShapeAdapter));<br>state.subscriptions = out.newList;<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.handleCreateSubscription<br>```typescript<br>async handleCreateSubscription(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  subsCoord.setData(state.subscriptions);<br>  const out = await subsCoord.create(<br>    e.currentTarget as HTMLFormElement,<br>    state.storeId,<br>    http,<br>    this.onErrorAuthGate,<br>    requestShapeAdapter.toSnake.bind(requestShapeAdapter),<br>  );<br>  state.subscriptions = out.newList;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.validatePrincipal<br>```typescript<br>validatePrincipal(address: string): boolean {<br>  return subsCoord.validatePrincipal(address);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.generateInvoiceForSubscription<br>```typescript<br>async generateInvoiceForSubscription(id: string): Promise<void> {<br>  subsCoord.setData(state.subscriptions);<br>  const { invoice } = await subsCoord.generateInvoice(id, state.storeId, http, this.onErrorAuthGate);<br>  state.subscriptions = subsCoord.associateInvoiceToSub(id, invoice);<br>  state.refetchKey++;<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  // Also prepend to invoices view<br>  const { invoices, filtered } = listVm.updateAfterCreate(invoice);<br>  state.invoices = invoices;<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.associateInvoiceToSubscription<br>```typescript<br>associateInvoiceToSubscription(subId: string, invoice: PublicInvoiceDTO): void {<br>  subsCoord.setData(state.subscriptions);<br>  state.subscriptions = subsCoord.associateInvoiceToSub(subId, invoice);<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.updateAfterCreate(invoice);<br>  state.invoices = invoices;<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.cancelSubscription<br>```typescript<br>async cancelSubscription(id: string): Promise<void> {<br>  subsCoord.setData(state.subscriptions);<br>  state.subscriptions = await subsCoord.cancel(id, state.storeId, http, this.onErrorAuthGate);<br>  state.refetchKey++;<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.setSubscriptionActive<br>```typescript<br>setSubscriptionActive(id: string, active: boolean): void {<br>  subsCoord.setData(state.subscriptions);<br>  state.subscriptions = subsCoord.setActive(id, active);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.setSubscriptionMode<br>```typescript<br>async setSubscriptionMode(<br>  storeId: string,<br>  subId: string,<br>  mode: SubscriptionMode,<br>  apiKey: string,<br>): Promise<{ id: string; mode: SubscriptionMode }> {<br>  http.setContext({ storeId, apiKey });<br>  subsCoord.setData(state.subscriptions);<br>  const resp = await subsCoord.setMode(storeId, subId, mode, http, this.onErrorAuthGate);<br>  state.subscriptions = resp.newList;<br>  state.refetchKey++;<br>  return resp.confirmed;<br>}<br>```<br><br>#### 🔧 Delegate Implementation<br>```typescript<br>// SubscriptionsCoordinator.ts<br>type SubscriptionMode = 'invoice' or 'direct';<br>type InvoiceStatus = 'unpaid' or 'paid' or 'partially_refunded' or 'refunded' or 'canceled' or 'expired';<br><br>interface PublicInvoiceDTO {<br>  invoiceId: string;<br>  idHex: string;<br>  storeId: string;<br>  amountSats: number;<br>  usdAtCreate: number;<br>  quoteExpiresAt: number;<br>  merchantPrincipal: string;<br>  status: InvoiceStatus;<br>  payer?: string;<br>  txId?: string;<br>  memo?: string;<br>  subscriptionId?: string;<br>  createdAt: number;<br>  refundAmount?: number;<br>  refundTxId?: string;<br>  magicLink?: string;<br>}<br><br>type SubItem = {<br>  id: string;<br>  subscriber: string;<br>  amountSats: number;<br>  intervalBlocks: number;<br>  active: boolean;<br>  nextInvoiceAt: number;<br>  lastBilledAt?: number;<br>  mode: SubscriptionMode;<br>};<br><br>export class SubscriptionsCoordinator {<br>  private subs: SubItem[] = [];<br><br>  public setData(subs: SubItem[]): void {<br>    this.subs = [...subs];<br>  }<br><br>  public validatePrincipal(address: string): boolean {<br>    return /^[ST][A-Za-z0-9]{20,}/.test(address);<br>  }<br><br>  public async create(<br>    formEl: HTMLFormElement,<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>    toSnake: (v: any) => any,<br>  ): Promise<{ newList: SubItem[] }> {<br>    const fd = new FormData(formEl);<br>    const subscriber = String(fd.get('subscriber') ?? '');<br>    const amountSats = parseInt(String(fd.get('amountSats') ?? '0'), 10);<br>    const intervalBlocks = parseInt(String(fd.get('intervalBlocks') ?? '0'), 10);<br>    const mode = String(fd.get('mode') ?? 'invoice') as SubscriptionMode;<br><br>    if (!this.validatePrincipal(subscriber)) throw new Error('Invalid subscriber principal.');<br>    if (!Number.isInteger(amountSats) or amountSats <= 0) throw new Error('amount_sats must be > 0.');<br>    if (!Number.isInteger(intervalBlocks) or intervalBlocks <= 0) throw new Error('interval_blocks must be > 0.');<br>    if (!(mode === 'invoice' or mode === 'direct')) throw new Error('Invalid subscription mode.');<br><br>    const body = toSnake({ subscriber, amountSats, intervalBlocks, mode });<br><br>    const sub = await http.requestJson<{<br>      id: string;<br>      idHex: string;<br>      storeId: string;<br>      merchantPrincipal: string;<br>      subscriber: string;<br>      amountSats: number;<br>      intervalBlocks: number;<br>      active: boolean;<br>      createdAt: number;<br>      lastBilledAt?: number;<br>      nextInvoiceAt: number;<br>      lastPaidInvoiceId?: string;<br>      mode: SubscriptionMode;<br>    }>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/subscriptions`,<br>      { method: 'POST', headers: http.buildHeaders(true), body: JSON.stringify(body) },<br>      onAuthError,<br>    );<br><br>    const newItem: SubItem = {<br>      id: sub.id,<br>      subscriber: sub.subscriber,<br>      amountSats: sub.amountSats,<br>      intervalBlocks: sub.intervalBlocks,<br>      active: sub.active,<br>      nextInvoiceAt: sub.nextInvoiceAt,<br>      lastBilledAt: sub.lastBilledAt,<br>      mode: sub.mode,<br>    };<br>    return { newList: [newItem, ...this.subs] };<br>  }<br><br>  public async generateInvoice(<br>    id: string,<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>  ): Promise<{ invoice: PublicInvoiceDTO }> {<br>    const resp = await http.requestJson<{ invoice: PublicInvoiceDTO; magicLink: string }>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/subscriptions/${encodeURIComponent(id)}/invoice`,<br>      { method: 'POST', headers: http.buildHeaders(true), body: JSON.stringify({}) },<br>      onAuthError,<br>    );<br>    return { invoice: resp.invoice };<br>  }<br><br>  public associateInvoiceToSub(subId: string, invoice: PublicInvoiceDTO): SubItem[] {<br>    return this.subs.map((s) => (s.id === subId ? { ...s, lastBilledAt: invoice.createdAt } : s));<br>  }<br><br>  public async cancel(<br>    id: string,<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>  ): Promise<SubItem[]> {<br>    await http.requestJson<void>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/subscriptions/${encodeURIComponent(id)}/cancel`,<br>      { method: 'POST', headers: http.buildHeaders(true), expectJson: false as any } as any,<br>      onAuthError,<br>    );<br>    return this.setActive(id, false);<br>  }<br><br>  public setActive(id: string, active: boolean): SubItem[] {<br>    return this.subs.map((s) => (s.id === id ? { ...s, active } : s));<br>  }<br><br>  public async setMode(<br>    storeId: string,<br>    subId: string,<br>    mode: SubscriptionMode,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>  ): Promise<{ newList: SubItem[]; confirmed: { id: string; mode: SubscriptionMode } }> {<br>    if (!(mode === 'invoice' or mode === 'direct')) throw new Error('Invalid mode');<br>    const confirmed = await http.requestJson<{ id: string; mode: SubscriptionMode }>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/subscriptions/${encodeURIComponent(subId)}/mode`,<br>      { method: 'POST', headers: http.buildHeaders(true), body: JSON.stringify({ mode }) },<br>      onAuthError,<br>    );<br>    const newList = this.subs.map((s) => (s.id === subId ? { ...s, mode: confirmed.mode } : s));<br>    return { newList, confirmed };<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const subsCoord = new SubscriptionsCoordinator();<br>```<br><br>--- |
| WebhookConsoleCoordinator | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-TEST-WEBHOOK, MDF-FETCH-WEBHOOK-LOGS, MDF-SET-TEST-RESULT<br><br>Delegate State Owned:<br>- webhookLogs: WebhookLogDTO[]<br>- testResult?: 'success' or 'failure'<br><br>Delegate Responsibilities Owned:<br>- POST test webhook endpoint and set test result.<br>- Fetch webhook logs with optional invoiceId filter and cap to latest 100.<br>- Manage local state slice for webhooks console.<br><br>Responsibilities Removed from Parent Class:<br>- Direct HTTP calls and state management for webhooks and test results.<br><br>Delegate Public Interface:<br>- setData(logs: WebhookLogDTO[], testResult?: 'success' or 'failure'): void<br>- test(storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never): Promise<'success' or 'failure'><br>- fetchLogs(storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never, invoiceIdFilter?: string): Promise<WebhookLogDTO[]><br>- setTestResult(result: 'success' or 'failure'): 'success' or 'failure'<br><br>Example Interaction:<br>```typescript<br>webhookCoord.setData(state.webhookLogs, state.testResult);<br>const res = await webhookCoord.test(state.storeId, http, this.onErrorAuthGate);<br>state.testResult = res;<br>state.webhookLogs = await webhookCoord.fetchLogs(state.storeId, http, this.onErrorAuthGate);<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.testWebhook<br>```typescript<br>async testWebhook(): Promise<void> {<br>  webhookCoord.setData(state.webhookLogs, state.testResult);<br>  const res = await webhookCoord.test(state.storeId, http, this.onErrorAuthGate);<br>  state.testResult = res;<br>  state.webhookLogs = await webhookCoord.fetchLogs(state.storeId, http, this.onErrorAuthGate);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.fetchWebhookLogs<br>```typescript<br>async fetchWebhookLogs(invoiceIdFilter?: string): Promise<void> {<br>  webhookCoord.setData(state.webhookLogs, state.testResult);<br>  state.webhookLogs = await webhookCoord.fetchLogs(state.storeId, http, this.onErrorAuthGate, invoiceIdFilter);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.setTestResult<br>```typescript<br>setTestResult(result: 'success' or 'failure'): void {<br>  webhookCoord.setData(state.webhookLogs, state.testResult);<br>  state.testResult = webhookCoord.setTestResult(result);<br>}<br>```<br><br>#### 🔧 Delegate Implementation<br>```typescript<br>// WebhookConsoleCoordinator.ts<br>export interface WebhookLogDTO {<br>  id: string;<br>  storeId: string;<br>  invoiceId?: string;<br>  subscriptionId?: string;<br>  eventType: string;<br>  payload: string;<br>  statusCode?: number;<br>  success: boolean;<br>  attempts: number;<br>  lastAttemptAt: number;<br>}<br><br>export class WebhookConsoleCoordinator {<br>  private logs: WebhookLogDTO[] = [];<br>  private testResult?: 'success' or 'failure';<br><br>  public setData(logs: WebhookLogDTO[], testResult?: 'success' or 'failure'): void {<br>    this.logs = [...logs];<br>    this.testResult = testResult;<br>  }<br><br>  public async test(<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>  ): Promise<'success' or 'failure'> {<br>    const res = await fetch(`/api/v1/stores/${encodeURIComponent(storeId)}/webhooks/test`, {<br>      method: 'POST',<br>      headers: http.buildHeaders(false),<br>    });<br>    if (res.status === 401 or res.status === 403) onAuthError(res);<br>    this.testResult = res.ok ? 'success' : 'failure';<br>    return this.testResult;<br>  }<br><br>  public async fetchLogs(<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>    invoiceIdFilter?: string,<br>  ): Promise<WebhookLogDTO[]> {<br>    const q = invoiceIdFilter ? `?invoiceId=${encodeURIComponent(invoiceIdFilter)}` : '';<br>    const rows = await http.requestJson<WebhookLogDTO[]>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/webhooks${q}`,<br>      { headers: http.buildHeaders(false) },<br>      onAuthError,<br>    );<br>    this.logs = rows.slice(0, 100);<br>    return this.logs;<br>  }<br><br>  public setTestResult(result: 'success' or 'failure'): 'success' or 'failure' {<br>    this.testResult = result;<br>    return this.testResult;<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const webhookCoord = new WebhookConsoleCoordinator();<br>```<br><br>--- |
| StoreProfileCoordinator | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-HANDLE-SAVE-STORE-SETTINGS, MDF-SET-PROFILE<br><br>Delegate State Owned:<br>- profile?: StorePrivateProfileDTO<br><br>Delegate Responsibilities Owned:<br>- Parse settings form to fields and CSV-join allowedOrigins as required.<br>- PATCH profile and store returned DTO.<br>- Provide setter for profile into state.<br><br>Responsibilities Removed from Parent Class:<br>- Form parsing and HTTP call for store profile updates.<br><br>Delegate Public Interface:<br>- setProfileLocal(profile?: StorePrivateProfileDTO): void<br>- save(formEl: HTMLFormElement, storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never, toSnake: (v: any) => any): Promise<StorePrivateProfileDTO><br><br>Example Interaction:<br>```typescript<br>storeProfileCoord.setProfileLocal(state.profile);<br>const prof = await storeProfileCoord.save(e.currentTarget as HTMLFormElement, state.storeId, http, this.onErrorAuthGate, requestShapeAdapter.toSnake.bind(requestShapeAdapter));<br>state.profile = prof;<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.handleSaveStoreSettings<br>```typescript<br>async handleSaveStoreSettings(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  storeProfileCoord.setProfileLocal(state.profile);<br>  const prof = await storeProfileCoord.save(<br>    e.currentTarget as HTMLFormElement,<br>    state.storeId,<br>    http,<br>    this.onErrorAuthGate,<br>    requestShapeAdapter.toSnake.bind(requestShapeAdapter),<br>  );<br>  this.setProfile(prof);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.setProfile<br>```typescript<br>setProfile(profile: StorePrivateProfileDTO): void {<br>  storeProfileCoord.setProfileLocal(profile);<br>  state.profile = profile;<br>}<br>```<br><br>#### 🔧 Delegate Implementation<br>```typescript<br>// StoreProfileCoordinator.ts<br>export interface StorePrivateProfileDTO {<br>  name?: string;<br>  displayName?: string;<br>  logoUrl?: string;<br>  brandColor?: string;<br>  webhookUrl?: string;<br>  supportEmail?: string;<br>  supportUrl?: string;<br>  allowedOrigins: string[];<br>  principal: string;<br>  active: boolean;<br>}<br><br>export class StoreProfileCoordinator {<br>  private profile?: StorePrivateProfileDTO;<br><br>  public setProfileLocal(profile?: StorePrivateProfileDTO): void {<br>    this.profile = profile;<br>  }<br><br>  public async save(<br>    formEl: HTMLFormElement,<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>    toSnake: (v: any) => any,<br>  ): Promise<StorePrivateProfileDTO> {<br>    const fd = new FormData(formEl);<br>    const name = fd.get('name') ? String(fd.get('name')) : undefined;<br>    const displayName = fd.get('displayName') ? String(fd.get('displayName')) : undefined;<br>    const logoUrl = fd.get('logoUrl') ? String(fd.get('logoUrl')) : undefined;<br>    const brandColor = fd.get('brandColor') ? String(fd.get('brandColor')) : undefined;<br>    const webhookUrl = fd.get('webhookUrl') ? String(fd.get('webhookUrl')) : undefined;<br>    const supportEmail = fd.get('supportEmail') ? String(fd.get('supportEmail')) : undefined;<br>    const supportUrl = fd.get('supportUrl') ? String(fd.get('supportUrl')) : undefined;<br>    const allowedOriginsRaw = fd.get('allowedOrigins') ? String(fd.get('allowedOrigins')) : '';<br>    const allowedOrigins = allowedOriginsRaw.split('\n').map((s) => s.trim()).filter(Boolean);<br><br>    const body = toSnake({<br>      name,<br>      displayName,<br>      logoUrl,<br>      brandColor,<br>      webhookUrl,<br>      supportEmail,<br>      supportUrl,<br>      allowedOrigins: allowedOrigins.join(','),<br>    });<br><br>    const prof = await http.requestJson<StorePrivateProfileDTO>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/profile`,<br>      { method: 'PATCH', headers: http.buildHeaders(true), body: JSON.stringify(body) },<br>      onAuthError,<br>    );<br>    this.profile = prof;<br>    return prof;<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const storeProfileCoord = new StoreProfileCoordinator();<br>```<br><br>--- |
| KeyRotationCoordinator | - **[Offloading Class Names]**: MerchantDashboardFrontend<br>- **[Originating Method Ids]**: MDF-ROTATE-KEYS, MDF-SHOW-ONE-TIME-SECRETS-MODAL, MDF-CLEAR-ONE-TIME-SECRETS<br><br>Delegate State Owned:<br>- oneTimeSecrets?: { apiKey: string; hmacSecret: string } or null<br><br>Delegate Responsibilities Owned:<br>- POST rotate-keys endpoint and store one-time secrets only in memory.<br>- Expose show/clear operations for modal lifecycle.<br><br>Responsibilities Removed from Parent Class:<br>- Direct HTTP call and transient state for secrets rotation UX.<br><br>Delegate Public Interface:<br>- rotate(storeId: string, http: MerchantApiHttpClient, onAuthError: (e: unknown) => never): Promise<{ apiKey: string; hmacSecret: string }><br>- show(secrets: { apiKey: string; hmacSecret: string }): { apiKey: string; hmacSecret: string }<br>- clear(): null or undefined<br>- get(): { apiKey: string; hmacSecret: string } or null<br><br>Example Interaction:<br>```typescript<br>const secrets = await keyRotator.rotate(state.storeId, http, this.onErrorAuthGate);<br>state.oneTimeSecrets = keyRotator.show(secrets);<br>// Later on close:<br>state.oneTimeSecrets = keyRotator.clear();<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.rotateKeys<br>```typescript<br>async rotateKeys(): Promise<void> {<br>  const secrets = await keyRotator.rotate(state.storeId, http, this.onErrorAuthGate);<br>  state.oneTimeSecrets = keyRotator.show(secrets);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.showOneTimeSecretsModal<br>```typescript<br>showOneTimeSecretsModal(secrets: { apiKey: string; hmacSecret: string }): void {<br>  state.oneTimeSecrets = keyRotator.show(secrets);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantDashboardFrontend.clearOneTimeSecrets<br>```typescript<br>clearOneTimeSecrets(): void {<br>  state.oneTimeSecrets = keyRotator.clear();<br>}<br>```<br><br>#### 🔧 Delegate Implementation<br>```typescript<br>// KeyRotationCoordinator.ts<br>export class KeyRotationCoordinator {<br>  private oneTimeSecrets: { apiKey: string; hmacSecret: string } or null = null;<br><br>  public async rotate(<br>    storeId: string,<br>    http: { requestJson<T>(url: string, init: RequestInit & { expectJson?: boolean }, onAuthError: (e: unknown) => never): Promise<T>; buildHeaders(hasJson: boolean): HeadersInit; },<br>    onAuthError: (e: unknown) => never,<br>  ): Promise<{ apiKey: string; hmacSecret: string }> {<br>    const secrets = await http.requestJson<{ apiKey: string; hmacSecret: string }>(<br>      `/api/v1/stores/${encodeURIComponent(storeId)}/rotate-keys`,<br>      { method: 'POST', headers: http.buildHeaders(false) },<br>      onAuthError,<br>    );<br>    return secrets;<br>  }<br><br>  public show(secrets: { apiKey: string; hmacSecret: string }): { apiKey: string; hmacSecret: string } {<br>    this.oneTimeSecrets = secrets;<br>    return secrets;<br>  }<br><br>  public clear(): null {<br>    this.oneTimeSecrets = null;<br>    return this.oneTimeSecrets;<br>  }<br><br>  public get(): { apiKey: string; hmacSecret: string } or null {<br>    return this.oneTimeSecrets;<br>  }<br>}<br><br>// Instantiation (in parent module scope)<br>const keyRotator = new KeyRotationCoordinator();<br>```<br><br>End of report. |
| AdminHttpClient | - **[Offloading Class Names]**: AdminConsoleFrontend<br>- **[Originating Method Ids]**: ACF-ON-CREATE-STORE-SUBMIT, ACF-ON-ACTIVATE-TOGGLE, ACF-ON-ROTATE-KEYS-CLICK, ACF-ON-SYNC-ONCHAIN-CLICK, ACF-ON-SET-SBTC-TOKEN-SUBMIT, ACF-ON-RESTART-POLLER-CLICK, ACF-ON-RETRY-WEBHOOK-CLICK, ACF-ON-CANCEL-INVOICE-CLICK<br><br>Delegate State Owned:<br>- None (stateless; Authorization header is passed per call)<br><br>Delegate Responsibilities Owned:<br>- Build and send HTTP requests to admin endpoints under /api/admin<br>- Attach Authorization header for every request<br>- Serialize JSON request bodies and parse JSON responses<br><br>Responsibilities Removed from Parent Class:<br>- Manual fetch initialization (method, headers, Content-Type)<br>- JSON serialization/deserialization details<br><br>Delegate Public Interface:<br>- request(path: string, options: { method: 'GET' or 'POST' or 'PATCH'; authHeader: string; jsonBody?: any }): Promise<Response><br>- parseJson<T = any>(resp: Response): Promise<T><br><br>Example Interaction:<br>```typescript<br>// Example code snippet clearly illustrating parent-delegate interaction<br>const resp = await AdminHttpClient.request('/stores', { method: 'POST', authHeader, jsonBody: body });<br>const json = await AdminHttpClient.parseJson(resp);<br>```<br><br>#### 🔧 Delegate Method: request<br>Responsible for issuing HTTP requests to admin endpoints with Authorization header and optional JSON body.<br>```typescript<br>export class AdminHttpClient {<br>  private static readonly base = '/api/admin';<br><br>  static async request(<br>    path: string,<br>    options: { method: 'GET' or 'POST' or 'PATCH'; authHeader: string; jsonBody?: any }<br>  ): Promise<Response> {<br>    const headers: Record<string, string> = { Authorization: options.authHeader };<br>    const init: RequestInit = { method: options.method, headers };<br>    if (options.jsonBody !== undefined) {<br>      headers['Content-Type'] = 'application/json';<br>      init.body = JSON.stringify(options.jsonBody);<br>    }<br>    const url = `${this.base}${path.startsWith('/') ? path : '/' + path}`;<br>    return fetch(url, init);<br>  }<br><br>  static async parseJson<T = any>(resp: Response): Promise<T> {<br>    const text = await resp.text();<br>    if (!text) {<br>      // @ts-expect-error allow undefined when caller expects optional<br>      return undefined as T;<br>    }<br>    return JSON.parse(text) as T;<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onCreateStoreSubmit<br>After refactoring, the method delegates HTTP setup and JSON handling to AdminHttpClient. It remains responsible for preventing default, validation, and status-specific error mapping.<br>```typescript<br>async onCreateStoreSubmit(<br>  e: Event,<br>  form: {<br>    principal: string;<br>    name?: string;<br>    display_name?: string;<br>    logo_url?: string;<br>    brand_color?: string;<br>    webhook_url?: string;<br>    support_email?: string;<br>    support_url?: string;<br>    allowed_origins?: string;<br>  },<br>  authHeader: string<br>): Promise<void> {<br>  e.preventDefault();<br>  const body = AdminStoreFormAdapter.toCreateStoreBody(form);<br>  const resp = await AdminHttpClient.request('/stores', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: body,<br>  });<br>  if (resp.status === 201) {<br>    await AdminHttpClient.parseJson(resp);<br>    return;<br>  }<br>  if (resp.status === 409) {<br>    throw new Error('conflict');<br>  }<br>  throw new Error(`create_store_failed_${resp.status}`);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onActivateToggle<br>Delegates HTTP to AdminHttpClient; retains UI outcome control by interpreting HTTP status.<br>```typescript<br>async onActivateToggle(storeId: string, active: boolean, authHeader: string): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/activate`, {<br>    method: 'PATCH',<br>    authHeader,<br>    jsonBody: { active },<br>  });<br>  if (resp.ok) {<br>    await AdminHttpClient.parseJson(resp);<br>    return;<br>  }<br>  throw new Error(`activate_toggle_failed_${resp.status}`);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onRotateKeysClick<br>Delegates HTTP; parses returned one-time secrets via AdminHttpClient.<br>```typescript<br>async onRotateKeysClick(storeId: string, authHeader: string): Promise<{ apiKey: string; hmacSecret: string }> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/rotate-keys`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (!resp.ok) {<br>    throw new Error(`rotate_keys_failed_${resp.status}`);<br>  }<br>  const json = await AdminHttpClient.parseJson<{ apiKey: string; hmacSecret: string }>(resp);<br>  return { apiKey: String(json.apiKey), hmacSecret: String(json.hmacSecret) };<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onSyncOnchainClick<br>Uses AdminHttpClient to fetch unsigned call descriptors; execution delegated to AdminContractCallSequencer.<br>```typescript<br>async onSyncOnchainClick(<br>  storeId: string,<br>  authHeader: string,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/sync-onchain`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (!resp.ok) {<br>    throw new Error(`sync_onchain_failed_${resp.status}`);<br>  }<br>  const json = await AdminHttpClient.parseJson<{ calls: any[] }>(resp);<br>  const calls = Array.isArray(json.calls) ? json.calls : [];<br>  await AdminContractCallSequencer.runSequential(calls, openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onSetSbtcTokenSubmit<br>Delegates POST and JSON handling to AdminHttpClient; uses sequencer to run the single wallet call.<br>```typescript<br>async onSetSbtcTokenSubmit(<br>  e: Event,<br>  form: { contractAddress: string; contractName: string },<br>  authHeader: string,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertContractPrincipalPair(form.contractAddress, form.contractName);<br>  const resp = await AdminHttpClient.request('/set-sbtc-token', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: { contractAddress: form.contractAddress, contractName: form.contractName },<br>  });<br>  if (!resp.ok) {<br>    throw new Error(`set_sbtc_token_failed_${resp.status}`);<br>  }<br>  const json = await AdminHttpClient.parseJson<{ call: any }>(resp);<br>  await AdminContractCallSequencer.runSingle(json.call, openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onRestartPollerClick<br>Delegates POST and JSON parsing to AdminHttpClient.<br>```typescript<br>async onRestartPollerClick(authHeader: string): Promise<{ running: boolean }> {<br>  const resp = await AdminHttpClient.request('/poller/restart', {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (!resp.ok) {<br>    throw new Error(`restart_poller_failed_${resp.status}`);<br>  }<br>  const json = await AdminHttpClient.parseJson<{ running: boolean }>(resp);<br>  return { running: !!json.running };<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onRetryWebhookClick<br>Validates UUID; uses AdminHttpClient to POST retry command.<br>```typescript<br>async onRetryWebhookClick(webhookLogId: string, authHeader: string): Promise<void> {<br>  AdminInputValidator.assertUuid(webhookLogId, 'webhookLogId');<br>  const resp = await AdminHttpClient.request('/webhooks/retry', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: { webhookLogId },<br>  });<br>  if (resp.status === 202 or resp.status === 200) {<br>    return;<br>  }<br>  throw new Error(`retry_webhook_failed_${resp.status}`);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onCancelInvoiceClick<br>Delegates POST and JSON parsing to AdminHttpClient; optional wallet call via sequencer when helper returns a call.<br>```typescript<br>async onCancelInvoiceClick(<br>  invoiceId: string,<br>  authHeader: string,<br>  maybeBuildOnchainCancel: () => Promise<any or undefined>,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  AdminInputValidator.assertUuid(invoiceId, 'invoiceId');<br>  const resp = await AdminHttpClient.request(`/invoices/${invoiceId}/cancel`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (resp.status === 400) {<br>    const j = await AdminHttpClient.parseJson<{ error?: string }>(resp);<br>    if (j && j.error === 'already_paid') throw new Error('already_paid');<br>    throw new Error('cancel_invoice_bad_request');<br>  }<br>  if (!resp.ok) {<br>    throw new Error(`cancel_invoice_failed_${resp.status}`);<br>  }<br>  await AdminHttpClient.parseJson(resp);<br>  const cancelCall = await maybeBuildOnchainCancel();<br>  if (cancelCall) {<br>    await AdminContractCallSequencer.runSingle(cancelCall, openContractCall);<br>  }<br>}<br>```<br><br>--- |
| AdminInputValidator | - **[Offloading Class Names]**: AdminConsoleFrontend<br>- **[Originating Method Ids]**: ACF-ON-CREATE-STORE-SUBMIT, ACF-ON-ACTIVATE-TOGGLE, ACF-ON-ROTATE-KEYS-CLICK, ACF-ON-SYNC-ONCHAIN-CLICK, ACF-ON-SET-SBTC-TOKEN-SUBMIT, ACF-ON-RETRY-WEBHOOK-CLICK, ACF-ON-CANCEL-INVOICE-CLICK<br><br>Delegate State Owned:<br>- None (pure validation)<br><br>Delegate Responsibilities Owned:<br>- Validate UUID format for identifiers<br>- Validate Stacks principal (merchant/store principal)<br>- Validate contract principal pair for SIP-010 token (contractAddress + contractName)<br><br>Responsibilities Removed from Parent Class:<br>- Inline regex checks and ad-hoc guards for IDs and principals<br><br>Delegate Public Interface:<br>- assertUuid(value: string, label?: string): string<br>- assertStacksAddress(value: string, label?: string): string<br>- assertContractPrincipalPair(contractAddress: string, contractName: string): { contractAddress: string; contractName: string }<br><br>Example Interaction:<br>```typescript<br>// Example usage within handler<br>AdminInputValidator.assertUuid(storeId, 'storeId');<br>```<br><br>#### 🔧 Delegate Method: assertUuid<br>Validates UUID v4-like format; throws TypeError on invalid input. Returns the input on success for convenient inline use.<br>```typescript<br>export class AdminInputValidator {<br>  static assertUuid(value: string, label: string = 'id'): string {<br>    const ok = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(value);<br>    if (!ok) throw new TypeError(`Invalid ${label}`);<br>    return value;<br>  }<br><br>  static assertStacksAddress(value: string, label: string = 'principal'): string {<br>    if (typeof value !== 'string' or value.length < 2 or !value.startsWith('S')) {<br>      throw new TypeError(`Invalid ${label}`);<br>    }<br>    return value;<br>  }<br><br>  static assertContractPrincipalPair(contractAddress: string, contractName: string): {<br>    contractAddress: string;<br>    contractName: string;<br>  } {<br>    this.assertStacksAddress(contractAddress, 'contractAddress');<br>    if (!contractName or typeof contractName !== 'string') {<br>      throw new TypeError('Invalid contractName');<br>    }<br>    return { contractAddress, contractName };<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onCreateStoreSubmit<br>Validation is now centrally handled:<br>```typescript<br>async onCreateStoreSubmit(<br>  e: Event,<br>  form: {<br>    principal: string;<br>    name?: string;<br>    display_name?: string;<br>    logo_url?: string;<br>    brand_color?: string;<br>    webhook_url?: string;<br>    support_email?: string;<br>    support_url?: string;<br>    allowed_origins?: string;<br>  },<br>  authHeader: string<br>): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertStacksAddress(form.principal, 'principal');<br>  const body = AdminStoreFormAdapter.toCreateStoreBody(form);<br>  const resp = await AdminHttpClient.request('/stores', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: body,<br>  });<br>  if (resp.status === 201) {<br>    await AdminHttpClient.parseJson(resp);<br>    return;<br>  }<br>  if (resp.status === 409) throw new Error('conflict');<br>  throw new Error(`create_store_failed_${resp.status}`);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onActivateToggle<br>```typescript<br>async onActivateToggle(storeId: string, active: boolean, authHeader: string): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/activate`, {<br>    method: 'PATCH',<br>    authHeader,<br>    jsonBody: { active },<br>  });<br>  if (resp.ok) {<br>    await AdminHttpClient.parseJson(resp);<br>    return;<br>  }<br>  throw new Error(`activate_toggle_failed_${resp.status}`);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onRotateKeysClick<br>```typescript<br>async onRotateKeysClick(storeId: string, authHeader: string): Promise<{ apiKey: string; hmacSecret: string }> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/rotate-keys`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (!resp.ok) throw new Error(`rotate_keys_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ apiKey: string; hmacSecret: string }>(resp);<br>  return { apiKey: String(json.apiKey), hmacSecret: String(json.hmacSecret) };<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onSyncOnchainClick<br>```typescript<br>async onSyncOnchainClick(<br>  storeId: string,<br>  authHeader: string,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/sync-onchain`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (!resp.ok) throw new Error(`sync_onchain_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ calls: any[] }>(resp);<br>  await AdminContractCallSequencer.runSequential(Array.isArray(json.calls) ? json.calls : [], openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onSetSbtcTokenSubmit<br>```typescript<br>async onSetSbtcTokenSubmit(<br>  e: Event,<br>  form: { contractAddress: string; contractName: string },<br>  authHeader: string,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertContractPrincipalPair(form.contractAddress, form.contractName);<br>  const resp = await AdminHttpClient.request('/set-sbtc-token', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: { contractAddress: form.contractAddress, contractName: form.contractName },<br>  });<br>  if (!resp.ok) throw new Error(`set_sbtc_token_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ call: any }>(resp);<br>  await AdminContractCallSequencer.runSingle(json.call, openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onRetryWebhookClick<br>```typescript<br>async onRetryWebhookClick(webhookLogId: string, authHeader: string): Promise<void> {<br>  AdminInputValidator.assertUuid(webhookLogId, 'webhookLogId');<br>  const resp = await AdminHttpClient.request('/webhooks/retry', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: { webhookLogId },<br>  });<br>  if (resp.status === 200 or resp.status === 202) return;<br>  throw new Error(`retry_webhook_failed_${resp.status}`);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onCancelInvoiceClick<br>```typescript<br>async onCancelInvoiceClick(<br>  invoiceId: string,<br>  authHeader: string,<br>  maybeBuildOnchainCancel: () => Promise<any or undefined>,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  AdminInputValidator.assertUuid(invoiceId, 'invoiceId');<br>  const resp = await AdminHttpClient.request(`/invoices/${invoiceId}/cancel`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (resp.status === 400) {<br>    const j = await AdminHttpClient.parseJson<{ error?: string }>(resp);<br>    if (j?.error === 'already_paid') throw new Error('already_paid');<br>    throw new Error('cancel_invoice_bad_request');<br>  }<br>  if (!resp.ok) throw new Error(`cancel_invoice_failed_${resp.status}`);<br>  await AdminHttpClient.parseJson(resp);<br>  const cancelCall = await maybeBuildOnchainCancel();<br>  if (cancelCall) await AdminContractCallSequencer.runSingle(cancelCall, openContractCall);<br>}<br>```<br><br>--- |
| AdminStoreFormAdapter | - **[Offloading Class Names]**: AdminConsoleFrontend<br>- **[Originating Method Ids]**: ACF-ON-CREATE-STORE-SUBMIT<br><br>Delegate State Owned:<br>- None (pure mapping)<br><br>Delegate Responsibilities Owned:<br>- Transform create-store form payload from snake_case fields to camelCase body required by backend<br><br>Responsibilities Removed from Parent Class:<br>- Inline snake_case → camelCase mapping for create store<br><br>Delegate Public Interface:<br>- toCreateStoreBody(form: { principal: string; name?: string; display_name?: string; logo_url?: string; brand_color?: string; webhook_url?: string; support_email?: string; support_url?: string; allowed_origins?: string }): { principal: string; name?: string; displayName?: string; logoUrl?: string; brandColor?: string; webhookUrl?: string; supportEmail?: string; supportUrl?: string; allowedOrigins?: string }<br><br>Example Interaction:<br>```typescript<br>const body = AdminStoreFormAdapter.toCreateStoreBody(form);<br>```<br><br>#### 🔧 Delegate Method: toCreateStoreBody<br>Maps form fields to the backend’s expected camelCase JSON payload.<br>```typescript<br>export class AdminStoreFormAdapter {<br>  static toCreateStoreBody(form: {<br>    principal: string;<br>    name?: string;<br>    display_name?: string;<br>    logo_url?: string;<br>    brand_color?: string;<br>    webhook_url?: string;<br>    support_email?: string;<br>    support_url?: string;<br>    allowed_origins?: string;<br>  }): {<br>    principal: string;<br>    name?: string;<br>    displayName?: string;<br>    logoUrl?: string;<br>    brandColor?: string;<br>    webhookUrl?: string;<br>    supportEmail?: string;<br>    supportUrl?: string;<br>    allowedOrigins?: string;<br>  } {<br>    return {<br>      principal: form.principal,<br>      name: form.name ?? undefined,<br>      displayName: form.display_name ?? undefined,<br>      logoUrl: form.logo_url ?? undefined,<br>      brandColor: form.brand_color ?? undefined,<br>      webhookUrl: form.webhook_url ?? undefined,<br>      supportEmail: form.support_email ?? undefined,<br>      supportUrl: form.support_url ?? undefined,<br>      allowedOrigins: form.allowed_origins ?? undefined,<br>    };<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onCreateStoreSubmit<br>The method now delegates all shape transformation to AdminStoreFormAdapter.<br>```typescript<br>async onCreateStoreSubmit(<br>  e: Event,<br>  form: {<br>    principal: string;<br>    name?: string;<br>    display_name?: string;<br>    logo_url?: string;<br>    brand_color?: string;<br>    webhook_url?: string;<br>    support_email?: string;<br>    support_url?: string;<br>    allowed_origins?: string;<br>  },<br>  authHeader: string<br>): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertStacksAddress(form.principal, 'principal');<br>  const body = AdminStoreFormAdapter.toCreateStoreBody(form);<br>  const resp = await AdminHttpClient.request('/stores', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: body,<br>  });<br>  if (resp.status === 201) {<br>    await AdminHttpClient.parseJson(resp);<br>    return;<br>  }<br>  if (resp.status === 409) throw new Error('conflict');<br>  throw new Error(`create_store_failed_${resp.status}`);<br>}<br>```<br><br>--- |
| AdminContractCallSequencer | - **[Offloading Class Names]**: AdminConsoleFrontend<br>- **[Originating Method Ids]**: ACF-ON-SYNC-ONCHAIN-CLICK, ACF-ON-SET-SBTC-TOKEN-SUBMIT, ACF-ON-CANCEL-INVOICE-CLICK, ACF-ON-BOOTSTRAP-ADMIN-CLICK<br><br>Delegate State Owned:<br>- None (stateless; executes provided calls)<br><br>Delegate Responsibilities Owned:<br>- Deterministically execute one or many unsigned contract call descriptors via provided openContractCall function<br>- Enforce sequential ordering for multi-call flows<br><br>Responsibilities Removed from Parent Class:<br>- Manual iteration and wallet invocation ordering for on-chain calls<br><br>Delegate Public Interface:<br>- runSequential(calls: any[], openContractCall: (call: any) => Promise<void>): Promise<void><br>- runSingle(call: any, openContractCall: (call: any) => Promise<void>): Promise<void><br><br>Example Interaction:<br>```typescript<br>await AdminContractCallSequencer.runSequential(calls, openContractCall);<br>```<br><br>#### 🔧 Delegate Method: runSequential<br>Executes an array of unsigned contract-call descriptors in-order, awaiting each wallet interaction.<br>```typescript<br>export class AdminContractCallSequencer {<br>  static async runSequential(<br>    calls: any[],<br>    openContractCall: (call: any) => Promise<void><br>  ): Promise<void> {<br>    for (const call of calls) {<br>      await openContractCall(call);<br>    }<br>  }<br><br>  static async runSingle(call: any, openContractCall: (call: any) => Promise<void>): Promise<void> {<br>    await openContractCall(call);<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onSyncOnchainClick<br>Delegates call sequencing to AdminContractCallSequencer.<br>```typescript<br>async onSyncOnchainClick(<br>  storeId: string,<br>  authHeader: string,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/sync-onchain`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (!resp.ok) throw new Error(`sync_onchain_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ calls: any[] }>(resp);<br>  await AdminContractCallSequencer.runSequential(Array.isArray(json.calls) ? json.calls : [], openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onSetSbtcTokenSubmit<br>Delegates single wallet invocation to AdminContractCallSequencer.runSingle.<br>```typescript<br>async onSetSbtcTokenSubmit(<br>  e: Event,<br>  form: { contractAddress: string; contractName: string },<br>  authHeader: string,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertContractPrincipalPair(form.contractAddress, form.contractName);<br>  const resp = await AdminHttpClient.request('/set-sbtc-token', {<br>    method: 'POST',<br>    authHeader,<br>    jsonBody: { contractAddress: form.contractAddress, contractName: form.contractName },<br>  });<br>  if (!resp.ok) throw new Error(`set_sbtc_token_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ call: any }>(resp);<br>  await AdminContractCallSequencer.runSingle(json.call, openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onCancelInvoiceClick<br>Optionally delegates the on-chain cancel call when helper returns a descriptor.<br>```typescript<br>async onCancelInvoiceClick(<br>  invoiceId: string,<br>  authHeader: string,<br>  maybeBuildOnchainCancel: () => Promise<any or undefined>,<br>  openContractCall: (call: any) => Promise<void><br>): Promise<void> {<br>  AdminInputValidator.assertUuid(invoiceId, 'invoiceId');<br>  const resp = await AdminHttpClient.request(`/invoices/${invoiceId}/cancel`, {<br>    method: 'POST',<br>    authHeader,<br>  });<br>  if (resp.status === 400) {<br>    const j = await AdminHttpClient.parseJson<{ error?: string }>(resp);<br>    if (j?.error === 'already_paid') throw new Error('already_paid');<br>    throw new Error('cancel_invoice_bad_request');<br>  }<br>  if (!resp.ok) throw new Error(`cancel_invoice_failed_${resp.status}`);<br>  await AdminHttpClient.parseJson(resp);<br>  const cancelCall = await maybeBuildOnchainCancel();<br>  if (cancelCall) await AdminContractCallSequencer.runSingle(cancelCall, openContractCall);<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleFrontend.onBootstrapAdminClick<br>Uses sequencer to execute the single bootstrap call; verification remains in parent to honor method contract.<br>```typescript<br>async onBootstrapAdminClick(<br>  authHeader: string,<br>  buildCall: () => Promise<any>,<br>  openContractCall: (call: any) => Promise<void>,<br>  verifyGetAdmin: () => Promise<boolean><br>): Promise<void> {<br>  const call = await buildCall();<br>  await AdminContractCallSequencer.runSingle(call, openContractCall);<br>  const ok = await verifyGetAdmin();<br>  if (!ok) throw new Error('bootstrap_admin_verification_failed');<br>}<br>```<br><br>End of report. |
| AdminSurfaceBinder | - **[Offloading Class Names]**: HttpApiServer<br>- **[Originating Method Ids]**: HAPI-1, HAPI-2, HAPI-4<br><br>Delegate State Owned:<br>- mountedAuth: boolean — prevents double registration of the global admin guard.<br>- mountedStatic: boolean — prevents double registration of static assets binding.<br>- mountedIndex: boolean — prevents double registration of SPA index route.<br><br>Delegate Responsibilities Owned:<br>- Bind global AdminAuth guard for /admin and /api/admin ensuring it precedes any static or route mounts.<br>- Bind protected static assets under /admin ensuring AdminAuth precedes express.static.<br>- Bind protected SPA index GET /admin ensuring AdminAuth precedes index handler.<br>- Enforce idempotent mounts to avoid duplicate middleware/route registration.<br><br>Responsibilities Removed from Parent Class:<br>- The detailed binding order, idempotence, and protection logic for admin surfaces (guard, static, and SPA index).<br><br>Delegate Public Interface:<br>- bindAdminAuth(app: Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }): void<br>- bindAdminStatic(app: Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }, staticMiddleware: RequestHandler): void<br>- bindAdminIndex(app: Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }, serveIndex: (req: any, res: any) => void): void<br><br>Example Interaction:<br>```typescript<br>// Example code snippet clearly illustrating parent-delegate interaction<br>const binder = new AdminSurfaceBinder();<br>binder.bindAdminAuth(app, adminAuth);<br>binder.bindAdminStatic(app, adminAuth, staticServer.serveStatic());<br>binder.bindAdminIndex(app, adminAuth, (req, res) => staticServer.serveIndex(req, res));<br>```<br><br>#### 🔁 Refactored Method: HttpApiServer.mountAdminAuth<br>After refactoring, this method delegates the guard binding to AdminSurfaceBinder, preserving signature and ensuring idempotent global protection for /admin and /api/admin.<br><br>```typescript<br>// Inside HttpApiServer<br>private readonly adminBinder = new AdminSurfaceBinder();<br><br>mountAdminAuth(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }): void {<br>  this.adminBinder.bindAdminAuth(app, adminAuth);<br>}<br>```<br><br>#### 🔁 Refactored Method: HttpApiServer.mountAdminStatic<br>After refactoring, this method delegates static asset binding to AdminSurfaceBinder. AdminAuth is guaranteed to run before static middleware.<br><br>```typescript<br>// Inside HttpApiServer<br>private readonly adminBinder = new AdminSurfaceBinder();<br><br>mountAdminStatic(<br>  app: import('express').Express,<br>  adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },<br>  staticMiddleware: import('express').RequestHandler,<br>): void {<br>  this.adminBinder.bindAdminStatic(app, adminAuth, staticMiddleware);<br>}<br>```<br><br>#### 🔁 Refactored Method: HttpApiServer.mountAdminIndex<br>After refactoring, this method delegates SPA index binding to AdminSurfaceBinder, ensuring the guard precedes the index streaming.<br><br>```typescript<br>// Inside HttpApiServer<br>private readonly adminBinder = new AdminSurfaceBinder();<br><br>mountAdminIndex(<br>  app: import('express').Express,<br>  adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },<br>  serveIndex: (req: any, res: any) => void,<br>): void {<br>  this.adminBinder.bindAdminIndex(app, adminAuth, serveIndex);<br>}<br>```<br><br>#### 🔧 Delegate Method: bindAdminAuth<br>```typescript<br>import type { Express, RequestHandler } from 'express';<br><br>export class AdminSurfaceBinder {<br>  private mountedAuth = false;<br>  private mountedStatic = false;<br>  private mountedIndex = false;<br><br>  public bindAdminAuth(<br>    app: Express,<br>    adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },<br>  ): void {<br>    if (this.mountedAuth) return;<br>    app.use(<br>      ['/admin', '/api/admin'],<br>      (req, res, next) => adminAuth.authenticateAdmin(req, res, next),<br>    );<br>    this.mountedAuth = true;<br>  }<br><br>  public bindAdminStatic(<br>    app: Express,<br>    adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },<br>    staticMiddleware: RequestHandler,<br>  ): void {<br>    // Ensure global guard mounted first and enforce guard before static serving<br>    this.bindAdminAuth(app, adminAuth);<br>    if (this.mountedStatic) return;<br>    app.use(<br>      '/admin',<br>      (req, res, next) => adminAuth.authenticateAdmin(req, res, next),<br>      staticMiddleware,<br>    );<br>    this.mountedStatic = true;<br>  }<br><br>  public bindAdminIndex(<br>    app: Express,<br>    adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },<br>    serveIndex: (req: any, res: any) => void,<br>  ): void {<br>    // Ensure global guard mounted first and enforce guard before index handler<br>    this.bindAdminAuth(app, adminAuth);<br>    if (this.mountedIndex) return;<br>    app.get(<br>      '/admin',<br>      (req, res, next) => adminAuth.authenticateAdmin(req, res, next),<br>      (req, res) => serveIndex(req, res),<br>    );<br>    this.mountedIndex = true;<br>  }<br>}<br>```<br><br>--- |
| WebhookInboundSurfaceBinder | - **[Offloading Class Names]**: HttpApiServer<br>- **[Originating Method Ids]**: HAPI-MOUNT-INBOUND-WEBHOOK-VERIFIER<br><br>Delegate State Owned:<br>- mounted: boolean — prevents double registration of the inbound webhook verification chain.<br><br>Delegate Responsibilities Owned:<br>- Mount express.raw({ type: 'application/json' }) and the verifier middleware under /webhooks/inbound.<br>- Guarantee idempotence, ensuring the raw body parser and verification are registered exactly once.<br><br>Responsibilities Removed from Parent Class:<br>- The detailed raw-body and verifier middleware mounting logic and idempotence.<br><br>Delegate Public Interface:<br>- bind(app: Express, verifierMw: RequestHandler): void<br><br>Example Interaction:<br>```typescript<br>const inboundBinder = new WebhookInboundSurfaceBinder();<br>inboundBinder.bind(app, inboundVerifier);<br>```<br><br>#### 🔁 Refactored Method: HttpApiServer.mountInboundWebhookVerifier<br>After refactoring, the method delegates the raw body + verifier chain mounting to WebhookInboundSurfaceBinder.<br><br>```typescript<br>// Inside HttpApiServer<br>private readonly inboundBinder = new WebhookInboundSurfaceBinder();<br><br>mountInboundWebhookVerifier(app: import('express').Express, verifierMw: import('express').RequestHandler): void {<br>  this.inboundBinder.bind(app, verifierMw);<br>}<br>```<br><br>#### 🔧 Delegate Method: bind<br>```typescript<br>import type { Express, RequestHandler } from 'express';<br>import express from 'express';<br><br>export class WebhookInboundSurfaceBinder {<br>  private mounted = false;<br><br>  public bind(app: Express, verifierMw: RequestHandler): void {<br>    if (this.mounted) return;<br>    app.use(<br>      '/webhooks/inbound',<br>      express.raw({ type: 'application/json' }),<br>      verifierMw,<br>    );<br>    this.mounted = true;<br>  }<br>}<br>```<br><br>--- |
| SchedulerStartupCoordinator | - **[Offloading Class Names]**: HttpApiServer<br>- **[Originating Method Ids]**: HAPI-START<br><br>Delegate State Owned:<br>- startedPoller: boolean — ensures the PaymentPoller is bootstrapped once.<br>- startedRetry: boolean — ensures the WebhookRetryScheduler is bootstrapped once.<br>- startedSubscription: boolean — ensures the SubscriptionScheduler is bootstrapped once (if provided).<br><br>Delegate Responsibilities Owned:<br>- Idempotently bootstrap background schedulers: poller, webhook retry, and optionally the subscription scheduler.<br>- Respect optional presence of subscription scheduler without assuming external configuration.<br><br>Responsibilities Removed from Parent Class:<br>- Idempotence and sequencing of scheduler bootstraps.<br><br>Delegate Public Interface:<br>- startSchedulers(deps: { poller: { bootstrapPoller(): void }; webhookRetry: { bootstrap(): void }; subscriptionScheduler?: { bootstrapScheduler(): void }; config: IConfigService }): Promise<void><br><br>Example Interaction:<br>```typescript<br>const sched = new SchedulerStartupCoordinator();<br>await sched.startSchedulers({ poller, webhookRetry, subscriptionScheduler, config });<br>```<br><br>#### 🔁 Refactored Method: HttpApiServer.start<br>After refactoring, this method delegates idempotent bootstrapping to SchedulerStartupCoordinator, preserving the signature and promise-based contract.<br><br>```typescript<br>// Inside HttpApiServer<br>private readonly schedulerCoordinator = new SchedulerStartupCoordinator();<br><br>async start(deps: {<br>  app: import('express').Express;<br>  poller: { bootstrapPoller(): void };<br>  webhookRetry: { bootstrap(): void };<br>  subscriptionScheduler?: { bootstrapScheduler(): void };<br>  config: IConfigService;<br>}): Promise<void> {<br>  await this.schedulerCoordinator.startSchedulers({<br>    poller: deps.poller,<br>    webhookRetry: deps.webhookRetry,<br>    subscriptionScheduler: deps.subscriptionScheduler,<br>    config: deps.config,<br>  });<br>}<br>```<br><br>#### 🔧 Delegate Method: startSchedulers<br>```typescript<br>import type { IConfigService } from '../contracts/interfaces';<br><br>export class SchedulerStartupCoordinator {<br>  private startedPoller = false;<br>  private startedRetry = false;<br>  private startedSubscription = false;<br><br>  public async startSchedulers(deps: {<br>    poller: { bootstrapPoller(): void };<br>    webhookRetry: { bootstrap(): void };<br>    subscriptionScheduler?: { bootstrapScheduler(): void };<br>    config: IConfigService;<br>  }): Promise<void> {<br>    if (!this.startedPoller) {<br>      deps.poller.bootstrapPoller();<br>      this.startedPoller = true;<br>    }<br>    if (!this.startedRetry) {<br>      deps.webhookRetry.bootstrap();<br>      this.startedRetry = true;<br>    }<br>    if (deps.subscriptionScheduler && !this.startedSubscription) {<br>      deps.subscriptionScheduler.bootstrapScheduler();<br>      this.startedSubscription = true;<br>    }<br>  }<br>}<br>```<br><br>--- |
| RootRouteBinder | - **[Offloading Class Names]**: HttpApiServer<br>- **[Originating Method Ids]**: HAPI-3<br><br>Delegate State Owned:<br>- mounted: boolean — ensures readiness route is bound only once.<br><br>Delegate Responsibilities Owned:<br>- Bind GET / readiness endpoint delegating to provided handler.getRoot.<br><br>Responsibilities Removed from Parent Class:<br>- Idempotent binding of the root readiness route.<br><br>Delegate Public Interface:<br>- bindRoot(app: Express, handler: { getRoot(req: any, res: any): void }): void<br><br>Example Interaction:<br>```typescript<br>const rootBinder = new RootRouteBinder();<br>rootBinder.bindRoot(app, healthCtrl);<br>```<br><br>#### 🔁 Refactored Method: HttpApiServer.mountRoot<br>After refactoring, the method delegates binding of the root readiness endpoint to RootRouteBinder, preserving signature.<br><br>```typescript<br>// Inside HttpApiServer<br>private readonly rootBinder = new RootRouteBinder();<br><br>mountRoot(app: import('express').Express, handler: { getRoot(req: any, res: any): void }): void {<br>  this.rootBinder.bindRoot(app, handler);<br>}<br>```<br><br>#### 🔧 Delegate Method: bindRoot<br>```typescript<br>import type { Express } from 'express';<br><br>export class RootRouteBinder {<br>  private mounted = false;<br><br>  public bindRoot(app: Express, handler: { getRoot(req: any, res: any): void }): void {<br>    if (this.mounted) return;<br>    app.get('/', (req, res) => handler.getRoot(req, res));<br>    this.mounted = true;<br>  }<br>}<br>```<br><br>--- |
| CorsMiddlewareFactory | - **[Offloading Class Names]**: HttpApiServer<br>- **[Originating Method Ids]**: None<br><br>Delegate State Owned:<br>- None (stateless factory).<br><br>Delegate Responsibilities Owned:<br>- Provide per-route CORS middleware that uses CorsPolicy.publicCorsOriginValidator and sets consistent allowed headers and methods.<br>- Centralize CORS construction to reduce duplication and ensure correct origin callback with req context.<br><br>Responsibilities Removed from Parent Class:<br>- Inline construction of cors(...) middleware for each route.<br><br>Delegate Public Interface:<br>- create(methods: string[], corsPolicy: { publicCorsOriginValidator(origin: string or undefined, cb: (err: Error or null, allow?: boolean) => void, req: any): void }): import('express').RequestHandler<br><br>Example Interaction:<br>```typescript<br>const corsFactory = new CorsMiddlewareFactory();<br>const corsMw = corsFactory.create(['GET', 'OPTIONS'], corsPolicy);<br>app.get('/i/:invoiceId', corsMw, (req, res) => publicCtrl.getInvoice(req, res));<br>```<br><br>#### 🔧 Delegate Method: create<br>```typescript<br>import type { RequestHandler } from 'express';<br>import cors from 'cors';<br><br>export class CorsMiddlewareFactory {<br>  public create(<br>    methods: string[],<br>    corsPolicy: {<br>      publicCorsOriginValidator(<br>        origin: string or undefined,<br>        cb: (err: Error or null, allow?: boolean) => void,<br>        req: any,<br>      ): void;<br>    },<br>  ): RequestHandler {<br>    return (req, res, next) =><br>      cors({<br>        origin: (origin, cb) => corsPolicy.publicCorsOriginValidator(origin, cb, req),<br>        methods,<br>        allowedHeaders: [<br>          'Content-Type',<br>          'X-API-Key',<br>          'X-Webhook-Timestamp',<br>          'X-Webhook-Signature',<br>        ],<br>      })(req, res, next);<br>  }<br>}<br>```<br><br>End of report. |
| ApplicationBootstrapper | Orchestrates backend process startup: loads configuration, opens SQLite and applies migrations, initializes chain client and builders, constructs services/controllers/middlewares, composes Express routes, boots background schedulers (poller, webhook retry, subscription scheduler), and starts HTTP listening. |

### Component Methods definition:
| Component Name | Signature | Description | Implementation Details |
| -------------- | --------- | ----------- | ---------------------- |
| SbtcPaymentContract | (define-public (bootstrap-admin) (response bool uint)) | One-time admin bootstrap. Reads data-var admin (optional principal); if none, sets admin to (some tx-sender) and returns (ok true); else returns (err u1). No events. Validates no prior admin. No external dependencies. Caller must be the intended operator wallet. |  |
| SbtcPaymentContract | (define-public (set-sbtc-token (token (contract-of ft-trait))) (response bool uint)) | Admin-only. Unwraps admin and asserts tx-sender == admin. Sets data-var sbtc-token = (some token). Returns (ok true). Enforces compile-time trait typing via (contract-of ft-trait). No event emitted. All subsequent transfers use this token principal; backend should read via get-sbtc(). |  |
| SbtcPaymentContract | (define-public (register-merchant (merchant principal) (name (optional (buff 34)))) (response bool uint)) | Admin-only. Validates tx-sender == admin. Inserts or upserts merchants{merchant} with active=true and provided name. Emits print event {event:"merchant-registered", merchant, active:true, name}. Ensures principal typed correctly; name buffer ≤ 34 bytes. Backend poller upserts local merchants table based on event. |  |
| SbtcPaymentContract | (define-public (set-merchant-active (merchant principal) (active bool)) (response bool uint)) | Admin-only. Asserts tx-sender == admin. Updates merchants{merchant}.active to active (upsert per design). Emits print {event:"merchant-active-updated", merchant, active}. Backend must mirror this to merchants.active and use it to gate create-invoice and pay-invoice payload creation. |  |
| SbtcPaymentContract | (define-public (create-invoice (id (buff 32)) (amount uint) (memo (optional (buff 34))) (expires-at (optional uint))) (response bool uint)) | Merchant-only (registered & active). Validates: unique id (map-get? invoices {id} is none), amount > 0, memo size ≤ 34 bytes, caller principal registered and active. Persists tuple with merchant=tx-sender, amount, memo, expires-at, paid=false, canceled=false, refund-amount=u0, payer=none. Emits {event:"invoice-created", id, merchant, amount, expiresAt, memo}. Backend must use 32-byte id (stored off-chain as 64-hex) and compute expires-at in block height from TTL. | SbtcPaymentContract.create-invoice HOW:<br>- Alignment: Exactly matches the Problem Statement’s on-chain invoice creation requirements: unique 32-byte ID, merchant must be registered and active, immutable amount, optional memo and expires-at, and emit invoice-created.<br>- Mechanics (Clarity):<br>  1. Data structures:<br>     - `data-var admin: (optional principal)`.<br>     - `data-var sbtc-token: (optional (contract-of ft-trait))`.<br>     - `map merchants: { merchant: principal } -> { active: bool, name: (optional (buff 34)) }`.<br>     - `map invoices: { id: (buff 32) } -> { merchant: principal, amount: uint, memo: (optional (buff 34)), expires-at: (optional uint), paid: bool, canceled: bool, refund-amount: uint, payer: (optional principal) }`.<br>  2. Preconditions:<br>     - `amount > u0`.<br>     - `map-get? merchants {merchant: tx-sender}` returns some and `.active == true`.<br>     - `map-get? invoices {id}` is none.<br>     - `memo` length ≤ 34 bytes is enforced by type `(optional (buff 34))`.<br>  3. State changes:<br>     - Insert invoices row with defaults: `paid=false`, `canceled=false`, `refund-amount=u0`, `payer=none`.<br>  4. Events:<br>     - `print` object: `{event:"invoice-created", id, merchant: tx-sender, amount, expiresAt: expires-at, memo}`.<br>  5. Return `(ok true)`.<br>- Pseudocode:<br>```clarity<br>(define-public (create-invoice (id (buff 32)) (amount uint) (memo (optional (buff 34))) (expires-at (optional uint)))<br>  (begin<br>    (asserts! (> amount u0) (err u100)) ;; ERR-AMOUNT-0<br>    (let<br>      (<br>        (m? (map-get? merchants { merchant: tx-sender }))<br>      )<br>      (asserts! (is-some m?) (err u101)) ;; ERR-MERCHANT-NOT-REGISTERED<br>      (let ((m (unwrap-panic m?)))<br>        (asserts! (eq true (get active m)) (err u102)) ;; ERR-MERCHANT-INACTIVE<br>        (asserts! (is-none (map-get? invoices { id: id })) (err u103)) ;; ERR-DUP-ID<br>        (map-set invoices { id: id }<br>          {<br>            merchant: tx-sender,<br>            amount: amount,<br>            memo: memo,<br>            expires-at: expires-at,<br>            paid: false,<br>            canceled: false,<br>            refund-amount: u0,<br>            payer: none<br>          }<br>        )<br>        (print { event: "invoice-created", id: id, merchant: tx-sender, amount: amount, expiresAt: expires-at, memo: memo })<br>        (ok true)<br>      )<br>    )<br>  )<br>)<br>```<br>- Gotchas:<br>  - Ensure `memo` optional CV is used; do not over-constrain beyond `(buff 34)`.<br>  - Do not allow creating invoice if merchant is inactive even if previously registered.<br>  - Uniqueness strictly enforced on `(buff 32)` id.<br>- Invariants:<br>  - Amount and merchant in invoice never change later (enforced by not exposing setters).<br>- Performance:<br>  - O(1) map lookups; Clarity per-tx limits easily satisfied.<br><br>--- |
| SbtcPaymentContract | (define-public (pay-invoice (id (buff 32))) (response bool uint)) | Payer-signed. Validates invoice exists, not paid, not canceled; if expires-at present, requires block-height < expires-at; merchant is still active; sbtc-token is set. Executes (contract-call? token.transfer? amount tx-sender merchant none) and asserts ok. Sets paid=true and payer=(some tx-sender). Emits {event:"invoice-paid", id, payer, merchant, amount}. Backend must build post-conditions: payer sent ≥ amount; merchant received ≥ amount using sBTC asset. | SbtcPaymentContract.pay-invoice HOW:<br>- Alignment: Enforces exact amount via SIP-010 transfer?, validates unpaid, not canceled, not expired, and active merchant. Emits invoice-paid. Matches Problem Statement.<br>- Mechanics (Clarity):<br>  1. Read invoice by id; require exists.<br>  2. Reject if `paid == true` or `canceled == true`.<br>  3. If `expires-at` is some, assert `block-height < expires-at`.<br>  4. Load `merchants{inv.merchant}` and assert `active == true`.<br>  5. Load `sbtc-token` from data-var, assert set.<br>  6. Call `(contract-call? token.transfer? (get amount inv) tx-sender (get merchant inv) none)` and assert `(ok true)`.<br>  7. Update invoice: `paid=true`, `payer=(some tx-sender)`.<br>  8. `print` event `{event:"invoice-paid", id, payer, merchant, amount}`.<br>  9. Return `(ok true)`.<br>- Pseudocode:<br>```clarity<br>(define-public (pay-invoice (id (buff 32)))<br>  (let ((inv? (map-get? invoices { id: id })))<br>    (asserts! (is-some inv?) (err u200)) ;; ERR-NOT-FOUND<br>    (let ((inv (unwrap-panic inv?)))<br>      (asserts! (eq false (get paid inv)) (err u201)) ;; ERR-ALREADY-PAID<br>      (asserts! (eq false (get canceled inv)) (err u202)) ;; ERR-CANCELED<br>      (if (is-some (get expires-at inv))<br>        (asserts! (< block-height (unwrap-panic (get expires-at inv))) (err u203)) ;; ERR-EXPIRED<br>        (ok true)<br>      )<br>      (let ((m? (map-get? merchants { merchant: (get merchant inv) })))<br>        (asserts! (is-some m?) (err u204)) ;; ERR-MERCHANT-MISSING<br>        (asserts! (eq true (get active (unwrap-panic m?))) (err u205)) ;; ERR-MERCHANT-INACTIVE<br>        (let ((tok? (var-get sbtc-token)))<br>          (asserts! (is-some tok?) (err u206)) ;; ERR-NO-TOKEN<br>          (let ((tok (unwrap-panic tok?)))<br>            (let ((res (contract-call? tok transfer? (get amount inv) tx-sender (get merchant inv) none)))<br>              (match res<br>                okv<br>                  (begin<br>                    (map-set invoices { id: id } (merge inv { paid: true, payer: (some tx-sender) }))<br>                    (print { event: "invoice-paid", id: id, payer: tx-sender, merchant: (get merchant inv), amount: (get amount inv) })<br>                    (ok true)<br>                  )<br>                errv (err errv)<br>              )<br>            )<br>          )<br>        )<br>      )<br>    )<br>  )<br>)<br>```<br>- Gotchas:<br>  - Expiration compares `block-height` to `expires-at` strictly `<` as specified.<br>  - Do not attempt partial payments; always transfer exact stored `amount`.<br>  - Requires wallet post-conditions off-chain: payer sent ≥ amount; merchant received ≥ amount.<br>- Invariants:<br>  - After success, invoice cannot be paid again; `paid` prevents replays.<br><br>--- |
| SbtcPaymentContract | (define-public (refund-invoice (id (buff 32)) (amount uint) (memo (optional (buff 34)))) (response bool uint)) | Merchant-signed (must equal invoice.merchant). Validates invoice exists and paid, payer present, memo ≤ 34 bytes, cumulative cap: refund-amount + amount ≤ invoice.amount. Calls token.transfer? amount from merchant to payer and asserts ok; increases refund-amount; emits {event:"invoice-refunded", id, merchant, payer, amount, refundTotal, memo}. Backend must pre-check merchant sBTC balance and cap outgoing via LessEqual post-condition. | SbtcPaymentContract.refund-invoice HOW:<br>- Alignment: Matches Problem Statement’s merchant-only refund with cumulative cap and event emission.<br>- Mechanics (Clarity):<br>  1. Load invoice; assert exists and `paid == true`.<br>  2. Assert `tx-sender == inv.merchant`.<br>  3. Assert `is-some inv.payer`; unwrap payer.<br>  4. Assert `amount > 0`.<br>  5. Assert `inv.refund-amount + amount ≤ inv.amount`.<br>  6. Ensure token set; call `transfer? amount from tx-sender to payer` with optional memo; assert ok.<br>  7. Increment `refund-amount` and persist.<br>  8. Emit `invoice-refunded` with cumulative `refundTotal`.<br>  9. Return `(ok true)`.<br>- Pseudocode:<br>```clarity<br>(define-public (refund-invoice (id (buff 32)) (amount uint) (memo (optional (buff 34))))<br>  (let ((inv? (map-get? invoices { id: id })))<br>    (asserts! (is-some inv?) (err u300)) ;; ERR-NOT-FOUND<br>    (let ((inv (unwrap-panic inv?)))<br>      (asserts! (eq true (get paid inv)) (err u301)) ;; ERR-NOT-PAID<br>      (asserts! (is-some (get payer inv)) (err u302)) ;; ERR-NO-PAYER<br>      (asserts! (is-eq tx-sender (get merchant inv)) (err u303)) ;; ERR-NOT-MERCHANT<br>      (asserts! (> amount u0) (err u304)) ;; ERR-AMOUNT-0<br>      (let ((new-total (+ (get refund-amount inv) amount)))<br>        (asserts! (<= new-total (get amount inv)) (err u305)) ;; ERR-REFUND-CAP<br>        (let ((tok? (var-get sbtc-token)))<br>          (asserts! (is-some tok?) (err u306)) ;; ERR-NO-TOKEN<br>          (let ((tok (unwrap-panic tok?)) (payr (unwrap-panic (get payer inv))))<br>            (match (contract-call? tok transfer? amount tx-sender payr memo)<br>              okv<br>                (begin<br>                  (map-set invoices { id: id } (merge inv { refund-amount: new-total }))<br>                  (print { event: "invoice-refunded", id: id, merchant: tx-sender, payer: payr, amount: amount, refundTotal: new-total, memo: memo })<br>                  (ok true)<br>                )<br>              errv (err errv)<br>            )<br>          )<br>        )<br>      )<br>    )<br>  )<br>)<br>```<br>- Gotchas:<br>  - Cumulative cap enforced on-chain prevents over-refund across multiple calls.<br>  - Off-chain must pre-check merchant balance; on-chain still rejects insufficient balance via `transfer?`.<br>  - Use wallet post-condition capping merchant outgoing sBTC ≥ amount to limit exposure.<br>- Invariants:<br>  - `amount` and original invoice remain immutable; only `refund-amount` mutates.<br><br>--- |
| SbtcPaymentContract | (define-public (create-subscription (id (buff 32)) (merchant principal) (subscriber principal) (amount uint) (interval uint)) (response bool uint)) | Merchant-signed (tx-sender == merchant). Validates merchant active, interval > u0, unique id, positive amount. Inserts subscriptions map with active=true and next-due=block-height + interval. Emits {event:"subscription-created", id, merchant, subscriber, amount, interval, nextDue}. Backend stores subscription, preserves mode, and uses nextDue for scheduling. | SbtcPaymentContract.create-subscription HOW:<br>- Alignment: Follows Problem Statement: merchant-signed, active merchant, interval > 0, unique id, init `next-due = block-height + interval`, emit subscription-created.<br>- Mechanics (Clarity):<br>  1. Data structure: `map subscriptions: { id: (buff 32) } -> { merchant: principal, subscriber: principal, amount: uint, interval: uint, active: bool, next-due: uint }`.<br>  2. Preconditions:<br>     - `tx-sender == merchant`.<br>     - `merchants{merchant}` exists and `active == true`.<br>     - `interval > 0`, `amount > 0`.<br>     - `subscriptions{id}` is none.<br>  3. Insert tuple with `active=true` and `next-due= block-height + interval`.<br>  4. Print event with `nextDue`.<br>  5. Return `(ok true)`.<br>- Pseudocode:<br>```clarity<br>(define-public (create-subscription (id (buff 32)) (merchant principal) (subscriber principal) (amount uint) (interval uint))<br>  (begin<br>    (asserts! (is-eq tx-sender merchant) (err u400)) ;; ERR-NOT-MERCHANT<br>    (asserts! (> amount u0) (err u401))<br>    (asserts! (> interval u0) (err u402))<br>    (let ((m? (map-get? merchants { merchant: merchant })))<br>      (asserts! (is-some m?) (err u403))<br>      (asserts! (eq true (get active (unwrap-panic m?))) (err u404))<br>      (asserts! (is-none (map-get? subscriptions { id: id })) (err u405))<br>      (map-set subscriptions { id: id }<br>        { merchant: merchant, subscriber: subscriber, amount: amount, interval: interval, active: true, next-due: (+ block-height interval) }<br>      )<br>      (print { event: "subscription-created", id: id, merchant: merchant, subscriber: subscriber, amount: amount, interval: interval, nextDue: (+ block-height interval) })<br>      (ok true)<br>    )<br>  )<br>)<br>```<br>- Gotchas:<br>  - Merchant passed as arg must match `tx-sender`.<br>  - Keep `next-due` at creation time to enforce schedule.<br><br>--- |
| SbtcPaymentContract | (define-public (pay-subscription (id (buff 32))) (response bool uint)) | Subscriber-signed. Validates sub exists, active, tx-sender == subscriber, block-height ≥ next-due; sbtc-token set. Calls token.transfer? amount from subscriber to merchant; advances next-due by interval; emits {event:"subscription-paid", id, merchant, subscriber, amount, nextDue}. Backend must attach two post-conditions (subscriber sent ≥, merchant received ≥) and update DB on confirmed events. | SbtcPaymentContract.pay-subscription HOW:<br>- Alignment: Matches Problem Statement: subscriber pays on/after next-due, exact amount transfer, advance schedule, event emit.<br>- Mechanics (Clarity):<br>  1. Load subscription; require exists and `active == true`.<br>  2. Assert `tx-sender == subscriber`.<br>  3. Assert `block-height ≥ next-due`.<br>  4. Assert token set; `(transfer? amount from tx-sender to merchant)`.<br>  5. Update `next-due = next-due + interval`.<br>  6. Print `subscription-paid` with new `nextDue`.<br>  7. Return `(ok true)`.<br>- Pseudocode:<br>```clarity<br>(define-public (pay-subscription (id (buff 32)))<br>  (let ((sub? (map-get? subscriptions { id: id })))<br>    (asserts! (is-some sub?) (err u500))<br>    (let ((sub (unwrap-panic sub?)))<br>      (asserts! (eq true (get active sub)) (err u501))<br>      (asserts! (is-eq tx-sender (get subscriber sub)) (err u502))<br>      (asserts! (>= block-height (get next-due sub)) (err u503))<br>      (let ((tok? (var-get sbtc-token)))<br>        (asserts! (is-some tok?) (err u504))<br>        (let ((tok (unwrap-panic tok?)))<br>          (match (contract-call? tok transfer? (get amount sub) tx-sender (get merchant sub) none)<br>            okv<br>              (let ((new-next (+ (get next-due sub) (get interval sub))))<br>                (map-set subscriptions { id: id } (merge sub { next-due: new-next }))<br>                (print { event: "subscription-paid", id: id, merchant: (get merchant sub), subscriber: tx-sender, amount: (get amount sub), nextDue: new-next })<br>                (ok true)<br>              )<br>            errv (err errv)<br>          )<br>        )<br>      )<br>    )<br>  )<br>)<br>```<br>- Gotchas:<br>  - Off-chain builder must add two fungible post-conditions (subscriber sent ≥, merchant received ≥).<br>  - Do not change `amount` or `interval`.<br><br>--- |
| SbtcPaymentContract | (define-public (cancel-invoice (id (buff 32))) (response bool uint)) | Merchant or admin. Validates invoice exists, unpaid, and authority (tx-sender == merchant or tx-sender == admin). Sets canceled=true; emits {event:"invoice-canceled", id, merchant}. Backend mirrors status=canceled and blocks further payload generation. |  |
| SbtcPaymentContract | (define-public (cancel-subscription (id (buff 32))) (response bool uint)) | Merchant or admin. Validates subscription exists and authority. Sets active=false; emits {event:"subscription-canceled", id, merchant}. Backend sets active=0, scheduler stops generating invoices for this sub. |  |
| SbtcPaymentContract | (define-public (mark-expired (id (buff 32))) (response bool uint)) | Helper to emit expiry event without mutation. If invoice exists and expires-at is some and block-height ≥ expires-at, prints {event:"invoice-expired", id, merchant, expiresAt}. Returns (ok true) always. Backend may ignore and instead use read-only get-invoice-status or expiry TTL to mark expired and dispatch webhooks. |  |
| StacksChainClient | getTipHeight(): Promise<number> | Returns current Stacks block height. Fetches chain tip from Stacks API; validates response schema; converts to number. Used to translate TTL seconds into expiresAtBlock. Errors propagate as exceptions; caller should handle retries/backoff. |  |
| StacksChainClient | getFungibleBalance(assetContract: { contractAddress: string; contractName: string }, principal: string): Promise<bigint> | Returns sBTC balance for a principal via token API or read-only. Validates principal format; validates assetContract fields. Parses integer balances into bigint to avoid precision loss. Used by refund pre-checks. | StacksChainClient.getFungibleBalance HOW:<br>- Alignment: Used by backend refund pre-check per Problem Statement.<br>- Mechanics (Node/TS):<br>  1. Inputs: `assetContract = {contractAddress, contractName}`, `principal` string.<br>  2. Validate:<br>     - `contractAddress` is a valid Stacks address format.<br>     - `contractName` non-empty.<br>     - `principal` is standard or contract principal.<br>  3. Query balance:<br>     - Preferred: Stacks API fungible balances endpoint for principal, then filter asset by `contractAddress.contractName::token` (SIP-010 name usually equals `token` but use configured `assetName` if known). Alternatively, call SIP-010 `get-balance` read-only if available.<br>  4. Parse integer amount as decimal string to `bigint`.<br>  5. Return `bigint`.<br>- Pseudocode:<br>```ts<br>async function getFungibleBalance(assetContract, principal): Promise<bigint> {<br>  assertValidPrincipal(principal);<br>  assertAddress(assetContract.contractAddress);<br>  assertNonEmpty(assetContract.contractName);<br>  const core = this.network.getCoreApiUrl();<br>  // Option A: Extended API balances<br>  const url = `${core}/extended/v1/address/${principal}/balances`;<br>  const resp = await fetch(url);<br>  if (!resp.ok) throw new Error(`balances http ${resp.status}`);<br>  const json = await resp.json();<br>  // Find by fully-qualified key "SP...contractName::assetName"<br>  const key = `${assetContract.contractAddress}.${assetContract.contractName}::${this.assetNameor'sbtc'}`;<br>  const entry = json.fungible_tokens?.[key];<br>  const amtStr = entry?.balance or "0";<br>  return BigInt(amtStr);<br>}<br>```<br>- Gotchas:<br>  - Asset name must match the actual sBTC token; if configurable, inject from `AssetInfoFactory`.<br>  - API shape differences across indexers; handle missing keys gracefully.<br>  - Use `bigint` to avoid JS number overflow for large balances.<br><br>--- |
| StacksChainClient | isMerchantRegisteredOnChain(principal: string): Promise<boolean> | Indicates whether a principal is registered in contract’s merchant registry. Uses read-only or indexer; validates principal; returns boolean. Admin Sync uses this to decide whether to include register-merchant call. |  |
| StacksChainClient | getTip(): Promise<{ height: number; blockHash: string }> | Returns chain tip metrics. Validates height and blockHash presence; ensures types; used for poller cursors, reorg detection, and due checks in direct subscription payments. | StacksChainClient.getTip HOW:<br>- Alignment: Required for poller cursors, reorg detection, and time-to-block conversions elsewhere.<br>- Mechanics:<br>  1. Compose request to chain tip endpoint:<br>     - Option A: `/v2/info` then read `burn_block_height` or `stacks_tip_height` (prefer `stacks_tip_height`).<br>     - Option B: `/extended/v1/block?limit=1` to get latest block hash and height.<br>  2. Validate response:<br>     - Ensure numeric height and non-empty `blockHash`.<br>  3. Return `{ height, blockHash }`.<br>- Pseudocode:<br>```ts<br>async function getTip(): Promise<{height:number; blockHash:string}> {<br>  const core = this.network.getCoreApiUrl();<br>  const info = await (await fetch(`${core}/v2/info`)).json();<br>  const height = Number(info.stacks_tip_height);<br>  if (!Number.isFinite(height)) throw new Error('invalid height');<br>  // Map to a block hash: fetch by height<br>  const blk = await (await fetch(`${core}/extended/v1/block/by_height/${height}`)).json();<br>  const blockHash = blk.hash;<br>  if (typeof blockHash !== 'string' or blockHash.length === 0) throw new Error('invalid hash');<br>  return { height, blockHash };<br>}<br>```<br>- Gotchas:<br>  - Tip height can advance between calls; acceptable for UI and poller stats.<br>  - Handle non-200s with retries/backoff at caller.<br><br>--- |
| StacksChainClient | readSbtcToken(): Promise<{ contractAddress: string; contractName: string } or undefined> | <br>readSbtcToken(): Promise<{ contractAddress: string; contractName: string } or undefined> performs the read-only get-sbtc call and delegates optional contract-principal decoding to ClarityCvAdapter.decodeOptionalContractPrincipal. No decoding logic remains inline.<br><br>External delegate calls:<br>- this.cvAdapter.decodeOptionalContractPrincipal(cv)<br><br>Implementation snippet:<br><br>```ts<br>async readSbtcToken(): Promise<{ contractAddress: string; contractName: string } or undefined> {<br>  const cv = await callReadOnlyFunction({<br>    contractAddress: this.contractAddress,<br>    contractName: this.contractName,<br>    functionName: 'get-sbtc',<br>    functionArgs: [],<br>    network: this.network,<br>  });<br>  return this.cvAdapter.decodeOptionalContractPrincipal(cv);<br>}<br>```<br><br> |  |
| StacksChainClient | readSubscription(idHex: string): Promise<OnChainSubscription or undefined> | <br>readSubscription(idHex: string): Promise<OnChainSubscription or undefined> validates idHex to an exact 32-byte buffer via ClarityCvAdapter.guardHex32, performs get-subscription, and delegates tuple decoding to ClarityCvAdapter.decodeOptionalSubscriptionTuple.<br><br>External delegate calls:<br>- this.cvAdapter.guardHex32(idHex)<br>- this.cvAdapter.decodeOptionalSubscriptionTuple(cv, idHex)<br><br>Implementation snippet:<br><br>```ts<br>async readSubscription(idHex: string): Promise<OnChainSubscription or undefined> {<br>  const idBuf = this.cvAdapter.guardHex32(idHex);<br>  const cv = await callReadOnlyFunction({<br>    contractAddress: this.contractAddress,<br>    contractName: this.contractName,<br>    functionName: 'get-subscription',<br>    functionArgs: [bufferCV(idBuf)],<br>    network: this.network,<br>  });<br>  return this.cvAdapter.decodeOptionalSubscriptionTuple(cv, idHex);<br>}<br>```<br><br>--- |  |
| StacksChainClient | callReadOnly(functionName: string, functionArgs: any[]): Promise<any> | Generic read-only invoker. Assembles {contractAddress, contractName, functionName, functionArgs, network}; validates CV encoding of args; executes via @stacks/transactions; decodes Clarity values to JS primitives. Callers are responsible for interpreting the result shape per function (e.g., 'get-invoice-status'). |  |
| ContractCallBuilder | buildCreateInvoice(args: { idHex: string; amountSats: number; memo?: string; expiresAtBlock?: number }): UnsignedContractCall | <br>buildCreateInvoice(args): UnsignedContractCall validates idHex, amount, optional expiresAt, encodes id and amount, delegates memo optional encoding to OptionalBuff34Encoder, then returns an unsigned create-invoice payload with no post-conditions.<br><br>External delegate calls:<br>- this.opt34.encodeOptionalUtf8ToBuff34(args.memo)<br><br>Implementation snippet:<br><br>```ts<br>buildCreateInvoice(args: { idHex: string; amountSats: number; memo?: string; expiresAtBlock?: number }): UnsignedContractCall {<br>  this.codec.assertHex64(args.idHex);<br>  this.assertPositiveInt(args.amountSats, 'amountSats');<br>  if (args.expiresAtBlock !== undefined) this.assertNonNegativeInt(args.expiresAtBlock, 'expiresAtBlock');<br>  const idBuf = this.codec.toBuff32Hex(args.idHex);<br>  const memoOpt = this.opt34.encodeOptionalUtf8ToBuff34(args.memo);<br>  const functionArgs = [<br>    bufferCV(idBuf),<br>    uintCV(args.amountSats),<br>    memoOpt,<br>    args.expiresAtBlock !== undefined ? someCV(uintCV(args.expiresAtBlock)) : noneCV(),<br>  ];<br>  return this.baseCall('create-invoice', functionArgs);<br>}<br>```<br><br> |  |
| ContractCallBuilder | buildRefundInvoice(args: { idHex: string; amountSats: number; memo?: string; merchantPrincipal: string }): UnsignedContractCall | <br>buildRefundInvoice(args): UnsignedContractCall validates inputs, encodes args, composes Deny post-conditions capping merchant outgoing sBTC to amountSats via PostConditionsComposer.forRefund, and returns the unsigned refund-invoice call.<br><br>External delegate calls:<br>- this.pcc.forRefund(args.merchantPrincipal, args.amountSats)<br>- this.opt34.encodeOptionalUtf8ToBuff34(args.memo)<br><br>Implementation snippet:<br><br>```ts<br>buildRefundInvoice(args: { idHex: string; amountSats: number; memo?: string; merchantPrincipal: string }): UnsignedContractCall {<br>  this.codec.assertHex64(args.idHex);<br>  this.assertPositiveInt(args.amountSats, 'amountSats');<br>  void standardPrincipalCV(args.merchantPrincipal);<br>  const idBuf = this.codec.toBuff32Hex(args.idHex);<br>  const memoOpt = this.opt34.encodeOptionalUtf8ToBuff34(args.memo);<br>  const pcs = this.pcc.forRefund(args.merchantPrincipal, args.amountSats);<br>  const functionArgs = [bufferCV(idBuf), uintCV(args.amountSats), memoOpt];<br>  return this.baseCall('refund-invoice', functionArgs, pcs);<br>}<br>```<br><br> |  |
| ContractCallBuilder | buildRegisterMerchant(args: { merchant: string; name?: string }): UnsignedContractCall | <br>buildRegisterMerchant(args): UnsignedContractCall validates merchant principal via CV build, delegates optional name encoding to OptionalBuff34Encoder, and returns unsigned register-merchant call.<br><br>External delegate calls:<br>- this.opt34.encodeOptionalUtf8ToBuff34(args.name)<br><br>Implementation snippet:<br><br>```ts<br>buildRegisterMerchant(args: { merchant: string; name?: string }): UnsignedContractCall {<br>  const merchantCv = standardPrincipalCV(args.merchant);<br>  const nameOpt = this.opt34.encodeOptionalUtf8ToBuff34(args.name);<br>  const functionArgs = [merchantCv, nameOpt];<br>  return this.baseCall('register-merchant', functionArgs);<br>}<br>```<br><br> |  |
| ContractCallBuilder | buildSetMerchantActive(args: { merchant: string; active: boolean }): UnsignedContractCall | Builds unsigned set-merchant-active payload. Validates merchant principal; args [standardPrincipalCV(merchant), boolCV(active)]. No post-conditions. |  |
| ContractCallBuilder | buildSetSbtcToken(args: { contractAddress: string; contractName: string }): UnsignedContractCall | Builds unsigned set-sbtc-token payload. Validates address/name; encodes [contractPrincipalCV(address, name)]. No post-conditions. |  |
| ContractCallBuilder | buildPaySubscription(args: { idHex: string; amountSats: number; subscriber: string; merchant: string }): UnsignedContractCall | <br>buildPaySubscription(args): UnsignedContractCall validates idHex and principals, delegates pay-mode post-conditions to PostConditionsComposer.forPay, encodes [bufferCV(id)], sets PostConditionMode.Deny, and returns the unsigned call.<br><br>External delegate calls:<br>- this.pcc.forPay(args.subscriber, args.merchant, args.amountSats)<br><br>Implementation snippet:<br><br>```ts<br>buildPaySubscription(args: { idHex: string; amountSats: number; subscriber: string; merchant: string }): UnsignedContractCall {<br>  this.codec.assertHex64(args.idHex);<br>  this.assertPositiveInt(args.amountSats, 'amountSats');<br>  void standardPrincipalCV(args.subscriber);<br>  void standardPrincipalCV(args.merchant);<br>  const idBuf = this.codec.toBuff32Hex(args.idHex);<br>  const pcs = this.pcc.forPay(args.subscriber, args.merchant, args.amountSats);<br>  const functionArgs = [bufferCV(idBuf)];<br>  return this.baseCall('pay-subscription', functionArgs, pcs);<br>}<br>```<br><br>--- |  |
| ContractCallBuilder | buildCreateSubscription(args: { idHex: string; merchant: string; subscriber: string; amountSats: number; intervalBlocks: number }): UnsignedContractCall | Builds unsigned create-subscription payload. Validates idHex, principals, amountSats>0, intervalBlocks>0. Encodes [bufferCV(id), principalCV(merchant), principalCV(subscriber), uintCV(amount), uintCV(interval)]. No post-conditions. |  |
| ContractCallBuilder | buildCancelSubscription(args: { idHex: string }): UnsignedContractCall | Builds unsigned cancel-subscription payload. Validates idHex; encodes [bufferCV(id)]. No post-conditions. Used by merchant/admin to deactivate on-chain subscription. |  |
| AssetInfoFactory | getSbtcAssetInfo(): { contractAddress: string; contractName: string; assetName: string } | Returns canonical sBTC asset info for post-conditions. Validates configuration presence (SBTC_CONTRACT_ADDRESS/NAME). Caches within process. Throws if missing to force callers to surface a 422 missingSbtcToken or operator action in Admin Console. | AssetInfoFactory.getSbtcAssetInfo HOW:<br>- Alignment: Provides canonical asset info for post-conditions; required by Problem Statement for transaction safety.<br>- Mechanics:<br>  1. Inputs: none. Reads env/config: `SBTC_CONTRACT_ADDRESS`, `SBTC_CONTRACT_NAME`, optional `SBTC_ASSET_NAME` (default: `token` or `sbtc` per implementation).<br>  2. On first call:<br>     - Validate non-empty address and name; basic address format check.<br>     - Compose and memoize `{ contractAddress, contractName, assetName }`.<br>  3. Return memoized object on subsequent calls.<br>  4. If missing config, throw a typed error to map to 422 missingSbtcToken in controllers.<br>- Pseudocode:<br>```ts<br>class AssetInfoFactory {<br>  private cached?: { contractAddress:string; contractName:string; assetName:string };<br>  constructor(private cfg: ConfigService) {}<br>  getSbtcAssetInfo() {<br>    if (this.cached) return this.cached;<br>    const ca = this.cfg.get('SBTC_CONTRACT_ADDRESS');<br>    const cn = this.cfg.get('SBTC_CONTRACT_NAME');<br>    const an = this.cfg.get('SBTC_ASSET_NAME') or 'sbtc';<br>    assertAddress(ca); if (!cn) throw new Error('missing contract name');<br>    this.cached = { contractAddress: ca, contractName: cn, assetName: an };<br>    return this.cached;<br>  }<br>}<br>```<br>- Gotchas:<br>  - Do not silently default contract identifiers; force operator to set via Admin Console if missing.<br>  - Post-condition asset info must match the token used by the contract’s `set-sbtc-token`.<br><br>--- |
| InvoiceIdCodec | generateRandomBuff32(): Buffer | Returns cryptographically secure 32-byte Buffer using Node crypto.randomBytes(32). Callers convert to 64-hex via hexFromBuff32 and persist to DB id_hex. Ensures ID is suitable for Clarity (buff 32). |  |
| InvoiceIdCodec | hexFromBuff32(buf32: Buffer): string | Validates input length === 32 bytes; returns lowercase 64-char hex string. Ensures round-trip: Buffer.from(result,'hex').length === 32. Used to persist id_hex and to build contract-call args from stored hex. Throws on invalid buffer length. |  |
| InvoiceIdCodec | assertHex64(idHex: string): void | Validates idHex matches /^[0-9A-Fa-f]{64}$/ and round-trips to a 32-byte Buffer. Throws on failure. Used prior to DB inserts/updates and before building any payloads to guarantee Clarity-compatible IDs. | InvoiceIdCodec.assertHex64 HOW:<br>- Alignment: Enforces exact 64-hex with 32-byte round-trip per Problem Statement. Required for DB immutability and Clarity `(buff 32)` compatibility.<br>- Mechanics:<br>  1. Input: `idHex: string`.<br>  2. Validate matches `/^[0-9A-Fa-f]{64}$/`.<br>  3. Decode `buf = Buffer.from(idHex, 'hex')`; assert `buf.length === 32`.<br>  4. Round-trip check: `buf.toString('hex').length === 64`.<br>  5. Throw descriptive error if any check fails.<br>- Pseudocode:<br>```ts<br>function assertHex64(idHex: string): void {<br>  if (typeof idHex !== 'string' or !/^[0-9A-Fa-f]{64}$/.test(idHex)) {<br>    throw new Error('idHex must be 64 hex chars');<br>  }<br>  const buf = Buffer.from(idHex, 'hex');<br>  if (buf.length !== 32) throw new Error('idHex must decode to 32 bytes');<br>  // Round-trip not strictly necessary if regex passes, but enforce anyway<br>  if (Buffer.from(buf).toString('hex').length !== 64) {<br>    throw new Error('idHex round-trip failed');<br>  }<br>}<br>```<br>- Gotchas:<br>  - Reject uppercase/lowercase mix is acceptable; normalize downstream as needed.<br>  - Perform this check before any DB insert/update or payload build.<br><br>End of report. |
| ConfigService | getAvgBlockSecs(): number | Returns configured average block seconds. Used to convert TTL seconds to expiresAtBlock: currentHeight + ceil(ttlSeconds / avgBlockSecs). Immutable per process. Controllers must not mutate returned value. |  |
| SqliteStore | invoices.insert(row: InvoiceRow): void | Inserts an invoice row. Validates: id_hex assert 64-hex and unique (ux_invoices_id_hex), amount_sats > 0, status='unpaid', merchant_principal non-empty, quote_expires_at present, created_at set. Enforces immutability of id_hex, amount_sats, merchant_principal by excluding them from future UPDATE statements. Throws on SQLITE_CONSTRAINT for controller to map (409). | Synchronous persistence of invoice rows with strict invariants and 64-hex id validation:<br>- Alignment<br>  - Fully aligned with Problem Statement: invoices must be created on-chain and backend persists 32-byte invoice ID as 64-hex; immutable fields enforced (DS-3-35).<br>- Mechanics (ordered)<br>  1. Validate `row.id_hex`:<br>     - Assert length is exactly 64 and matches hex class `[0-9A-Fa-f]*`.<br>     - Round-trip: `buf = Buffer.from(idHex, 'hex')`; assert `buf.length === 32`; assert `buf.toString('hex') === idHex.toLowerCase()`.<br>  2. Validate `row.amount_sats > 0` (integer).<br>  3. Validate `row.status === 'unpaid'` on insert.<br>  4. Validate `row.merchant_principal` is non-empty string.<br>  5. Validate timestamps: `row.quote_expires_at` and `row.created_at` present as epoch seconds (ints).<br>  6. Enforce uniqueness:<br>     - Either pre-check via `ensureInvoiceIdHexUnique(idHex)` OR rely on `ux_invoices_id_hex` unique index; map constraint to 409.<br>  7. Insert with prepared statement inside optional transaction:<br>     - Columns: `id_raw, id_hex, store_id, amount_sats, usd_at_create, quote_expires_at, merchant_principal, status, memo, webhook_url, created_at, subscription_id, refunded_at=NULL, refund_amount=0, refund_txid=NULL, refund_count=0, payer=NULL, txid=NULL, expired=0`.<br>  8. Do not return secrets or perform logging.<br>- Side-effects<br>  - Inserts one row; no updates to immutable columns ever in this method.<br>- Data structures/DB rows touched<br>  - Table `invoices`; unique index `ux_invoices_id_hex`; indices `idx_invoices_store`, `idx_invoices_status`.<br>- Performance<br>  - O(1); target ≤ 2 ms typical on SQLite with indices present.<br>- Pseudocode<br>  ```<br>  function insert(row: InvoiceRow): void {<br>    assert(typeof row.id_raw === 'string' && isUuid(row.id_raw));<br>    assert(typeof row.id_hex === 'string' && row.id_hex.length === 64 && /^[0-9A-Fa-f]+$/.test(row.id_hex));<br>    const buf = Buffer.from(row.id_hex, 'hex');<br>    assert(buf.length === 32 && buf.toString('hex') === row.id_hex.toLowerCase());<br>    assert(Number.isInteger(row.amount_sats) && row.amount_sats > 0);<br>    assert(row.status === 'unpaid');<br>    assert(typeof row.merchant_principal === 'string' && row.merchant_principal.length > 0);<br>    assert(Number.isInteger(row.quote_expires_at));<br>    assert(Number.isInteger(row.created_at));<br><br>    const stmt = db.prepare(`<br>      INSERT INTO invoices(<br>        id_raw,id_hex,store_id,amount_sats,usd_at_create,quote_expires_at,<br>        merchant_principal,status,memo,webhook_url,created_at,subscription_id,<br>        refunded_at,refund_amount,refund_txid,refund_count,payer,txid,expired<br>      ) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,NULL,0,NULL,0,NULL,NULL,0)<br>    `);<br>    try {<br>      stmt.run(<br>        row.id_raw, row.id_hex, row.store_id, row.amount_sats, row.usd_at_create, row.quote_expires_at,<br>        row.merchant_principal, 'unpaid', row.memo ?? null, row.webhook_url ?? null, row.created_at, row.subscription_id ?? null<br>      );<br>    } catch (e) {<br>      if (isSqliteConstraint(e)) throw new ConflictError('invoice id_hex or FK conflict');<br>      throw e;<br>    }<br>  }<br>  ```<br>- Gotchas/failure-modes<br>  - id_hex not 64-hex or not 32-byte round-trip → reject 400.<br>  - Unique constraint violation → map to 409.<br>  - Amount 0 or negative → reject.<br>  - Mutating immutable fields later: ensure future UPDATE statements never include `id_hex`, `amount_sats`, `merchant_principal`.<br>- Invariants<br>  - `id_hex`, `amount_sats`, `merchant_principal` immutable post-insert.<br>  - `status` initial is 'unpaid'.<br>- Edge cases<br>  - `memo` must respect Clarity limit (≤ 34 bytes) upstream; store verbatim if provided.<br>  - `webhook_url` may be null; default to merchant’s at usage time, not here.<br><br>--- |
| SqliteStore | invoices.findByStoreAndIdRaw(storeId: string, idRaw: string): InvoiceRow or undefined | Retrieves invoice by store scope and UUID. Validates inputs format; returns undefined if not found. Used for refund building and ownership checks. Caller must verify status allows operation and enforce id_hex round-trip. |  |
| SqliteStore | merchants.updateKeys(storeId: string, apiKey: string, hmacSecret: string): number | Updates merchant secrets atomically (single UPDATE). Validates key formats (hex length); returns rows affected for controller to ensure store exists. Never returns secrets outside rotate-keys response; do not log values. |  |
| SqliteStore | insertMerchant(row: MerchantRow): void | Inserts merchant with UNIQUE(principal) and UNIQUE(api_key). Validates principal format, required secrets, and created_at. Optional branding fields stored as provided. Throws on constraint violations for controller to map to 409. Secrets never returned by projection queries. |  |
| SqliteStore | listMerchantsProjection(): Array<Omit<MerchantRow, 'api_key' or 'hmac_secret'>> | <br>listMerchantsProjection(): Array<Omit<MerchantRow, 'api_key' or 'hmac_secret'>> returns the non-secret projection using MerchantProjectionPolicy for both SELECT and mapping.<br><br>External delegate calls:<br>- this.merchantProjection.getListProjectionSQL()<br>- this.merchantProjection.mapListRow(raw)<br><br>Implementation snippet:<br><br>```ts<br>listMerchantsProjection(): Omit<MerchantRow, 'api_key' or 'hmac_secret'>[] {<br>  const sql = this.merchantProjection.getListProjectionSQL();<br>  const dbRows = this.db.prepare(sql).all() as any[];<br>  return dbRows.map(r => this.merchantProjection.mapListRow(r));<br>}<br>```<br><br> |  |
| SqliteStore | updateMerchantKeysTx(storeId: string, apiKey: string, hmacSecret: string): void | Wraps secrets rotation in a DB transaction. Ensures atomicity; throws on failure for controller to handle. No selection of updated row; controller returns new keys once in response. |  |
| SqliteStore | getInvoiceById(idRaw: string): InvoiceRow or undefined | Fetches invoice by UUID without store scope (admin usage). Returns undefined if not found. Controller enforces status constraints (e.g., cannot cancel paid). |  |
| SqliteStore | updateInvoiceStatus(idRaw: string, status: InvoiceStatus, expired?: 0 or 1): void | Updates invoice status and optional expired flag. Validates status ∈ allowed set. Does not touch immutable columns. Used by admin cancel and expiry monitor. Callers must ensure business rules (e.g., not cancel paid). |  |
| SqliteStore | updateMerchantActive(storeId: string, active: boolean): number | Sets merchants.active; returns changes count. Admin controller validates inputs. Downstream logic gates API access and invoice creation based on this flag. |  |
| SqliteStore | selectAdminInvoices(statuses?: InvoiceStatus[], storeId?: string): InvoiceRow[] | Index-aware SELECT with conditional WHERE by status IN (...) and/or store_id. Validates query params. Returns raw rows (snake_case); controller maps to camelCase DTOs. |  |
| SqliteStore | getSubscriptionByIdForStore(id: string, storeId: string): SubscriptionRow or undefined | Retrieves subscription scoped to store. Returns fields for validations: active, mode, id_hex, subscriber, amount_sats, merchant_principal, interval_blocks, next_invoice_at. Used by mode change and invoice generation. |  |
| SqliteStore | getWebhookLogById(id: string): WebhookLogRow or undefined | Fetches webhook log by primary key. Used by admin retry. Controller checks idempotence before re-dispatching (existsSuccessfulDeliveryFor). No payload mutation here; payload stored as raw JSON string. |  |
| SqliteStore | existsSuccessfulDeliveryFor(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: 'paid'or'refunded'or'subscription'or'subscription-created'or'subscription-paid'or'subscription-canceled'or'invoice-expired' }): boolean | <br>existsSuccessfulDeliveryFor(ctx): boolean uses strict context predicate SQL from the composer to check for any success=1 row in same logical context.<br><br>External delegate calls:<br>- this.webhookRetryComposer.composeExistsSuccessfulDeliverySQL(ctx)<br><br>Implementation snippet:<br><br>```ts<br>existsSuccessfulDeliveryFor(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType or 'invoice-expired' }): boolean {<br>  const { sql, params } = this.webhookRetryComposer.composeExistsSuccessfulDeliverySQL({<br>    storeId: ctx.storeId,<br>    invoiceId: ctx.invoiceId,<br>    subscriptionId: ctx.subscriptionId,<br>    eventType: ctx.eventType as WebhookEventType,<br>  });<br>  const row = this.db.prepare(sql).get(...params) as { 1: number } or undefined;<br>  return !!row;<br>}<br>```<br><br> |  |
| SqliteStore | listAdminWebhooks(storeId?: string, failedOnly?: boolean): WebhookLogRow[] | Builds dynamic SELECT with optional WHERE store_id=? and success=0 when failedOnly=true. Orders by last_attempt_at DESC. Returns raw rows (snake_case); controller maps to camelCase. Validates UUID if storeId provided at controller layer; this method assumes pre-validated inputs. |  |
| SqliteStore | insertSubscription(row: SubscriptionRow): void | Inserts new subscription. Expects row.id and row.id_hex validated as UUID and 64-hex elsewhere. Enforces CHECKs and UNIQUE via schema. No mutation of row fields; stores mode, active, block heights as provided. Throws on constraint violations for controller to map to 409. |  |
| SqliteStore | ensureInvoiceIdHexUnique(idHex: string): boolean | Validates uniqueness of 64-hex invoice id against ux_invoices_id_hex via SELECT 1. Assumes idHex already validated for 64-hex and 32-byte round-trip. Returns true if not present; false if collision (caller regenerates). |  |
| SqliteStore | advanceSubscriptionSchedule(id: string, tx?: unknown): void | Updates subscriptions.next_invoice_at += interval_blocks and sets last_billed_at=now() for the given subscription id. Must run inside a transaction when paired with invoice insert to ensure atomicity. |  |
| SqliteStore | updateSubscriptionMode(id: string, storeId: string, mode: 'invoice'or'direct'): void | Updates mode field preserving other columns. Assumes controller validated mode list and tenant ownership via storeId. |  |
| SqliteStore | getActiveSubscription(id: string, storeId: string): SubscriptionRow | Returns active=1 subscription row scoped by storeId or undefined. No transformations. |  |
| SqliteStore | deactivateSubscription(id: string, storeId: string, tx?: unknown): void | Sets active=0 for subscription within optional transaction context. Assumes controller handles on-chain cancel and error mapping. |  |
| SqliteStore | listWebhooksForStore(storeId: string): WebhookLogRow[] | Returns webhook_logs rows scoped by store_id ordered by last_attempt_at DESC. No secrets involved. Controller maps to camelCase and may redact payload in UI. |  |
| SqliteStore | selectDueWebhookRetries(): WebhookLogRow[] | <br>selectDueWebhookRetries(): WebhookLogRow[] executes composer-provided SQL for deduped, backoff-respected selection.<br><br>External delegate calls:<br>- this.webhookRetryComposer.composeSelectDueRetriesSQL()<br><br>Implementation snippet:<br><br>```ts<br>selectDueWebhookRetries(): WebhookLogRow[] {<br>  const { sql } = this.webhookRetryComposer.composeSelectDueRetriesSQL();<br>  const rows = this.db.prepare(sql).all() as WebhookLogRow[];<br>  return rows;<br>}<br>```<br><br> |  |
| SqliteStore | getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[] | <br>getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[] executes parameterized SQL composed by the delegate for all due attempts.<br><br>External delegate calls:<br>- this.webhookRetryComposer.composeGetDueAttemptsSQL(nowEpochSecs)<br><br>Implementation snippet:<br><br>```ts<br>getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[] {<br>  const { sql, params } = this.webhookRetryComposer.composeGetDueAttemptsSQL(nowEpochSecs);<br>  const rows = this.db.prepare(sql).all(...params) as WebhookLogRow[];<br>  return rows;<br>}<br>```<br><br> |  |
| SqliteStore | invoiceExists(idHex: string): boolean | Checks existence of invoice by 64-hex id in invoices table. Assumes idHex pre-validated. Used by poller to drop unknown chain events. |  |
| SqliteStore | subscriptionExists(idHex: string): boolean | Checks existence of subscription by 64-hex id in subscriptions. Assumes idHex pre-validated. |  |
| SqliteStore | hasSuccessfulExpiredWebhook(storeId: string, invoiceId: string): boolean | <br>hasSuccessfulExpiredWebhook(storeId, invoiceId): boolean checks success=1 invoice-expired existence using delegate SQL.<br><br>External delegate calls:<br>- this.webhookRetryComposer.composeHasSuccessfulExpiredWebhookSQL(storeId, invoiceId)<br><br>Implementation snippet:<br><br>```ts<br>hasSuccessfulExpiredWebhook(storeId: string, invoiceId: string): boolean {<br>  const { sql, params } = this.webhookRetryComposer.composeHasSuccessfulExpiredWebhookSQL(storeId, invoiceId);<br>  const row = this.db.prepare(sql).get(...params) as { 1: number } or undefined;<br>  return !!row;<br>}<br>```<br><br> |  |
| SqliteStore | bulkMarkExpired(idRawList: string[]): number | <br>bulkMarkExpired(idRawList: string[]): number builds a safe IN-clause via SqlInListBuilder and executes the UPDATE, returning number of rows changed.<br><br>External delegate calls:<br>- this.inListBuilder.buildInClause('id_raw', idRawList)<br><br>Implementation snippet:<br><br>```ts<br>bulkMarkExpired(idRawList: string[]): number {<br>  if (!idRawList.length) return 0;<br>  const { clause, params } = this.inListBuilder.buildInClause('id_raw', idRawList);<br>  const stmt = this.db.prepare(`UPDATE invoices SET status = 'expired', expired = 1 WHERE ${ clause }`);<br>  const info = stmt.run(...params);<br>  return info.changes;<br>}<br>```<br><br>--- |  |
| SqliteStore | getPollerCursor(): { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string } | Loads persisted poller cursor or returns null if uninitialized. Controller handles defaulting. | Persisted poller cursor load with default-null when uninitialized:<br>- Alignment<br>  - Aligned with poller requirements: expose `lastRunAt`, `lastHeight`, `lastTxId`, `lastBlockHash` for admin/status and reorg handling.<br>- Minimal schema (create once during migration)<br>  ```<br>  CREATE TABLE IF NOT EXISTS poller_cursor (<br>    id INTEGER PRIMARY KEY CHECK (id = 1),<br>    last_run_at INTEGER NOT NULL,<br>    last_height INTEGER NOT NULL CHECK (last_height >= 0),<br>    last_txid TEXT,<br>    last_block_hash TEXT<br>  );<br>  ```<br>- Mechanics (ordered)<br>  1. Attempt to fetch row with `id=1`.<br>  2. If none, return `null`/`undefined` to indicate uninitialized cursor to caller.<br>  3. If present, coerce numeric fields to numbers, leave optional text fields as nullable.<br>- Performance<br>  - Single SELECT by PK; ≤ 1 ms.<br>- Pseudocode<br>  ```<br>  function getPollerCursor(): { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string } or null {<br>    const row = db.prepare('SELECT last_run_at, last_height, last_txid, last_block_hash FROM poller_cursor WHERE id=1').get() as<br>      or { last_run_at: number; last_height: number; last_txid: string or null; last_block_hash: string or null }<br>      or undefined;<br>    if (!row) return null;<br>    return {<br>      lastRunAt: Number(row.last_run_at),<br>      lastHeight: Number(row.last_height),<br>      lastTxId: row.last_txid ?? undefined,<br>      lastBlockHash: row.last_block_hash ?? undefined,<br>    };<br>  }<br>  ```<br>- Gotchas/failure-modes<br>  - SQLite returns numbers as JS numbers; ensure safe integer range (block heights fit).<br>  - Handle nullables correctly.<br>- Invariants<br>  - At most one row with `id=1`.<br><br>--- |
| SqliteStore | savePollerCursor(cursor: { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string }): void | Upserts cursor atomically. Validates numeric types and presence of lastHeight. Used at end of poller tick. | Atomic upsert of poller cursor with input validation:<br>- Alignment<br>  - Supports PaymentPoller.updateCursorState and Admin Poller Status endpoints; includes block-hash tracking for reorg detection.<br>- Mechanics (ordered)<br>  1. Validate inputs:<br>     - `Number.isInteger(cursor.lastRunAt)` and `cursor.lastRunAt > 0`.<br>     - `Number.isInteger(cursor.lastHeight)` and `cursor.lastHeight >= 0`.<br>     - `cursor.lastTxId` and `cursor.lastBlockHash` may be `undefined`/`null` or non-empty strings.<br>  2. Execute UPSERT in a transaction:<br>     - If row with `id=1` does not exist → INSERT.<br>     - Else → UPDATE fields.<br>- Performance<br>  - Single UPSERT; ≤ 2 ms.<br>- Pseudocode<br>  ```<br>  function savePollerCursor(cursor: { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string }): void {<br>    assert(Number.isInteger(cursor.lastRunAt) && cursor.lastRunAt > 0);<br>    assert(Number.isInteger(cursor.lastHeight) && cursor.lastHeight >= 0);<br>    const tx = db.transaction((c) => {<br>      db.prepare(`<br>        INSERT INTO poller_cursor (id, last_run_at, last_height, last_txid, last_block_hash)<br>        VALUES (1, ?, ?, ?, ?)<br>        ON CONFLICT(id) DO UPDATE SET<br>          last_run_at=excluded.last_run_at,<br>          last_height=excluded.last_height,<br>          last_txid=excluded.last_txid,<br>          last_block_hash=excluded.last_block_hash<br>      `).run(c.lastRunAt, c.lastHeight, c.lastTxId ?? null, c.lastBlockHash ?? null);<br>    });<br>    tx(cursor);<br>  }<br>  ```<br>- Gotchas/failure-modes<br>  - SQLite version must support UPSERT (≥ 3.24). If not, fallback to SELECT then INSERT/UPDATE in the transaction.<br>- Invariants<br>  - `id=1` row is the only persisted cursor.<br>  - No secret data stored.<br><br>--- |
| SqliteStore | selectDueSubscriptions(currentHeight: number): SubscriptionRow[] | Returns subscriptions where active=1 AND mode='invoice' AND next_invoice_at <= currentHeight ordered by next_invoice_at ASC. Used by scheduler; no mapping. |  |
| PublicApiController | getInvoice(req: Request, res: Response): Promise<void> | <br>The method getInvoice(req, res): Promise<void> loads the invoice row joined with store, validates id_hex via InvoiceIdGuard, reads on-chain status via InvoiceStatusResolver.readOnchainStatus, computes display status via InvoiceStatusResolver.computeDisplayStatus using TTL vs on-chain precedence, projects store public profile via StorePublicProfileProjector, then returns PublicInvoiceDTO (camelCase). All status and id validation logic is offloaded; controller remains orchestration and DTO assembly only.<br><br>External delegate calls:<br>- this.idGuard.validateHexIdOrThrow(row.id_hex)<br>- this.statusResolver.readOnchainStatus(row.id_hex)<br>- this.statusResolver.computeDisplayStatus({ id_hex, status, quote_expires_at }, onchain, Date.now())<br>- this.profileProjector.project(row.store)<br><br>Implementation snippet:<br><br>```ts<br>async getInvoice(req: Request, res: Response): Promise<void> {<br>  const idRaw = req.params.invoiceId;<br>  const row = this.store.getInvoiceWithStore(idRaw);<br>  this.idGuard.validateHexIdOrThrow(row.id_hex);<br>  const onchain = await this.statusResolver.readOnchainStatus(row.id_hex);<br>  const status = this.statusResolver.computeDisplayStatus(<br>    { id_hex: row.id_hex, status: row.status, quote_expires_at: row.quote_expires_at },<br>    onchain,<br>    Date.now()<br>  );<br>  const storeProfile = this.profileProjector.project(row.store);<br>  const dto: PublicInvoiceDTO = {<br>    invoiceId: row.id_raw,<br>    idHex: row.id_hex,<br>    storeId: row.store_id,<br>    amountSats: row.amount_sats,<br>    usdAtCreate: row.usd_at_create,<br>    quoteExpiresAt: row.quote_expires_at,<br>    merchantPrincipal: row.merchant_principal,<br>    status,<br>    payer: row.payer ?? undefined,<br>    txId: row.txid ?? undefined,<br>    memo: row.memo ?? undefined,<br>    subscriptionId: row.subscription_id ?? undefined,<br>    createdAt: row.created_at,<br>    refundAmount: row.refund_amount ? row.refund_amount : undefined,<br>    refundTxId: row.refund_txid ?? undefined,<br>    store: storeProfile,<br>  };<br>  res.json(dto);<br>}<br>```<br><br> |  |
| PublicApiController | getStorePublicProfile(req: Request, res: Response): Promise<void> | <br>The method getStorePublicProfile(req, res): Promise<void> loads the target store projection row and fully delegates DTO shaping to StorePublicProfileProjector.project. After refactor, the controller does not perform manual field mapping.<br><br>External delegate calls:<br>- this.profileProjector.project(row)<br><br>Implementation snippet:<br><br>```ts<br>async getStorePublicProfile(req: Request, res: Response): Promise<void> {<br>  const storeId = req.params.storeId;<br>  const rows = this.store.listMerchantsProjection();<br>  const m = rows.find((r) => r.id === storeId);<br>  const profile = this.profileProjector.project(m);<br>  res.json(profile);<br>}<br>```<br><br> |  |
| PublicApiController | createTx(req: Request, res: Response): Promise<void> | <br>The method createTx(req, res): Promise<void> loads the invoice row by invoiceId and delegates all gating/validation + unsigned payload build to PayInvoiceTxAssembler.buildUnsignedPayInvoice. It maps domain HttpError codes to API error bodies. The controller does not reimplement any validation logic: id_hex, TTL, on-chain checks, or sBTC token config are enforced by the assembler.<br><br>External delegate calls:<br>- this.txAssembler.buildUnsignedPayInvoice(row, payerPrincipal)<br><br>Implementation snippet:<br><br>```ts<br>async createTx(req: Request, res: Response): Promise<void> {<br>  const { invoiceId, payerPrincipal } = req.body or {};<br>  const row = this.store.getInvoiceWithStore(String(invoiceId));<br>  try {<br>    const payload = await this.txAssembler.buildUnsignedPayInvoice(row, payerPrincipal);<br>    res.json(payload);<br>  } catch (e: any) {<br>    if (e instanceof HttpError) {<br>      if (e.code === 'merchant-inactive') {<br>        res.status(e.status).json(PublicErrors.invalidState);<br>      } else if (e.code === 'expired') {<br>        res.status(e.status).json(PublicErrors.expired);<br>      } else if (e.code === 'missing-token') {<br>        res.status(e.status).json(PublicErrors.missingSbtcToken);<br>      } else if (e.code === 'invalid-id') {<br>        res.status(e.status).json(PublicErrors.invalidId);<br>      } else {<br>        res.status(HttpStatusMap.conflict).json(PublicErrors.invalidState);<br>      }<br>      return;<br>    }<br>    res.status(HttpStatusMap.conflict).json(PublicErrors.invalidState);<br>  }<br>}<br>```<br><br>--- |  |
| MerchantApiController | getInvoice(req: Request, res: Response): Promise<void> | <br>getInvoice(req, res): Promise<void> loads a store-scoped invoice row and delegates DTO mapping to ApiCaseAndDtoMapper.invoiceToPublicDto. No inline mapping remains.<br><br>External delegate calls:<br>- this.dtoMapper.invoiceToPublicDto(row)<br><br>Implementation snippet:<br><br>```ts<br>async getInvoice(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const idRaw = String(req.params.invoiceId);<br>  const row = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, idRaw);<br>  const dto = this.dtoMapper.invoiceToPublicDto(row);<br>  res.json(dto);<br>}<br>```<br><br> |  |
| MerchantApiController | listInvoices(req: Request, res: Response): Promise<void> | <br>listInvoices(req, res): Promise<void> enforces allowed status validation, queries rows, and maps each via ApiCaseAndDtoMapper.invoiceToPublicDto.<br><br>External delegate calls:<br>- this.dtoMapper.invoiceToPublicDto(r)<br><br>Implementation snippet:<br><br>```ts<br>async listInvoices(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const statusQ = req.query.status ? String(req.query.status) : undefined;<br>  const allowed: InvoiceStatus[] = ['unpaid','paid','partially_refunded','refunded','canceled','expired'];<br>  if (statusQ && !allowed.includes(statusQ as InvoiceStatus)) {<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.bad_status);<br>    return;<br>  }<br>  const rows = this.store.listInvoicesByStore(sreq.store.id, { status: statusQ as InvoiceStatus or undefined, orderByCreatedDesc: true });<br>  res.json(rows.map(r => this.dtoMapper.invoiceToPublicDto(r)));<br>}<br>```<br><br> |  |
| MerchantApiController | cancelInvoice(req: Request, res: Response): Promise<void> | Auth and tenant enforced. Loads invoice; ensures status==='unpaid' and not expired/canceled. Optionally builds unsigned cancel-invoice payload; if broadcast configured and succeeds, updates DB status='canceled' in a transaction. Returns either {canceled:true} or {unsignedPayload}. Handles 409 when not cancellable. |  |
| MerchantApiController | getStoreProfile(req: Request, res: Response): Promise<void> | <br>getStoreProfile(req, res): Promise<void> uses ApiCaseAndDtoMapper.storeToPrivateProfile to return the store private profile DTO.<br><br>External delegate calls:<br>- this.dtoMapper.storeToPrivateProfile(sreq.store)<br><br>Implementation snippet:<br><br>```ts<br>async getStoreProfile(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const dto = this.dtoMapper.storeToPrivateProfile(sreq.store);<br>  res.json(dto);<br>}<br>```<br><br> |  |
| MerchantApiController | updateStoreProfile(req: Request, res: Response): Promise<void> | Auth and tenant enforced. Whitelists snake_case fields; validates brand_color with hex regex; updates only provided keys. Reads back profile and returns camelCase DTO. No secrets logged or returned. |  |
| MerchantApiController | createInvoice(req: import('express').Request, res: import('express').Response): Promise<void> | Purpose: Handle POST /api/v1/stores/:storeId/invoices. Responsibilities: authenticate via StoreApiAuth and CrossTenantMask (upstream); parse JSON body (snake_case) and validate amount_sats>0, ttl_seconds>0, memo ≤34 bytes UTF-8, optional webhook_url valid URL; transform to internal camelCase DTO { amountSats, ttlSeconds, memo?, webhookUrl? }; call InvoiceService.createInvoice(req.store, dto); map service response to camelCase PublicInvoiceDTO plus { magicLink, unsignedTx? }; ensure idHex is 64-hex and round-trips to 32-byte buffer; avoid leaking secrets; return 400 for validation errors, 409 for constraint/duplicate, 422 when merchant inactive or missing sBTC token gating; respond JSON. |  |
| MerchantApiController | validateCreateInvoiceBody(body: any): { amountSats: number; ttlSeconds: number; memo?: string; webhookUrl?: string } | <br>validateCreateInvoiceBody(body): returns { amountSats, ttlSeconds, memo?, webhookUrl? } using MerchantInputValidator with all invariants enforced.<br><br>External delegate calls:<br>- this.inputValidator.validateCreateInvoiceBody(body)<br><br>Implementation snippet:<br><br>```ts<br>validateCreateInvoiceBody(body: any): { amountSats: number; ttlSeconds: number; memo?: string; webhookUrl?: string } {<br>  return this.inputValidator.validateCreateInvoiceBody(body);<br>}<br>```<br><br> |  |
| MerchantApiController | buildRefund(req: Request, res: Response): Promise<void> | <br>buildRefund(req, res): Promise<void> validates body via MerchantInputValidator, loads invoice row, then fully delegates policy enforcement and payload building to RefundPolicyGuard.enforceAndBuild. HTTP error mapping is performed based on error codes thrown by the delegate.<br><br>External delegate calls:<br>- this.inputValidator.validateRefundBody(req.body)<br>- this.refundPolicy.enforceAndBuild(sreq.store, invRow, amountSats, memo)<br><br>Implementation snippet:<br><br>```ts<br>async buildRefund(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const { invoiceId, amountSats, memo } = this.inputValidator.validateRefundBody(req.body);<br>  const invRow = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, invoiceId);<br>  try {<br>    const payload = await this.refundPolicy.enforceAndBuild(sreq.store, invRow, amountSats, memo);<br>    res.json(payload);<br>  } catch (err: any) {<br>    const code = err?.code as string;<br>    if (code === 'bad_status' or code === 'cap_violation') {<br>      res.status(HttpStatusMap.conflict).json(MerchantAdminErrors.bad_status);<br>      return;<br>    }<br>    if (code === 'insufficient_balance') {<br>      res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.insufficient_balance);<br>      return;<br>    }<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>  }<br>}<br>```<br><br> |  |
| MerchantApiController | validateRefundBody(body: any): { invoiceId: string; amountSats: number; memo?: string } | <br>validateRefundBody(body): returns { invoiceId, amountSats, memo? } using MerchantInputValidator.<br><br>External delegate calls:<br>- this.inputValidator.validateRefundBody(body)<br><br>Implementation snippet:<br><br>```ts<br>validateRefundBody(body: any): { invoiceId: string; amountSats: number; memo?: string } {<br>  return this.inputValidator.validateRefundBody(body);<br>}<br>```<br><br> |  |
| MerchantApiController | rotateKeys(req: Request, res: Response): Promise<void> | Auth and tenant enforced. Generates new apiKey and hmacSecret via generateSecrets(). Persists both atomically. Returns once-only { apiKey, hmacSecret }. Avoids logging secrets. |  |
| MerchantApiController | generateSecrets(): { apiKey: string; hmacSecret: string } | Uses crypto.randomBytes(32).toString('hex') for API key and HMAC secret. No IO. Caller persists and returns once. |  |
| MerchantApiController | buildDirectSubscriptionPaymentTx(req: Request, res: Response): Promise<void> | <br>buildDirectSubscriptionPaymentTx(req, res): Promise<void> loads subscription and calls DirectSubscriptionPaymentTxBuilder.assemble to enforce direct-mode constraints and build unsigned pay-subscription payload. Maps delegate error codes to HTTP statuses.<br><br>External delegate calls:<br>- this.directSubPayBuilder.assemble(sub, payerPrincipal, sreq.store.principal)<br><br>Implementation snippet:<br><br>```ts<br>async buildDirectSubscriptionPaymentTx(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const id = String(req.params.id);<br>  const sub = this.store.getSubscriptionByIdForStore(id, sreq.store.id);<br>  const payerPrincipal = String(req.body?.payerPrincipal or '');<br>  try {<br>    const payload = await this.directSubPayBuilder.assemble(sub, payerPrincipal, sreq.store.principal);<br>    res.json(payload);<br>  } catch (err: any) {<br>    const code = err?.code as string;<br>    if (code === 'bad_status' or code === 'invalid_payer' or code === 'too_early') {<br>      res.status(HttpStatusMap.conflict).json(MerchantAdminErrors.bad_status);<br>      return;<br>    }<br>    if (code === 'missing_token') {<br>      res.status(HttpStatusMap.unprocessable).json(PublicErrors.missingSbtcToken);<br>      return;<br>    }<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>  }<br>}<br>```<br><br>--- |  |
| MerchantApiController | createSubscription(req: Request, res: Response): Promise<void> | <br>createSubscription(req, res): Promise<void> replaces inline assertions with MerchantInputValidator asserts, then delegates to a subscription service (unchanged). Response schema unchanged.<br><br>External delegate calls:<br>- this.inputValidator.assertStacksPrincipal(subscriber)<br>- this.inputValidator.assertPositiveInt(amountSats, 'amount_sats')<br>- this.inputValidator.assertPositiveInt(intervalBlocks, 'interval_blocks')<br><br>Implementation snippet:<br><br>```ts<br>async createSubscription(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const body = req.body or {};<br>  const subscriber: string = String(body.subscriber);<br>  const amountSats = Number(body.amount_sats);<br>  const intervalBlocks = Number(body.interval_blocks);<br>  const mode: 'invoice' or 'direct' or undefined = body.mode ? String(body.mode) as any : undefined;<br><br>  this.inputValidator.assertStacksPrincipal(subscriber);<br>  this.inputValidator.assertPositiveInt(amountSats, 'amount_sats');<br>  this.inputValidator.assertPositiveInt(intervalBlocks, 'interval_blocks');<br>  if (mode && !['invoice', 'direct'].includes(mode)) {<br>    res.status(HttpStatusMap.invalidPayload).json(MerchantAdminErrors.validation_error);<br>    return;<br>  }<br><br>  const { row, unsignedCall } = await this.subs.createSubscription(<br>    { id: sreq.store.id, principal: sreq.store.principal },<br>    { subscriber, amountSats, intervalBlocks, mode }<br>  );<br><br>  res.json({<br>    id: row.id,<br>    idHex: row.id_hex,<br>    storeId: row.store_id,<br>    merchantPrincipal: row.merchant_principal,<br>    subscriber: row.subscriber,<br>    amountSats: row.amount_sats,<br>    intervalBlocks: row.interval_blocks,<br>    active: row.active === 1,<br>    createdAt: row.created_at,<br>    lastBilledAt: row.last_billed_at,<br>    nextInvoiceAt: row.next_invoice_at,<br>    lastPaidInvoiceId: row.last_paid_invoice_id,<br>    mode: row.mode,<br>    unsignedCall,<br>  });<br>}<br>```<br><br> |  |
| MerchantApiController | genSubscriptionInvoice(req: Request, res: Response): Promise<void> | Auth and tenant enforced; rate-limited. Loads subscription; asserts active=1 and mode='invoice'. Generates random 32-byte id for invoice; validates 64-hex and uniqueness via ensureInvoiceIdHexUnique. Takes USD snapshot and current height; computes ttlSeconds (body or default), quote_expires_at (now+ttl), expiresAtBlock. Builds unsigned create-invoice; within a transaction inserts invoice linked to subscription and advances schedule. Returns camelCase DTO and magicLink (and optional unsignedTx). |  |
| MerchantApiController | setSubscriptionMode(req: Request, res: Response): Promise<void> | Auth and tenant enforced. Loads subscription. Validates body.mode ∈ {'invoice','direct'}. Updates mode. If switching to 'direct', reads on-chain subscription; when absent, builds unsigned create-subscription call and includes unsignedTx. Returns { id, mode, unsignedTx? }. |  |
| MerchantApiController | cancelSubscription(req: Request, res: Response): Promise<void> | Auth and tenant enforced. Loads active subscription; inside a transaction sets active=0. Builds unsigned cancel-subscription call; if broadcast configured and succeeds, commits; otherwise returns unsignedTx. Responds { canceled:true } or payload. |  |
| MerchantApiController | listWebhooks(req: Request, res: Response): Promise<void> | <br>listWebhooks(req, res): Promise<void> queries logs and maps via ApiCaseAndDtoMapper.webhookToDto.<br><br>External delegate calls:<br>- this.dtoMapper.webhookToDto(w)<br><br>Implementation snippet:<br><br>```ts<br>async listWebhooks(req: Request, res: Response): Promise<void> {<br>  const sreq = req as AuthedRequest;<br>  const rows = this.store.listWebhooksForStore(sreq.store.id);<br>  res.json(rows.map(w => this.dtoMapper.webhookToDto(w)));<br>}<br>```<br><br> |  |
| AdminApiController | createStore(req: Request, res: Response): Promise<void> | <br>createStore(req, res): Promise<void> asserts principal via AdminParamGuard.assertStacksPrincipal and delegates creation to MerchantCreationService.create, which returns either { status:'created'; dto } or { status:'conflict' }.<br><br>External delegate calls:<br>- this.paramGuard.assertStacksPrincipal(principal)<br>- this.merchantCreation.create(this.store, { ...req.body, principal })<br><br>Implementation snippet:<br><br>```ts<br>async createStore(req: Request, res: Response): Promise<void> {<br>  const principal = String((req.body or {}).principal ?? '');<br>  this.paramGuard.assertStacksPrincipal(principal);<br>  const result = await this.merchantCreation.create(this.store, { ...req.body, principal });<br>  if (result.status === 'conflict') { res.status(409).end(); return; }<br>  res.status(201).json(result.dto);<br>}<br>```<br><br> |  |
| AdminApiController | listStores(req: import('express').Request, res: import('express').Response): Promise<void> | <br>listStores(req, res): Promise<void> calls SqliteStore.listMerchantsProjection and maps via AdminDtoProjector.merchantToDto. No secrets are ever returned.<br><br>External delegate calls:<br>- this.projector.merchantToDto(r)<br><br>Implementation snippet:<br><br>```ts<br>async listStores(_req: Request, res: Response): Promise<void> {<br>  const rows = this.store.listMerchantsProjection();<br>  res.json(rows.map(r => this.projector.merchantToDto(r)));<br>}<br>```<br><br> |  |
| AdminApiController | rotateKeys(req: import('express').Request, res: import('express').Response): Promise<void> | <br>rotateKeys(req, res): Promise<void> validates UUID via AdminParamGuard and delegates to MerchantKeyRotationService.rotate to perform atomic rotation and return one-time secrets or not-found.<br><br>External delegate calls:<br>- this.paramGuard.assertUuid(storeId)<br>- this.keyRotation.rotate(this.store, storeId)<br><br>Implementation snippet:<br><br>```ts<br>async rotateKeys(req: Request, res: Response): Promise<void> {<br>  const storeId = String(req.params.storeId);<br>  this.paramGuard.assertUuid(storeId);<br>  const result = this.keyRotation.rotate(this.store, storeId);<br>  if (!result.ok) { res.status(404).end(); return; }<br>  res.json({ apiKey: result.apiKey, hmacSecret: result.hmacSecret });<br>}<br>```<br><br> |  |
| AdminApiController | syncOnchain(req: import('express').Request, res: import('express').Response): Promise<void> | <br>syncOnchain(req, res): Promise<void> validates storeId via AdminParamGuard and delegates unsigned calls planning to MerchantOnchainSyncPlanner.planForStore. Returns { calls } or 404.<br><br>External delegate calls:<br>- this.paramGuard.assertUuid(storeId)<br>- this.syncPlanner.planForStore(this.store, this.chain, this.builder, storeId)<br><br>Implementation snippet:<br><br>```ts<br>async syncOnchain(req: Request, res: Response): Promise<void> {<br>  const storeId = String(req.params.storeId);<br>  this.paramGuard.assertUuid(storeId);<br>  const result = await this.syncPlanner.planForStore(this.store, this.chain, this.builder, storeId);<br>  if ('notFound' in result) { res.status(404).end(); return; }<br>  res.json({ calls: result.calls });<br>}<br>```<br><br> |  |
| AdminApiController | setSbtcToken(req: import('express').Request, res: import('express').Response): Promise<void> | <br>setSbtcToken(req, res): Promise<void> centralizes contract pair validation via AdminParamGuard (additional usage) and returns unsigned call via builder; unchanged otherwise.<br><br>External delegate calls:<br>- this.paramGuard.assertStacksPrincipal(contractAddress)<br><br>Implementation snippet:<br><br>```ts<br>async setSbtcToken(req: Request, res: Response): Promise<void> {<br>  const body = req.body or {};<br>  const contractAddress = String(body.contractAddress ?? '');<br>  const contractName = String(body.contractName ?? '');<br>  this.paramGuard.assertStacksPrincipal(contractAddress);<br>  if (!contractName) { res.status(400).end(); return; }<br>  const call = this.builder.buildSetSbtcToken({ contractAddress, contractName });<br>  res.json({ call });<br>}<br>```<br><br> |  |
| AdminApiController | cancelInvoice(req: import('express').Request, res: import('express').Response): Promise<void> | <br>cancelInvoice(req, res): Promise<void> validates invoiceId via AdminParamGuard.assertUuid, updates invoice status via DAO, returns JSON outcome. On already paid, returns 400; optional on-chain cancel is separate.<br><br>External delegate calls:<br>- this.paramGuard.assertUuid(invoiceId)<br><br>Implementation snippet:<br><br>```ts<br>async cancelInvoice(req: Request, res: Response): Promise<void> {<br>  const invoiceId = String(req.params.invoiceId);<br>  this.paramGuard.assertUuid(invoiceId);<br>  const row = this.store.getInvoiceById(invoiceId);<br>  if (!row) { res.status(404).end(); return; }<br>  if (row.status === 'paid') { res.status(400).json({ error: 'already paid' }); return; }<br>  this.store.updateInvoiceStatus(invoiceId, { status: 'canceled', expired: 0 });<br>  res.json({ canceled: true, invoiceId });<br>}<br>```<br><br> |  |
| AdminApiController | activateStore(req: import('express').Request, res: import('express').Response): Promise<void> | <br>activateStore(req, res): Promise<void> validates storeId via AdminParamGuard.assertUuid, parses body.active, updates merchants.active, returns updated projection row.<br><br>External delegate calls:<br>- this.paramGuard.assertUuid(storeId)<br><br>Implementation snippet:<br><br>```ts<br>async activateStore(req: Request, res: Response): Promise<void> {<br>  const storeId = String(req.params.storeId);<br>  this.paramGuard.assertUuid(storeId);<br>  const active = !!req.body?.active;<br>  this.store.updateMerchantActive(storeId, active ? 1 : 0);<br>  const rows = this.store.listMerchantsProjection();<br>  const m = rows.find(r => r.id === storeId);<br>  res.json(m);<br>}<br>```<br><br>--- |  |
| AdminApiController | listAdminInvoices(req: import('express').Request, res: import('express').Response): Promise<void> | <br>listAdminInvoices(req, res): Promise<void> uses AdminParamGuard.parseInvoiceStatuses and optional AdminParamGuard.assertUuid for storeId, queries DAO, and maps via AdminDtoProjector.invoiceToDto.<br><br>External delegate calls:<br>- this.paramGuard.parseInvoiceStatuses(req.query.status as any)<br>- this.paramGuard.assertUuid(storeId)<br>- this.projector.invoiceToDto(r)<br><br>Implementation snippet:<br><br>```ts<br>async listAdminInvoices(req: Request, res: Response): Promise<void> {<br>  const statuses = this.paramGuard.parseInvoiceStatuses(req.query.status as any);<br>  const storeId = req.query.storeId ? String(req.query.storeId) : undefined;<br>  if (storeId) this.paramGuard.assertUuid(storeId);<br>  const rows = this.store.selectAdminInvoices(statuses.length ? (statuses as any) : undefined, storeId);<br>  res.json(rows.map(r => this.projector.invoiceToDto(r)));<br>}<br>```<br><br> |  |
| AdminApiController | retryWebhook(req: import('express').Request, res: import('express').Response): Promise<void> | <br>retryWebhook(req, res): Promise<void> validates webhookLogId via AdminParamGuard, delegates to WebhookAdminRetryService.retry, and maps outcomes to (404 or 200 already delivered or 202 enqueued).<br><br>External delegate calls:<br>- this.paramGuard.assertUuid(webhookLogId)<br>- this.webhookRetry.retry(this.store, this.dispatcher, webhookLogId)<br><br>Implementation snippet:<br><br>```ts<br>async retryWebhook(req: Request, res: Response): Promise<void> {<br>  const body = req.body or {};<br>  const webhookLogId = String(body.webhookLogId ?? '');<br>  this.paramGuard.assertUuid(webhookLogId);<br>  const outcome = await this.webhookRetry.retry(this.store, this.dispatcher, webhookLogId);<br>  if (outcome.type === 'not-found') { res.status(404).end(); return; }<br>  if (outcome.type === 'already-delivered') { res.status(200).json({ alreadyDelivered: true }); return; }<br>  res.status(202).json({ enqueued: outcome.enqueued });<br>}<br>```<br><br> |  |
| AdminApiController | getPoller(req: import('express').Request, res: import('express').Response): Promise<void> | Purpose: Handle GET /api/admin/poller. Responsibilities: requires AdminAuth; call PollerAdminBridge.getState() and return exactly { running, lastRunAt, lastHeight, lastTxId, lastBlockHash, lagBlocks }; no DB access; 200 JSON. |  |
| AdminApiController | restartPoller(req: import('express').Request, res: import('express').Response): Promise<void> | Purpose: Handle POST /api/admin/poller/restart. Responsibilities: requires AdminAuth; call PollerAdminBridge.restart(); return { running }; preserve cursor; ensure idempotent restart semantics; 200 JSON; guard against concurrent restarts. |  |
| AdminApiController | listWebhooks(req: import('express').Request, res: import('express').Response): Promise<void> | <br>listWebhooks(req, res): Promise<void> validates storeId via AdminParamGuard, determines failedOnly, fetches rows, and maps via AdminDtoProjector.webhookToDto.<br><br>External delegate calls:<br>- this.paramGuard.assertUuid(storeId)<br>- this.projector.webhookToDto(w)<br><br>Implementation snippet:<br><br>```ts<br>async listWebhooks(req: Request, res: Response): Promise<void> {<br>  const q = req.query or {};<br>  const storeId = q.storeId ? String(q.storeId) : undefined;<br>  if (storeId) this.paramGuard.assertUuid(storeId);<br>  const failedOnly = String(q.status ?? 'all') === 'failed';<br>  const rows = this.store.listAdminWebhooks(storeId, failedOnly);<br>  res.json(rows.map(w => this.projector.webhookToDto(w)));<br>}<br>```<br><br> |  |
| StoreApiAuth | verifyApiKey(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | Purpose: Middleware for /api/v1/stores/:storeId/* auth. Responsibilities: read X-API-Key; if missing or invalid, res.status(401).end(); query SqliteStore.findActiveByApiKey(apiKey); if found, attach req.store (merchant row) and call next(); otherwise 401; do not leak tenancy or secrets; no writes. |  |
| CrossTenantMask | enforce(req: import('express').Request & { store?: MerchantRow }, res: import('express').Response, next: import('express').NextFunction): void | Purpose: Middleware to enforce tenant isolation. Responsibilities: compare req.params.storeId to req.store.id; on mismatch, return 404 .end() to mask tenancy; on match, next(); stateless; no logs of mismatches. |  |
| CorsPolicy | publicCorsOriginValidator(origin: string or undefined, cb: (err: Error or null, allow?: boolean) => void, req: import('express').Request): void | Purpose: Dynamic CORS origin gate for public routes. Responsibilities: determine context by req.path: for /i/:invoiceId and OPTIONS, resolve store via SqliteStore.getAllowedOriginsByInvoiceId(req.params.invoiceId); for /create-tx, use req.query.invoiceId; for /api/v1/stores/:storeId/public-profile, use merchants.allowed_origins by storeId; parse CSV allowlist; compare supplied Origin; on allow, cb(null, true) and ensure server cors config includes Access-Control-Allow-Headers: Content-Type, X-API-Key, X-Webhook-Timestamp, X-Webhook-Signature and proper methods; on deny or unresolved, cb(new Error('Not allowed'), false) so ACAO is omitted; no state changes. | CorsPolicy.publicCorsOriginValidator:<br>- Alignment: Fully aligned with DS-2-CORS-1/2/3 and DS-2-CORS-ORIGIN-1. Enforces dynamic allowlists per route, sets allow/deny without side-effects.<br>- Mechanics:<br>  1. Read `origin` (may be undefined for non-browser clients). If undefined, call `cb(new Error('Not allowed'), false)` to omit ACAO.<br>  2. Inspect `req.path` and params to determine lookup mode:<br>     - If matches `/^\/i\/[^/]+$/` use `req.params.invoiceId` → `SqliteStore.getAllowedOriginsByInvoiceId(invoiceId)`.<br>     - If path is `/create-tx`, use `req.query.invoiceId` (if present) → `SqliteStore.getAllowedOriginsByInvoiceId(invoiceId)`.<br>     - If matches `/^\/api\/v1\/stores\/[^/]+\/public-profile$/`, use `req.params.storeId` → `SqliteStore.getAllowedOriginsByStoreId(storeId)`.<br>  3. If the invoice/store cannot be resolved, or DB returns null, call `cb(new Error('Not allowed'), false)`.<br>  4. Parse CSV/text allowlist from DB (`merchants.allowed_origins`): split by `,`, trim, normalize to lowercase, ignore blanks.<br>  5. Normalize request `origin` to lowercase; compare exact match against allowlist entries (support scheme+host; optional wildcard support is out-of-scope).<br>  6. If match → `cb(null, true)`; else → `cb(new Error('Not allowed'), false)`.<br>- Order of operations:<br>  - Determine context → resolve allowlist → parse → compare → callback.<br>- Data touched: SQLite read of `merchants.allowed_origins` via invoice join or direct merchant row.<br>- Performance: O(n) in number of allowed origins (typically small). ≤ 1 DB read per invocation.<br>- Pseudocode:<br>  ```<br>  function publicCorsOriginValidator(origin, cb, req) {<br>    if (!origin) return cb(new Error('Not allowed'), false);<br>    let allowedCsv = null;<br>    if (req.path.startsWith('/i/')) {<br>      allowedCsv = store.getAllowedOriginsByInvoiceId(req.params.invoiceId);<br>    } else if (req.path === '/create-tx') {<br>      const id = req.query.invoiceId;<br>      if (!id) return cb(new Error('Not allowed'), false);<br>      allowedCsv = store.getAllowedOriginsByInvoiceId(id);<br>    } else if (req.path.endsWith('/public-profile')) {<br>      allowedCsv = store.getAllowedOriginsByStoreId(req.params.storeId);<br>    } else {<br>      return cb(new Error('Not allowed'), false);<br>    }<br>    if (!allowedCsv) return cb(new Error('Not allowed'), false);<br>    const list = allowedCsv.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);<br>    const ok = list.includes(origin.toLowerCase());<br>    return ok ? cb(null, true) : cb(new Error('Not allowed'), false);<br>  }<br>  ```<br>- Gotchas:<br>  - Must not set headers here; cors package will do it if `cb(null,true)` is called and route-level `allowedHeaders`/`methods` are configured as specified.<br>  - Ensure `invoiceId` resolution for `/create-tx` via `req.query.invoiceId`; if missing, deny.<br>- Invariants:<br>  - No writes; purely reads and compare.<br>  - Denied paths result in omitted ACAO.<br><br>--- |
| RateLimitPolicy | publicInvoiceViewLimiterHandler(req: import('express').Request, res: import('express').Response): void | Purpose: Custom handler for GET /i/:invoiceId rate-limit exceed. Responsibilities: immediately return res.status(429).json({ reason: 'rateLimited' }); do not call next(); prevent DB/chain access; consistent camelCase response for public routes. |  |
| RateLimitPolicy | publicProfileLimiterHandler(req: import('express').Request, res: import('express').Response): void | Purpose: Custom handler for GET /api/v1/stores/:storeId/public-profile rate-limit exceed. Responsibilities: return res.status(429).json({ reason: 'rateLimited' }); halt chain; no DB calls. |  |
| RateLimitPolicy | publicCreateTxLimiterHandler(req: import('express').Request, res: import('express').Response): void | Purpose: Custom handler for POST /create-tx rate-limit exceed. Responsibilities: return res.status(429).json({ reason: 'rateLimited' }); mounted before express.json() to avoid parsing body when limited; no further processing. |  |
| RateLimitPolicy | createInvoiceLimiterHandler(req: import('express').Request, res: import('express').Response): void | Purpose: Custom handler for POST /api/v1/stores/:storeId/invoices rate-limit exceed. Responsibilities: return res.status(429).json({ error: 'rate_limited' }); halt chain; ensure no DB/chain operations run. |  |
| RateLimitPolicy | buildSubInvoiceLimiter(windowMs?: number, max?: number): import('express').RequestHandler | Purpose: Factory to create limiter for POST /api/v1/stores/:storeId/subscriptions/:id/invoice. Responsibilities: configure windowMs/max, standardHeaders true, legacyHeaders false, and keyGenerator(req) combining req.store.id and X-API-Key to avoid cross-tenant bleed; return middleware instance with handler returning 429 { error:'rate_limited' } on exceed; mount before JSON parser. |  |
| RateLimitPolicy | subInvoiceLimiterHandler(req: import('express').Request, res: import('express').Response): void | Purpose: Custom handler used by subscription invoice limiter on exceed. Responsibilities: return res.status(429).json({ error: 'rate_limited' }); do not call next(); ensure no controller logic executes. |  |
| RateLimitPolicy | createTxLimiterHandler(req: import('express').Request, res: import('express').Response): void | Purpose: Alias behavior for publicCreateTx limiter in shared middleware sets. Responsibilities: identical to publicCreateTxLimiterHandler; return 429 { reason:'rateLimited' }; no body parsing. |  |
| PricingService | getUsdPriceSnapshot(): Promise<number> | Purpose: Fetch BTC/USD price snapshot with TTL cache. Responsibilities: read from external PRICE_API_URL; respect cache TTL to reduce calls; return numeric USD price used at invoice creation; propagate network errors as 502/500 to caller or map to 500; no mutation; callers persist the number into invoices.usd_at_create. | PricingService.getUsdPriceSnapshot:<br>- Alignment: Aligned with pricing snapshot requirement; used at invoice creation; cache TTL required.<br>- Mechanics:<br>  1. Maintain in-memory `{ value: number, fetchedAt: number }` and `TTL_SECS` from config (e.g., 30–60s).<br>  2. On call:<br>     - If `cache.value` exists and `now - fetchedAt <= TTL_SECS`, return `cache.value`.<br>     - Else, perform GET to `PRICE_API_URL` (e.g., CoinGecko) to fetch BTC/USD.<br>  3. Parse numeric USD price; validate `> 0` and finite.<br>  4. Save to cache with `fetchedAt = now`; return number.<br>- Order:<br>  - Check cache → HTTP fetch (if needed) → parse → validate → cache → return.<br>- Data touched: No DB; in-memory cache only.<br>- Performance: One HTTP call per TTL window; O(1) otherwise.<br>- Pseudocode:<br>  ```<br>  let cache = { value: null, fetchedAt: 0 };<br>  const TTL = Number(process.env.PRICE_TTL_SECS or 60);<br><br>  async function getUsdPriceSnapshot() {<br>    const now = Math.floor(Date.now()/1000);<br>    if (cache.value && now - cache.fetchedAt <= TTL) return cache.value;<br>    const resp = await axios.get(process.env.PRICE_API_URL);<br>    const usd = Number(resp.data?.bitcoin?.usd ?? resp.data?.USD ?? resp.data?.price);<br>    if (!Number.isFinite(usd) or usd <= 0) throw new Error('bad_price');<br>    cache = { value: usd, fetchedAt: now };<br>    return usd;<br>  }<br>  ```<br>- Gotchas:<br>  - Map provider JSON schema explicitly; fail closed on malformed data.<br>  - Do not store in DB; callers persist the numeric snapshot.<br>- Invariants: Returns a positive finite number.<br><br>--- |
| InvoiceService | createInvoice(store: MerchantRow, input: { amountSats: number; ttlSeconds: number; memo?: string; webhookUrl?: string }): Promise<PublicInvoiceDTO & { magicLink: string; unsignedTx?: UnsignedContractCall }> | Purpose: Orchestrate on-chain invoice creation and DB insert. Responsibilities: generate idHex via InvoiceIdCodec.generateRandomBuff32Hex(); assert 64-hex; compute id buffer; get usdAtCreate via PricingService.getUsdPriceSnapshot(); get tip height via StacksChainClient.getTipHeight(); compute expiresAtBlock = tip + ceil(ttlSeconds/avgBlockSecs from ConfigService); build unsigned create-invoice via ContractCallBuilder.buildCreateInvoice({ idHex, amountSats, memo, expiresAtBlock }); if ConfigService.isAutoBroadcastEnabled() then sign/broadcast via broadcastCreateInvoice and include txid; persist row via SqliteStore.invoices.insert with immutable fields (id_hex, amount_sats, merchant_principal), quote_expires_at = now + ttlSeconds, status='unpaid', memo, webhook_url override; return DTO with camelCase and magicLink; ensure off-chain/on-chain idHex consistency; throw on DB constraint violations. | InvoiceService.createInvoice:<br>- Alignment: Strictly aligned with on-chain-first creation, ID hex64 persistence, TTL and block expiry conversion, and API snapshot rules.<br>- Mechanics (minimal reproducible logic):<br>  1. Generate `(buff 32)` hex ID:<br>     - `idHex = InvoiceIdCodec.generateRandomBuff32Hex()`; assert `idHex.length === 64` and hex pattern.<br>  2. Compute IDs:<br>     - `idBuff = Buffer.from(idHex, 'hex')` for contract args.<br>  3. USD snapshot:<br>     - `usdAtCreate = await PricingService.getUsdPriceSnapshot()`.<br>  4. Read tip height:<br>     - `tip = await StacksChainClient.getTipHeight()`.<br>  5. Compute on-chain `expiresAtBlock`:<br>     - `avg = ConfigService.getAvgBlockSecs()` (≈30).<br>     - `expiresAtBlock = tip + Math.ceil(ttlSeconds / avg)`.<br>  6. Build unsigned `create-invoice` call:<br>     - Use `ContractCallBuilder.buildCreateInvoice({ idBuff, amountSats, memo, expiresAtBlock })`.<br>  7. Optional auto-broadcast (POC):<br>     - If `ConfigService.isAutoBroadcastEnabled()`, sign/broadcast using `broadcastCreateInvoice(unsignedCall)` to get `txid`.<br>  8. Persist DB row (single transaction):<br>     - `SqliteStore.invoices.insert({ id_raw: uuidV4(), id_hex: idHex, store_id: store.id, amount_sats: amountSats, usd_at_create: usdAtCreate, quote_expires_at: now + ttlSeconds, merchant_principal: store.principal, status:'unpaid', memo, webhook_url, created_at: now, expired:0, refund_amount:0, refund_count:0 })`.<br>     - Enforce invariants: `id_hex`, `amount_sats`, `merchant_principal` immutable thereafter (DS-3-35).<br>  9. Return DTO camelCase with `magicLink = https://host/i/<id_raw>` and optionally include unsigned call for clients that need to present the creation tx (if exposed).<br>- Order of operations:<br>  - Generate id → read USD + tip → compute expiry block → build unsigned call → optional broadcast → DB insert → return DTO.<br>- Key data structures: invoices table fields per schema; immutable columns.<br>- Performance: One external price call (cached), one tip call, one DB insert. Fits within standard API latency.<br>- Pseudocode:<br>  ```<br>  async function createInvoice(store, { amountSats, ttlSeconds, memo, webhookUrl }) {<br>    assert(amountSats > 0 && ttlSeconds > 0);<br>    const idHex = InvoiceIdCodec.generateRandomBuff32Hex();<br>    if (!/^[0-9a-fA-F]{64}$/.test(idHex)) throw new Error('id_hex_invalid');<br>    const usdAtCreate = await pricing.getUsdPriceSnapshot();<br>    const tip = await chain.getTipHeight();<br>    const avg = cfg.getAvgBlockSecs();<br>    const expiresAtBlock = tip + Math.ceil(ttlSeconds / avg);<br>    const unsignedTx = ContractCallBuilder.buildCreateInvoice({ idHex, amountSats, memo, expiresAtBlock });<br>    let txid;<br>    if (cfg.isAutoBroadcastEnabled()) {<br>      txid = await this.broadcastCreateInvoice(unsignedTx);<br>    }<br>    const now = Math.floor(Date.now()/1000);<br>    const idRaw = uuidv4();<br>    storeDb.insertInvoice({<br>      id_raw: idRaw, id_hex: idHex, store_id: store.id, amount_sats: amountSats,<br>      usd_at_create: usdAtCreate, quote_expires_at: now + ttlSeconds,<br>      merchant_principal: store.principal, status: 'unpaid', memo, webhook_url: webhookUrl ?? null,<br>      created_at: now, expired: 0, refund_amount: 0, refund_count: 0<br>    });<br>    return { invoiceId: idRaw, idHex, amountSats, usdAtCreate, quoteExpiresAt: now + ttlSeconds, magicLink: `${baseUrl}/i/${idRaw}`, unsignedTx, txid };<br>  }<br>  ```<br>- Gotchas:<br>  - Ensure `idHex` round-trips: `Buffer.from(idHex,'hex').length === 32`.<br>  - Memo ≤ 34 bytes if passed to on-chain as `(optional (buff 34))`.<br>  - On DB constraint violation (ux_invoices_id_hex), handle 409.<br>- Invariants:<br>  - Each invoice exists on-chain via create-invoice; backend must persist 64-hex ID for wallet pay-invoice calls.<br><br>--- |
| InvoiceService | broadcastCreateInvoice(unsignedCall: UnsignedContractCall): Promise<string> | Purpose: Optionally sign and broadcast create-invoice. Responsibilities: sign with configured operator/merchant key; broadcast to network; return txid on success; throw on failure; no DB writes; caller handles rollback/propagation; ensure network matches ConfigService. | InvoiceService.broadcastCreateInvoice:<br>- Alignment: Optional POC broadcast path; must respect configured network.<br>- Mechanics:<br>  1. Load operator key material and network from `ConfigService` (only for testnet in POC).<br>  2. Sign the provided `unsignedCall` using `@stacks/transactions` with the private key.<br>  3. Broadcast via Stacks API endpoint; await response.<br>  4. On non-2xx or error, throw; otherwise return `txid`.<br>- Order:<br>  - Resolve network/config → sign → broadcast → parse txid → return.<br>- Pseudocode:<br>  ```<br>  async function broadcastCreateInvoice(unsignedCall) {<br>    const net = cfg.getStacksNetwork();<br>    const privKey = cfg.getOperatorPrivateKey();<br>    const signed = await signTransaction(unsignedCall, privKey, net);<br>    const txid = await broadcastTransaction(signed, net);<br>    if (!txid) throw new Error('broadcast_failed');<br>    return txid;<br>  }<br>  ```<br>- Gotchas:<br>  - Do not persist anything here; caller handles rollback/propagation.<br>  - Ensure the network matches the deployed contract network.<br><br>--- |
| RefundService | precheckBalance(merchantPrincipal: string, amountSats: number): Promise<boolean> | Purpose: Avoid wallet failures by pre-checking sBTC balance. Responsibilities: read current sBTC token contract from ConfigService.getSbtcContractId(); call StacksChainClient.getFungibleBalance(assetContract, merchantPrincipal); compare ≥ amountSats; return boolean; treat missing token as false; do not mutate state. | RefundService.precheckBalance:<br>- Alignment: Matches pre-check rule to avoid wallet failures; respects missing token handling.<br>- Mechanics:<br>  1. Read current sBTC asset contract from `ConfigService.getSbtcContractId()`; if null/undefined → return `false`.<br>  2. Call `StacksChainClient.getFungibleBalance(assetContract, merchantPrincipal)` (read-only).<br>  3. Compare `balance >= amountSats`; return boolean.<br>- Pseudocode:<br>  ```<br>  async function precheckBalance(merchantPrincipal, amountSats) {<br>    const asset = cfg.getSbtcContractId();<br>    if (!asset) return false;<br>    const bal = await chain.getFungibleBalance(asset, merchantPrincipal);<br>    return BigInt(bal) >= BigInt(amountSats);<br>    }<br>  ```<br>- Gotchas:<br>  - Balance may be returned as string; cast carefully to bigints to avoid overflow.<br>  - Network timeouts should be treated as false upstream (mapped to 400 insufficient_balance).<br><br>--- |
| RefundService | buildRefundPayload(store: MerchantRow, invoice: InvoiceRow, amountSats: number, memo?: string): Promise<UnsignedContractCall> | Purpose: Build unsigned refund-invoice payload with safe post-conditions. Responsibilities: validate invoice.status in ['paid','partially_refunded']; enforce refund cap: invoice.refund_amount + amountSats ≤ invoice.amount_sats; assert invoice.id_hex is 64 hex and round-trips to 32 bytes; construct post-conditions via PostConditionFactory.forRefund(store.principal, amountSats, AssetInfoFactory.getSbtcAssetInfo()) using PostConditionMode.Deny; build call via ContractCallBuilder.buildRefundInvoice({ idHex: invoice.id_hex, amountSats, memo, merchantPrincipal: store.principal }); return payload; do not persist; controller handles insufficient_balance precheck. | RefundService.buildRefundPayload:<br>- Alignment: Enforces refund cap on-chain/off-chain and safe post-conditions per Problem Statement.<br>- Mechanics:<br>  1. Validate invoice status in ['paid','partially_refunded']; else throw conflict.<br>  2. Validate `invoice.id_hex` is hex64 and round-trips to 32 bytes.<br>  3. Compute `newTotal = invoice.refund_amount + amountSats`; assert `newTotal <= invoice.amount_sats`.<br>  4. Build post-conditions:<br>     - PostConditionMode.Deny.<br>     - Fungible PC for merchant principal: LessEqual amountSats (caps outgoing transfer).<br>  5. Build unsigned contract call:<br>     - `functionName = 'refund-invoice'`.<br>     - Args: `id: (buff32)`, `amount: uint`, `memo: (optional (buff 34))`.<br>     - `contractAddress/Name` from config.<br>  6. Return unsigned payload.<br>- Pseudocode:<br>  ```<br>  async function buildRefundPayload(store, inv, amountSats, memo) {<br>    if (!['paid','partially_refunded'].includes(inv.status)) throw new Error('not_refundable');<br>    if (!/^[0-9a-fA-F]{64}$/.test(inv.id_hex)) throw new Error('id_hex_invalid');<br>    if (Buffer.from(inv.id_hex, 'hex').length !== 32) throw new Error('id_hex_roundtrip');<br>    const remaining = BigInt(inv.amount_sats) - BigInt(inv.refund_amount);<br>    if (BigInt(amountSats) > remaining) throw new Error('refund_cap_exceeded');<br>    const assetInfo = AssetInfoFactory.getSbtcAssetInfo();<br>    const pcs = PostConditionFactory.forRefund(store.principal, amountSats, assetInfo);<br>    return ContractCallBuilder.buildRefundInvoice({<br>      idHex: inv.id_hex, amountSats, memo, merchantPrincipal: store.principal, postConditions: pcs<br>    });<br>  }<br>  ```<br>- Gotchas:<br>  - Memo must fit 34 bytes if present.<br>  - Use Deny mode to prevent any extra unintended transfers.<br>- Invariants:<br>  - No DB writes; pure builder.<br><br>--- |
| WebhookDispatcher | verifyWebhookSignature(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | <br>verifyWebhookSignature(req, res, next): void reads headers and raw body, resolves the HMAC secret, delegates full verification including skew, replay, and timing-safe compare to WebhookSignatureService.verifyInbound, and then either ends with proper status or calls next().<br><br>External delegate calls:<br>- this.sigSvc.verifyInbound(tsHeader, sigHeader, rawBody, secret, now)<br><br>Implementation snippet:<br><br>```ts<br>verifyWebhookSignature(req: Request, res: Response, next: NextFunction): void {<br>  const tsHeader = req.header('X-Webhook-Timestamp') or req.header('x-webhook-timestamp');<br>  const sigHeader = req.header('X-Webhook-Signature') or req.header('x-webhook-signature');<br>  const rawBody = typeof req.body === 'string' ? req.body : Buffer.isBuffer(req.body) ? req.body.toString('utf8') : '';<br>  const secret: string = (this.store as any).getStoreHmacSecretForInbound(req);<br>  const now = Math.floor(Date.now() / 1000);<br>  const decision = this.sigSvc.verifyInbound(tsHeader, sigHeader, rawBody, secret, now);<br>  if (!decision.ok) {<br>    res.status(decision.status).end();<br>    return;<br>  }<br>  next();<br>}<br>```<br><br> | WebhookDispatcher.verifyWebhookSignature:<br>- Alignment: Enforces inbound HMAC per spec (timestamped, skew check, timing-safe compare, replay window, express.raw).<br>- Mechanics:<br>  1. Assume route mounted with `express.raw({ type:'application/json' })`.<br>  2. Extract headers `X-Webhook-Timestamp`, `X-Webhook-Signature` (case-insensitive).<br>  3. Obtain raw body string from `req.body` (buffer/string).<br>  4. Resolve HMAC secret for this inbound surface (store-defined; from a configured resolver).<br>  5. Compute `now = unix seconds`.<br>  6. Delegate to `WebhookSignatureService.verifyInbound(ts, sig, rawBody, secret, now)` which:<br>     - Validates timestamp skew ≤ 300s.<br>     - Validates signature format `v1=<hex>`.<br>     - Computes HMAC_SHA256(secret, `${ts}.${rawBody}`), compares timing-safe.<br>     - Checks 10-minute replay cache; rejects duplicates.<br>  7. If decision not ok, return `res.status(decision.status).end()`; else `next()`.<br>- Pseudocode:<br>  ```<br>  function verifyWebhookSignature(req, res, next) {<br>    const ts = req.get('X-Webhook-Timestamp') or req.get('x-webhook-timestamp');<br>    const sig = req.get('X-Webhook-Signature') or req.get('x-webhook-signature');<br>    const raw = Buffer.isBuffer(req.body) ? req.body.toString('utf8') : (typeof req.body === 'string' ? req.body : '');<br>    const secret = secretResolver.getStoreHmacSecretForInbound(req);<br>    const now = Math.floor(Date.now()/1000);<br>    const decision = sigSvc.verifyInbound(ts, sig, raw, secret, now);<br>    if (!decision.ok) return res.status(decision.status).end();<br>    return next();<br>  }<br>  ```<br>- Gotchas:<br>  - Must use raw body; do not JSON.parse before verification.<br>  - Reject if headers missing or malformed signature.<br><br>--- |
| WebhookDispatcher | enqueueRetryIfNotInflight(row: WebhookLogRow): Promise<boolean> | Purpose: Manually or automatically enqueue retry if not already inflight. Responsibilities: check in-memory de-dup Set; if inflight, return false; else mark inflight; increment attempts and update last_attempt_at in DB via SqliteStore.updateWebhookAttemptStatus or insert row; dispatch asynchronously with current payload and headers; plan backoff if needed; return true; ensure idempotence and no duplicate sends; clear inflight on completion. | WebhookDispatcher.enqueueRetryIfNotInflight:<br>- Alignment: Matches admin/manual retry idempotence and dedupe semantics.<br>- Mechanics:<br>  1. Build inflight key: `${row.store_id}:${row.invoice_id ?? row.subscription_id ?? 'none'}:${row.event_type}`.<br>  2. If key in `inflight` Set → return `false`.<br>  3. Add key to `inflight`.<br>  4. Increment `attempts` and set `last_attempt_at=now` in DB for this log row.<br>  5. Dispatch immediately: `dispatch({ storeId, invoiceId, subscriptionId, eventType, rawBody: row.payload, attempts: row.attempts + 1 })`.<br>  6. On completion (success/failure), remove key from `inflight`.<br>  7. Return `true`.<br>- Pseudocode:<br>  ```<br>  async function enqueueRetryIfNotInflight(row) {<br>    const key = `${row.store_id}:${row.invoice_id ?? row.subscription_id ?? 'none'}:${row.event_type}`;<br>    if (inflight.has(key)) return false;<br>    inflight.add(key);<br>    const now = Math.floor(Date.now()/1000);<br>    store.bumpWebhookAttempt(row.id, now);<br>    try {<br>      await dispatch({ storeId: row.store_id, invoiceId: row.invoice_id, subscriptionId: row.subscription_id,<br>        eventType: row.event_type, rawBody: row.payload, attempts: row.attempts + 1 });<br>    } finally {<br>      inflight.delete(key);<br>    }<br>    return true;<br>  }<br>  ```<br>- Gotchas:<br>  - Always clear inflight key in finally to avoid deadlocks.<br>- Invariants:<br>  - Payload unchanged; signature will be recomputed per attempt.<br><br>--- |
| WebhookDispatcher | dispatch(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts?: number }): Promise<void> | <br>dispatch(ctx): Promise<void> resolves destination URL/secret, records the initial attempt row using WebhookAttemptPlanner.recordInitialAttempt, signs headers via WebhookSignatureService.buildOutboundHeaders, and POSTs. Calls onHttpSuccess/onHttpFailure accordingly.<br><br>External delegate calls:<br>- this.attempts.recordInitialAttempt(this.store, { ... })<br>- this.sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now)<br><br>Implementation snippet:<br><br>```ts<br>async dispatch(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string; rawBody: string; attempts?: number }): Promise<void> {<br>  const dest = await this.resolveDestinationAndSecret(ctx.storeId, ctx.invoiceId);<br>  const attemptNumber = ctx.attempts ? ctx.attempts : 1;<br>  const now = Math.floor(Date.now() / 1000);<br>  const attemptId = this.attempts.recordInitialAttempt(this.store, {<br>    storeId: ctx.storeId,<br>    invoiceId: ctx.invoiceId,<br>    subscriptionId: ctx.subscriptionId,<br>    eventType: ctx.eventType,<br>    rawBody: ctx.rawBody,<br>    attempts: attemptNumber,<br>    now,<br>  });<br>  const { headers } = this.sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now);<br>  try {<br>    const resp = await axios.post(dest.url, ctx.rawBody, { headers, timeout: 10000 });<br>    if (resp.status >= 200 && resp.status < 300) {<br>      await this.onHttpSuccess({ attemptLogId: attemptId, status: resp.status });<br>    } else {<br>      await this.onHttpFailure({ attemptLogId: attemptId, attempts: attemptNumber, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType as any, rawBody: ctx.rawBody }, resp.status);<br>    }<br>  } catch (err: any) {<br>    const status = err?.response?.status as number or undefined;<br>    await this.onHttpFailure({ attemptLogId: attemptId, attempts: attemptNumber, storeId: ctx.storeId, invoiceId: ctx.invoiceId, subscriptionId: ctx.subscriptionId, eventType: ctx.eventType as any, rawBody: ctx.rawBody }, status);<br>  }<br>}<br>```<br><br> | WebhookDispatcher.dispatch:<br>- Alignment: Implements outbound send with durable attempt logging, signatures, and success/failure routing.<br>- Mechanics:<br>  1. Resolve destination:<br>     - Use invoice override `invoices.webhook_url` if invoiceId present; else use `merchants.webhook_url`. If none → return (no-op).<br>     - Resolve store HMAC secret.<br>  2. Record initial attempt:<br>     - `attemptId = WebhookAttemptPlanner.recordInitialAttempt({ storeId, invoiceId?, subscriptionId?, eventType, rawBody, attempts: ctx.attempts ?? 1, now })`.<br>  3. Build headers:<br>     - From `WebhookSignatureService.buildOutboundHeaders(secret, rawBody, now)` returns `{ 'X-Webhook-Timestamp': ts, 'X-Webhook-Signature': 'v1=<hex>', 'Content-Type': 'application/json' }`.<br>  4. HTTP POST:<br>     - `axios.post(dest.url, rawBody, { headers, timeout: 10000 })`.<br>  5. On 2xx:<br>     - `onHttpSuccess({ attemptLogId: attemptId, status })`.<br>  6. On non-2xx or error:<br>     - Extract `status` if available; call `onHttpFailure({ attemptLogId, attempts, storeId, invoiceId, subscriptionId, eventType, rawBody }, status)`.<br>- Pseudocode:<br>  ```<br>  async function dispatch(ctx) {<br>    const dest = await resolveDestinationAndSecret(ctx.storeId, ctx.invoiceId);<br>    if (!dest?.url or !dest?.secret) return;<br>    const now = Math.floor(Date.now()/1000);<br>    const attemptId = attempts.recordInitialAttempt({ ...ctx, now, attempts: ctx.attempts ?? 1 });<br>    const headers = sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now).headers;<br>    try {<br>      const resp = await axios.post(dest.url, ctx.rawBody, { headers, timeout: 10000 });<br>      if (resp.status >= 200 && resp.status < 300) {<br>        await onHttpSuccess({ attemptLogId: attemptId, status: resp.status });<br>      } else {<br>        await onHttpFailure({ attemptLogId: attemptId, attempts: ctx.attempts ?? 1, ...ctx }, resp.status);<br>      }<br>    } catch (e) {<br>      const status = e?.response?.status;<br>      await onHttpFailure({ attemptLogId: attemptId, attempts: ctx.attempts ?? 1, ...ctx }, status);<br>    }<br>  }<br>  ```<br>- Gotchas:<br>  - Use exact `rawBody` as stored to keep signature stable across retries.<br>  - Timeout reasonable (10s); do not mutate payload.<br>- Invariants:<br>  - Attempt row persisted before network request.<br><br>--- |
| WebhookDispatcher | enqueueRetryIfNotInflight(row: WebhookLogRow): Promise<void> | Checks in-memory inflight set by row context; if absent, increments attempts, updates last_attempt_at, and enqueues dispatch through scheduler immediately (delay=0 or backoff-computed). No duplicate enqueues for same context. | WebhookDispatcher.enqueueRetryIfNotInflight:<br>- Mechanics:<br>  1. Compute dedupe key `storeId:entityId:eventType`.<br>  2. If inflight → return.<br>  3. Mark inflight, schedule `setTimeout` with computed delay (0 or backoff) to call `dispatch(ctx)`.<br>  4. Clear inflight key after dispatch completes.<br>- Pseudocode:<br>  ```<br>  function enqueueRetry(ctx) {<br>    const id = ctx.invoiceId ?? ctx.subscriptionId ?? 'none';<br>    const key = `${ctx.storeId}:${id}:${ctx.eventType}`;<br>    if (inflight.has(key)) return;<br>    inflight.add(key);<br>    setTimeout(async () => {<br>      try { await dispatch(ctx); } finally { inflight.delete(key); }<br>    }, 0);<br>  }<br>  ```<br>- Notes:<br>  - For admin manual retry this can be immediate (delay=0); scheduled backoff is handled elsewhere.<br><br>--- |
| WebhookDispatcher | onHttpFailure(ctx: { attemptLogId: string; attempts: number; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType or 'invoice-expired'; rawBody: string }, statusOrNull?: number): Promise<void> | <br>onHttpFailure(ctx, statusOrNull?): Promise<void> updates current attempt status and plans the next attempt with capped exponential backoff via WebhookAttemptPlanner.handleFailureAndPlanNext. The dispatcher itself contains no backoff logic after refactor.<br><br>External delegate calls:<br>- this.attempts.handleFailureAndPlanNext(this.store, { ... }, statusOrNull)<br><br>Implementation snippet:<br><br>```ts<br>async onHttpFailure(<br>  ctx: { attemptLogId: string; attempts: number; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: any; rawBody: string },<br>  statusOrNull?: number,<br>): Promise<void> {<br>  const now = Math.floor(Date.now() / 1000);<br>  await this.attempts.handleFailureAndPlanNext(this.store, {<br>    attemptLogId: ctx.attemptLogId,<br>    attempts: ctx.attempts,<br>    storeId: ctx.storeId,<br>    invoiceId: ctx.invoiceId,<br>    subscriptionId: ctx.subscriptionId,<br>    eventType: ctx.eventType,<br>    rawBody: ctx.rawBody,<br>    now,<br>  }, statusOrNull);<br>}<br>```<br><br> | WebhookDispatcher.onHttpFailure:<br>- Alignment: Delegates all failure persistence and next planning to AttemptPlanner.<br>- Mechanics:<br>  1. Compute `now = unix seconds`.<br>  2. Call `WebhookAttemptPlanner.handleFailureAndPlanNext({ attemptLogId, attempts, storeId, invoiceId, subscriptionId, eventType, rawBody, now }, statusOrNull)`.<br>- Pseudocode:<br>  ```<br>  async function onHttpFailure(ctx, status) {<br>    const now = Math.floor(Date.now()/1000);<br>    await attempts.handleFailureAndPlanNext({ ...ctx, now }, status);<br>  }<br>  ```<br>- Gotchas:<br>  - No extra logic here; centralize scheduling to planner to keep policy consistent.<br><br>--- |
| WebhookDispatcher | planRetry(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType or 'invoice-expired' or 'invoice-canceled'; rawBody: string; attempts: number }): Promise<void> | <br>planRetry(ctx): Promise<void> computes the next attempt number and persists a planned retry row through WebhookAttemptPlanner.planNextAttempt without sending anything immediately.<br><br>External delegate calls:<br>- this.attempts.planNextAttempt(this.store, { ... })<br><br>Implementation snippet:<br><br>```ts<br>async planRetry(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: any; rawBody: string; attempts: number }): Promise<void> {<br>  const now = Math.floor(Date.now() / 1000);<br>  await this.attempts.planNextAttempt(this.store, { ...ctx, now });<br>}<br>```<br><br>--- | WebhookDispatcher.planRetry:<br>- Mechanics:<br>  1. Compute `now = unix seconds`.<br>  2. Persist the next attempt plan via `WebhookAttemptPlanner.planNextAttempt({ storeId, invoiceId, subscriptionId, eventType, rawBody, attempts, now })`.<br>- Pseudocode:<br>  ```<br>  async function planRetry(ctx) {<br>    const now = Math.floor(Date.now()/1000);<br>    await attempts.planNextAttempt({ ...ctx, now });<br>  }<br>  ```<br>- Invariants:<br>  - No send; persistence-only.<br><br>--- |
| WebhookRetryScheduler | bootstrap(): Promise<void> | Resumes due retries at process start without blocking readiness. Data handling: queries SqliteStore.selectDueWebhookRetries() where success=0 AND attempts<5 AND (now − last_attempt_at) ≥ backoff(attempts). Dedupes logical contexts by (store_id, coalesce(invoice_id, subscription_id), event_type). For each due context, calls enqueueRetry({ storeId, invoiceId, subscriptionId, eventType, rawBody: row.payload, attempts: row.attempts }). Does not mutate payloads. | WebhookRetryScheduler.bootstrap:<br>- Alignment: Resume due retries at start, idempotently.<br>- Mechanics:<br>  1. Compute `now = unix seconds`.<br>  2. Query due via `SqliteStore.selectDueWebhookRetries(now)` where `success=0 AND attempts<5 AND (now - last_attempt_at) >= backoff(attempts)`.<br>  3. Deduplicate contexts by `(store_id, coalesce(invoice_id, subscription_id), event_type)`; pick latest attempt per context.<br>  4. For each due row, call `enqueueRetry({ storeId, invoiceId, subscriptionId, eventType, rawBody: row.payload, attempts: row.attempts })`.<br>- Pseudocode:<br>  ```<br>  async function bootstrap() {<br>    const now = Math.floor(Date.now()/1000);<br>    const rows = store.selectDueWebhookRetries(now);<br>    const seen = new Set();<br>    for (const r of rows) {<br>      const key = `${r.store_id}:${r.invoice_id ?? r.subscription_id ?? 'none'}:${r.event_type}`;<br>      if (seen.has(key)) continue;<br>      seen.add(key);<br>      enqueueRetry({ storeId: r.store_id, invoiceId: r.invoice_id, subscriptionId: r.subscription_id,<br>        eventType: r.event_type, rawBody: r.payload, attempts: r.attempts });<br>    }<br>  }<br>  ```<br>- Gotchas:<br>  - Do not block server readiness; run asynchronously after boot.<br>  - Do not mutate `rawBody`.<br><br>--- |
| WebhookRetryScheduler | onWake(): void | Timer callback invoked by setInterval. Immediately delegates to processDueRetries(Math.floor(Date.now()/1000)). No data mutation beyond passing current time. Ensures single-flight by relying on in-memory inflight de-dup in enqueueRetry/dispatch path. |  |
| WebhookRetryScheduler | processDueRetries(nowEpochSecs: number): Promise<void> | Finds and dispatches due retry attempts. Data handling: calls SqliteStore.getDueWebhookAttempts(nowEpochSecs) using due = (now − last_attempt_at) ≥ backoff(attempts) AND attempts < 5. For each row, builds ctx with exact stored payload (rawBody = row.payload) and invokes WebhookDispatcher.dispatch({ storeId, invoiceId, subscriptionId, eventType, rawBody, attempts }). No pre-alteration of payload or headers. | WebhookRetryScheduler.processDueRetries:<br>- Alignment: Periodic due scanning and dispatch.<br>- Mechanics:<br>  1. Query DB for due attempts via `SqliteStore.getDueWebhookAttempts(nowEpochSecs)` defined by backoff gate and attempts cap.<br>  2. For each row, construct ctx `{ storeId, invoiceId, subscriptionId, eventType, rawBody: row.payload, attempts: row.attempts }`.<br>  3. Call `WebhookDispatcher.dispatch(ctx)` for each; dispatch path records success/failure and plans next attempt if needed.<br>- Pseudocode:<br>  ```<br>  async function processDueRetries(now) {<br>    const rows = store.getDueWebhookAttempts(now);<br>    for (const r of rows) {<br>      await dispatcher.dispatch({<br>        storeId: r.store_id, invoiceId: r.invoice_id, subscriptionId: r.subscription_id,<br>        eventType: r.event_type, rawBody: r.payload, attempts: r.attempts<br>      });<br>    }<br>  }<br>  ```<br>- Gotchas:<br>  - Dispatcher will handle marking success/failure; do not duplicate DB writes here.<br>- Invariants:<br>  - Attempts < 5 enforced in SQL query.<br><br>--- |
| WebhookRetryScheduler | enqueueRetry(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType or 'invoice-expired' or 'invoice-canceled'; rawBody: string; attempts: number }): void | Schedules an in-memory delayed job honoring exponential backoff and inflight de-dup. Data handling: computes delaySecs for attempts N as [60,120,240,480,960][N−1] with clamp to range; derives inflight key `${storeId}:${invoiceId‖subscriptionId‖'none'}:${eventType}`; if already inflight, no-op; else marks inflight and schedules a setTimeout that calls WebhookDispatcher.dispatch(ctx), then clears inflight on completion. | WebhookRetryScheduler.enqueueRetry:<br>- Alignment: In-memory delayed job honoring backoff and dedupe.<br>- Mechanics:<br>  1. Compute delay table `[60,120,240,480,960]`; pick `delaySecs = table[Math.min(ctx.attempts, 5)-1]`.<br>  2. Build inflight key `storeId:entityId:eventType`; if inflight → return.<br>  3. Mark inflight; schedule `setTimeout` with `delaySecs*1000` to call `WebhookDispatcher.dispatch(ctx)`; clear inflight after completion.<br>- Pseudocode:<br>  ```<br>  function enqueueRetry(ctx) {<br>    const id = ctx.invoiceId ?? ctx.subscriptionId ?? 'none';<br>    const key = `${ctx.storeId}:${id}:${ctx.eventType}`;<br>    if (inflight.has(key)) return;<br>    inflight.add(key);<br>    const delays = [60,120,240,480,960];<br>    const delay = delays[Math.min(ctx.attempts, 5) - 1];<br>    setTimeout(async () => {<br>      try { await dispatcher.dispatch(ctx); } finally { inflight.delete(key); }<br>    }, delay * 1000);<br>  }<br>  ```<br>- Gotchas:<br>  - Ensure attempts value starts at 1.<br><br>--- |
| PaymentPoller | bootstrapPoller(): void | Idempotently registers the poller interval at service boot using environment cadence. Data handling: reads env POLL_INTERVAL_SECS and AVG_BLOCK_SECS, computes interval = max of both (default 30s), ensures only one setInterval is active. Initializes in-memory cursor { lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined } and metrics { running: false, lastRunAt: undefined, lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined, lagBlocks: undefined }. Schedules timerCallback. | PaymentPoller.bootstrapPoller:<br>- Alignment: Registers periodic scan with idempotence; initializes cursor and metrics.<br>- Mechanics:<br>  1. If an interval already exists (`pollHandle`), return (idempotent).<br>  2. Read cadence from env: `POLL_INTERVAL_SECS` and fallback to `AVG_BLOCK_SECS`; interval = `Math.max(POLL_INTERVAL_SECS, AVG_BLOCK_SECS, 30) * 1000`.<br>  3. Initialize in-memory cursor `{ lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined }` if not set.<br>  4. Initialize metrics `{ running:false, lastRunAt: undefined, lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined, lagBlocks: undefined }`.<br>  5. Register `setInterval(() => void timerCallback(), interval)`.<br>- Pseudocode:<br>  ```<br>  function bootstrapPoller() {<br>    if (this.pollHandle) return;<br>    const s = Number(process.env.POLL_INTERVAL_SECS or 30);<br>    const avg = Number(process.env.AVG_BLOCK_SECS or 30);<br>    const ms = Math.max(s, avg, 30) * 1000;<br>    if (!this.cursor) this.cursor = { lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined };<br>    this.metrics = { running:false, lastRunAt: undefined, lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined, lagBlocks: undefined };<br>    this.pollHandle = setInterval(() => void this.timerCallback(), ms);<br>  }<br>  ```<br>- Invariants:<br>  - Only one interval runs.<br><br>--- |
| PaymentPoller | timerCallback(): void | Bound to setInterval; invokes void pollTick().catch(logError) to avoid unhandled rejections. Contains no business logic. |  |
| PaymentPoller | pollTick(): Promise<void> | Orchestrates a full poll cycle. Data handling: guards reentrancy (guardReentrancy), reads tip (readChainTip), fetches normalized events (fetchAndFilterEvents(fromHeight)), processes subscription lifecycle first (processSubscriptionEvents(batch, tipHeight, minConfirmations)), then iterates remaining events calling processEvent(e, tipHeight, minConfirmations) with confirmations gate and idempotency. Performs expiration sweeps (DB TTL and optional on-chain). Detects potential reorg (detectReorg) and plans rewind (planRewindWindow) if needed; on success updates cursor (updateCursorState). Always updates metrics in finally (refreshMetrics). | PaymentPoller.pollTick:<br>- Alignment: Full orchestration per DS-8-SCHED-2 et al., including confirmations, expirations, reorg safety, telemetry.<br>- Mechanics:<br>  1. Entry guard: `if (!guardReentrancy()) return;`<br>  2. `try {`<br>     - Read chain tip: `{ tipHeight, tipBlockHash, cursorRef } = await readChainTip()`.<br>     - Determine `fromHeight = this.rewindToHeight ?? (cursorRef.lastHeight + 1)`.<br>     - Fetch normalized events: `batch = await fetchAndFilterEvents(fromHeight)`.<br>     - Process subscription lifecycle first: `await processSubscriptionEvents(batch, tipHeight, cfg.minConfirmations)`.<br>     - For each event in `batch` not subscription-related: `await processEvent(e, tipHeight, cfg.minConfirmations)`.<br>     - Sweep expirations:<br>       - DB TTL: `ExpirationMonitor.sweepDbTtl(nowEpochSecs)`.<br>       - Optional on-chain: `ExpirationMonitor.sweepOnchainStatuses(candidates)`.<br>     - Detect reorg: `const reorg = await detectReorg(fromHeight, tipHeight)`; if true → `planRewindWindow()` and `return`.<br>     - Update cursor: `await updateCursorState({ height: tipHeight, blockHash: tipBlockHash, parentHash: '?' }, lastTxIdFromBatchEnd)`.<br>  3. `} finally { refreshMetrics({ tipHeight }); }`<br>- Pseudocode:<br>  ```<br>  async function pollTick() {<br>    if (!guardReentrancy()) return;<br>    try {<br>      const { tipHeight, tipBlockHash, cursorRef } = await readChainTip();<br>      const from = this.rewindToHeight ?? (cursorRef.lastHeight + 1);<br>      const batch = await fetchAndFilterEvents(from);<br>      await processSubscriptionEvents(batch, tipHeight, cfg.minConfirmations);<br>      for (const e of batch) await processEvent(e, tipHeight, cfg.minConfirmations);<br>      await ExpirationMonitor.sweepDbTtl(Math.floor(Date.now()/1000));<br>      const reorg = await detectReorg(from, tipHeight);<br>      if (reorg) { planRewindWindow(); return; }<br>      await updateCursorState({ height: tipHeight, blockHash: tipBlockHash, parentHash: '' }, batch.at(-1)?.tx_id);<br>    } finally {<br>      refreshMetrics({ tipHeight });<br>    }<br>  }<br>  ```<br>- Gotchas:<br>  - Always clear running flag in `refreshMetrics`.<br>  - Do not advance cursor on reorg detection.<br>- Invariants:<br>  - Deterministic event order (block_height ASC, tx_index ASC) ensured by normalizer.<br><br>--- |
| PaymentPoller | guardReentrancy(): boolean | Ensures single-flight: if metrics.running is true returns false; else sets metrics.running=true and returns true. Caller must set running=false in finally. No external I/O. |  |
| PaymentPoller | readChainTip(): Promise<{ tipHeight: number; tipBlockHash: string; cursorRef: { lastHeight: number; lastTxId?: string; lastBlockHash?: string } }> | Reads current tip via StacksChainClient.getTip() and snapshots current cursor. Data handling: returns immutable snapshot of in-memory cursor for deterministic computation within the tick; does not persist. | PaymentPoller.readChainTip:<br>- Alignment: Snapshots cursor and reads tip; no persistence.<br>- Mechanics:<br>  1. `cursorRef = { ...this.cursor }` to freeze starting point.<br>  2. Call `StacksChainClient.getTip()` to retrieve `{ tipHeight, tipBlockHash }`.<br>  3. Return `{ tipHeight, tipBlockHash, cursorRef }`.<br>- Pseudocode:<br>  ```<br>  async function readChainTip() {<br>    const cursorRef = { ...this.cursor };<br>    const { height: tipHeight, blockHash: tipBlockHash } = await chain.getTip();<br>    return { tipHeight, tipBlockHash, cursorRef };<br>  }<br>  ```<br>- Invariants:<br>  - No DB writes; pure read.<br><br>--- |
| PaymentPoller | processEvent(event: NormalizedEvent, tipHeight: number, minConfirmations: number): Promise<void> | <br>processEvent(event, tipHeight, minConfirmations): Promise<void> performs confirmation gating and routes invoice events to InvoiceEventApplier. Subscription events are excluded (handled by processSubscriptionEvents).<br><br>External delegate calls:<br>- this.invoiceApplier.handlePaid(e)<br>- this.invoiceApplier.handleRefund(e)<br>- this.invoiceApplier.handleCanceled(e)<br><br>Implementation snippet:<br><br>```ts<br>async processEvent(e: NormalizedEvent, tipHeight: number, minConfirmations: number): Promise<void> {<br>  const confirmations = tipHeight - e.block_height + 1;<br>  if (confirmations < minConfirmations) return;<br>  if (e.type === 'invoice-paid') { await this.invoiceApplier.handlePaid(e); return; }<br>  if (e.type === 'refund-invoice') { await this.invoiceApplier.handleRefund(e); return; }<br>  if (e.type === 'invoice-canceled') { await this.invoiceApplier.handleCanceled(e); return; }<br>}<br>```<br><br> |  |
| PaymentPoller | detectReorg(firstBlockToProcessHeight: number, tipHeight: number): Promise<boolean> | <br>detectReorg(firstBlockToProcessHeight, tipHeight): Promise<boolean> calls ReorgGuard.detectReorg with cursor snapshot and chain client to decide reorg presence or tip regression.<br><br>External delegate calls:<br>- this.reorgGuard.detectReorg(firstBlockToProcessHeight, tipHeight, { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash }, this.chain)<br><br>Implementation snippet:<br><br>```ts<br>async detectReorg(firstBlockToProcessHeight: number, tipHeight: number): Promise<boolean> {<br>  return this.reorgGuard.detectReorg(<br>    firstBlockToProcessHeight,<br>    tipHeight,<br>    { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash },<br>    this.chain,<br>  );<br>}<br>```<br><br> |  |
| PaymentPoller | planRewindWindow(): void | <br>planRewindWindow(): void uses ReorgGuard.computeRewindTarget to compute a rewind height and forwards to planRewind (existing).<br><br>External delegate calls:<br>- this.reorgGuard.computeRewindTarget({ lastHeight, lastBlockHash }, reorgWindowBlocks)<br><br>Implementation snippet:<br><br>```ts<br>planRewindWindow(): void {<br>  const { reorgWindowBlocks } = this.cfg.getPollingConfig();<br>  const target = this.reorgGuard.computeRewindTarget(<br>    { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash },<br>    reorgWindowBlocks,<br>  );<br>  this.planRewind(target);<br>}<br>```<br><br> |  |
| PaymentPoller | updateCursorState(processedBlockHeader: { height: number; blockHash: string; parentHash: string }, lastTxId?: string): Promise<void> | Persists in-memory cursor advance after a successful batch without reorg. Data handling: builds new state { lastRunAt: nowEpochSecs, lastHeight: processedBlockHeader.height, lastTxId, lastBlockHash: processedBlockHeader.blockHash }; optionally persists via SqliteStore.savePollerCursor(state) if enabled; sets this.cursor = state. Recomputes lagBlocks by querying StacksChainClient.getTip() and updates metrics. | PaymentPoller.updateCursorState:<br>- Alignment: Advances in-memory cursor and recomputes lag; optional durability.<br>- Mechanics:<br>  1. Build new state:<br>     - `this.cursor.lastHeight = processedBlockHeader.height`<br>     - `this.cursor.lastTxId = lastTxId`<br>     - `this.cursor.lastBlockHash = processedBlockHeader.blockHash`<br>  2. Optional: `SqliteStore.savePollerCursor(this.cursor)` if durability enabled.<br>  3. Update metrics auxiliary fields (not running flag) and lag:<br>     - Query tip again or use snapshot: `lagBlocks = Math.max(0, tipHeight - this.cursor.lastHeight)`; if not provided, call `chain.getTip()` to compute.<br>- Pseudocode:<br>  ```<br>  async function updateCursorState(header, lastTxId) {<br>    this.cursor = { lastHeight: header.height, lastTxId, lastBlockHash: header.blockHash };<br>    if (cfg.persistCursor()) await store.savePollerCursor(this.cursor);<br>    const tip = await chain.getTip();<br>    this.metrics.lastHeight = this.cursor.lastHeight;<br>    this.metrics.lastTxId = this.cursor.lastTxId;<br>    this.metrics.lastBlockHash = this.cursor.lastBlockHash;<br>    this.metrics.lagBlocks = Math.max(0, tip.height - this.cursor.lastHeight);<br>  }<br>  ```<br>- Gotchas:<br>  - Do not modify `metrics.running` here; `refreshMetrics` handles it.<br><br>--- |
| PaymentPoller | onInvoicePaidConfirmed(event: NormalizedEvent): Promise<void> | <br>onInvoicePaidConfirmed(event): Promise<void> directly delegates to InvoiceEventApplier.handlePaid.<br><br>External delegate calls:<br>- this.invoiceApplier.handlePaid(event)<br><br>Implementation snippet:<br><br>```ts<br>async onInvoicePaidConfirmed(event: NormalizedEvent): Promise<void> {<br>  await this.invoiceApplier.handlePaid(event);<br>}<br>```<br><br> |  |
| PaymentPoller | onRefundConfirmed(event: NormalizedEvent): Promise<void> | <br>onRefundConfirmed(event): Promise<void> directly delegates to InvoiceEventApplier.handleRefund.<br><br>External delegate calls:<br>- this.invoiceApplier.handleRefund(event)<br><br>Implementation snippet:<br><br>```ts<br>async onRefundConfirmed(event: NormalizedEvent): Promise<void> {<br>  await this.invoiceApplier.handleRefund(event);<br>}<br>```<br><br> |  |
| PaymentPoller | onSubscriptionCreated(event: NormalizedEvent, tipHeight: number, minConfirmations: number): Promise<void> | Handles 'subscription-created' after confirmations. Data handling: ensures confirmations ≥ minConfirmations; validates idHex (64-hex); resolves storeId via SqliteStore.getStoreIdByPrincipal(event.merchantPrincipal!); upserts row via SqliteStore.upsertSubscriptionByHex({ idHex, storeId, merchantPrincipal, subscriber: event.subscriber!, amountSats: event.amountSats!, intervalBlocks: event.intervalBlocks!, active: 1 }) preserving existing mode. Builds webhook payload: {"subscriptionId": subscriptionUuid, "merchant": merchantPrincipal, "subscriber": subscriber, "amountSats": amountSats, "intervalBlocks": intervalBlocks, "nextDue": nextDueBlocksFromChainIfAvailableOrDb}. Dispatch with eventType:'subscription'. | PaymentPoller.onSubscriptionCreated:<br>- Alignment: Confirms, validates hex64, resolves store, upserts, preserves mode, dispatches webhook.<br>- Mechanics:<br>  1. Confirmations: `confirmations = tipHeight - event.block_height + 1`; if `< minConfirmations` → return.<br>  2. Validate `event.idHex` is hex64; if invalid → skip.<br>  3. Resolve `storeId = SqliteStore.getStoreIdByPrincipal(event.merchantPrincipal)`. If null → skip.<br>  4. Upsert DB:<br>     - `SqliteStore.upsertSubscriptionByHex({ idHex, storeId, merchantPrincipal, subscriber: event.subscriber, amountSats: event.amountSats, intervalBlocks: event.intervalBlocks, active: 1 })`.<br>     - Preserve existing `mode` if present.<br>  5. Enrich `nextDue`:<br>     - Prefer `next-due` from chain via read-only if available; else compute `nowTip + intervalBlocks`.<br>  6. Build webhook payload JSON with camelCase.<br>  7. `WebhookDispatcher.dispatch({ storeId, subscriptionId, eventType:'subscription', rawBody })`.<br>- Pseudocode:<br>  ```<br>  async function onSubscriptionCreated(e, tipHeight, minConf) {<br>    const conf = tipHeight - e.block_height + 1;<br>    if (conf < minConf) return;<br>    if (!/^[0-9a-fA-F]{64}$/.test(e.idHex)) return;<br>    const storeId = store.getStoreIdByPrincipal(e.merchantPrincipal);<br>    if (!storeId) return;<br>    await store.upsertSubscriptionByHex({<br>      idHex: e.idHex, storeId, merchant_principal: e.merchantPrincipal,<br>      subscriber: e.subscriber, amount_sats: e.amountSats, interval_blocks: e.intervalBlocks, active: 1<br>    });<br>    const nextDue = await chain.readSubscriptionNextDue(e.idHex) ?? (tipHeight + e.intervalBlocks);<br>    const rawBody = JSON.stringify({ subscriptionId: e.idHex, merchant: e.merchantPrincipal, subscriber: e.subscriber, amountSats: e.amountSats, intervalBlocks: e.intervalBlocks, nextDue });<br>    await dispatcher.dispatch({ storeId, subscriptionId: e.idHex, eventType: 'subscription', rawBody });<br>  }<br>  ```<br>- Gotchas:<br>  - Preserve `mode` column in upsert (do not overwrite).<br>- Invariants:<br>  - Idempotent upsert keyed by `id_hex`.<br><br>--- |
| PaymentPoller | onSubscriptionPaid(event: NormalizedEvent, tipHeight: number, minConfirmations: number): Promise<void> | Handles confirmed 'subscription-paid'. Data handling: ensures confirmations gate; updates DB via SqliteStore.updateSubscriptionLastPaid({ subscriptionId: subscriptionUuid, lastPaidInvoiceId: linkedInvoiceUuidIfKnown }); commits. Builds webhook payload: {"subscriptionId": subscriptionUuid, "subscriber": event.subscriber!, "amountSats": event.amountSats!, "txId": event.tx_id, "nextDue": nextDueFromChainIfAvailableOrDb}. Dispatch with eventType:'subscription'. | PaymentPoller.onSubscriptionPaid:<br>- Alignment: Confirmations gating, DB update, webhook payload with nextDue.<br>- Mechanics:<br>  1. Compute confirmations; if below threshold, return.<br>  2. Update DB linkage:<br>     - `SqliteStore.updateSubscriptionLastPaid({ idHex: event.idHex, txId: event.tx_id, subscriber: event.subscriber })` (or `last_paid_invoice_id` if known).<br>  3. Resolve next due via chain or compute `tipHeight + intervalBlocks`.<br>  4. Dispatch webhook: `{"subscriptionId","subscriber","amountSats","txId","nextDue"}`.<br>- Pseudocode:<br>  ```<br>  async function onSubscriptionPaid(e, tipHeight, minConf) {<br>    if (tipHeight - e.block_height + 1 < minConf) return;<br>    await store.updateSubscriptionLastPaid(e.idHex, e.tx_id, e.subscriber);<br>    const nextDue = await chain.readSubscriptionNextDue(e.idHex) ?? (tipHeight + e.intervalBlocks);<br>    const raw = JSON.stringify({ subscriptionId: e.idHex, subscriber: e.subscriber, amountSats: e.amountSats, txId: e.tx_id, nextDue });<br>    const storeId = store.getStoreIdByPrincipal(e.merchantPrincipal);<br>    if (storeId) await dispatcher.dispatch({ storeId, subscriptionId: e.idHex, eventType: 'subscription', rawBody: raw });<br>  }<br>  ```<br>- Gotchas:<br>  - Ensure storeId resolution; if unknown merchant, skip webhook.<br><br>--- |
| PaymentPoller | onSubscriptionCanceled(event: NormalizedEvent, tipHeight: number, minConfirmations: number): Promise<void> | Handles 'subscription-canceled' after confirmations. Data handling: ensures confirmations gate; sets active=0 via SqliteStore.setSubscriptionActive({ idHex: event.idHex, active: 0 }); builds webhook payload {"subscriptionId": subscriptionUuid}; dispatch with eventType:'subscription'. | PaymentPoller.onSubscriptionCanceled:<br>- Alignment: Confirmations gating, deactivate subscription, dispatch webhook.<br>- Mechanics:<br>  1. If confirmations below threshold, return.<br>  2. `SqliteStore.setSubscriptionActive({ idHex: event.idHex, active: 0 })`.<br>  3. Build payload `{"subscriptionId": idHex, "subscriber": event.subscriber}`.<br>  4. Resolve storeId by merchant principal; dispatch webhook.<br>- Pseudocode:<br>  ```<br>  async function onSubscriptionCanceled(e, tipHeight, minConf) {<br>    if (tipHeight - e.block_height + 1 < minConf) return;<br>    await store.setSubscriptionActive(e.idHex, 0);<br>    const raw = JSON.stringify({ subscriptionId: e.idHex, subscriber: e.subscriber });<br>    const storeId = store.getStoreIdByPrincipal(e.merchantPrincipal);<br>    if (storeId) await dispatcher.dispatch({ storeId, subscriptionId: e.idHex, eventType: 'subscription', rawBody: raw });<br>  }<br>  ```<br>- Invariants:<br>  - Active flag set to 0 only.<br><br>--- |
| PaymentPoller | onInvoiceCanceled(event: NormalizedEvent): Promise<void> | <br>onInvoiceCanceled(event): Promise<void> directly delegates to InvoiceEventApplier.handleCanceled.<br><br>External delegate calls:<br>- this.invoiceApplier.handleCanceled(event)<br><br>Implementation snippet:<br><br>```ts<br>async onInvoiceCanceled(event: NormalizedEvent): Promise<void> {<br>  await this.invoiceApplier.handleCanceled(event);<br>}<br>```<br><br>--- |  |
| PaymentPoller | refreshMetrics(snapshot?: Partial<PollerMetrics> & { tipHeight?: number }): void | Updates in-memory telemetry at tick end. Data handling: sets metrics.running=false; sets metrics.lastRunAt=nowEpochSecs; copies cursor fields (lastHeight/lastTxId/lastBlockHash) and computes lagBlocks = max(0, (snapshot.tipHeight ‖ tipFromClient) − cursor.lastHeight). No DB writes. | PaymentPoller.refreshMetrics:<br>- Alignment: End-of-tick telemetry update and running flag reset.<br>- Mechanics:<br>  1. Set `this.metrics.running = false`.<br>  2. Set `this.metrics.lastRunAt = Math.floor(Date.now()/1000)`.<br>  3. Copy cursor fields: `lastHeight`, `lastTxId`, `lastBlockHash`.<br>  4. Compute `lagBlocks = max(0, (snapshot.tipHeight ?? chain.getTip().height) - this.cursor.lastHeight)`.<br>- Pseudocode:<br>  ```<br>  async function refreshMetrics(snapshot) {<br>    this.metrics.running = false;<br>    this.metrics.lastRunAt = Math.floor(Date.now()/1000);<br>    this.metrics.lastHeight = this.cursor.lastHeight;<br>    this.metrics.lastTxId = this.cursor.lastTxId;<br>    this.metrics.lastBlockHash = this.cursor.lastBlockHash;<br>    const tipH = snapshot?.tipHeight ?? (await chain.getTip()).height;<br>    this.metrics.lagBlocks = Math.max(0, tipH - this.cursor.lastHeight);<br>  }<br>  ```<br>- Invariants:<br>  - Non-persistent; in-memory only.<br><br>--- |
| PaymentPoller | restartPoller(): { running: boolean } | Restarts the poll loop preserving cursor. Data handling: clearInterval if set; sets metrics.running=false; recreates setInterval with existing cadence; returns { running: true } if interval successfully re-registered. Does not reset cursor or metrics fields besides running flag. | PaymentPoller.restartPoller:<br>- Alignment: Clears interval, preserves cursor, re-registers with same cadence.<br>- Mechanics:<br>  1. If `pollHandle` set → `clearInterval(pollHandle)` and set to `null`.<br>  2. Set `metrics.running = false`.<br>  3. Recreate interval with existing cadence (reuse stored ms or recompute from env).<br>  4. Return `{ running: true }` if re-registered.<br>- Pseudocode:<br>  ```<br>  function restartPoller() {<br>    if (this.pollHandle) { clearInterval(this.pollHandle); this.pollHandle = null; }<br>    this.metrics.running = false;<br>    const ms = this.currentIntervalMs ?? (Number(process.env.POLL_INTERVAL_SECS or 30) * 1000);<br>    this.pollHandle = setInterval(() => void this.timerCallback(), ms);<br>    return { running: !!this.pollHandle };<br>  }<br>  ```<br>- Invariants:<br>  - Cursor unchanged.<br><br>--- |
| PaymentPoller | startPoller(): Promise<void> | Initializes or restarts poller with durable cursor. Data handling: loads persisted cursor via SqliteStore.getPollerCursor(); if none, bootstraps from StacksChainClient.getTip(); reads env config for cadence and confirmations; registers setInterval(timerCallback). Exposes metrics snapshot via internal getters for admin. | PaymentPoller.startPoller:<br>- Alignment: Initializes cursor durably if present, else from tip; registers loop; exposes metrics for admin.<br>- Mechanics:<br>  1. Attempt to load durable cursor via `SqliteStore.getPollerCursor()`; if none:<br>     - Read tip via `StacksChainClient.getTip()` and initialize cursor `{ lastHeight: tip.height, lastTxId: undefined, lastBlockHash: tip.blockHash }`.<br>  2. Read config `{ minConfirmations, reorgWindowBlocks, pollIntervalSecs }`.<br>  3. Register `setInterval(() => void timerCallback(), pollIntervalSecs*1000)`.<br>  4. Initialize metrics snapshot mirroring cursor; `running=false`.<br>- Pseudocode:<br>  ```<br>  async function startPoller() {<br>    const saved = store.getPollerCursor();<br>    if (saved) this.cursor = saved;<br>    else {<br>      const tip = await chain.getTip();<br>      this.cursor = { lastHeight: tip.height, lastTxId: undefined, lastBlockHash: tip.blockHash };<br>    }<br>    this.cfg.loadPollingConfig();<br>    const ms = this.cfg.getPollingConfig().intervalSecs * 1000;<br>    this.pollHandle = setInterval(() => void this.timerCallback(), ms);<br>    this.metrics = { running:false, lastRunAt: undefined, lastHeight: this.cursor.lastHeight, lastTxId: this.cursor.lastTxId, lastBlockHash: this.cursor.lastBlockHash, lagBlocks: 0 };<br>  }<br>  ```<br>- Gotchas:<br>  - If no cursor saved, starting at tip avoids replay of historical events.<br><br>--- |
| PaymentPoller | fetchAndFilterEvents(fromHeight: number): Promise<NormalizedEvent[]> | <br>fetchAndFilterEvents(fromHeight: number): Promise<NormalizedEvent[]> fetches and normalizes events through ContractCallEventNormalizer with no inline arg decoding or DB existence checks.<br><br>External delegate calls:<br>- this.eventNormalizer.fetchAndFilterEvents(fromHeight, this.chain, this.store)<br><br>Implementation snippet:<br><br>```ts<br>async fetchAndFilterEvents(fromHeight: number): Promise<NormalizedEvent[]> {<br>  return this.eventNormalizer.fetchAndFilterEvents(fromHeight, this.chain, this.store);<br>}<br>```<br><br> |  |
| PaymentPoller | planRewind(targetHeight: number): void | <br>planRewind(targetHeight: number): void remains unchanged; it sets internal next scan start to targetHeight. No delegate call here; other methods compute target via delegate.<br><br>Implementation snippet:<br><br>```ts<br>planRewind(targetHeight: number): void {<br>  this.rewindToHeight = targetHeight;<br>  // update metrics if applicable<br>}<br>```<br><br> |  |
| PaymentPoller | processSubscriptionEvents(eventBatch: NormalizedEvent[], tipHeight: number, minConfirmations: number): Promise<void> | <br>processSubscriptionEvents(eventBatch, tipHeight, minConfirmations): Promise<void> delegates the entire lifecycle flow to SubscriptionLifecycleProcessor.processBatch.<br><br>External delegate calls:<br>- this.subscriptionProcessor.processBatch(eventBatch, tipHeight, minConfirmations)<br><br>Implementation snippet:<br><br>```ts<br>async processSubscriptionEvents(eventBatch: NormalizedEvent[], tipHeight: number, minConfirmations: number): Promise<void> {<br>  await this.subscriptionProcessor.processBatch(eventBatch, tipHeight, minConfirmations);<br>}<br>```<br><br> | PaymentPoller.processSubscriptionEvents:<br>- Alignment: Delegates to `SubscriptionLifecycleProcessor` with gating/ordering defined; keeps this method thin.<br>- Mechanics:<br>  1. Call `SubscriptionLifecycleProcessor.processBatch(eventBatch, tipHeight, minConfirmations)`.<br>     - The processor must: upsert create-subscription, cancel, and paid events; preserve mode; enrich nextDue via read-only; dispatch webhooks.<br>- Pseudocode:<br>  ```<br>  async function processSubscriptionEvents(batch, tipHeight, minConf) {<br>    await this.subscriptionProcessor.processBatch(batch, tipHeight, minConf);<br>  }<br>  ```<br>- Invariants:<br>  - No extra filtering here; processor owns the lifecycle logic.<br><br>---<br><br>End of report. |
| SubscriptionScheduler | tick(): Promise<void> | Periodic scheduler tick to generate per-period invoices for due subscriptions in mode='invoice'. Data handling: obtains currentHeight via StacksChainClient.getTip(); selects dues via SqliteStore.selectDueSubscriptions(currentHeight). For each: delegates to onSubscriptionInvoiceCreated({ subscription, currentHeight }); continues on individual failures. |  |
| SubscriptionScheduler | onSubscriptionInvoiceCreated(ctx: { subscription: SubscriptionRow; currentHeight: number }): Promise<void> | <br>onSubscriptionInvoiceCreated(ctx): Promise<void> now delegates plan computation and webhook payload composition to SubscriptionInvoicePlanner. Parent performs broadcast (unsigned create-invoice building/signing as configured), persists invoice + advances schedule in a transaction, and dispatches webhook using the planner’s pre-built payload.<br><br>External delegate calls:<br>- planner.plan(subscription, currentHeight)<br>- planner.buildWebhookRawBody(planned, subscription)<br><br>Implementation snippet:<br><br>```ts<br>async onSubscriptionInvoiceCreated(ctx: { subscription: SubscriptionRow; currentHeight: number }): Promise<void> {<br>  const sub = ctx.subscription;<br>  const planner = new SubscriptionInvoicePlanner(this.store, this.pricing, this.cfg, this.codec);<br>  const planned = await planner.plan(sub, ctx.currentHeight);<br><br>  await this.broadcastCreateInvoiceTx({<br>    idBuf32: planned.idBuf32,<br>    amountSats: sub.amount_sats,<br>    memo: undefined,<br>    expiresAtBlocks: planned.expiresAtBlocks,<br>  });<br><br>  const nowSecs = Math.floor(Date.now() / 1000);<br>  this.store.invoices.insert({<br>    id_raw: planned.idRaw,<br>    id_hex: planned.idHex,<br>    store_id: sub.store_id,<br>    amount_sats: sub.amount_sats,<br>    usd_at_create: planned.usdAtCreate,<br>    quote_expires_at: planned.quoteExpiresAtMs,<br>    merchant_principal: sub.merchant_principal,<br>    status: 'unpaid',<br>    payer: undefined,<br>    txid: undefined,<br>    memo: undefined,<br>    webhook_url: undefined,<br>    created_at: nowSecs,<br>    refunded_at: undefined,<br>    refund_amount: 0,<br>    refund_txid: undefined,<br>    subscription_id: sub.id,<br>    refund_count: 0,<br>    expired: 0,<br>  });<br>  this.store.advanceSubscriptionSchedule(sub.id);<br><br>  const rawBody = planner.buildWebhookRawBody(planned, sub);<br>  await this.dispatcher.dispatch({<br>    storeId: sub.store_id,<br>    subscriptionId: sub.id,<br>    invoiceId: planned.idRaw,<br>    eventType: 'subscription',<br>    rawBody,<br>  });<br>}<br>```<br><br>--- | SubscriptionScheduler.onSubscriptionInvoiceCreated:<br>- Alignment: Fully aligned with the Problem Statement and DS-9-SCHED-2. Must broadcast on-chain create-invoice first, then persist and advance schedule atomically; dispatch webhook after persistence.<br>- Mechanics (order of operations):<br>  1. Input: `ctx = { subscription: subRow, currentHeight: number }`.<br>  2. Instantiate planner with dependencies (`store`, `pricing`, `cfg`, `codec`).<br>  3. Plan invoice using `planner.plan(sub, currentHeight)`:<br>     - Derive `idRaw` (UUID v4), `idHex` (64-hex), `idBuf32` (Uint8Array length 32).<br>     - Validate `idHex` is 64 hex chars and round-trips to 32-byte buffer.<br>     - Compute `usdAtCreate` via `PricingService`.<br>     - Compute `quoteExpiresAtMs = now + QUOTE_TTL_SECONDS*1000`.<br>     - Compute `expiresAtBlocks = currentHeight + ceil(QUOTE_TTL_SECONDS / AVG_BLOCK_SECONDS)`.<br>  4. Broadcast on-chain create-invoice:<br>     - Call `broadcastCreateInvoiceTx({ idBuf32, amountSats: sub.amount_sats, memo: undefined, expiresAtBlocks })`.<br>     - On failure: log and return early (no DB changes, no webhook).<br>  5. Persist in a single DB transaction:<br>     - INSERT invoices row with fields:<br>       - `id_raw`, `id_hex`, `store_id`, `amount_sats`, `usd_at_create`, `quote_expires_at`, `merchant_principal`, `status='unpaid'`, `payer=NULL`, `txid=NULL`, `memo=NULL`, `webhook_url=NULL`, `created_at=nowSecs`, `refunded_at=NULL`, `refund_amount=0`, `refund_txid=NULL`, `subscription_id=sub.id`, `refund_count=0`, `expired=0`.<br>       - Enforce constraints: `CHECK(length(id_hex)=64)`, `GLOB '[0-9A-Fa-f]*'`, unique `ux_invoices_id_hex`.<br>     - UPDATE subscription schedule: `last_billed_at=nowSecs`, `next_invoice_at = sub.next_invoice_at + sub.interval_blocks`. Ensure `mode='invoice'` and `active=1`.<br>     - Commit transaction.<br>  6. Build webhook raw body via `planner.buildWebhookRawBody(planned, sub)`.<br>  7. Dispatch webhook:<br>     - `dispatcher.dispatch({ storeId: sub.store_id, subscriptionId: sub.id, invoiceId: planned.idRaw, eventType: 'subscription', rawBody })`.<br>- Pseudocode:<br>  ```<br>  async function onSubscriptionInvoiceCreated({ subscription: sub, currentHeight }) {<br>    const planner = new SubscriptionInvoicePlanner(store, pricing, cfg, codec);<br>    const planned = await planner.plan(sub, currentHeight); // validates idHex (64-hex) and round-trip<br>    const txid = await broadcastCreateInvoiceTx({<br>      idBuf32: planned.idBuf32,<br>      amountSats: sub.amount_sats,<br>      expiresAtBlocks: planned.expiresAtBlocks,<br>    }); // throws on failure<br><br>    const nowSecs = Math.floor(Date.now() / 1000);<br>    store.db.begin();<br>    try {<br>      store.invoices.insert({<br>        id_raw: planned.idRaw,<br>        id_hex: planned.idHex,<br>        store_id: sub.store_id,<br>        amount_sats: sub.amount_sats,<br>        usd_at_create: planned.usdAtCreate,<br>        quote_expires_at: planned.quoteExpiresAtMs,<br>        merchant_principal: sub.merchant_principal,<br>        status: 'unpaid',<br>        payer: null,<br>        txid: null,<br>        memo: null,<br>        webhook_url: null,<br>        created_at: nowSecs,<br>        refunded_at: null,<br>        refund_amount: 0,<br>        refund_txid: null,<br>        subscription_id: sub.id,<br>        refund_count: 0,<br>        expired: 0,<br>      });<br>      store.advanceSubscriptionSchedule(sub.id); // updates last_billed_at, next_invoice_at<br>      store.db.commit();<br>    } catch (e) {<br>      store.db.rollback();<br>      throw e;<br>    }<br><br>    const rawBody = planner.buildWebhookRawBody(planned, sub);<br>    await dispatcher.dispatch({<br>      storeId: sub.store_id,<br>      subscriptionId: sub.id,<br>      invoiceId: planned.idRaw,<br>      eventType: 'subscription',<br>      rawBody,<br>    });<br>  }<br>  ```<br>- Invariants:<br>  - Do not persist invoice if the on-chain `create-invoice` broadcast fails.<br>  - `invoices.id_hex`, `invoices.merchant_principal`, `invoices.amount_sats` are immutable (DS-3-35).<br>- Failure modes:<br>  - Invalid `idHex` (not 64 hex chars or not round-trippable): abort planning.<br>  - Stacks API failure on broadcast: abort with no DB write.<br>  - Unique constraint violation on `ux_invoices_id_hex`: treat as collision → regenerate or abort this item.<br>  - Partial DB failure: ensure rollback.<br>- Timing/dependencies:<br>  - Requires env: `AVG_BLOCK_SECONDS`, `QUOTE_TTL_SECONDS`.<br>  - Requires Planner, SqliteStore, PricingService, Dispatcher.<br>- Performance:<br>  - O(1) per subscription; dominated by broadcast latency.<br>  - Transaction should complete in ≤ 10 ms locally (excluding I/O).<br><br>--- |
| SubscriptionScheduler | bootstrapScheduler(): void | Registers the in-process scheduler when required env vars are present. Data handling: validates AVG_BLOCK_SECONDS, QUOTE_TTL_SECONDS, POLL_INTERVAL_SECS; computes intervalMs; guards against double registration; sets setInterval(timerCallback, intervalMs). No DB I/O. |  |
| SubscriptionScheduler | processDueSubscriptions(currentHeight: number): Promise<void> | Internal helper to scan and process due subscriptions. Data handling: calls SqliteStore.selectDueSubscriptions(currentHeight) with filters active=1 AND mode='invoice' AND next_invoice_at ≤ currentHeight; for each subscription, executes onSubscriptionInvoiceCreated({ subscription, currentHeight }). Ensures failures are isolated per item. |  |
| SubscriptionScheduler | timerCallback(): void | Bound to setInterval; invokes void tick().catch(logError). No additional logic or state mutation. |  |
| SubscriptionScheduler | broadcastCreateInvoiceTx(input: { idBuf32: Uint8Array; amountSats: number; memo?: string; expiresAtBlocks?: number }): Promise<string> | Builds and broadcasts a create-invoice transaction. Data handling: constructs unsigned payload via IContractCallBuilder.buildCreateInvoice({ idHex: InvoiceIdCodec.hexFromBuff32(idBuf32), amountSats, memo, expiresAtBlock: expiresAtBlocks }); signs with the scheduler’s configured merchant key in test environments if AUTO_BOOTSTRAP_ADMIN is true; broadcasts via @stacks/transactions; returns txid on success; throws on failure. Does not persist; caller persists only on success. | SubscriptionScheduler.broadcastCreateInvoiceTx:<br>- Alignment: Matches Problem Statement’s requirement that invoices must be created on-chain via `create-invoice` and that backend builds transactions with `@stacks/transactions`.<br>- Mechanics:<br>  1. Inputs: `{ idBuf32: Uint8Array(32), amountSats: number > 0, memo?: string, expiresAtBlocks?: number }`.<br>  2. Convert args to Clarity Values:<br>     - `id`: `bufferCV(idBuf32)`; assert `idBuf32.length === 32`.<br>     - `amount`: `uintCV(amountSats)`; assert `amountSats > 0`.<br>     - `memoCV`: `memo ? someCV(bufferCVFromString(memo, max=34)) : noneCV()`.<br>     - `expiresCV`: `typeof expiresAtBlocks === 'number' ? someCV(uintCV(expiresAtBlocks)) : noneCV()`.<br>  3. Build unsigned contract-call options:<br>     - `functionName: 'create-invoice'`.<br>     - `functionArgs: [idCV, amountCV, memoCV, expiresCV]`.<br>     - `contractAddress`, `contractName` from config.<br>     - `network` from env (testnet/mainnet).<br>     - `anchorMode: AnchorMode.Any` (or as required).<br>  4. Signing/broadcast:<br>     - If `AUTO_BOOTSTRAP_ADMIN=true`: sign with configured scheduler private key (test environments only).<br>     - Else: throw or return an error indicating broadcasting is disabled.<br>     - Broadcast via `broadcastTransaction(signedTx, network)`.<br>     - Verify acceptance: check `txid` returned and response OK.<br>  5. Return `txid` string on success.<br>- Pseudocode:<br>  ```<br>  async function broadcastCreateInvoiceTx({ idBuf32, amountSats, memo, expiresAtBlocks }) {<br>    assert(idBuf32 instanceof Uint8Array && idBuf32.length === 32);<br>    assert(Number.isInteger(amountSats) && amountSats > 0);<br><br>    const idCV = bufferCV(idBuf32);<br>    const amountCV = uintCV(amountSats);<br>    const memoCV = memo ? someCV(bufferCVFromString(memo, 34)) : noneCV();<br>    const expiresCV = typeof expiresAtBlocks === 'number' ? someCV(uintCV(expiresAtBlocks)) : noneCV();<br><br>    const opts = {<br>      contractAddress: cfg.contractAddress,<br>      contractName: cfg.contractName,<br>      functionName: 'create-invoice',<br>      functionArgs: [idCV, amountCV, memoCV, expiresCV],<br>      network: cfg.network,<br>      senderKey: cfg.schedulerPrivKey, // only if AUTO_BOOTSTRAP_ADMIN<br>      anchorMode: AnchorMode.Any,<br>    };<br><br>    if (!cfg.AUTO_BOOTSTRAP_ADMIN) throw new Error('AUTO_BOOTSTRAP_ADMIN disabled');<br><br>    const tx = await makeContractCall(opts);<br>    const resp = await broadcastTransaction(tx, cfg.network);<br>    if (!resp or typeof resp.txid !== 'string') throw new Error('Broadcast failed');<br>    return resp.txid;<br>  }<br><br>  function bufferCVFromString(s, maxLen) {<br>    const enc = new TextEncoder().encode(s);<br>    if (enc.length > maxLen) throw new Error('memo too long');<br>    return bufferCV(enc);<br>  }<br>  ```<br>- Gotchas:<br>  - Ensure network matches the deployed contract (426 errors originate at client; here we ensure config parity).<br>  - Memo length cap as per `(buff 34)` assumption.<br>  - Only broadcast after validating inputs.<br>- Performance: CPU trivial; network latency dominates.<br><br>--- |
| CheckoutFrontend | onRouteEnter(evt?: Event): Promise<void> | Startup handler executed on DOMContentLoaded. Data handling: parses invoiceId from location.pathname (/i/:invoiceId); calls clearTimers(); resets in-memory UI state (invoice=null, store=null, status='loading', banners/errors cleared); fetches invoice JSON via GET /i/:invoiceId with Accept: application/json; if 404, renders not-found and aborts; else validates response fields (camelCase, includes idHex 64-hex, quoteExpiresAt ms, amountSats integer), stores state, renders branding (displayName/logoUrl/brandColor), starts countdown setInterval(1s) to update expiry, and starts status poll setInterval(15–30s) while status=='unpaid'. Ensures wallet action buttons are disabled if expired/canceled/paid. | CheckoutFrontend.onRouteEnter:<br>- Alignment: Matches DS-4-ROUTE-1 and DS-4-QR-1.<br>- Mechanics:<br>  1. Parse `invoiceId` from `location.pathname` expecting `/i/:invoiceId` (UUID).<br>  2. Call `clearTimers()` to stop any prior countdown/poll intervals.<br>  3. Call `resetUiState()` to clear DOM and local state (invoice/store, banners, errors) and show loading.<br>  4. Fetch invoice JSON:<br>     - `await fetchInvoiceJson(invoiceId, { signal: optionalAbortSignal })`.<br>     - Set `Accept: application/json`.<br>  5. Branch:<br>     - If 404: `renderNotFound()`; return.<br>     - Else: `handleInvoiceResponse(json)`.<br>- Pseudocode:<br>  ```<br>  async function onRouteEnter() {<br>    const invoiceId = extractIdFromPath(location.pathname); // '/i/<id>'<br>    clearTimers();<br>    resetUiState();<br>    try {<br>      const dto = await fetchInvoiceJson(invoiceId);<br>      await handleInvoiceResponse(dto);<br>    } catch (e) {<br>      if (isHttpStatus(e, 404)) { renderNotFound(); return; }<br>      banner('Failed to load invoice', 'error');<br>    }<br>  }<br>  ```<br>- Edge cases:<br>  - Malformed path: show not-found.<br>  - In-flight fetch on reload: optional AbortController to cancel previous request.<br>- Invariants:<br>  - No wallet invocation here; user must click Open Wallet.<br><br>--- |
| CheckoutFrontend | clearTimers(): void | Clears countdown and status polling intervals if set, using window.clearInterval for both countdownIntervalId and pollIntervalId; resets handle references to undefined. Ensures no duplicate timers on route changes or reloads. |  |
| CheckoutFrontend | resetUiState(): void | Clears all transient UI state (invoice, store, status badge, banners/errors), shows loading spinner, re-enables default controls. Does not start or stop timers; caller must manage timers. Ensures no stale DOM content remains before new data is loaded. |  |
| CheckoutFrontend | fetchInvoiceJson(invoiceId: string, opts?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> | <br>fetchInvoiceJson(invoiceId, opts?): Promise<PublicInvoiceDTO> proxies to PublicCheckoutApiClient.<br><br>External delegate calls:<br>- this._api.fetchInvoiceJson(invoiceId, opts)<br><br>Implementation snippet:<br><br>```ts<br>async fetchInvoiceJson(invoiceId: string, opts?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> {<br>  return this._api.fetchInvoiceJson(invoiceId, opts);<br>}<br>```<br><br> |  |
| CheckoutFrontend | renderNotFound(): void | Replaces checkout container with a “Not found” view, clears loading indicators, and disables payment interactions. Ensures all existing timers are cleared by the caller; this method only handles DOM state. |  |
| CheckoutFrontend | onRouteChange(): Promise<void> | Reads invoiceId from location.pathname, clears existing timers (by calling a higher-level clearTimers owned by the component), calls resetUiState(), then invokes fetchInvoiceJson(invoiceId). On 404 calls renderNotFound(); on success calls handleInvoiceResponse(json). Ensures no stale in-flight requests by coordinating with an external AbortController if present. | CheckoutFrontend.onRouteChange:<br>- Alignment: Matches DS-4-ROUTE-2.<br>- Mechanics:<br>  1. Read `invoiceId` from `location.pathname`.<br>  2. `clearTimers()` to stop countdown/poll.<br>  3. `resetUiState()` to clear UI state and show loading.<br>  4. Cancel any in-flight fetch using an AbortController (if used).<br>  5. Fetch invoice: `const dto = await fetchInvoiceJson(invoiceId, { signal })`.<br>  6. Branch:<br>     - 404 → `renderNotFound()`.<br>     - Else → `handleInvoiceResponse(dto)`.<br>- Pseudocode:<br>  ```<br>  async function onRouteChange() {<br>    const invoiceId = extractIdFromPath(location.pathname);<br>    clearTimers();<br>    resetUiState();<br>    const ctrl = new AbortController();<br>    try {<br>      const dto = await fetchInvoiceJson(invoiceId, { signal: ctrl.signal });<br>      await handleInvoiceResponse(dto);<br>    } catch (e) {<br>      if (isHttpStatus(e, 404)) { renderNotFound(); return; }<br>      banner('Failed to load invoice', 'error');<br>    }<br>  }<br>  ```<br>- Gotchas:<br>  - Ensure no overlapping intervals remain after route change.<br><br>--- |
| CheckoutFrontend | handleInvoiceResponse(invoice: PublicInvoiceDTO): Promise<void> | Applies invoice fields to local state; updates status via setStatusBadge(invoice.status). If invoice.store is present uses applyBranding(invoice.store); else fetches StorePublicProfileDTO via fetchStorePublicProfile(invoice.storeId) and applies branding. If status === 'unpaid': renders QR, shows Open Wallet button, starts countdown (startCountdown(invoice.quoteExpiresAt)) and status poll (startPoll(invoice.invoiceId)). Otherwise calls disablePaymentActions(). | CheckoutFrontend.handleInvoiceResponse:<br>- Alignment: Matches DS-4-HTTP-1 and frontend UI specs.<br>- Mechanics:<br>  1. Validate payload:<br>     - Required fields: `invoiceId`, `storeId`, `status`, `amountSats` (int), `quoteExpiresAt` (ms), `idHex` (64-hex).<br>     - `status ∈ { 'unpaid', 'paid', 'canceled', 'expired' }`.<br>  2. Set local state: `this.state.invoice = dto; this.state.store = dto.store or null`.<br>  3. Update status badge: `setStatusBadge(dto.status)`.<br>  4. Branding:<br>     - If `dto.store` present → `applyBranding(dto.store)`.<br>     - Else → `const profile = await fetchStorePublicProfile(dto.storeId); applyBranding(profile)`.<br>  5. Conditional UI:<br>     - If `status === 'unpaid'`:<br>       - `renderQr(dto.invoiceId)`.<br>       - Show Open Wallet button.<br>       - `startCountdown(dto.quoteExpiresAt)`.<br>       - `startPoll(dto.invoiceId, 15000)` (15–30s acceptable).<br>     - Else:<br>       - `disablePaymentActions()`.<br>- Pseudocode:<br>  ```<br>  async function handleInvoiceResponse(dto) {<br>    assertValidInvoiceDTO(dto);<br>    this.state.invoice = dto;<br>    setStatusBadge(dto.status);<br><br>    if (dto.store) applyBranding(dto.store);<br>    else applyBranding(await fetchStorePublicProfile(dto.storeId));<br><br>    if (dto.status === 'unpaid') {<br>      renderQr(dto.invoiceId);<br>      show('#openWallet');<br>      startCountdown(dto.quoteExpiresAt);<br>      startPoll(dto.invoiceId, 15000);<br>    } else {<br>      disablePaymentActions();<br>    }<br>  }<br>  ```<br>- Edge cases:<br>  - If `quoteExpiresAt` already in the past, countdown should immediately expire via delegate’s onExpire.<br>- Invariants:<br>  - UI uses camelCase; API guaranteed to provide camelCase per public endpoints.<br><br>--- |
| CheckoutFrontend | setStatusBadge(status: InvoiceStatus): void | <br>setStatusBadge(status): void maps UI styling via StatusBadgeDelegate.<br><br>External delegate calls:<br>- this._badge.setStatusBadge(status, '#statusBadge')<br><br>Implementation snippet:<br><br>```ts<br>setStatusBadge(status: InvoiceStatus): void {<br>  this._badge.setStatusBadge(status, '#statusBadge');<br>}<br>```<br><br> |  |
| CheckoutFrontend | fetchStorePublicProfile(storeId: string, opts?: { signal?: AbortSignal }): Promise<StorePublicProfileDTO> | <br>fetchStorePublicProfile(storeId, opts?): Promise<StorePublicProfileDTO> proxies to PublicCheckoutApiClient.<br><br>External delegate calls:<br>- this._api.fetchStorePublicProfile(storeId, opts)<br><br>Implementation snippet:<br><br>```ts<br>async fetchStorePublicProfile(storeId: string, opts?: { signal?: AbortSignal }): Promise<StorePublicProfileDTO> {<br>  return this._api.fetchStorePublicProfile(storeId, opts);<br>}<br>```<br><br> |  |
| CheckoutFrontend | renderQr(invoiceId: string): void | <br>renderQr(invoiceId): void delegates placeholder rendering to QrRenderDelegate.<br><br>External delegate calls:<br>- this._qr.renderInvoiceLink('#qrCanvas', invoiceId)<br><br>Implementation snippet:<br><br>```ts<br>renderQr(invoiceId: string): void {<br>  this._qr.renderInvoiceLink('#qrCanvas', invoiceId);<br>}<br>```<br><br> |  |
| CheckoutFrontend | startCountdown(quoteExpiresAtMs: number): void | <br>startCountdown(quoteExpiresAtMs: number): void binds renderCountdown as onTick and an expiry handler that updates status badge, disables actions, and shows expired view. The delegate owns the timer.<br><br>External delegate calls:<br>- this._countdown.start(quoteExpiresAtMs, onTick, onExpire)<br><br>Implementation snippet:<br><br>```ts<br>startCountdown(quoteExpiresAtMs: number): void {<br>  this._countdown.start(<br>    quoteExpiresAtMs,<br>    (timeLeftMs) => this.renderCountdown(timeLeftMs),<br>    () => { this.setStatusBadge('expired'); this.disablePaymentActions(); show('#expiredView'); }<br>  );<br>}<br>```<br><br> | CheckoutFrontend.startCountdown:<br>- Alignment: Matches DS-4-TIMER-1 and DS-4-HTTP-1.<br>- Mechanics:<br>  1. Input: `quoteExpiresAtMs` (epoch ms when quote expires).<br>  2. Delegate start:<br>     - `this._countdown.start(quoteExpiresAtMs, onTick, onExpire)`.<br>     - `onTick = (timeLeftMs) => renderCountdown(timeLeftMs)`.<br>     - `onExpire = () => { setStatusBadge('expired'); disablePaymentActions(); show('#expiredView'); }`.<br>- Pseudocode:<br>  ```<br>  function startCountdown(quoteExpiresAtMs) {<br>    this._countdown.start(<br>      quoteExpiresAtMs,<br>      (timeLeftMs) => renderCountdown(timeLeftMs),<br>      () => { setStatusBadge('expired'); disablePaymentActions(); show('#expiredView'); }<br>    );<br>  }<br>  ```<br>- Edge cases:<br>  - If current time ≥ `quoteExpiresAtMs`, delegate should trigger onExpire immediately and clear its timer.<br><br>--- |
| CheckoutFrontend | startPoll(invoiceId: string, intervalMs?: number): void | <br>startPoll(invoiceId: string, intervalMs = 15000): void starts guarded polling using the delegate; fetcher is PublicCheckoutApiClient.fetchInvoiceJson and handler is handlePoll.<br><br>External delegate calls:<br>- this._poller.start(invoiceId, intervalMs, fetcher, handler)<br><br>Implementation snippet:<br><br>```ts<br>startPoll(invoiceId: string, intervalMs: number = 15000): void {<br>  const client = this._api;<br>  this._poller.start(<br>    invoiceId,<br>    intervalMs,<br>    (id, signal) => client.fetchInvoiceJson(id, { signal }),<br>    (dto) => this.handlePoll(dto)<br>  );<br>}<br>```<br><br> |  |
| CheckoutFrontend | disablePaymentActions(): void | <br>disablePaymentActions(): void delegates to PaymentActionsDelegate.<br><br>External delegate calls:<br>- this._actions.disablePaymentActions()<br><br>Implementation snippet:<br><br>```ts<br>disablePaymentActions(): void {<br>  this._actions.disablePaymentActions();<br>}<br>```<br><br> |  |
| CheckoutFrontend | applyBranding(profile: StorePublicProfileDTO): void | <br>applyBranding(profile): void applies theme + header via StoreBrandingDelegate.<br><br>External delegate calls:<br>- this._branding.applyBranding(profile)<br><br>Implementation snippet:<br><br>```ts<br>applyBranding(profile: StorePublicProfileDTO): void {<br>  this._branding.applyBranding(profile);<br>}<br>```<br><br> |  |
| CheckoutFrontend | updateHeader(displayName?: string, logoUrl?: string): void | <br>updateHeader(displayName?, logoUrl?): void delegates to StoreBrandingDelegate.<br><br>External delegate calls:<br>- this._branding.updateHeader(displayName, logoUrl)<br><br>Implementation snippet:<br><br>```ts<br>updateHeader(displayName?: string, logoUrl?: string): void {<br>  this._branding.updateHeader(displayName, logoUrl);<br>}<br>```<br><br> |  |
| CheckoutFrontend | onOpenWallet(): Promise<void> | <br>onOpenWallet(): Promise<void> uses WalletContractCallDelegate.getProvider to gate, then proceeds to requestCreateTx and handleCreateTxResponse.<br><br>External delegate calls:<br>- this._wallet.getProvider()<br><br>Implementation snippet:<br><br>```ts<br>async onOpenWallet(): Promise<void> {<br>  const provider = this._wallet.getProvider();<br>  if (!provider) { this.banner('Wallet not connected', 'error'); return; }<br>  if (!state.invoice) return;<br>  const res = await this.requestCreateTx(state.invoice.invoiceId);<br>  await this.handleCreateTxResponse(res);<br>}<br>```<br><br> | CheckoutFrontend.onOpenWallet:<br>- Alignment: Matches DS-4-UI-1.<br>- Mechanics:<br>  1. Ensure Stacks provider exists:<br>     - `const provider = this._wallet.getProvider(); if (!provider) { banner('Wallet not connected', 'error'); return; }`.<br>  2. Ensure invoice is loaded: `if (!this.state.invoice) return;`.<br>  3. Request unsigned tx payload:<br>     - `const res = await requestCreateTx(this.state.invoice.invoiceId)`.<br>  4. Pass response to handler:<br>     - `await handleCreateTxResponse(res)`.<br>- Pseudocode:<br>  ```<br>  async function onOpenWallet() {<br>    const provider = this._wallet.getProvider();<br>    if (!provider) { banner('Wallet not connected', 'error'); return; }<br>    if (!this.state.invoice) return;<br>    const res = await requestCreateTx(this.state.invoice.invoiceId);<br>    await handleCreateTxResponse(res);<br>  }<br>  ```<br>- Edge cases:<br>  - Prevent double-clicks by disabling button early if desired; final disablement happens on `onTxFinish`.<br><br>--- |
| CheckoutFrontend | getStacksProvider(): (Window & typeof globalThis)['StacksProvider'] or null | <br>getStacksProvider(): returns WalletContractCallDelegate.getProvider result.<br><br>External delegate calls:<br>- this._wallet.getProvider()<br><br>Implementation snippet:<br><br>```ts<br>getStacksProvider(): (Window & typeof globalThis)['StacksProvider'] or null {<br>  return this._wallet.getProvider();<br>}<br>```<br><br> |  |
| CheckoutFrontend | requestCreateTx(invoiceId: string): Promise<Response> | POSTs /create-tx with JSON { invoiceId }. Sets Content-Type: application/json. No additional headers required. Returns raw Response for downstream mapping in handleCreateTxResponse. Does not parse or mutate the payload. |  |
| CheckoutFrontend | banner(message: string, type?: 'info' or 'success' or 'error'): void | <br>banner(message, type?): void displays via BannerDelegate.<br><br>External delegate calls:<br>- this._banner.show(message, type, '#banner')<br><br>Implementation snippet:<br><br>```ts<br>banner(message: string, type: 'info' or 'success' or 'error' = 'info'): void {<br>  this._banner.show(message, type, '#banner');<br>}<br>```<br><br>--- |  |
| CheckoutFrontend | handleCreateTxResponse(res: Response): Promise<void> | If res.ok, parses JSON UnsignedContractCall and calls invokeWalletOpenContractCall(payload). Else maps res.status to user-facing messages: 404 (not found), 409 (invalid state), 400 (invalid id), 422 (merchant inactive or missing sBTC token), 426 (wrong network). Prevents wallet invocation on errors. | CheckoutFrontend.handleCreateTxResponse:<br>- Alignment: Matches DS-4-HTTP-3 and error mapping requirements.<br>- Mechanics:<br>  1. Input: `res: Response`.<br>  2. If `res.ok`:<br>     - `const payload = await res.json()`; validate shape for UnsignedContractCall (function name `pay-invoice`, contract details, args, post-conditions).<br>     - `await invokeWalletOpenContractCall(payload)`.<br>  3. Else map status to banner and abort:<br>     - 404 → `banner('Invoice not found', 'error')`.<br>     - 409 → `banner('Invoice cannot be paid (already paid, canceled, or expired)', 'error')`.<br>     - 400 → `banner('Invalid invoice ID', 'error')`.<br>     - 422 → `banner('Merchant inactive or sBTC token not configured', 'error')`.<br>     - 426 → `banner('Wrong network selected in wallet', 'error')`.<br>     - default → `banner('Failed to prepare transaction', 'error')`.<br>- Pseudocode:<br>  ```<br>  async function handleCreateTxResponse(res) {<br>    if (res.ok) {<br>      const payload = await res.json();<br>      await invokeWalletOpenContractCall(payload);<br>      return;<br>    }<br>    switch (res.status) {<br>      case 404: banner('Invoice not found', 'error'); break;<br>      case 409: banner('Invoice cannot be paid (already paid, canceled, or expired)', 'error'); break;<br>      case 400: banner('Invalid invoice ID', 'error'); break;<br>      case 422: banner('Merchant inactive or sBTC token not configured', 'error'); break;<br>      case 426: banner('Wrong network selected in wallet', 'error'); break;<br>      default: banner('Failed to prepare transaction', 'error');<br>    }<br>  }<br>  ```<br>- Invariants:<br>  - Do not open wallet on any error status.<br><br>--- |
| CheckoutFrontend | invokeWalletOpenContractCall(payload: UnsignedContractCall): Promise<void> | <br>invokeWalletOpenContractCall(payload): Promise<void> opens wallet via delegate and wires parent callbacks.<br><br>External delegate calls:<br>- this._wallet.openUnsignedContractCall(payload, onFinish, onCancel)<br><br>Implementation snippet:<br><br>```ts<br>async invokeWalletOpenContractCall(payload: UnsignedContractCall): Promise<void> {<br>  await this._wallet.openUnsignedContractCall(<br>    payload,<br>    (tx) => this.onTxFinish(tx),<br>    () => this.onTxCancel()<br>  );<br>}<br>```<br><br> |  |
| CheckoutFrontend | onTxFinish(tx?: unknown): void | <br>onTxFinish(tx?): void delegates banner and button disabling to WalletContractCallDelegate.<br><br>External delegate calls:<br>- this._wallet.onFinish(this.banner.bind(this), () => this.disableOpenWallet(), tx)<br><br>Implementation snippet:<br><br>```ts<br>onTxFinish(tx?: unknown): void {<br>  this._wallet.onFinish(this.banner.bind(this), () => this.disableOpenWallet(), tx);<br>}<br>```<br><br> |  |
| CheckoutFrontend | disableOpenWallet(): void | <br>disableOpenWallet(): void disables the button via delegate DOM utility.<br><br>External delegate calls:<br>- this._wallet.disableOpenWallet('#openWallet')<br><br>Implementation snippet:<br><br>```ts<br>disableOpenWallet(): void {<br>  this._wallet.disableOpenWallet('#openWallet');<br>}<br>```<br><br> |  |
| CheckoutFrontend | onTxCancel(): void | <br>onTxCancel(): void shows banner via delegate.<br><br>External delegate calls:<br>- this._wallet.onCancel(this.banner.bind(this))<br><br>Implementation snippet:<br><br>```ts<br>onTxCancel(): void {<br>  this._wallet.onCancel(this.banner.bind(this));<br>}<br>```<br><br> |  |
| CheckoutFrontend | handlePoll(fresh: PublicInvoiceDTO): void | Processes polled invoice: if status === 'paid', updates badge, shows confirmation banner, disables actions, and clears countdown/poll timers. If status === 'expired' or 'canceled', updates badge, disables actions, clears timers. Otherwise leaves timers active. Never flips to paid without server confirmation. | CheckoutFrontend.handlePoll:<br>- Alignment: Matches DS-4-HTTP-4.<br>- Mechanics:<br>  1. Input: `fresh: PublicInvoiceDTO`.<br>  2. If `fresh.status === 'paid'`:<br>     - `setStatusBadge('paid')`.<br>     - `banner('Payment confirmed', 'success')`.<br>     - `disablePaymentActions()`.<br>     - `clearTimers()` via delegates (countdown + poll).<br>  3. Else if `fresh.status === 'expired' or fresh.status === 'canceled'`:<br>     - `setStatusBadge(fresh.status)`.<br>     - `disablePaymentActions()`.<br>     - `clearTimers()`.<br>  4. Else (still unpaid):<br>     - Leave timers active; update any dynamic UI as needed (optional).<br>- Pseudocode:<br>  ```<br>  function handlePoll(fresh) {<br>    if (fresh.status === 'paid') {<br>      setStatusBadge('paid');<br>      banner('Payment confirmed', 'success');<br>      disablePaymentActions();<br>      clearTimers();<br>      return;<br>    }<br>    if (fresh.status === 'expired' or fresh.status === 'canceled') {<br>      setStatusBadge(fresh.status);<br>      disablePaymentActions();<br>      clearTimers();<br>    }<br>  }<br>  ```<br>- Invariants:<br>  - Never mark paid without server-confirmed status.<br>- Edge cases:<br>  - If countdown already expired, ensure consistent UI by disabling actions even if poll says unpaid (expiry wins for UX).<br><br>--- |
| CheckoutFrontend | updateCountdown(): void | <br>updateCountdown(): void forces a tick on the countdown delegate.<br><br>External delegate calls:<br>- this._countdown.forceTick()<br><br>Implementation snippet:<br><br>```ts<br>updateCountdown(): void {<br>  this._countdown.forceTick();<br>}<br>```<br><br> |  |
| CheckoutFrontend | renderCountdown(timeLeftMs: number): void | <br>renderCountdown(timeLeftMs: number): void remains a pure DOM update; used as onTick callback.<br><br>Implementation snippet:<br><br>```ts<br>renderCountdown(timeLeftMs: number): void {<br>  const node = document.querySelector('#countdown') as HTMLElement or null;<br>  if (!node) return;<br>  const totalSeconds = Math.floor(timeLeftMs / 1000);<br>  const m = Math.floor(totalSeconds / 60);<br>  const s = totalSeconds % 60;<br>  node.textContent = `${m}:${s.toString().padStart(2, '0')}`;<br>  if (timeLeftMs <= HIGHLIGHT_THRESHOLD_MS) node.classList.add('expiring'); else node.classList.remove('expiring');<br>}<br>```<br><br> |  |
| CheckoutFrontend | handleExpiry(): void | <br>handleExpiry(): void triggers the one-shot expiry behavior via delegate.<br><br>External delegate calls:<br>- this._countdown.expireNow()<br><br>Implementation snippet:<br><br>```ts<br>handleExpiry(): void {<br>  this._countdown.expireNow();<br>}<br>```<br><br> |  |
| CheckoutFrontend | pollStatus(): Promise<void> | <br>pollStatus(): Promise<void> executes a single guarded tick through the delegate.<br><br>External delegate calls:<br>- this._poller.tick()<br><br>Implementation snippet:<br><br>```ts<br>async pollStatus(): Promise<void> {<br>  await this._poller.tick();<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | handleCreateInvoice(e: React.FormEvent<HTMLFormElement>): Promise<void> | <br>handleCreateInvoice(e): Promise<void> validates fields, builds snake_case body via RequestShapeAdapter, POSTs via MerchantApiHttpClient.requestJson, updates list using InvoiceListViewModel.<br><br>External delegate calls:<br>- requestShapeAdapter.toSnake(...)<br>- http.setContext({ storeId, apiKey })<br>- http.requestJson<PublicInvoiceDTO>(...)<br>- listVm.setData(...)<br>- listVm.updateAfterCreate(created)<br><br>Implementation snippet:<br><br>```ts<br>async handleCreateInvoice(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  const fd = new FormData(e.currentTarget);<br>  const amountSats = parseInt(String(fd.get('amountSats') ?? '0'), 10);<br>  const ttlSeconds = parseInt(String(fd.get('ttlSeconds') ?? '0'), 10);<br>  const memo = fd.get('memo') ? String(fd.get('memo')) : undefined;<br>  const webhookUrl = fd.get('webhookUrl') ? String(fd.get('webhookUrl')) : undefined;<br>  if (memo) { const bytes = new TextEncoder().encode(memo); if (bytes.length > 34) throw new Error('memo must be ≤ 34 bytes (UTF-8).'); }<br>  http.setContext({ storeId: state.storeId, apiKey: state.apiKey });<br>  const body = requestShapeAdapter.toSnake({ amountSats, ttlSeconds, memo, webhookUrl });<br>  const created = await http.requestJson<PublicInvoiceDTO>(<br>    `/api/v1/stores/${state.storeId}/invoices`,<br>    { method: 'POST', headers: http.buildHeaders(true), body: JSON.stringify(body) },<br>    this.onErrorAuthGate,<br>  );<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.updateAfterCreate(created);<br>  state.invoices = invoices; state.filteredInvoices = filtered; state.refetchKey++;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | toSnake<T extends Record<string, any>>(camel: T): Record<string, any> | <br>toSnake(camel): Record<string, any> delegates to RequestShapeAdapter.toSnake.<br><br>External delegate calls:<br>- requestShapeAdapter.toSnake(camel)<br><br>Implementation snippet:<br><br>```ts<br>toSnake<T extends Record<string, any>>(camel: T): Record<string, any> {<br>  return requestShapeAdapter.toSnake(camel);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | updateInvoicesList(created: PublicInvoiceDTO): void | <br>updateInvoicesList(created): void uses InvoiceListViewModel to sync local lists.<br><br>External delegate calls:<br>- listVm.setData(...)<br>- listVm.updateAfterCreate(created)<br><br>Implementation snippet:<br><br>```ts<br>updateInvoicesList(created: PublicInvoiceDTO): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.updateAfterCreate(created);<br>  state.invoices = invoices;<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | onCancelInvoice(invoiceId: string): Promise<void> | <br>onCancelInvoice(invoiceId): Promise<void> performs POST using MerchantApiHttpClient and updates local status.<br><br>External delegate calls:<br>- http.setContext(...)<br>- http.requestJson<void>(..., { expectJson: false })<br><br>Implementation snippet:<br><br>```ts<br>async onCancelInvoice(invoiceId: string): Promise<void> {<br>  http.setContext({ storeId: state.storeId, apiKey: state.apiKey });<br>  await http.requestJson<void>(<br>    `/api/v1/stores/${state.storeId}/invoices/${invoiceId}/cancel`,<br>    { method: 'POST', headers: http.buildHeaders(false), expectJson: false as any } as any,<br>    this.onErrorAuthGate,<br>  );<br>  this.setInvoiceStatus(invoiceId, 'canceled');<br>  state.refetchKey++;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | setInvoiceStatus(invoiceId: string, status: InvoiceStatus): void | <br>setInvoiceStatus(invoiceId, status): void delegates to InvoiceListViewModel.<br><br>External delegate calls:<br>- listVm.setData(...)<br>- listVm.setStatus(invoiceId, status)<br><br>Implementation snippet:<br><br>```ts<br>setInvoiceStatus(invoiceId: string, status: InvoiceStatus): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.setStatus(invoiceId, status);<br>  state.invoices = invoices; state.filteredInvoices = filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | openRefundDialog(invoice: PublicInvoiceDTO): void | <br>openRefundDialog(invoice): void opens via RefundFlowCoordinator.<br><br>External delegate calls:<br>- refundFlow.openDialog(invoice)<br><br>Implementation snippet:<br><br>```ts<br>openRefundDialog(invoice: PublicInvoiceDTO): void {<br>  state.refundDialog = refundFlow.openDialog(invoice);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | handleRefundSubmit(e: React.FormEvent<HTMLFormElement>): Promise<void> | <br>handleRefundSubmit(e): Promise<void> delegates to RefundFlowCoordinator.submit and optionally invokes wallet through RefundFlowCoordinator.invokeWallet.<br><br>External delegate calls:<br>- refundFlow.submit(...)<br>- refundFlow.invokeWallet(unsignedCall, { onFinish, onCancel })<br><br>Implementation snippet:<br><br>```ts<br>async handleRefundSubmit(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  const { newState, unsignedCall } = await refundFlow.submit(<br>    e.currentTarget as HTMLFormElement,<br>    state.refundDialog,<br>    state.storeId,<br>    http,<br>    this.onErrorAuthGate,<br>    requestShapeAdapter.toSnake.bind(requestShapeAdapter),<br>  );<br>  state.refundDialog = newState;<br>  if (unsignedCall) {<br>    refundFlow.invokeWallet(unsignedCall, {<br>      onFinish: (tx?: unknown) => this.onRefundTxFinish(tx),<br>      onCancel: () => this.onRefundTxCancel(),<br>    });<br>  }<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | invokeWalletOpenContractCall(payload: UnsignedContractCall): Promise<void> | <br>invokeWalletOpenContractCall(payload): Promise<void> delegates to RefundFlowCoordinator.invokeWallet with parent’s callbacks.<br><br>External delegate calls:<br>- refundFlow.invokeWallet(payload, handlers)<br><br>Implementation snippet:<br><br>```ts<br>async invokeWalletOpenContractCall(payload: UnsignedContractCall): Promise<void> {<br>  refundFlow.invokeWallet(payload, {<br>    onFinish: (tx?: unknown) => this.onRefundTxFinish(tx),<br>    onCancel: () => this.onRefundTxCancel(),<br>  });<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | onRefundTxFinish(tx?: unknown): void | <br>onRefundTxFinish(tx?): void updates dialog state via RefundFlowCoordinator.onFinish and triggers refetch.<br><br>External delegate calls:<br>- refundFlow.onFinish(state.refundDialog)<br><br>Implementation snippet:<br><br>```ts<br>onRefundTxFinish(_tx?: unknown): void {<br>  const out = refundFlow.onFinish(state.refundDialog);<br>  state.refundDialog = out.newState;<br>  if (out.shouldRefetch) state.refetchKey++;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | onRefundTxCancel(): void | <br>onRefundTxCancel(): void updates dialog state via RefundFlowCoordinator.onCancel.<br><br>External delegate calls:<br>- refundFlow.onCancel(state.refundDialog)<br><br>Implementation snippet:<br><br>```ts<br>onRefundTxCancel(): void {<br>  state.refundDialog = refundFlow.onCancel(state.refundDialog);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | closeRefundDialog(): void | <br>closeRefundDialog(): void delegates to RefundFlowCoordinator.closeDialog.<br><br>External delegate calls:<br>- refundFlow.closeDialog()<br><br>Implementation snippet:<br><br>```ts<br>closeRefundDialog(): void {<br>  state.refundDialog = refundFlow.closeDialog();<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | handleCreateSubscription(e: React.FormEvent<HTMLFormElement>): Promise<void> | Prevents default; validates subscriber principal format, amount_sats > 0, interval_blocks > 0; builds snake_case body; POSTs /api/v1/stores/:storeId/subscriptions with X-API-Key. On 200, prepends returned subscription (camelCase) and resets form. On 4xx, maps validation errors to UI. | SubscriptionsCoordinator.create (invoked by this method) must enforce Problem Statement and Requirements alignment:<br>- Must validate `subscriber` is a principal, `amount_sats > 0`, `interval_blocks > 0`, and `mode ∈ {'invoice','direct'}`.<br>- Must POST body in snake_case with header `X-API-Key: apiKey`.<br>- Response is camelCase; UI state must be updated accordingly.<br><br>Mechanics:<br>1) Prevent default form submit.<br>2) Parse input fields from `HTMLFormElement`:<br>   - `subscriber` (string principal)<br>   - `amountSats` (number, integer > 0)<br>   - `intervalBlocks` (number, integer > 0)<br>   - `mode` ("invoice" or "direct")<br>3) Validate:<br>   - `validatePrincipal(subscriber) === true`<br>   - `Number.isInteger(amountSats) && amountSats > 0`<br>   - `Number.isInteger(intervalBlocks) && intervalBlocks > 0`<br>   - `mode` is one of the allowed values<br>   - On any failure, set local validation errors and return early.<br>4) HTTP setup:<br>   - `http.setContext({ storeId, apiKey })`<br>   - Build snake_case body via `toSnake({ subscriber, amountSats, intervalBlocks, mode })`<br>   - `POST /api/v1/stores/:storeId/subscriptions` with `Content-Type: application/json` and `X-API-Key`.<br>5) On 200/201:<br>   - Prepend returned subscription into `state.subscriptions`<br>   - Reset form values<br>   - Bump `refetchKey` to refresh downstream views if needed<br>6) On 401/403:<br>   - Call `onErrorAuthGate(err)`; it will gate UI and rethrow.<br>7) On other 4xx:<br>   - Map server validation messages to local UI state (e.g., inline error strings).<br>8) Return.<br><br>Data touched:<br>- `state.subscriptions` (mutable, append/prepend)<br>- `state.refetchKey` (mutable counter)<br><br>Pseudocode:<br>```ts<br>async function handleCreateSubscription(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  const form = e.currentTarget;<br>  const fd = new FormData(form);<br>  const subscriber = String(fd.get('subscriber') ?? '').trim();<br>  const amountSats = parseInt(String(fd.get('amountSats') ?? '0'), 10);<br>  const intervalBlocks = parseInt(String(fd.get('intervalBlocks') ?? '0'), 10);<br>  const mode = String(fd.get('mode') ?? 'invoice');<br><br>  if (!subsCoord.validatePrincipal(subscriber)) { setLocalError('Invalid principal'); return; }<br>  if (!Number.isInteger(amountSats) or amountSats <= 0) { setLocalError('amountSats must be > 0'); return; }<br>  if (!Number.isInteger(intervalBlocks) or intervalBlocks <= 0) { setLocalError('intervalBlocks must be > 0'); return; }<br>  if (mode !== 'invoice' && mode !== 'direct') { setLocalError('Invalid mode'); return; }<br><br>  http.setContext({ storeId: state.storeId, apiKey: state.apiKey });<br>  const body = requestShapeAdapter.toSnake({ subscriber, amountSats, intervalBlocks, mode });<br><br>  try {<br>    const created = await http.requestJson<any>(<br>      `/api/v1/stores/${state.storeId}/subscriptions`,<br>      { method: 'POST', headers: http.buildHeaders(true), body: JSON.stringify(body) },<br>      this.onErrorAuthGate,<br>    );<br>    state.subscriptions = [created, ...(state.subscriptions ?? [])];<br>    form.reset();<br>    state.refetchKey++;<br>  } catch (err) {<br>    if (!isAuth(err)) mapValidationErrors(err, setLocalError);<br>    throw err;<br>  }<br>}<br>```<br><br>Gotchas / Failure modes:<br>- Incorrect principal format (use `validatePrincipal`).<br>- Negative or zero `amountSats`/`intervalBlocks`.<br>- Missing `X-API-Key` header.<br>- Forgetting camelCase→snake_case conversion.<br>- Not handling non-auth 4xx gracefully.<br><br>Alignment:<br>- Matches merchant API and subscription mode requirement (DS-5-USER-6, Merchant API endpoints).<br>- Uses camelCase responses, snake_case requests (DS-5-22).<br><br>--- |
| MerchantDashboardFrontend | validatePrincipal(address: string): boolean | <br>validatePrincipal(address): boolean delegates to SubscriptionsCoordinator.validatePrincipal.<br><br>External delegate calls:<br>- subsCoord.validatePrincipal(address)<br><br>Implementation snippet:<br><br>```ts<br>validatePrincipal(address: string): boolean {<br>  return subsCoord.validatePrincipal(address);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | generateInvoiceForSubscription(id: string): Promise<void> | <br>generateInvoiceForSubscription(id): Promise<void> delegates to SubscriptionsCoordinator.generateInvoice and associateInvoiceToSub, then sync invoices view via InvoiceListViewModel.<br><br>External delegate calls:<br>- subsCoord.generateInvoice(...)<br>- subsCoord.associateInvoiceToSub(...)<br>- listVm.updateAfterCreate(invoice)<br><br>Implementation snippet:<br><br>```ts<br>async generateInvoiceForSubscription(id: string): Promise<void> {<br>  subsCoord.setData(state.subscriptions);<br>  const { invoice } = await subsCoord.generateInvoice(id, state.storeId, http, this.onErrorAuthGate);<br>  state.subscriptions = subsCoord.associateInvoiceToSub(id, invoice);<br>  state.refetchKey++;<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.updateAfterCreate(invoice);<br>  state.invoices = invoices; state.filteredInvoices = filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | associateInvoiceToSubscription(subId: string, invoice: PublicInvoiceDTO): void | <br>associateInvoiceToSubscription(subId, invoice): void delegates to SubscriptionsCoordinator and updates invoices list via InvoiceListViewModel.<br><br>External delegate calls:<br>- subsCoord.associateInvoiceToSub(...)<br>- listVm.updateAfterCreate(invoice)<br><br>Implementation snippet:<br><br>```ts<br>associateInvoiceToSubscription(subId: string, invoice: PublicInvoiceDTO): void {<br>  subsCoord.setData(state.subscriptions);<br>  state.subscriptions = subsCoord.associateInvoiceToSub(subId, invoice);<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { invoices, filtered } = listVm.updateAfterCreate(invoice);<br>  state.invoices = invoices; state.filteredInvoices = filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | cancelSubscription(id: string): Promise<void> | <br>cancelSubscription(id): Promise<void> delegates to SubscriptionsCoordinator.cancel and patches local list.<br><br>External delegate calls:<br>- subsCoord.cancel(id, storeId, http, onAuthError)<br><br>Implementation snippet:<br><br>```ts<br>async cancelSubscription(id: string): Promise<void> {<br>  subsCoord.setData(state.subscriptions);<br>  state.subscriptions = await subsCoord.cancel(id, state.storeId, http, this.onErrorAuthGate);<br>  state.refetchKey++;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | setSubscriptionActive(id: string, active: boolean): void | <br>setSubscriptionActive(id, active): void updates local list via SubscriptionsCoordinator.setActive.<br><br>External delegate calls:<br>- subsCoord.setActive(id, active)<br><br>Implementation snippet:<br><br>```ts<br>setSubscriptionActive(id: string, active: boolean): void {<br>  subsCoord.setData(state.subscriptions);<br>  state.subscriptions = subsCoord.setActive(id, active);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | handleSaveStoreSettings(e: React.FormEvent<HTMLFormElement>): Promise<void> | <br>handleSaveStoreSettings(e): Promise<void> delegates form parsing and PATCH to StoreProfileCoordinator.save.<br><br>External delegate calls:<br>- storeProfileCoord.save(formEl, storeId, http, onAuthError, toSnake)<br><br>Implementation snippet:<br><br>```ts<br>async handleSaveStoreSettings(e: React.FormEvent<HTMLFormElement>): Promise<void> {<br>  e.preventDefault();<br>  storeProfileCoord.setProfileLocal(state.profile);<br>  const prof = await storeProfileCoord.save(<br>    e.currentTarget as HTMLFormElement,<br>    state.storeId,<br>    http,<br>    this.onErrorAuthGate,<br>    requestShapeAdapter.toSnake.bind(requestShapeAdapter),<br>  );<br>  this.setProfile(prof);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | setProfile(profile: StorePrivateProfileDTO): void | <br>setProfile(profile): void delegates to StoreProfileCoordinator.setProfileLocal then updates state.<br><br>External delegate calls:<br>- storeProfileCoord.setProfileLocal(profile)<br><br>Implementation snippet:<br><br>```ts<br>setProfile(profile: StorePrivateProfileDTO): void {<br>  storeProfileCoord.setProfileLocal(profile);<br>  state.profile = profile;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | testWebhook(): Promise<void> | <br>testWebhook(): Promise<void> delegates to WebhookConsoleCoordinator and updates state.testResult + refresh logs.<br><br>External delegate calls:<br>- webhookCoord.test(storeId, http, onAuthError)<br>- webhookCoord.fetchLogs(...)<br><br>Implementation snippet:<br><br>```ts<br>async testWebhook(): Promise<void> {<br>  webhookCoord.setData(state.webhookLogs, state.testResult);<br>  const res = await webhookCoord.test(state.storeId, http, this.onErrorAuthGate);<br>  state.testResult = res;<br>  state.webhookLogs = await webhookCoord.fetchLogs(state.storeId, http, this.onErrorAuthGate);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | setTestResult(result: 'success' or 'failure'): void | <br>setTestResult(result): void uses WebhookConsoleCoordinator.setTestResult.<br><br>External delegate calls:<br>- webhookCoord.setTestResult(result)<br><br>Implementation snippet:<br><br>```ts<br>setTestResult(result: 'success' or 'failure'): void {<br>  webhookCoord.setData(state.webhookLogs, state.testResult);<br>  state.testResult = webhookCoord.setTestResult(result);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | fetchWebhookLogs(invoiceIdFilter?: string): Promise<void> | <br>fetchWebhookLogs(invoiceIdFilter?): Promise<void> delegates to WebhookConsoleCoordinator.fetchLogs and caps to latest 100 rows.<br><br>External delegate calls:<br>- webhookCoord.fetchLogs(storeId, http, onAuthError, invoiceIdFilter)<br><br>Implementation snippet:<br><br>```ts<br>async fetchWebhookLogs(invoiceIdFilter?: string): Promise<void> {<br>  webhookCoord.setData(state.webhookLogs, state.testResult);<br>  state.webhookLogs = await webhookCoord.fetchLogs(state.storeId, http, this.onErrorAuthGate, invoiceIdFilter);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | rotateKeys(): Promise<void> | <br>rotateKeys(): Promise<void> delegates POST rotate and sets one-time secrets via KeyRotationCoordinator.<br><br>External delegate calls:<br>- keyRotator.rotate(storeId, http, onAuthError)<br>- keyRotator.show(secrets)<br><br>Implementation snippet:<br><br>```ts<br>async rotateKeys(): Promise<void> {<br>  const secrets = await keyRotator.rotate(state.storeId, http, this.onErrorAuthGate);<br>  state.oneTimeSecrets = keyRotator.show(secrets);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | showOneTimeSecretsModal(secrets: { apiKey: string; hmacSecret: string }): void | <br>showOneTimeSecretsModal(secrets): void delegates to KeyRotationCoordinator.show.<br><br>External delegate calls:<br>- keyRotator.show(secrets)<br><br>Implementation snippet:<br><br>```ts<br>showOneTimeSecretsModal(secrets: { apiKey: string; hmacSecret: string }): void {<br>  state.oneTimeSecrets = keyRotator.show(secrets);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | clearOneTimeSecrets(): void | <br>clearOneTimeSecrets(): void clears via KeyRotationCoordinator.clear.<br><br>External delegate calls:<br>- keyRotator.clear()<br><br>Implementation snippet:<br><br>```ts<br>clearOneTimeSecrets(): void {<br>  state.oneTimeSecrets = keyRotator.clear();<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | toggleSort(field: 'createdAt'): void | <br>toggleSort(field: 'createdAt'): void flips via InvoiceListViewModel.toggleSort and re-applies sorting.<br><br>External delegate calls:<br>- listVm.toggleSort()<br>- listVm.sortByCreatedAt(newDir)<br><br>Implementation snippet:<br><br>```ts<br>toggleSort(field: 'createdAt'): void {<br>  if (field !== 'createdAt') return;<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const newDir = listVm.toggleSort();<br>  state.sortDirection = newDir;<br>  state.filteredInvoices = listVm.sortByCreatedAt(newDir).filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | sortInvoicesByCreatedAt(direction: 'asc' or 'desc'): void | <br>sortInvoicesByCreatedAt(direction): void delegates to InvoiceListViewModel.sortByCreatedAt.<br><br>External delegate calls:<br>- listVm.sortByCreatedAt(direction)<br><br>Implementation snippet:<br><br>```ts<br>sortInvoicesByCreatedAt(direction: 'asc' or 'desc'): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { filtered } = listVm.sortByCreatedAt(direction);<br>  state.filteredInvoices = filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | applyInvoiceStatusFilter(value: InvoiceStatus or 'all'): void | <br>applyInvoiceStatusFilter(value): void delegates to InvoiceListViewModel.applyFilter and then sorts.<br><br>External delegate calls:<br>- listVm.applyFilter(value)<br>- listVm.sortByCreatedAt(state.sortDirection)<br><br>Implementation snippet:<br><br>```ts<br>applyInvoiceStatusFilter(value: InvoiceStatus or 'all'): void {<br>  listVm.setData(state.invoices, state.filteredInvoices, state.sortDirection);<br>  const { filtered } = listVm.applyFilter(value);<br>  state.filteredInvoices = listVm.sortByCreatedAt(state.sortDirection).filtered;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | setFilteredInvoices(list: PublicInvoiceDTO[]): void | <br>setFilteredInvoices(list): void assigns list (delegates manage filtering/sorting elsewhere).<br><br>Implementation snippet:<br><br>```ts<br>setFilteredInvoices(list: PublicInvoiceDTO[]): void {<br>  state.filteredInvoices = list;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | exportCsv(): void | <br>exportCsv(): void delegates to InvoiceListViewModel.exportCsv over currently visible rows.<br><br>External delegate calls:<br>- listVm.exportCsv(rows)<br><br>Implementation snippet:<br><br>```ts<br>exportCsv(): void {<br>  const rows = state.filteredInvoices.map((i) => ({<br>    invoiceId: i.invoiceId,<br>    amountSats: i.amountSats,<br>    usdAtCreate: i.usdAtCreate,<br>    status: i.status,<br>    txId: i.txId ?? '',<br>    createdAt: i.createdAt,<br>    refundAmount: i.refundAmount ?? '',<br>    refundTxId: i.refundTxId ?? '',<br>  }));<br>  listVm.exportCsv(rows as any);<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | toCsv(rows: Array<{ invoiceId: string; amountSats: number; usdAtCreate: number; status: InvoiceStatus; txId?: string; createdAt: number; refundAmount?: number; refundTxId?: string }>): string | <br>toCsv(rows): string delegates to InvoiceListViewModel.toCsv.<br><br>External delegate calls:<br>- listVm.toCsv(rows)<br><br>Implementation snippet:<br><br>```ts<br>toCsv(rows: Array<{ invoiceId: string; amountSats: number; usdAtCreate: number; status: InvoiceStatus; txId?: string; createdAt: number; refundAmount?: number; refundTxId?: string }>): string {<br>  return listVm.toCsv(rows as any);<br>}<br>```<br><br>--- |  |
| MerchantDashboardFrontend | openInExplorer(txId: string): void | Builds explorer URL from environment (e.g., EXPLORER_BASE_URL) and opens window.open(url, '_blank', 'noopener'). Validates txId presence; no network calls. |  |
| MerchantDashboardFrontend | fetchInvoices(storeId: string, apiKey: string, options?: { status?: InvoiceStatus; signal?: AbortSignal }): Promise<PublicInvoiceDTO[]> | <br>fetchInvoices(storeId, apiKey, options?): Promise<PublicInvoiceDTO[]> uses MerchantApiHttpClient to GET invoices, then updates lists and sorts via InvoiceListViewModel.<br><br>External delegate calls:<br>- http.setContext({ storeId, apiKey })<br>- http.requestJson<PublicInvoiceDTO[]>(...)<br>- listVm.sortByCreatedAt(direction)<br><br>Implementation snippet:<br><br>```ts<br>async fetchInvoices(storeId: string, apiKey: string, options?: { status?: InvoiceStatus; signal?: AbortSignal }): Promise<PublicInvoiceDTO[]> {<br>  http.setContext({ storeId, apiKey });<br>  const q = options?.status ? `?status=${encodeURIComponent(options.status)}` : '';<br>  const rows = await http.requestJson<PublicInvoiceDTO[]>(<br>    `/api/v1/stores/${storeId}/invoices${q}`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  state.invoices = rows; state.filteredInvoices = rows;<br>  this.sortInvoicesByCreatedAt(state.sortDirection);<br>  return rows;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | onErrorAuthGate(error: unknown): never | Centralized interceptor for merchant-scoped HTTP errors. If error represents an HTTP 401 or 403 from Merchant API routes, sets UI auth-gated state (e.g., setAuthError(true)), disables actionable controls, and throws to stop the promise chain. Must not log secrets. Clears gate only after subsequent successful authenticated requests elsewhere. | Auth-gating must isolate Merchant API failures (401/403) and set UI state to block actions until a valid API key is provided. Must not log secrets. Aligns with DS-5-SYS-9.<br><br>Mechanics:<br>1) Accept `error` from HTTP client interceptor (axios/fetch wrapper).<br>2) Detect if error is an HTTP response for Merchant API (paths starting with `/api/v1/stores/`), with `status ∈ {401,403}`.<br>3) If matched:<br>   - Set UI state: `state.authError = true`<br>   - Disable actionable controls (forms/buttons) in the UI layer (controlled by `state.authError`).<br>   - Optionally clear transient submitting flags.<br>   - Rethrow to stop current promise chain.<br>4) Else:<br>   - Rethrow without changing auth state.<br>5) Secrets hygiene:<br>   - Do not log request bodies or headers.<br>   - Do not print `X-API-Key` or any token.<br><br>Pseudocode:<br>```ts<br>function onErrorAuthGate(err: unknown): never {<br>  const isHttp = (e: any) => e && (e.status or e.response?.status);<br>  const status = (err as any)?.response?.status ?? (err as any)?.status;<br>  const url: string or undefined = (err as any)?.config?.url ?? (err as any)?.response?.config?.url;<br><br>  const isMerchantRoute = typeof url === 'string' && url.startsWith('/api/v1/stores/');<br>  if (isHttp(err) && isMerchantRoute && (status === 401 or status === 403)) {<br>    state.authError = true; // UI must render gated state and prompt for API key<br>    // Any in-flight submitting flags are cleared by respective coordinators if needed<br>    throw err;<br>  }<br>  throw err;<br>}<br>```<br><br>Edge cases:<br>- Network errors with no `status`: rethrow (do not gate).<br>- Admin endpoints (`/api/admin/*`): do not set merchant auth gate here.<br>- Multiple concurrent requests: first failure gates UI; subsequent will also fail until key updated.<br><br>Invariant:<br>- No secrets are logged or stored beyond necessary in-memory UI state.<br><br>--- |
| MerchantDashboardFrontend | fetchInvoice(storeId: string, invoiceId: string, apiKey: string, options?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> | <br>fetchInvoice(storeId, invoiceId, apiKey, options?): Promise<PublicInvoiceDTO> uses MerchantApiHttpClient and updates state.invoiceDetail.<br><br>External delegate calls:<br>- http.setContext(...)<br>- http.requestJson<PublicInvoiceDTO>(...)<br><br>Implementation snippet:<br><br>```ts<br>async fetchInvoice(storeId: string, invoiceId: string, apiKey: string, options?: { signal?: AbortSignal }): Promise<PublicInvoiceDTO> {<br>  http.setContext({ storeId, apiKey });<br>  const dto = await http.requestJson<PublicInvoiceDTO>(<br>    `/api/v1/stores/${storeId}/invoices/${invoiceId}`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  state.invoiceDetail = dto;<br>  return dto;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | fetchSubscriptions(storeId: string, apiKey: string, options?: { signal?: AbortSignal }): Promise<Array<{ id: string; subscriber: string; amountSats: number; intervalBlocks: number; active: boolean; nextInvoiceAt: number; lastBilledAt?: number; mode: SubscriptionMode }>> | <br>fetchSubscriptions(...): Promise<...> GETs via http, updates subscriptions list.<br><br>External delegate calls:<br>- http.setContext(...)<br>- http.requestJson<...>(...)<br><br>Implementation snippet:<br><br>```ts<br>async fetchSubscriptions(storeId: string, apiKey: string, options?: { signal?: AbortSignal }): Promise<Array<{ id: string; subscriber: string; amountSats: number; intervalBlocks: number; active: boolean; nextInvoiceAt: number; lastBilledAt?: number; mode: SubscriptionMode }>> {<br>  http.setContext({ storeId, apiKey });<br>  const rows = await http.requestJson<Array<{ id: string; subscriber: string; amountSats: number; intervalBlocks: number; active: boolean; nextInvoiceAt: number; lastBilledAt?: number; mode: SubscriptionMode }>>(<br>    `/api/v1/stores/${storeId}/subscriptions`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br>  state.subscriptions = rows;<br>  return rows;<br>}<br>```<br><br> |  |
| MerchantDashboardFrontend | fetchStoreProfile(storeId: string, apiKey: string, options?: { signal?: AbortSignal }): Promise<StorePrivateProfileDTO> | Issues GET /api/v1/stores/:storeId/profile with X-API-Key. Expects camelCase StorePrivateProfileDTO. Returns parsed profile and should apply to UI state. On 401/403, call onErrorAuthGate. Ensure allowedOrigins rendered as list while DB persists CSV. | Fetch must return the full private store profile for dashboard usage. Response is camelCase; ensure `allowedOrigins` is represented as an array in UI even if backend persists CSV. Aligns with DS-5-22 and DS-5-SYS-4.<br><br>Mechanics:<br>1) Input: `storeId`, `apiKey`, optional `AbortSignal`.<br>2) Set HTTP context: `http.setContext({ storeId, apiKey })`.<br>3) GET `/api/v1/stores/:storeId/profile` with headers:<br>   - `X-API-Key: apiKey`<br>   - `Accept: application/json`<br>4) On 200:<br>   - Normalize `allowedOrigins` to an array for UI:<br>     - If the field is a string (CSV or newline-delimited), split on commas/newlines, trim entries, drop empties.<br>     - If already an array, keep as-is.<br>   - Delegate to `storeProfileCoord.setProfileLocal(profile)` to persist in UI state.<br>   - Return the normalized profile object.<br>5) On 401/403:<br>   - Call `onErrorAuthGate(err)`; it will gate UI and rethrow.<br>6) Propagate any other error.<br><br>Pseudocode:<br>```ts<br>async function fetchStoreProfile(<br>  storeId: string,<br>  apiKey: string,<br>  options?: { signal?: AbortSignal }<br>): Promise<StorePrivateProfileDTO> {<br>  http.setContext({ storeId, apiKey });<br>  const prof = await http.requestJson<any>(<br>    `/api/v1/stores/${storeId}/profile`,<br>    { headers: http.buildHeaders(false), signal: options?.signal },<br>    this.onErrorAuthGate,<br>  );<br><br>  const normalizeAllowed = (v: unknown): string[] => {<br>    if (Array.isArray(v)) return v.filter(Boolean).map(s => String(s).trim()).filter(s => s.length > 0);<br>    if (typeof v === 'string') {<br>      return v.split(/[\n,]/g).map(s => s.trim()).filter(s => s.length > 0);<br>    }<br>    return [];<br>    };<br>  prof.allowedOrigins = normalizeAllowed(prof.allowedOrigins);<br><br>  storeProfileCoord.setProfileLocal(prof);<br>  state.profile = prof;<br>  return prof;<br>}<br>```<br><br>Edge cases:<br>- Missing `allowedOrigins` → default to `[]`.<br>- Large lists → UI should still render; no performance constraints here.<br>- Ensure camelCase keys maintained in UI; do not snake_case responses.<br><br>Invariant:<br>- Only GET; no secret fields (apiKey/hmacSecret) are leaked by the UI render from this method.<br><br>--- |
| MerchantDashboardFrontend | refetch(ctx: { view: 'invoices' or 'invoice' or 'subscriptions' or 'webhooks'; storeId: string; apiKey: string; invoiceId?: string; invoiceIdFilter?: string; signal?: AbortSignal }): Promise<void> | Central reload orchestrator. Switches by ctx.view to chain the appropriate fetch method with provided identifiers and signal. After each fetch resolves, reconciles optimistic flags like refundPending with server data. Must not alter returned DTO shapes; only hydrate UI. Propagates errors via onErrorAuthGate for 401/403 while keeping prior state. | Central reload orchestrator that re-issues the appropriate GET(s) depending on current view and reconciles optimistic flags (e.g., refund pending). Aligns with DS-5-SYS-8.<br><br>Mechanics:<br>1) Input `ctx`:<br>   - `view`: 'invoices' or 'invoice' or 'subscriptions' or 'webhooks'<br>   - `storeId`, `apiKey`<br>   - Optional: `invoiceId`, `invoiceIdFilter`, `signal`<br>2) Switch on `ctx.view` and call the corresponding fetch method:<br>   - 'invoices' → `fetchInvoices(storeId, apiKey, { signal })`<br>   - 'invoice' → require `invoiceId` then `fetchInvoice(storeId, invoiceId, apiKey, { signal })`<br>   - 'subscriptions' → `fetchSubscriptions(storeId, apiKey, { signal })`<br>   - 'webhooks' → `fetchWebhookLogs(invoiceIdFilter)`<br>3) After the fetch resolves, reconcile optimistic flags:<br>   - If `state.refundDialog?.refundPending === true` and the target invoice status is now 'refunded' or `refundTxId` exists, clear `refundPending` and close dialog.<br>   - Ensure UI reflects authoritative server state while preserving camelCase fields.<br>4) Errors:<br>   - On 401/403, `onErrorAuthGate` will gate UI and rethrow.<br>   - Other errors surface to caller.<br><br>Pseudocode:<br>```ts<br>async function refetch(ctx: {<br>  view: 'invoices' or 'invoice' or 'subscriptions' or 'webhooks';<br>  storeId: string; apiKey: string;<br>  invoiceId?: string; invoiceIdFilter?: string; signal?: AbortSignal;<br>}): Promise<void> {<br>  switch (ctx.view) {<br>    case 'invoices':<br>      await this.fetchInvoices(ctx.storeId, ctx.apiKey, { signal: ctx.signal });<br>      break;<br>    case 'invoice':<br>      if (!ctx.invoiceId) throw new Error('invoiceId required for view=invoice');<br>      await this.fetchInvoice(ctx.storeId, ctx.invoiceId, ctx.apiKey, { signal: ctx.signal });<br>      break;<br>    case 'subscriptions':<br>      await this.fetchSubscriptions(ctx.storeId, ctx.apiKey, { signal: ctx.signal });<br>      break;<br>    case 'webhooks':<br>      await this.fetchWebhookLogs(ctx.invoiceIdFilter);<br>      break;<br>    default:<br>      return;<br>  }<br><br>  // Reconcile optimistic refund flags<br>  const inv = state.invoiceDetail or state.invoices?.find(i => i.invoiceId === ctx.invoiceId);<br>  if (state.refundDialog?.refundPending && inv) {<br>    const refunded = !!inv.refundTxId or inv.status === 'refunded';<br>    if (refunded) state.refundDialog = refundFlow.closeDialog();<br>  }<br>}<br>```<br><br>Edge cases:<br>- Missing `invoiceId` for 'invoice' view must throw early.<br>- Concurrent refetches: last write wins for UI state.<br>- Avoid mutating DTO shapes: keep camelCase intact.<br><br>Invariant:<br>- This method does not alter server-derived DTO shapes; it only hydrates UI state and resolves optimistic markers.<br><br>--- |
| MerchantDashboardFrontend | setSubscriptionMode(storeId: string, subId: string, mode: SubscriptionMode, apiKey: string): Promise<{ id: string; mode: SubscriptionMode }> | <br>setSubscriptionMode(storeId, subId, mode, apiKey): Promise<{ id, mode }> uses http + SubscriptionsCoordinator.setMode and updates local list.<br><br>External delegate calls:<br>- http.setContext({ storeId, apiKey })<br>- subsCoord.setMode(storeId, subId, mode, http, onAuthError)<br><br>Implementation snippet:<br><br>```ts<br>async setSubscriptionMode(storeId: string, subId: string, mode: SubscriptionMode, apiKey: string): Promise<{ id: string; mode: SubscriptionMode }> {<br>  http.setContext({ storeId, apiKey });<br>  subsCoord.setData(state.subscriptions);<br>  const resp = await subsCoord.setMode(storeId, subId, mode, http, this.onErrorAuthGate);<br>  state.subscriptions = resp.newList;<br>  state.refetchKey++;<br>  return resp.confirmed;<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onCreateStoreSubmit(e: Event, form: { principal: string; name?: string; display_name?: string; logo_url?: string; brand_color?: string; webhook_url?: string; support_email?: string; support_url?: string; allowed_origins?: string }, authHeader: string): Promise<void> | <br>onCreateStoreSubmit(e, form, authHeader): Promise<void> validates principal via AdminInputValidator, maps body via AdminStoreFormAdapter, and POSTs via AdminHttpClient.<br><br>External delegate calls:<br>- AdminInputValidator.assertStacksAddress(form.principal, 'principal')<br>- AdminStoreFormAdapter.toCreateStoreBody(form)<br>- AdminHttpClient.request('/stores', ...)<br>- AdminHttpClient.parseJson(resp)<br><br>Implementation snippet:<br><br>```ts<br>async onCreateStoreSubmit(e: Event, form: { principal: string; name?: string; display_name?: string; logo_url?: string; brand_color?: string; webhook_url?: string; support_email?: string; support_url?: string; allowed_origins?: string }, authHeader: string): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertStacksAddress(form.principal, 'principal');<br>  const body = AdminStoreFormAdapter.toCreateStoreBody(form);<br>  const resp = await AdminHttpClient.request('/stores', { method: 'POST', authHeader, jsonBody: body });<br>  if (resp.status === 201) { await AdminHttpClient.parseJson(resp); return; }<br>  if (resp.status === 409) throw new Error('conflict');<br>  throw new Error(`create_store_failed_${resp.status}`);<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onActivateToggle(storeId: string, active: boolean, authHeader: string): Promise<void> | <br>onActivateToggle(storeId, active, authHeader): Promise<void> validates UUID, PATCHes via AdminHttpClient, parses JSON on success.<br><br>External delegate calls:<br>- AdminInputValidator.assertUuid(storeId, 'storeId')<br>- AdminHttpClient.request(`/stores/${storeId}/activate`, ...)<br><br>Implementation snippet:<br><br>```ts<br>async onActivateToggle(storeId: string, active: boolean, authHeader: string): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/activate`, { method: 'PATCH', authHeader, jsonBody: { active } });<br>  if (resp.ok) { await AdminHttpClient.parseJson(resp); return; }<br>  throw new Error(`activate_toggle_failed_${resp.status}`);<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onRotateKeysClick(storeId: string, authHeader: string): Promise<{ apiKey: string; hmacSecret: string }> | <br>onRotateKeysClick(storeId, authHeader): Promise<{ apiKey, hmacSecret }> validates UUID, POSTs rotate, and returns parsed secrets.<br><br>External delegate calls:<br>- AdminInputValidator.assertUuid(storeId, 'storeId')<br>- AdminHttpClient.request(`/stores/${storeId}/rotate-keys`, ...)<br><br>Implementation snippet:<br><br>```ts<br>async onRotateKeysClick(storeId: string, authHeader: string): Promise<{ apiKey: string; hmacSecret: string }> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/rotate-keys`, { method: 'POST', authHeader });<br>  if (!resp.ok) throw new Error(`rotate_keys_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ apiKey: string; hmacSecret: string }>(resp);<br>  return { apiKey: String(json.apiKey), hmacSecret: String(json.hmacSecret) };<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onSyncOnchainClick(storeId: string, authHeader: string, openContractCall: (call: any) => Promise<void>): Promise<void> | <br>onSyncOnchainClick(storeId, authHeader, openContractCall): Promise<void> validates UUID, requests calls, executes sequentially via AdminContractCallSequencer.<br><br>External delegate calls:<br>- AdminInputValidator.assertUuid(storeId, 'storeId')<br>- AdminHttpClient.request(`/stores/${storeId}/sync-onchain`, ...)<br>- AdminHttpClient.parseJson<{ calls: any[] }>(...)<br>- AdminContractCallSequencer.runSequential(calls, openContractCall)<br><br>Implementation snippet:<br><br>```ts<br>async onSyncOnchainClick(storeId: string, authHeader: string, openContractCall: (call: any) => Promise<void>): Promise<void> {<br>  AdminInputValidator.assertUuid(storeId, 'storeId');<br>  const resp = await AdminHttpClient.request(`/stores/${storeId}/sync-onchain`, { method: 'POST', authHeader });<br>  if (!resp.ok) throw new Error(`sync_onchain_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ calls: any[] }>(resp);<br>  await AdminContractCallSequencer.runSequential(Array.isArray(json.calls) ? json.calls : [], openContractCall);<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onSetSbtcTokenSubmit(e: Event, form: { contractAddress: string; contractName: string }, authHeader: string, openContractCall: (call: any) => Promise<void>): Promise<void> | <br>onSetSbtcTokenSubmit(e, form, authHeader, openContractCall): Promise<void> validates contract pair via AdminInputValidator, requests unsigned call, executes single call via sequencer.<br><br>External delegate calls:<br>- AdminInputValidator.assertContractPrincipalPair(form.contractAddress, form.contractName)<br>- AdminHttpClient.request('/set-sbtc-token', ...)<br>- AdminContractCallSequencer.runSingle(json.call, openContractCall)<br><br>Implementation snippet:<br><br>```ts<br>async onSetSbtcTokenSubmit(e: Event, form: { contractAddress: string; contractName: string }, authHeader: string, openContractCall: (call: any) => Promise<void>): Promise<void> {<br>  e.preventDefault();<br>  AdminInputValidator.assertContractPrincipalPair(form.contractAddress, form.contractName);<br>  const resp = await AdminHttpClient.request('/set-sbtc-token', { method: 'POST', authHeader, jsonBody: { contractAddress: form.contractAddress, contractName: form.contractName } });<br>  if (!resp.ok) throw new Error(`set_sbtc_token_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ call: any }>(resp);<br>  await AdminContractCallSequencer.runSingle(json.call, openContractCall);<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onRestartPollerClick(authHeader: string): Promise<{ running: boolean }> | <br>onRestartPollerClick(authHeader): Promise<{ running: boolean }> POSTs restart and parses { running }.<br><br>External delegate calls:<br>- AdminHttpClient.request('/poller/restart', { method: 'POST', authHeader })<br>- AdminHttpClient.parseJson<{ running: boolean }>(resp)<br><br>Implementation snippet:<br><br>```ts<br>async onRestartPollerClick(authHeader: string): Promise<{ running: boolean }> {<br>  const resp = await AdminHttpClient.request('/poller/restart', { method: 'POST', authHeader });<br>  if (!resp.ok) throw new Error(`restart_poller_failed_${resp.status}`);<br>  const json = await AdminHttpClient.parseJson<{ running: boolean }>(resp);<br>  return { running: !!json.running };<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onRetryWebhookClick(webhookLogId: string, authHeader: string): Promise<void> | <br>onRetryWebhookClick(webhookLogId, authHeader): Promise<void> validates UUID and POSTs retry.<br><br>External delegate calls:<br>- AdminInputValidator.assertUuid(webhookLogId, 'webhookLogId')<br>- AdminHttpClient.request('/webhooks/retry', ...)<br><br>Implementation snippet:<br><br>```ts<br>async onRetryWebhookClick(webhookLogId: string, authHeader: string): Promise<void> {<br>  AdminInputValidator.assertUuid(webhookLogId, 'webhookLogId');<br>  const resp = await AdminHttpClient.request('/webhooks/retry', { method: 'POST', authHeader, jsonBody: { webhookLogId } });<br>  if (resp.status === 200 or resp.status === 202) return;<br>  throw new Error(`retry_webhook_failed_${resp.status}`);<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onCancelInvoiceClick(invoiceId: string, authHeader: string, maybeBuildOnchainCancel: () => Promise<any or undefined>, openContractCall: (call: any) => Promise<void>): Promise<void> | <br>onCancelInvoiceClick(invoiceId, authHeader, maybeBuildOnchainCancel, openContractCall): Promise<void> validates UUID, POSTs cancel, handles 400 mapping, optionally executes helper wallet call via sequencer.<br><br>External delegate calls:<br>- AdminInputValidator.assertUuid(invoiceId, 'invoiceId')<br>- AdminHttpClient.request(`/invoices/${invoiceId}/cancel`, ...)<br>- AdminContractCallSequencer.runSingle(cancelCall, openContractCall)<br><br>Implementation snippet:<br><br>```ts<br>async onCancelInvoiceClick(invoiceId: string, authHeader: string, maybeBuildOnchainCancel: () => Promise<any or undefined>, openContractCall: (call: any) => Promise<void>): Promise<void> {<br>  AdminInputValidator.assertUuid(invoiceId, 'invoiceId');<br>  const resp = await AdminHttpClient.request(`/invoices/${invoiceId}/cancel`, { method: 'POST', authHeader });<br>  if (resp.status === 400) {<br>    const j = await AdminHttpClient.parseJson<{ error?: string }>(resp);<br>    if (j?.error === 'already_paid') throw new Error('already_paid');<br>    throw new Error('cancel_invoice_bad_request');<br>  }<br>  if (!resp.ok) throw new Error(`cancel_invoice_failed_${resp.status}`);<br>  await AdminHttpClient.parseJson(resp);<br>  const cancelCall = await maybeBuildOnchainCancel();<br>  if (cancelCall) await AdminContractCallSequencer.runSingle(cancelCall, openContractCall);<br>}<br>```<br><br> |  |
| AdminConsoleFrontend | onBootstrapAdminClick(authHeader: string, buildCall: () => Promise<any>, openContractCall: (call: any) => Promise<void>, verifyGetAdmin: () => Promise<boolean>): Promise<void> | <br>onBootstrapAdminClick(authHeader, buildCall, openContractCall, verifyGetAdmin): Promise<void> executes single call via sequencer and verifies via provided callback.<br><br>External delegate calls:<br>- AdminContractCallSequencer.runSingle(call, openContractCall)<br><br>Implementation snippet:<br><br>```ts<br>async onBootstrapAdminClick(authHeader: string, buildCall: () => Promise<any>, openContractCall: (call: any) => Promise<void>, verifyGetAdmin: () => Promise<boolean>): Promise<void> {<br>  const call = await buildCall();<br>  await AdminContractCallSequencer.runSingle(call, openContractCall);<br>  const ok = await verifyGetAdmin();<br>  if (!ok) throw new Error('bootstrap_admin_verification_failed');<br>}<br>```<br><br>--- |  |
| HttpApiServer | mountAdminAuth(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }): void | <br>mountAdminAuth(app, adminAuth): void delegates guard binding to AdminSurfaceBinder.bindAdminAuth.<br><br>External delegate calls:<br>- this.adminBinder.bindAdminAuth(app, adminAuth)<br><br>Implementation snippet:<br><br>```ts<br>mountAdminAuth(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }): void {<br>  this.adminBinder.bindAdminAuth(app, adminAuth);<br>}<br>```<br><br> |  |
| HttpApiServer | mountAdminStatic(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }, staticMiddleware: import('express').RequestHandler): void | <br>mountAdminStatic(app, adminAuth, staticMiddleware): void binds protected static assets via AdminSurfaceBinder.bindAdminStatic, ensuring guard precedes static.<br><br>External delegate calls:<br>- this.adminBinder.bindAdminStatic(app, adminAuth, staticMiddleware)<br><br>Implementation snippet:<br><br>```ts<br>mountAdminStatic(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }, staticMiddleware: import('express').RequestHandler): void {<br>  this.adminBinder.bindAdminStatic(app, adminAuth, staticMiddleware);<br>}<br>```<br><br> |  |
| HttpApiServer | mountRoot(app: import('express').Express, handler: { getRoot(req: any, res: any): void }): void | <br>mountRoot(app, handler): void binds GET / readiness endpoint once via RootRouteBinder.bindRoot.<br><br>External delegate calls:<br>- this.rootBinder.bindRoot(app, handler)<br><br>Implementation snippet:<br><br>```ts<br>mountRoot(app: import('express').Express, handler: { getRoot(req: any, res: any): void }): void {<br>  this.rootBinder.bindRoot(app, handler);<br>}<br>```<br><br> |  |
| HttpApiServer | mountAdminIndex(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }, serveIndex: (req: any, res: any) => void): void | <br>mountAdminIndex(app, adminAuth, serveIndex): void binds protected SPA index via AdminSurfaceBinder.bindAdminIndex.<br><br>External delegate calls:<br>- this.adminBinder.bindAdminIndex(app, adminAuth, serveIndex)<br><br>Implementation snippet:<br><br>```ts<br>mountAdminIndex(app: import('express').Express, adminAuth: { authenticateAdmin(req: any, res: any, next: any): void }, serveIndex: (req: any, res: any) => void): void {<br>  this.adminBinder.bindAdminIndex(app, adminAuth, serveIndex);<br>}<br>```<br><br> |  |
| HttpApiServer | mountInboundWebhookVerifier(app: import('express').Express, verifierMw: import('express').RequestHandler): void | <br>mountInboundWebhookVerifier(app, verifierMw): void delegates raw-body + verifier chain mounting to WebhookInboundSurfaceBinder.bind.<br><br>External delegate calls:<br>- this.inboundBinder.bind(app, verifierMw)<br><br>Implementation snippet:<br><br>```ts<br>mountInboundWebhookVerifier(app: import('express').Express, verifierMw: import('express').RequestHandler): void {<br>  this.inboundBinder.bind(app, verifierMw);<br>}<br>```<br><br> |  |
| HttpApiServer | start(deps: { app: import('express').Express; poller: { bootstrapPoller(): void }; webhookRetry: { bootstrap(): void }; subscriptionScheduler?: { bootstrapScheduler(): void }; config: IConfigService }): Promise<void> | <br>start(deps): Promise<void> defers scheduler bootstrapping to SchedulerStartupCoordinator.startSchedulers, guaranteeing idempotence across hot reloads.<br><br>External delegate calls:<br>- this.schedulerCoordinator.startSchedulers({ poller, webhookRetry, subscriptionScheduler, config })<br><br>Implementation snippet:<br><br>```ts<br>async start(deps: { app: import('express').Express; poller: { bootstrapPoller(): void }; webhookRetry: { bootstrap(): void }; subscriptionScheduler?: { bootstrapScheduler(): void }; config: IConfigService }): Promise<void> {<br>  await this.schedulerCoordinator.startSchedulers({<br>    poller: deps.poller,<br>    webhookRetry: deps.webhookRetry,<br>    subscriptionScheduler: deps.subscriptionScheduler,<br>    config: deps.config,<br>  });<br>}<br>```<br><br>---<br><br>End of report. |  |
| PostConditionFactory | forRefund(merchantPrincipal: string, amountSats: number or bigint, asset: { contractAddress: string; contractName: string; assetName: string }): any[] | Constructs a single standard fungible post-condition that caps merchant outflow to LessEqual amountSats for the sBTC asset. Returns array with that post-condition to be used with PostConditionMode.Deny. Validates positive integer amount and that asset identifiers are non-empty. No mutation of caller payloads. | PostConditionFactory.forRefund:<br>- Alignment: Fully aligned with Problem Statement and Event Flow DS-3-API-5. It must build a single fungible post-condition capping merchant outflow (LessEqual) for sBTC with PostConditionMode.Deny.<br>- Minimal mechanics:<br>  1. Validate `merchantPrincipal` is a non-empty Stacks principal string.<br>  2. Validate `amountSats` is a positive integer (uint-like; BigInt-safe).<br>  3. Validate `asset.contractAddress`, `asset.contractName`, `asset.assetName` are non-empty strings.<br>  4. Build `assetInfo` using `createAssetInfo`.<br>  5. Build a Standard principal fungible post-condition with `FungibleConditionCode.LessEqual`.<br>  6. Return `[postCondition]`. The caller will set `PostConditionMode.Deny` on the unsigned payload.<br>- Side effects: None. Pure function.<br>- Algorithm/order:<br>  - Convert `amountSats` to `bigint`.<br>  - Construct asset info and then FPC.<br>- Data touched: None (stateless).<br>- Performance: O(1), ≤ 1 ms typical.<br>- Pseudocode:<br>  ```ts<br>  import {<br>    FungibleConditionCode,<br>    createAssetInfo,<br>    makeStandardFungiblePostCondition,<br>  } from '@stacks/transactions';<br><br>  export function forRefund(<br>    merchantPrincipal: string,<br>    amountSats: number or bigint,<br>    asset: { contractAddress: string; contractName: string; assetName: string },<br>  ): any[] {<br>    if (typeof merchantPrincipal !== 'string' or merchantPrincipal.length === 0) {<br>      throw new Error('invalid_merchant_principal');<br>    }<br>    if (typeof asset?.contractAddress !== 'string' or asset.contractAddress.length === 0) {<br>      throw new Error('invalid_contract_address');<br>    }<br>    if (typeof asset?.contractName !== 'string' or asset.contractName.length === 0) {<br>      throw new Error('invalid_contract_name');<br>    }<br>    if (typeof asset?.assetName !== 'string' or asset.assetName.length === 0) {<br>      throw new Error('invalid_asset_name');<br>    }<br>    const amt = typeof amountSats === 'bigint' ? amountSats : BigInt(amountSats);<br>    if (amt <= 0n) throw new Error('invalid_amount');<br><br>    const assetInfo = createAssetInfo(asset.contractAddress, asset.contractName, asset.assetName);<br><br>    const capOutflowPc = makeStandardFungiblePostCondition(<br>      merchantPrincipal,                      // standard principal (merchant)<br>      FungibleConditionCode.LessEqual,        // cap outgoing amount<br>      amt,<br>      assetInfo<br>    );<br>    return [capOutflowPc];<br>  }<br>  ```<br>- Gotchas/failure modes:<br>  - Amount 0 or negative → reject.<br>  - Non-integer numbers → coerce to BigInt or reject if not finite.<br>  - Contract principals as merchant are not supported here (uses Standard PC); ensure merchant is a standard principal.<br>  - Caller must set `postConditionMode: PostConditionMode.Deny` in the unsigned call.<br>- Edge cases:<br>  - Very large amounts must fit BigInt; avoid JS number overflow.<br>  - Empty strings for asset identifiers.<br>- Invariants:<br>  - Does not mutate inputs.<br>  - Returns exactly one FPC.<br>- Timing/dependencies:<br>  - Requires `@stacks/transactions` available at build-time.<br><br>--- |
| PollerAdminBridge | getState(): PollerMetrics | Returns a snapshot of in-memory poller metrics { running, lastRunAt, lastHeight, lastTxId, lastBlockHash, lagBlocks }. No DB access and no side effects. Consumers must treat missing fields as undefined when poller not yet run. |  |
| PollerAdminBridge | restart(): { running: boolean } | Stops existing timer (if any), reinitializes poll loop preserving cursor; returns running=true on success. No DB changes. | PollerAdminBridge.restart:<br>- Alignment: Matches DS-6-SYS-12/97; preserves cursor, restarts loop, no DB changes.<br>- Minimal mechanics:<br>  1. Obtain the poller instance.<br>  2. Stop existing timer/interval if running.<br>  3. Preserve cursor `{ lastHeight, lastTxId, lastBlockHash }` and in-memory metrics.<br>  4. Start a new interval with the same `POLL_INTERVAL_MS`.<br>  5. Update `metrics.running = true` and return `{ running: true }`.<br>- Side effects: Stops and starts an in-process timer; does not touch DB.<br>- Algorithm/order:<br>  - Check `poller.isRunning()`; if true, call `poller.stop()`.<br>  - Call `poller.start({ preserveCursor: true })`.<br>  - Return `{ running: poller.isRunning() }`.<br>- Data touched: In-memory fields on Poller (timer handle, metrics, cursor).<br>- Performance: O(1).<br>- Pseudocode:<br>  ```ts<br>  // Assuming Poller exposes stop(), start(opts), isRunning(), getState()<br>  export class PollerAdminBridge {<br>    constructor(private poller: {<br>      stop: () => void;<br>      start: (opts?: { preserveCursor?: boolean }) => void;<br>      isRunning: () => boolean;<br>      getState: () => { lastRunAt?: number; lastHeight?: number; lastTxId?: string; lastBlockHash?: string; lagBlocks?: number; running: boolean };<br>    }) {}<br><br>    restart(): { running: boolean } {<br>      if (this.poller.isRunning()) {<br>        this.poller.stop(); // clears setInterval and flips running=false<br>      }<br>      this.poller.start({ preserveCursor: true }); // reuses lastHeight/lastTxId/lastBlockHash<br>      return { running: this.poller.isRunning() };<br>    }<br>  }<br>  ```<br>- Gotchas/failure modes:<br>  - Double-restart races: ensure `stop()` clears exactly one interval handle.<br>  - Do not zero out cursor; admin expects continuity and reorg handling to remain intact.<br>  - Ensure `restart()` is idempotent under rapid clicks (debounce at UI is recommended; not implemented here).<br>- Edge cases:<br>  - Restart when not running → just start and return running=true.<br>  - Poller start failure should surface upstream (throw); controller maps to 5xx.<br>- Invariants:<br>  - Cursor is preserved across restarts.<br>  - No DB writes.<br><br>--- |
| ExpirationMonitor | emitInvoiceExpiredWebhook(invoiceId: string, storeId: string, deps: { store: ISqliteStore; dispatcher: IWebhookDispatcher; nowEpochSecs?: number }): Promise<boolean> | Emits a single-shot invoice-expired webhook if not already successfully delivered. Checks idempotence via store.existsSuccessfulDeliveryFor for context { storeId, invoiceId, eventType: 'invoice-expired' }. If none, builds raw JSON payload { invoiceId, status: 'expired' } strictly camelCase, then calls dispatcher.dispatch which persists attempt with HMAC headers. Returns true if dispatched, false if previously delivered. No invoice state mutation here. | ExpirationMonitor.emitInvoiceExpiredWebhook:<br>- Alignment: Matches DS-7-SCHED-2. Emits a one-shot invoice-expired webhook with idempotence guard; no invoice mutation.<br>- Minimal mechanics:<br>  1. Validate inputs `invoiceId`, `storeId` as non-empty strings.<br>  2. Ask store idempotence guard: `store.existsSuccessfulDeliveryFor({ storeId, invoiceId, eventType: 'invoice-expired' })`.<br>  3. If true → return `false` (already delivered).<br>  4. Build payload with strict camelCase: `{ invoiceId, status: 'expired' }`.<br>  5. Compute `ts = nowEpochSecs or Math.floor(Date.now()/1000)`.<br>  6. Call `dispatcher.dispatch({ storeId, eventType: 'invoice-expired', payload, timestamp: ts })`.<br>  7. Return `true` if dispatch attempt was made (irrespective of HTTP outcome, since retry subsystem handles persistence/backoff).<br>- Side effects:<br>  - Creates a delivery attempt in `webhook_logs` via dispatcher.<br>- Algorithm/order:<br>  - Guard → Build payload → Dispatch.<br>- Data touched:<br>  - Read: webhook_logs EXISTS via `existsSuccessfulDeliveryFor`.<br>  - Write: webhook_logs via dispatcher.<br>- Performance: O(1), dominated by DB access (single EXISTS + single INSERT).<br>- Pseudocode:<br>  ```ts<br>  type Deps = {<br>    store: {<br>      existsSuccessfulDeliveryFor: (q: { storeId: string; invoiceId: string; eventType: 'invoice-expired' }) => Promise<boolean>;<br>    };<br>    dispatcher: {<br>      dispatch: (args: {<br>        storeId: string;<br>        eventType: 'invoice-expired';<br>        payload: { invoiceId: string; status: 'expired' };<br>        timestamp: number;<br>      }) => Promise<void>;<br>    };<br>  };<br><br>  export async function emitInvoiceExpiredWebhook(<br>    invoiceId: string,<br>    storeId: string,<br>    deps: Deps & { nowEpochSecs?: number }<br>  ): Promise<boolean> {<br>    if (!invoiceId or !storeId) throw new Error('invalid_args');<br>    const already = await deps.store.existsSuccessfulDeliveryFor({ storeId, invoiceId, eventType: 'invoice-expired' });<br>    if (already) return false;<br><br>    const payload = { invoiceId, status: 'expired' as const };<br>    const ts = deps.nowEpochSecs ?? Math.floor(Date.now() / 1000);<br><br>    await deps.dispatcher.dispatch({<br>      storeId,<br>      eventType: 'invoice-expired',<br>      payload,<br>      timestamp: ts,<br>    });<br>    return true;<br>  }<br>  ```<br>- Gotchas/failure modes:<br>  - Must use camelCase JSON keys exactly.<br>  - Do not flip invoice state here (no DB mutation of invoices table).<br>  - Ensure dispatcher signs HMAC and persists attempt; this function does not re-implement signatures.<br>- Edge cases:<br>  - Re-entrancy: multiple callers; idempotence guard prevents duplicate “successful” deliveries. Retries remain allowed.<br>- Invariants:<br>  - No change to invoice status.<br>  - At most one successful delivery recorded per invoice for this event type.<br><br>--- |
| ExpirationMonitor | sweepOnchainStatuses(candidateIdHexes: string[], deps: { store: ISqliteStore; chain: IStacksChainClient; dispatcher: IWebhookDispatcher }): Promise<{ expiredIds: string[]; updated: number }> | For each 64-hex candidate ID, calls chain.readInvoiceStatus to collect those with status 'expired'. Filters DB invoices where status not in paid or canceled and expired flag is 0. In a transaction, calls store.bulkMarkExpired for matched id_raw set to expired status and expired=1. For each updated invoice, calls emitInvoiceExpiredWebhook to send one-shot webhooks idempotently. Returns the expired id list and count of rows updated. Validates idHex format before read-only calls to avoid round-trip failures. | ExpirationMonitor.sweepOnchainStatuses:<br>- Alignment: Matches DS-8-SCHED-5. Read chain status via `get-invoice-status`, mark DB expired for eligible rows, emit idempotent webhooks.<br>- Minimal mechanics:<br>  1. Filter `candidateIdHexes` to those matching 64-hex.<br>  2. For each valid idHex, call chain read-only to get current status.<br>  3. Collect `expired` idHexes.<br>  4. Open DB transaction:<br>     - From collected expired idHexes, select invoices where `status NOT IN ('paid','canceled') AND expired = 0`.<br>     - Bulk update those rows to `status='expired', expired=1`.<br>     - Return updated rows list with `invoiceId` (UUID) and `storeId` for webhook emission.<br>  5. After commit, for each updated row, call `emitInvoiceExpiredWebhook(invoiceId, storeId, deps)`.<br>  6. Return `{ expiredIds: expiredIdHexes, updated: updatedRowsCount }`.<br>- Side effects:<br>  - DB update of invoices (status/expired).<br>  - Webhook attempts persisted via dispatcher.<br>- Algorithm/order:<br>  - Validate → chain read-only map → filter DB → transactional update → webhooks.<br>- Data touched:<br>  - invoices (bulk status update, expired flag).<br>  - webhook_logs (via dispatcher).<br>- Performance:<br>  - O(n) in number of candidates; read-only calls cost network latency per id. Batch/parallelize within rate limits as needed.<br>- Pseudocode:<br>  ```ts<br>  type Deps = {<br>    store: {<br>      begin: () => { commit: () => void; rollback: () => void };<br>      // Returns subset of idHexes that were updated with their invoice/store identity<br>      bulkMarkExpired: (idHexes: string[]) => { updated: number; rows: Array<{ invoiceId: string; storeId: string; idHex: string }> };<br>      filterUpdatableExpiredByIdHex: (idHexes: string[]) => string[]; // applies NOT IN (paid,canceled) AND expired=0<br>    };<br>    chain: {<br>      readInvoiceStatus: (idHex: string) => Promise<'paid'or'unpaid'or'canceled'or'expired'or'not-found'>;<br>    };<br>    dispatcher: {<br>      // reused through emitInvoiceExpiredWebhook<br>    };<br>  };<br><br>  export async function sweepOnchainStatuses(<br>    candidateIdHexes: string[],<br>    deps: { store: Deps['store']; chain: Deps['chain']; dispatcher: any }<br>  ): Promise<{ expiredIds: string[]; updated: number }> {<br>    const isHex64 = (s: string) => typeof s === 'string' && s.length === 64 && /^[0-9A-Fa-f]+$/.test(s);<br>    const valid = Array.from(new Set(candidateIdHexes.filter(isHex64)));<br>    if (valid.length === 0) return { expiredIds: [], updated: 0 };<br><br>    // Read-only status per ID (sequential or limited parallelism)<br>    const statuses: Array<{ idHex: string; status: string }> = [];<br>    for (const idHex of valid) {<br>      const status = await deps.chain.readInvoiceStatus(idHex);<br>      statuses.push({ idHex, status });<br>    }<br><br>    const expiredIdHexes = statuses.filter(s => s.status === 'expired').map(s => s.idHex);<br>    if (expiredIdHexes.length === 0) return { expiredIds: [], updated: 0 };<br><br>    // Filter to only rows eligible to be marked expired<br>    const toUpdate = deps.store.filterUpdatableExpiredByIdHex(expiredIdHexes);<br>    if (toUpdate.length === 0) return { expiredIds: expiredIdHexes, updated: 0 };<br><br>    // Transactional bulk update<br>    const tx = deps.store.begin();<br>    let updatedRows: Array<{ invoiceId: string; storeId: string; idHex: string }> = [];<br>    try {<br>      const { updated, rows } = deps.store.bulkMarkExpired(toUpdate);<br>      updatedRows = rows;<br>      tx.commit();<br>      // Emit webhooks after commit<br>      for (const r of updatedRows) {<br>        await emitInvoiceExpiredWebhook(r.invoiceId, r.storeId, { store: deps.store as any, dispatcher: deps.dispatcher });<br>      }<br>      return { expiredIds: expiredIdHexes, updated: updatedRows.length };<br>    } catch (e) {<br>      tx.rollback();<br>      throw e;<br>    }<br>  }<br>  ```<br>- Gotchas/failure modes:<br>  - Only mark DB expired if not already paid/canceled and `expired=0`.<br>  - Ensure idHex validation (64-hex, case-insensitive).<br>  - Chain may return `not-found`: ignore.<br>  - Do not emit webhooks for rows not updated within this sweep (idempotence is ensured by emit function + webhook_logs).<br>- Edge cases:<br>  - Duplicates in `candidateIdHexes` handled by `Set`.<br>  - Partial failures on chain reads should abort or be retried by caller; keep behavior consistent with poller error handling policy.<br>- Invariants:<br>  - Invoice rows are updated at most once from non-terminal to expired in this path.<br>  - Webhooks are one-shot successful per invoice for `invoice-expired`.<br>- Timing/dependencies:<br>  - Respect Stacks API rate limits; throttle/parallelize accordingly (implementation detail outside this method’s contract).<br><br>---<br><br>End of report. |

# File Definitions:
| File Name | Components That Must Be Implemented Within The File | Static Definitions That Must Be Implemented Within The File |
| --------- | --------------------------------------------------- | ----------------------------------------------------------- |
| /src/contracts/domain.ts |  | Core Data Structures & Domain Models; Event & Messaging Interfaces |
| /src/contracts/concurrency.ts |  | Concurrency & Synchronization Handling; Error Handling & Fault Tolerance: PollerResilience, WebhookRetryPolicy |
| /src/validation/rules.ts |  | Validation & Constraint Definitions; Error Handling & Fault Tolerance: PublicErrorReason, MerchantAdminError |
| /db/migrations.sql |  | Persistence & Data Access Interfaces: SQL DDL (SQLite) |
| /.env.example |  | Configuration Management & Dependency Injection Contracts: .env template |
| /clarity/contracts/sbtc-payment.clar | SbtcPaymentContract |  |
| /src/servers/AdminStaticServer.ts | AdminStaticServer |  |
| /src/middleware/RateLimitPolicy.ts | RateLimitPolicy |  |
| /src/controllers/HealthController.ts | HealthController |  |
| /src/services/PricingCache.ts | PricingCache |  |
| /src/misc/ComponentName.ts | Component Name |  |
| /src/contracts/state.ts |  | State Store Interface; Configuration Management & Dependency Injection Contracts: IConfigSnapshot |
| /src/contracts/dao.ts |  | Persistence & Data Access Interfaces: ISqliteStore |
| /src/contracts/interfaces.ts |  | Service & Component Communication Interfaces |
| /src/config/env.ts |  | Configuration Management & Dependency Injection Contracts: loadEnvSnapshot |
| /src/factories/PostConditionFactory.ts | PostConditionFactory |  |
| /src/utils/InvoiceIdCodec.ts | InvoiceIdCodec |  |
| /src/config/ConfigService.ts | ConfigService |  |
| /src/factories/AssetInfoFactory.ts | AssetInfoFactory |  |
| /src/services/PricingService.ts | PricingService |  |
| /src/db/SqliteStore.ts | SqliteStore |  |
| /src/delegates/WebhookRetryQueryComposer.ts | WebhookRetryQueryComposer |  |
| /src/delegates/MerchantProjectionPolicy.ts | MerchantProjectionPolicy |  |
| /src/delegates/SqlInListBuilder.ts | SqlInListBuilder |  |
| /src/clients/StacksChainClient.ts | StacksChainClient |  |
| /src/delegates/ClarityCvAdapter.ts | ClarityCvAdapter |  |
| /src/builders/ContractCallBuilder.ts | ContractCallBuilder |  |
| /src/delegates/PostConditionsComposer.ts | PostConditionsComposer |  |
| /src/delegates/OptionalBuff34Encoder.ts | OptionalBuff34Encoder |  |
| /src/middleware/StoreApiAuth.ts | StoreApiAuth |  |
| /src/middleware/CorsPolicy.ts | CorsPolicy |  |
| /src/middleware/AdminAuth.ts | AdminAuth |  |
| /src/middleware/CrossTenantMask.ts | CrossTenantMask |  |
| /src/webhooks/WebhookRetryScheduler.ts | WebhookRetryScheduler |  |
| /src/webhooks/WebhookDispatcher.ts | WebhookDispatcher |  |
| /src/delegates/WebhookSignatureService.ts | WebhookSignatureService |  |
| /src/delegates/WebhookAttemptPlanner.ts | WebhookAttemptPlanner |  |
| /src/services/ExpirationMonitor.ts | ExpirationMonitor |  |
| /src/poller/PaymentPoller.ts | PaymentPoller |  |
| /src/delegates/ContractCallEventNormalizer.ts | ContractCallEventNormalizer |  |
| /src/delegates/ReorgGuard.ts | ReorgGuard |  |
| /src/delegates/SubscriptionLifecycleProcessor.ts | SubscriptionLifecycleProcessor |  |
| /src/delegates/InvoiceEventApplier.ts | InvoiceEventApplier |  |
| /src/poller/PollerAdminBridge.ts | PollerAdminBridge |  |
| /src/schedulers/SubscriptionScheduler.ts | SubscriptionScheduler |  |
| /src/delegates/SubscriptionInvoicePlanner.ts | SubscriptionInvoicePlanner |  |
| /src/services/InvoiceService.ts | InvoiceService |  |
| /src/services/RefundService.ts | RefundService |  |
| /src/services/SubscriptionService.ts | SubscriptionService |  |
| /src/controllers/PublicApiController.ts | PublicApiController |  |
| /src/delegates/InvoiceStatusResolver.ts | InvoiceStatusResolver |  |
| /src/delegates/StorePublicProfileProjector.ts | StorePublicProfileProjector |  |
| /src/delegates/PayInvoiceTxAssembler.ts | PayInvoiceTxAssembler |  |
| /src/delegates/InvoiceIdGuard.ts | InvoiceIdGuard |  |
| /src/controllers/AdminApiController.ts | AdminApiController |  |
| /src/delegates/AdminParamGuard.ts | AdminParamGuard |  |
| /src/delegates/AdminDtoProjector.ts | AdminDtoProjector |  |
| /src/delegates/MerchantKeyRotationService.ts | MerchantKeyRotationService |  |
| /src/delegates/MerchantOnchainSyncPlanner.ts | MerchantOnchainSyncPlanner |  |
| /src/delegates/WebhookAdminRetryService.ts | WebhookAdminRetryService |  |
| /src/delegates/MerchantCreationService.ts | MerchantCreationService |  |
| /src/delegates/AdditionalControllerUsagesOfAdminParamGuard.ts | Additional Controller Usages of AdminParamGuard |  |
| /src/controllers/MerchantApiController.ts | MerchantApiController |  |
| /src/delegates/ApiCaseAndDtoMapper.ts | ApiCaseAndDtoMapper |  |
| /src/delegates/MerchantInputValidator.ts | MerchantInputValidator |  |
| /src/delegates/DirectSubscriptionPaymentTxBuilder.ts | DirectSubscriptionPaymentTxBuilder |  |
| /src/delegates/RefundPolicyGuard.ts | RefundPolicyGuard |  |
| /frontend/checkout/CheckoutFrontend.ts | CheckoutFrontend |  |
| /frontend/checkout/delegates/InvoiceCountdownDelegate.ts | InvoiceCountdownDelegate |  |
| /frontend/checkout/delegates/InvoiceStatusPollerDelegate.ts | InvoiceStatusPollerDelegate |  |
| /frontend/checkout/delegates/WalletContractCallDelegate.ts | WalletContractCallDelegate |  |
| /frontend/checkout/delegates/StoreBrandingDelegate.ts | StoreBrandingDelegate |  |
| /frontend/checkout/delegates/StatusBadgeDelegate.ts | StatusBadgeDelegate |  |
| /frontend/checkout/delegates/PaymentActionsDelegate.ts | PaymentActionsDelegate |  |
| /frontend/checkout/delegates/PublicCheckoutApiClient.ts | PublicCheckoutApiClient |  |
| /frontend/checkout/delegates/QrRenderDelegate.ts | QrRenderDelegate |  |
| /frontend/checkout/delegates/BannerDelegate.ts | BannerDelegate |  |
| /frontend/merchant-dashboard/MerchantDashboardFrontend.ts | MerchantDashboardFrontend |  |
| /frontend/merchant-dashboard/adapters/RequestShapeAdapter.ts | RequestShapeAdapter |  |
| /frontend/merchant-dashboard/http/MerchantApiHttpClient.ts | MerchantApiHttpClient |  |
| /frontend/merchant-dashboard/flows/RefundFlowCoordinator.ts | RefundFlowCoordinator |  |
| /frontend/merchant-dashboard/viewmodels/InvoiceListViewModel.ts | InvoiceListViewModel |  |
| /frontend/merchant-dashboard/subscriptions/SubscriptionsCoordinator.ts | SubscriptionsCoordinator |  |
| /frontend/merchant-dashboard/webhooks/WebhookConsoleCoordinator.ts | WebhookConsoleCoordinator |  |
| /frontend/merchant-dashboard/profile/StoreProfileCoordinator.ts | StoreProfileCoordinator |  |
| /frontend/merchant-dashboard/keys/KeyRotationCoordinator.ts | KeyRotationCoordinator |  |
| /frontend/admin-console/AdminConsoleFrontend.ts | AdminConsoleFrontend |  |
| /frontend/admin-console/http/AdminHttpClient.ts | AdminHttpClient |  |
| /frontend/admin-console/validation/AdminInputValidator.ts | AdminInputValidator |  |
| /frontend/admin-console/adapters/AdminStoreFormAdapter.ts | AdminStoreFormAdapter |  |
| /frontend/admin-console/wallet/AdminContractCallSequencer.ts | AdminContractCallSequencer |  |
| /src/server/HttpApiServer.ts | HttpApiServer |  |
| /src/delegates/AdminSurfaceBinder.ts | AdminSurfaceBinder |  |
| /src/delegates/WebhookInboundSurfaceBinder.ts | WebhookInboundSurfaceBinder |  |
| /src/delegates/SchedulerStartupCoordinator.ts | SchedulerStartupCoordinator |  |
| /src/delegates/RootRouteBinder.ts | RootRouteBinder |  |
| /src/delegates/CorsMiddlewareFactory.ts | CorsMiddlewareFactory |  |
| /src/bootstrap/ApplicationBootstrapper.ts | ApplicationBootstrapper |  |

# Static Report:
##### **Core Data Structures & Domain Models
// TypeScript types and DTOs

// Enums
type InvoiceStatus = 'unpaid' | 'paid' | 'partially_refunded' | 'refunded' | 'canceled' | 'expired';
type WebhookEventType = 'paid' | 'refunded' | 'subscription' | 'subscription-created' | 'subscription-paid' | 'subscription-canceled' | 'invoice-expired' | 'invoice-canceled';
type SubscriptionMode = 'invoice' | 'direct';

// On-chain mirrors (read-only DTOs)
interface OnChainInvoice {
  idHex: string; // 64-hex for (buff 32)
  merchant: string; // principal
  amountSats: bigint;
  memo?: string; // ≤34 bytes utf8
  expiresAt?: bigint; // block height
  paid: boolean;
  canceled: boolean;
  refundAmountSats: bigint;
  payer?: string; // principal
}
interface OnChainSubscription {
  idHex: string; // 64-hex
  merchant: string;
  subscriber: string;
  amountSats: bigint;
  intervalBlocks: bigint;
  active: boolean;
  nextDue: bigint;
}
interface OnChainAdminState {
  admin?: string; // principal
  sbtcToken?: { contractAddress: string; contractName: string };
}

// SQLite rows (snake_case)
interface MerchantRow {
  id: string;
  principal: string;
  name?: string;
  display_name?: string;
  logo_url?: string;
  brand_color?: string;
  webhook_url?: string;
  hmac_secret: string;
  api_key: string;
  active: number; // 0/1
  support_email?: string;
  support_url?: string;
  allowed_origins?: string; // CSV
  created_at: number; // seconds
}
interface InvoiceRow {
  id_raw: string;
  id_hex: string; // 64-hex, CHECK enforced
  store_id: string;
  amount_sats: number;
  usd_at_create: number;
  quote_expires_at: number; // ms
  merchant_principal: string;
  status: InvoiceStatus;
  payer?: string;
  txid?: string;
  memo?: string;
  webhook_url?: string;
  created_at: number; // seconds
  refunded_at?: number;
  refund_amount: number;
  refund_txid?: string;
  subscription_id?: string;
  refund_count: number;
  expired: number; // 0/1
}
interface SubscriptionRow {
  id: string;
  id_hex: string; // 64-hex
  store_id: string;
  merchant_principal: string;
  subscriber: string;
  amount_sats: number;
  interval_blocks: number;
  active: number; // 0/1
  created_at: number;
  last_billed_at?: number;
  next_invoice_at: number; // block height
  last_paid_invoice_id?: string;
  mode: SubscriptionMode;
}
interface WebhookLogRow {
  id: string;
  store_id: string;
  invoice_id?: string;
  subscription_id?: string;
  event_type: WebhookEventType;
  payload: string; // raw JSON
  status_code?: number;
  success: number; // 0/1
  attempts: number;
  last_attempt_at: number; // seconds
}

// Public DTOs (camelCase)
interface PublicInvoiceDTO {
  invoiceId: string;
  idHex: string;
  storeId: string;
  amountSats: number;
  usdAtCreate: number;
  quoteExpiresAt: number; // ms
  merchantPrincipal: string;
  status: InvoiceStatus;
  payer?: string;
  txId?: string;
  memo?: string;
  subscriptionId?: string;
  createdAt: number; // seconds
  refundAmount?: number;
  refundTxId?: string;
  store?: StorePublicProfileDTO;
}
interface StorePublicProfileDTO {
  displayName?: string;
  logoUrl?: string;
  brandColor?: string;
  supportEmail?: string;
  supportUrl?: string;
}
interface StorePrivateProfileDTO extends StorePublicProfileDTO {
  name?: string;
  webhookUrl?: string;
  allowedOrigins: string[];
  principal: string;
  active: boolean;
}
interface AdminPollerStatusDTO {
  running: boolean;
  lastRunAt?: number;
  lastHeight?: number;
  lastTxId?: string;
  lastBlockHash?: string;
  lagBlocks?: number;
}

// Unsigned contract-call payload
interface UnsignedContractCall {
  contractAddress: string;
  contractName: string;
  functionName: string;
  functionArgs: any[]; // Clarity CV descriptors
  postConditionMode?: 'deny' | 'allow';
  postConditions?: any[];
  anchorMode?: 'any' | 'onChainOnly' | 'offChainOnly';
  network: 'mainnet' | 'testnet' | 'devnet';
}

// Poller telemetry
interface PollerMetrics {
  running: boolean;
  lastRunAt?: number;
  lastHeight?: number;
  lastTxId?: string;
  lastBlockHash?: string;
  lagBlocks?: number;
}

// Normalized chain event (for internal processing)
type NormalizedEventType =
  | 'invoice-paid'
  | 'refund-invoice'
  | 'invoice-canceled'
  | 'create-subscription'
  | 'cancel-subscription'
  | 'pay-subscription';
interface NormalizedEvent {
  type: NormalizedEventType;
  idHex: string;
  block_height: number;
  tx_id: string;
  tx_index: number;
  sender?: string;
  merchantPrincipal?: string;
  subscriber?: string;
  amountSats?: number;
  intervalBlocks?: number;
  refundAmountSats?: number;
}


##### **State Store Interface
// Global state access for poller metrics and control
interface IPollerState {
  getMetrics(): PollerMetrics;
}
interface IPollerControl {
  restart(): { running: boolean };
}
// Immutable configuration snapshot
interface IConfigSnapshot {
  network: 'mainnet' | 'testnet' | 'devnet';
  contractAddress: string;
  contractName: string;
  sbtcContract?: { contractAddress: string; contractName: string };
  avgBlockSecs: number;
  minConfirmations: number;
  reorgWindowBlocks: number;
  pollIntervalSecs: number;
  priceApiUrl?: string;
  autoBroadcast: boolean;
}


##### **Persistence & Data Access Interfaces
-- SQL DDL (SQLite)
CREATE TABLE IF NOT EXISTS merchants (
  id TEXT PRIMARY KEY,
  principal TEXT NOT NULL UNIQUE,
  name TEXT,
  display_name TEXT,
  logo_url TEXT,
  brand_color TEXT,
  webhook_url TEXT,
  hmac_secret TEXT NOT NULL,
  api_key TEXT NOT NULL UNIQUE,
  active INTEGER NOT NULL DEFAULT 1,
  support_email TEXT,
  support_url TEXT,
  allowed_origins TEXT,
  created_at INTEGER
);
CREATE UNIQUE INDEX IF NOT EXISTS ux_merchants_principal ON merchants(principal);
CREATE UNIQUE INDEX IF NOT EXISTS ux_merchants_api_key ON merchants(api_key);

CREATE TABLE IF NOT EXISTS invoices (
  id_raw TEXT PRIMARY KEY,
  id_hex TEXT NOT NULL,
  store_id TEXT NOT NULL REFERENCES merchants(id),
  amount_sats INTEGER NOT NULL,
  usd_at_create REAL NOT NULL,
  quote_expires_at INTEGER NOT NULL,
  merchant_principal TEXT NOT NULL,
  status TEXT NOT NULL,
  payer TEXT,
  txid TEXT,
  memo TEXT,
  webhook_url TEXT,
  created_at INTEGER NOT NULL,
  refunded_at INTEGER,
  refund_amount INTEGER NOT NULL DEFAULT 0,
  refund_txid TEXT,
  subscription_id TEXT,
  refund_count INTEGER NOT NULL DEFAULT 0,
  expired INTEGER NOT NULL DEFAULT 0,
  CHECK (length(id_hex) = 64),
  CHECK (id_hex GLOB '[0-9A-Fa-f]*')
);
CREATE INDEX IF NOT EXISTS idx_invoices_store ON invoices(store_id);
CREATE INDEX IF NOT EXISTS idx_invoices_status ON invoices(status);
CREATE UNIQUE INDEX IF NOT EXISTS ux_invoices_id_hex ON invoices(id_hex);

CREATE TABLE IF NOT EXISTS subscriptions (
  id TEXT PRIMARY KEY,
  id_hex TEXT NOT NULL,
  store_id TEXT NOT NULL REFERENCES merchants(id),
  merchant_principal TEXT NOT NULL,
  subscriber TEXT NOT NULL,
  amount_sats INTEGER NOT NULL CHECK(amount_sats > 0),
  interval_blocks INTEGER NOT NULL CHECK(interval_blocks > 0),
  active INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  last_billed_at INTEGER,
  next_invoice_at INTEGER NOT NULL,
  last_paid_invoice_id TEXT,
  mode TEXT NOT NULL CHECK(mode IN ('invoice','direct')),
  CHECK(length(id_hex)=64),
  CHECK(id_hex GLOB '[0-9A-Fa-f]*')
);
CREATE INDEX IF NOT EXISTS idx_subs_store_next ON subscriptions(store_id, next_invoice_at);
CREATE UNIQUE INDEX IF NOT EXISTS ux_subscriptions_id_hex ON subscriptions(id_hex);

CREATE TABLE IF NOT EXISTS webhook_logs (
  id TEXT PRIMARY KEY,
  store_id TEXT NOT NULL REFERENCES merchants(id),
  invoice_id TEXT,
  subscription_id TEXT,
  event_type TEXT NOT NULL,
  payload TEXT NOT NULL,
  status_code INTEGER,
  success INTEGER NOT NULL,
  attempts INTEGER NOT NULL,
  last_attempt_at INTEGER NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_webhooks_store ON webhook_logs(store_id);

-- Data Access Layer (TypeScript)
interface ISqliteStore {
  migrate(): void;

  // Merchants
  findActiveByApiKey(apiKey: string): MerchantRow | undefined;
  insertMerchant(row: MerchantRow): void;
  updateMerchantActive(storeId: string, active: boolean): number;
  updateMerchantKeysTx(storeId: string, apiKey: string, hmacSecret: string): void;
  listMerchantsProjection(): Omit<MerchantRow, 'api_key'|'hmac_secret'>[];

  // Invoices
  invoices: {
    insert(row: InvoiceRow): void;
    findByStoreAndIdRaw(storeId: string, idRaw: string): InvoiceRow | undefined;
  };
  getInvoiceById(idRaw: string): InvoiceRow | undefined;
  getInvoiceWithStore(idRaw: string): (InvoiceRow & { store: MerchantRow }) | undefined;
  listInvoicesByStore(
    storeId: string,
    opts?: { status?: InvoiceStatus; orderByCreatedDesc?: boolean }
  ): InvoiceRow[];
  markInvoicePaid(idHex: string, payer: string, txId: string, tx?: unknown): void;
  upsertInvoiceRefund(idHex: string, amountSats: number, refundTxId: string, tx?: unknown): void;
  markInvoiceCanceled(idHexOrIdRaw: string, tx?: unknown): void;
  updateInvoiceStatus(idRaw: string, status: InvoiceStatus, expired?: 0|1): void;
  ensureInvoiceIdHexUnique(idHex: string): boolean;
  invoiceExists(idHex: string): boolean;
  bulkMarkExpired(idRawList: string[]): number;

  // Subscriptions
  insertSubscription(row: SubscriptionRow): void;
  getSubscriptionByIdForStore(id: string, storeId: string): SubscriptionRow | undefined;
  getActiveSubscription(id: string, storeId: string): SubscriptionRow | undefined;
  updateSubscriptionMode(id: string, storeId: string, mode: SubscriptionMode): void;
  deactivateSubscription(id: string, storeId: string, tx?: unknown): void;
  setSubscriptionActive(input: { idHex: string; active: 0|1 }): void;
  upsertSubscriptionByHex(input: {
    idHex: string; storeId: string; merchantPrincipal: string; subscriber: string; amountSats: number; intervalBlocks: number; active: 1
  }): void;
  advanceSubscriptionSchedule(id: string): void;
  updateSubscriptionLastPaid(input: { subscriptionId: string; lastPaidInvoiceId: string }): void;
  subscriptionExists(idHex: string): boolean;
  selectDueSubscriptions(currentHeight: number): SubscriptionRow[];
  getStoreIdByPrincipal(merchantPrincipal: string): string | undefined;

  // Webhooks
  insertWebhookAttempt(row: WebhookLogRow): string;
  updateWebhookAttemptStatus(id: string, patch: { success: 0|1; statusCode?: number }): void;
  listWebhooksForStore(storeId: string): WebhookLogRow[];
  listAdminWebhooks(storeId?: string, failedOnly?: boolean): WebhookLogRow[];
  getWebhookLogById(id: string): WebhookLogRow | undefined;
  existsSuccessfulDeliveryFor(ctx: {
    storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType
  }): boolean;
  selectDueWebhookRetries(): WebhookLogRow[];
  getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[];

  // Admin queries
  selectAdminInvoices(statuses?: InvoiceStatus[], storeId?: string): InvoiceRow[];

  // Optional cursor persistence
  getPollerCursor(): { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string } | null;
  savePollerCursor(cursor: { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string }): void;
}


##### **Service & Component Communication Interfaces
// Clarity Contract ABI (sbtc-payment)
contract SbtcPaymentContract {
  // public functions
  bootstrap-admin(): (response bool uint);
  set-sbtc-token(token: (contract-of ft-trait)): (response bool uint);
  register-merchant(merchant: principal, name: (optional (buff 34))): (response bool uint);
  set-merchant-active(merchant: principal, active: bool): (response bool uint);
  create-invoice(id: (buff 32), amount: uint, memo: (optional (buff 34)), expires-at: (optional uint)): (response bool uint);
  pay-invoice(id: (buff 32)): (response bool uint);
  refund-invoice(id: (buff 32), amount: uint, memo: (optional (buff 34))): (response bool uint);
  create-subscription(id: (buff 32), merchant: principal, subscriber: principal, amount: uint, interval: uint): (response bool uint);
  pay-subscription(id: (buff 32)): (response bool uint);
  cancel-invoice(id: (buff 32)): (response bool uint);
  cancel-subscription(id: (buff 32)): (response bool uint);
  mark-expired(id: (buff 32)): (response bool uint);

  // read-only functions
  get-invoice(id: (buff 32)): (optional (tuple {
    merchant: principal,
    amount: uint,
    memo: (optional (buff 34)),
    expires-at: (optional uint),
    paid: bool,
    canceled: bool,
    refund-amount: uint,
    payer: (optional principal)
  }));
  is-paid(id: (buff 32)): bool;
  get-invoice-status(id: (buff 32)): (buff or string-like: 'not-found'|'paid'|'canceled'|'expired'|'unpaid');
  get-subscription(id: (buff 32)): (optional (tuple {
    merchant: principal, subscriber: principal, amount: uint, interval: uint, active: bool, 'next-due': uint
  }));
  next-due(id: (buff 32)): (optional uint);
  get-sbtc(): (optional contract-principal);
  get-admin(): (optional principal);
}

// REST API (paths, auth, schemas)
// Public
GET /i/:invoiceId
  Auth: none, CORS per store
  Response: PublicInvoiceDTO

POST /create-tx
  Auth: none, CORS per store
  Request JSON: { invoiceId: string, payerPrincipal?: string }
  Response: UnsignedContractCall

GET /api/v1/stores/:storeId/public-profile
  Auth: none, CORS per store
  Response: StorePublicProfileDTO

// Merchant (header: X-API-Key)
POST /api/v1/stores/:storeId/invoices
  Body (snake_case): { amount_sats: number; ttl_seconds: number; memo?: string; webhook_url?: string }
  Response: PublicInvoiceDTO & { magicLink: string; unsignedTx?: UnsignedContractCall }

GET /api/v1/stores/:storeId/invoices
  Query: ?status=unpaid|paid|partially_refunded|refunded|canceled|expired
  Response: PublicInvoiceDTO[]

GET /api/v1/stores/:storeId/invoices/:invoiceId
  Response: PublicInvoiceDTO

POST /api/v1/stores/:storeId/invoices/:invoiceId/cancel
  Response: { canceled: boolean; invoiceId: string } | { unsignedPayload: UnsignedContractCall }

POST /api/v1/stores/:storeId/refunds
  Body (snake_case): { invoice_id: string; amount_sats: number; memo?: string }
  Response: UnsignedContractCall

GET /api/v1/stores/:storeId/webhooks
  Response: Array<{
    id: string; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string;
    payload: string; statusCode?: number; success: boolean; attempts: number; lastAttemptAt: number;
  }>

GET /api/v1/stores/:storeId/profile
  Response: StorePrivateProfileDTO

PATCH /api/v1/stores/:storeId/profile
  Body (snake_case): Partial<{ name:string; display_name:string; logo_url:string; brand_color:string; webhook_url:string; support_email:string; support_url:string; allowed_origins:string }>
  Response: StorePrivateProfileDTO

POST /api/v1/stores/:storeId/rotate-keys
  Response: { apiKey: string; hmacSecret: string }

POST /api/v1/stores/:storeId/subscriptions
  Body (snake_case): { subscriber: string; amount_sats: number; interval_blocks: number; mode?: 'invoice'|'direct' }
  Response: {
    id: string; idHex: string; storeId: string; merchantPrincipal: string; subscriber: string;
    amountSats: number; intervalBlocks: number; active: boolean; createdAt: number; lastBilledAt?: number;
    nextInvoiceAt: number; lastPaidInvoiceId?: string; mode: SubscriptionMode; unsignedCall?: UnsignedContractCall
  }

POST /api/v1/stores/:storeId/subscriptions/:id/invoice
  Body: { ttl_seconds?: number; memo?: string }
  Response: PublicInvoiceDTO & { magicLink: string; unsignedTx?: UnsignedContractCall }

POST /api/v1/stores/:storeId/subscriptions/:id/mode
  Body: { mode: 'invoice'|'direct' }
  Response: { id: string; mode: SubscriptionMode; unsignedTx?: UnsignedContractCall }

POST /api/v1/stores/:storeId/subscriptions/:id/cancel
  Response: { canceled: boolean; subscriptionId: string } | { unsignedTx: UnsignedContractCall }

POST /api/v1/stores/:storeId/subscriptions/:id/create-tx
  Body: { payerPrincipal: string }
  Response: UnsignedContractCall

// Admin (Authorization: Bearer ADMIN_TOKEN or Basic)
GET /api/admin/stores
  Response: Array<{
    id:string; principal:string; name?:string; displayName?:string; logoUrl?:string; brandColor?:string; webhookUrl?:string;
    active:boolean; supportEmail?:string; supportUrl?:string; allowedOrigins?:string; createdAt:number
  }>

POST /api/admin/stores
  Body: { principal: string; name?: string; display_name?: string; logo_url?: string; brand_color?: string; webhook_url?: string; support_email?: string; support_url?: string; allowed_origins?: string }
  Response: same projection as list; 201 or 409

PATCH /api/admin/stores/:storeId/activate
  Body: { active: boolean }
  Response: merchant projection

POST /api/admin/stores/:storeId/rotate-keys
  Response: { apiKey: string; hmacSecret: string }

POST /api/admin/stores/:storeId/sync-onchain
  Response: { calls: UnsignedContractCall[] }

POST /api/admin/set-sbtc-token
  Body: { contractAddress: string; contractName: string }
  Response: { call: UnsignedContractCall }

GET /api/admin/poller
  Response: AdminPollerStatusDTO

POST /api/admin/poller/restart
  Response: { running: boolean }

GET /api/admin/webhooks
  Query: ?storeId=&status=failed|all
  Response: Array<{
    id: string; storeId: string; invoiceId?: string; subscriptionId?: string; eventType: string;
    payload: string; statusCode?: number; success: boolean; attempts: number; lastAttemptAt: number;
  }>

POST /api/admin/webhooks/retry
  Body: { webhookLogId: string }
  Response: 202 { enqueued: boolean } or 200 { alreadyDelivered: true }

GET /api/admin/invoices
  Query: ?status=&storeId=
  Response: Array<{
    idRaw: string; idHex: string; storeId: string; amountSats: number; usdAtCreate: number; quoteExpiresAt: number;
    merchantPrincipal: string; status: string; payer?: string; txId?: string; memo?: string; webhookUrl?: string; createdAt: number;
    refundedAt?: number; refundAmount: number; refundTxId?: string; subscriptionId?: string; refundCount: number; expired: number;
  }>

POST /api/admin/invoices/:invoiceId/cancel
  Response: { canceled: true; invoiceId: string } | 400 { error: 'already paid' }

// Cross-component contracts (TypeScript)
interface IStacksChainClient {
  callReadOnly(fn: string, args: any[]): Promise<any>;
  readInvoiceStatus(idHex: string): Promise<'not-found'|'paid'|'canceled'|'expired'|'unpaid'>;
  readSbtcToken(): Promise<{ contractAddress: string; contractName: string } | undefined>;
  readSubscription(idHex: string): Promise<OnChainSubscription | undefined>;
  getTip(): Promise<{ height: number; blockHash: string }>;
  getTipHeight(): Promise<number>;
  getFungibleBalance(assetContract: { contractAddress: string; contractName: string }, principal: string): Promise<bigint>;
  getContractCallEvents(params: { fromHeight: number }): Promise<any[]>;
  getBlockHeader(height: number): Promise<{ parent_block_hash: string; block_hash: string }>;
}
interface IContractCallBuilder {
  buildCreateInvoice(args: { idHex: string; amountSats: number; memo?: string; expiresAtBlock?: number }): UnsignedContractCall;
  buildRefundInvoice(args: { idHex: string; amountSats: number; memo?: string; merchantPrincipal: string }): UnsignedContractCall;
  buildPayInvoice(args: { idHex: string; amountSats: number; payerPrincipal: string; merchantPrincipal: string }): UnsignedContractCall;
  buildCancelInvoice(args: { idHex: string }): UnsignedContractCall;
  buildCreateSubscription(args: { idHex: string; merchant: string; subscriber: string; amountSats: number; intervalBlocks: number }): UnsignedContractCall;
  buildPaySubscription(args: { idHex: string; amountSats: number; subscriber: string; merchant: string }): UnsignedContractCall;
  buildCancelSubscription(args: { idHex: string }): UnsignedContractCall;
  buildRegisterMerchant(args: { merchant: string; name?: string }): UnsignedContractCall;
  buildSetMerchantActive(args: { merchant: string; active: boolean }): UnsignedContractCall;
  buildSetSbtcToken(args: { contractAddress: string; contractName: string }): UnsignedContractCall;
  buildBootstrapAdmin(): UnsignedContractCall;
}
interface IAssetInfoFactory {
  getSbtcAssetInfo(): { contractAddress: string; contractName: string; assetName: string };
}
interface IPostConditionFactory {
  forPayInvoice(payer: string, merchant: string, amountSats: number, asset: any): any[];
  forRefund(merchant: string, amountSats: number, asset: any): any[];
}
interface IInvoiceIdCodec {
  assertHex64(idHex: string): void;
  isValidHex64(idHex: string): boolean;
  toBuff32Hex(idHex: string): Uint8Array;
  hexFromBuff32(buf: Uint8Array): string;
  generateRandomBuff32Hex(): string;
}
interface IConfigService {
  getNetwork(): 'mainnet'|'testnet'|'devnet';
  getContractId(): { contractAddress: string; contractName: string };
  getSbtcContractId(): { contractAddress: string; contractName: string } | undefined;
  getPollingConfig(): { minConfirmations: number; reorgWindowBlocks: number; pollIntervalSecs: number };
  getAvgBlockSecs(): number;
  getPriceApiUrl(): string | undefined;
  isAutoBroadcastEnabled(): boolean;
}
interface IWebhookDispatcher {
  dispatch(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType; rawBody: string; attempts?: number }): Promise<void>;
}
interface IWebhookRetryScheduler {
  enqueueRetry(ctx: { storeId: string; invoiceId?: string; subscriptionId?: string; eventType: WebhookEventType; rawBody: string; attempts: number }): void;
}


##### **Configuration Management & Dependency Injection Contracts
// .env template
NODE_ENV=development
PORT=3000
STACKS_NETWORK=testnet
CONTRACT_ADDRESS=SPXXXX...
CONTRACT_NAME=sbtc-payment
SBTC_CONTRACT_ADDRESS=SPYYYY...
SBTC_CONTRACT_NAME=sbtc-token
ADMIN_TOKEN=changeme
ADMIN_USER=admin
ADMIN_PASS=secret
MIN_CONFIRMATIONS=2
REORG_WINDOW_BLOCKS=6
POLL_INTERVAL_SECS=30
AVG_BLOCK_SECONDS=30
QUOTE_TTL_SECONDS=300
PRICE_API_URL=https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd
DB_PATH=./invoices.sqlite
AUTO_BOOTSTRAP_ADMIN=false

// Config snapshot accessor (TypeScript)
interface EnvConfig extends IConfigSnapshot {}
function loadEnvSnapshot(): IConfigSnapshot {
  return Object.freeze({
    network: (process.env.STACKS_NETWORK as any) ?? 'testnet',
    contractAddress: String(process.env.CONTRACT_ADDRESS),
    contractName: String(process.env.CONTRACT_NAME),
    sbtcContract: process.env.SBTC_CONTRACT_ADDRESS && process.env.SBTC_CONTRACT_NAME
      ? { contractAddress: String(process.env.SBTC_CONTRACT_ADDRESS), contractName: String(process.env.SBTC_CONTRACT_NAME) }
      : undefined,
    avgBlockSecs: Number(process.env.AVG_BLOCK_SECONDS ?? 30),
    minConfirmations: Number(process.env.MIN_CONFIRMATIONS ?? 2),
    reorgWindowBlocks: Number(process.env.REORG_WINDOW_BLOCKS ?? 6),
    pollIntervalSecs: Number(process.env.POLL_INTERVAL_SECS ?? 30),
    priceApiUrl: process.env.PRICE_API_URL ? String(process.env.PRICE_API_URL) : undefined,
    autoBroadcast: String(process.env.AUTO_BOOTSTRAP_ADMIN ?? 'false') === 'true'
  });
}


##### **Mandatory Dependency Injection Contracts
// Interface usage map to prevent circular deps

// ISqliteStore
// Imported by: PublicApiController, MerchantApiController, AdminApiController, PaymentPoller, WebhookDispatcher, WebhookRetryScheduler, SubscriptionScheduler, CorsPolicy, StoreApiAuth

// IStacksChainClient
// Imported by: PublicApiController, MerchantApiController, AdminApiController (read-only checks), PaymentPoller, SubscriptionScheduler, RefundService, DirectSubscriptionPaymentTxBuilder

// IContractCallBuilder
// Imported by: PublicApiController (via assembler), MerchantApiController, AdminApiController, InvoiceService, RefundService, SubscriptionService, SubscriptionScheduler

// IAssetInfoFactory
// Imported by: ContractCallBuilder, PublicApiController (tx assembler), RefundService, PostConditionsComposer

// IPostConditionFactory
// Imported by: ContractCallBuilder, RefundService, PostConditionsComposer

// IInvoiceIdCodec
// Imported by: PublicApiController, MerchantApiController, InvoiceService, SubscriptionService, SubscriptionScheduler, RefundPolicyGuard, DirectSubscriptionPaymentTxBuilder

// IConfigService
// Imported by: StacksChainClient (network/init), ContractCallBuilder, PublicApiController, MerchantApiController, AdminApiController, PricingService, PaymentPoller, SubscriptionScheduler, RefundService

// IWebhookDispatcher
// Imported by: PaymentPoller, SubscriptionScheduler, AdminApiController (retry)

// IWebhookRetryScheduler
// Imported by: WebhookDispatcher

// IPollerState/IPollerControl (via PollerAdminBridge)
// Imported by: AdminApiController


##### **Validation & Constraint Definitions
// JSON-like rule set (TypeScript annotations)

const Validation = {
  idHex64: /^[0-9A-Fa-f]{64}$/,
  url: /^(https?):\/\/[^\s]+$/i,
  colorHex: /^#[0-9A-Fa-f]{6}$/,
  uuid: /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/,
  stacksPrincipal: /^S[^\s]{10,}$/,

  // Rules
  createInvoice: {
    amount_sats: 'integer > 0',
    ttl_seconds: 'integer > 0',
    memoMaxUtf8Bytes: 34,
    webhook_url: 'optional URL'
  },
  refund: {
    invoice_id: 'uuid',
    amount_sats: 'integer > 0',
    memoMaxUtf8Bytes: 34,
    cap: 'refund_amount + request ≤ amount_sats'
  },
  subscription: {
    subscriber: 'stacks principal',
    amount_sats: 'integer > 0',
    interval_blocks: 'integer > 0',
    mode: ['invoice','direct']
  },
  publicCreateTxGate: [
    'invoice exists',
    'merchant active',
    'status not in [paid,canceled,expired]',
    'TTL not expired',
    'on-chain status not expired',
    'id_hex valid 64-hex',
    'sBTC token configured'
  ],
  storeProfileUpdate: {
    brand_color: 'optional color hex #RRGGBB',
    allowed_origins: 'CSV string'
  }
};

// Error mapping (HTTP → codes)
type PublicErrorReason = 'notFound' | 'invalidId' | 'expired' | 'invalidState' | 'rateLimited' | 'missingIdentifier' | 'missingSbtcToken';
type MerchantAdminError = 'rate_limited' | 'bad_status' | 'not_cancellable' | 'already_paid' | 'insufficient_balance' | 'validation_error';


##### **Lifecycle Contracts
// Merchant
// - Create (admin): insert row with api_key, hmac_secret, active=1.
// - Activate/Deactivate (admin): updates active; gates invoice create and payment acceptance (on-chain registry mirrored).
// - Rotate keys: update secrets atomically; return once.

// Invoice
// - Create: must call on-chain create-invoice; persist id_hex, amount_sats, merchant_principal, usd_at_create, quote_expires_at; status='unpaid'.
// - Pay: on-chain pay-invoice; poller marks paid with payer & txid.
// - Refund: on-chain refund-invoice; track refund_amount/refund_txid; fully refunded => status='refunded', partial => 'paid' with refund_amount > 0.
// - Cancel: when unpaid; merchant/admin; on-chain cancel-invoice; mark canceled.
// - Expire: if quote_expires_at elapsed or on-chain expired; mark expired; emit one-shot webhook.

// Subscription
// - Create: store row with next_invoice_at; mode in {'invoice','direct'}; active=1.
// - Invoice mode: scheduler generates per-period invoice; advances schedule atomically with insert.
// - Direct mode: subscriber pays pay-subscription when due; next_due advances on-chain; backend updates on events.
// - Cancel: set active=0 on-chain and DB.

// Webhook logs
// - Each attempt persisted with attempts and last_attempt_at.
// - Success halts retries; failures schedule exponential backoff up to 5 attempts.

// Admin bootstrap
// - bootstrap-admin sets immutable admin principal; further changes require redeploy.


##### **Event & Messaging Interfaces
// Outbound webhook payloads (camelCase JSON)
type InvoicePaidEvent = { invoiceId: string; status: 'paid'; txId: string; payer: string; amountSats: number };
type InvoiceRefundedEvent = { invoiceId: string; status: 'refunded'; refundTxId: string; refundAmount: number };
type SubscriptionInvoiceCreatedEvent = { subscriptionId: string; invoiceId: string; amountSats: number; nextDue: number; subscriber: string };
type SubscriptionCreatedEvent = { subscriptionId: string; merchant: string; subscriber: string; amountSats: number; intervalBlocks: number; nextDue: number };
type SubscriptionPaidEvent = { subscriptionId: string; subscriber: string; amountSats: number; txId: string; nextDue: number };
type SubscriptionCanceledEvent = { subscriptionId: string };
type InvoiceExpiredEvent = { invoiceId: string; status: 'expired' };
type InvoiceCanceledEvent = { invoiceId: string };

// Webhook headers
// - Content-Type: application/json
// - X-Webhook-Timestamp: <unix seconds>
// - X-Webhook-Signature: v1=<hex(hmac_sha256(secret, `${ts}.${rawBody}`))>

// Contract print events (semantic names)
// - 'invoice-created', 'invoice-paid', 'invoice-refunded', 'invoice-canceled', 'invoice-expired'
// - 'subscription-created', 'subscription-paid', 'subscription-canceled'


##### **SerializationFormats
// Network JSON (selected canonical shapes)

// UnsignedContractCall
{
  "contractAddress": "SPXXXX...",
  "contractName": "sbtc-payment",
  "functionName": "pay-invoice",
  "functionArgs": [/* CVs */],
  "postConditionMode": "deny",
  "postConditions": [/* FPCs */],
  "anchorMode": "any",
  "network": "testnet"
}

// PublicInvoiceDTO
{
  "invoiceId": "6c9c...-uuid",
  "idHex": "aabb...64hex",
  "storeId": "f1a9...-uuid",
  "amountSats": 25000,
  "usdAtCreate": 17000.12,
  "quoteExpiresAt": 1724301234567,
  "merchantPrincipal": "SP123...",
  "status": "unpaid",
  "createdAt": 1724300000
}

// StorePublicProfileDTO
{
  "displayName": "Demo Shop",
  "logoUrl": "https://...",
  "brandColor": "#00AAFF",
  "supportEmail": "help@shop.tld",
  "supportUrl": "https://support.shop.tld"
}


##### **Error Handling & Fault Tolerance
// API error shapes
// Public routes: { "reason": PublicErrorReason }
// Merchant/Admin routes: { "error": MerchantAdminError }

// Retry policies (webhooks)
interface WebhookRetryPolicy {
  maxAttempts: 5;
  backoffSeconds: number[]; // e.g., [0, 60, 120, 240, 480, 960] planned per attempt
}

// Poller resilience
interface PollerResilience {
  minConfirmations: number; // from config
  reorgWindowBlocks: number; // from config
  singleFlightPerTick: true; // reentrancy guard
}

// Expiration handling
// - DB TTL: quote_expires_at < now => expired
// - On-chain: get-invoice-status === 'expired' => expired
// - Single-shot 'invoice-expired' webhook if not previously successful


##### **Concurrency & Synchronization Handling
// Atomicity and single-flight constraints

// DB transaction hints (applied by callers):
// - Mark paid/refunded/canceled updates occur within single statements or transactions.
// - Subscription invoice generation + schedule advancement executed atomically.

// Single-flight poller
interface ReentrancyGuard {
  guardReentrancy(): boolean; // returns false if already running
}

// Webhook inflight dedupe
interface RetryDeduper {
  isInflight(key: string): boolean;
  markInflight(key: string): void;
  clearInflight(key: string): void;
}

// Idempotent updates
// - Use unique keys (id_hex) to avoid duplicate invoice/subscription inserts.
// - Webhook success existence check prevents duplicate deliveries.


##### **Multi-User Environments & Authentication
// Public endpoints
// - No auth; dynamic CORS enforced via merchants.allowed_origins.

// Merchant endpoints
// - Header: X-API-Key required; must resolve to active merchant.
// - Tenant isolation: :storeId in path MUST equal authenticated merchant.id; mismatch → 404.

// Admin endpoints
// - Authorization: Bearer ADMIN_TOKEN or Basic (ADMIN_USER/ADMIN_PASS).
// - Admin SPA assets and /api/admin guarded identically.

// Webhook signatures (outbound/inbound verify)
// - Headers: X-Webhook-Timestamp, X-Webhook-Signature.
// - Skew: reject if |now - ts| > 300s (inbound).
// - Replay cache: 10 minutes keyed by signature.
// - HMAC: v1 with store-scoped hmac_secret.

End of report.
```
