

# Architectural Plan:
| Component Name | Description |
| -------------- | ----------- |
| ExpressServer | Acts as the central HTTP server and routing orchestrator for all incoming requests (web, API, static, middleware). Dispatches and delegates to specific handlers, applies validation, CORS, error, and session middleware, manages full server lifecycle, and statelessly routes all feature flows. Explicitly owns parsing of session state, constructs per-request context, and orchestrates secure handling of secrets (API key/HMAC never escape backend). Integrates with BridgeApiClient for all business data operations, Postmark API for email relay, QR code rendering for visual displays, and employs Tailwind CSS for UI styling in server-rendered HTML. Engages in dynamic CORS header application based on live store config, injects branding and profile data into rendering, and ensures no local or persistent business state is stored (requests always source from Bridge). All errors from downstream handlers or Bridge API calls are captured by error-handling middleware and relayed as-is to the UI. Session management is active for protected routes, delegating to SessionManager for authentication state. For all static assets, ExpressServer registers static file middleware, serving Tailwind builds and image assets. |
| BridgeApiClient | Acts as the sole conduit for all business-data operations between WEBPAY and the Bridge API. On request, retrieves and injects the correct per-store `X-API-Key` (from dotenv or secure session) to every outgoing Bridge API call. Performs validated forwarding of all CRUD and business actions: invoice creation, status lookup, subscription management, refunds, admin operations, branding/profile updates, webhook retry, sBTC config, and protocol bootstrap/sync. Normalizes error codes and propagates clean error objects upstream for UI surfacing. Ensures secrets are never exposed outside backend context, including live reload of secrets after key rotation. Coordinates synchronous and asynchronous fetch/XHR actions, always sourcing freshest data for business flows. Integration point for middleware and route handlers: every meaningful stateful operation passes through this component (no local data is persisted). |
| MagicLinkValidator | Decodes, parses, and rigorously validates the `u` payload attached to magic-link page requests for both invoices and subscriptions. Verifies the presence and structure of `u`, decodes base64url, checks that HMAC-SHA256 signature (using the per-store `hmacSecret` loaded from secure server-side env or config) matches the canonical JSON serialization of the relevant fields (`{v,storeId,invoiceId,unsignedCall,exp}`). Enforces domain invariants: ensures expiry is not past and TTL not excessive, path parameters (`storeId`, `invoiceId`/`subscriptionId`) match the decoded data, unsignedCall is shaped and parameterized correctly (function, postConditionMode, FT post-condition, network matches), and checks live invoice/subscription status and values by calling the Bridge API. Rejects any validation failure by halting processing and triggering error rendering. Owns all security and anti-replay checks, ensuring wallet cannot be invoked unless all validations pass. Data is transient and request-bound; no persistent business or session state is kept. |
| MagicLinkPageRenderer | Composes and renders the server-side HTML for both invoice and subscription magic-link checkout pages, receiving validated data from MagicLinkValidator. Injects all data required for the client (unsignedCall, expiry, branding/profile, QR code, error/expired/paid state). Chooses the correct template and UI state (valid/expired/error) and disables wallet UI elements as needed. Fetches and applies current branding via BrandingProfileManager, ensures QR is generated for the magic-link, and prepares client-side script initialization with the validated payload. Ensures Tailwind styling and minimal, user-friendly error fallback. No persistent state; all data contextual to request. |
| MagicLinkClientScript | Executes all client-side behaviors for the magic-link page lifecycle: on DOMContentLoaded, decodes and re-validates the `u` payload (defense-in-depth), checking expiry, unsignedCall shape, postConditionMode, and FT post-condition. Immediately attempts to open the wallet via @stacks/connect if valid; if browser blocks auto-open, injects/attaches "Open wallet" button (binding click event). On wallet Connect completion, handles wallet response, displays broadcasted txid, and triggers redirect if `return` param present. Sets up setInterval polling for invoice/subscription status, updating UI in real time for status transitions (paid/expired/canceled/broadcasted). Handles disabling or updating UI controls on expiry or error. All state is ephemeral and scoped to the page session; no data is retained after navigation. |
| CheckoutHandler | Handles POST /checkout/:storeId requests from merchant sites/apps. On request, validates payload structure and invariants (amount>0, TTL in [120,1800]), using TypeScript schema or manual checks. Calls BridgeApiClient.prepareInvoice(storeId, payload) with the securely loaded per-store API key. Interprets Bridge response: on success, returns HTTP 302 redirect to magicLink for shopper; on error, calls ErrorHandler to return user-friendly 4xx/409 error ("Store not ready"). Owns no state; all data is request-scoped and business logic is owned by Bridge. |
| PosRouteHandler | Directly renders and controls the POS terminal page for merchants, orchestrating sale flows: receives authenticated GET requests, renders POS HTML with amount, memo, TTL fields (using Tailwind CSS), and ensures merchant session is valid via SessionManager. Handles "Create" button clicks by collecting form data, submitting POST to backend, which validates, loads API key, calls Bridge to prepare invoice, and returns invoice/magicLink/unsignedCall as JSON. Renders QR for magicLink in UI, sets up timers, and status strip. Handles "Cancel" button clicks by submitting POST to backend, which uses API key to call Bridge cancel endpoint, and updates UI accordingly. Polls invoice status (paid, expired, canceled) via setInterval and disables/updates UI as per result. After payment/expiry/cancel, displays relevant end state ("Paid ✓", "Expired", "Canceled") and enables "New Sale" action. Only ever fetches/transmits ephemeral data; never exposes API key client-side. |
| MerchantConsoleHandler | Drives all merchant dashboard interactions for invoices, refunds, subscriptions, and branding. Handles explicit UI events tied to merchant actions, including creating invoices (modal form collection, POST to backend, Bridge call, UI update), sending/resending/previews of emails (invokes backend endpoints, fetches latest invoice and branding data from Bridge, regenerates magic-link, assembles email content via renderInvoiceEmail/renderInvoiceEmailText, sends via Postmark API; updates UI with confirmation toast/banner on success or displays error on failure), copying magic-links (Clipboard API), showing QRs, canceling invoices (backend POST, disables UI), opening refund drawers (validates refund amount, submits refund POST, wallet Connect for signing), and enables/disables row-level actions by invoice status. Implements polling for invoice statuses to update UI. All email delivery logic for resending is orchestrated as a backend call, ensuring all template data is fresh and secrets are never exposed. Errors are surfaced in a non-technical, user-friendly fashion, disabling further actions as necessary. All data/state is session or page-local, only ever ephemeral, and always sourced live from backend/Bridge calls. |
| AdminConsoleHandler | Orchestrates full admin UI and backend flows: creates and lists stores (validates inputs, POSTs to backend, processes Bridge response, triggers UI update), activates/deactivates stores (toggles badge/UI, PATCHes to Bridge, updates on response), updates branding/profile (form validation, PATCH to Bridge, triggers UI update), rotates keys (POST to Bridge, processes one-time reveal, disables future reveals, copies secret to clipboard), sets sBTC token (form, unsigned call generation, triggers wallet Connect), syncs on-chain state (fetches unsigned calls, triggers Connect for each), manages poller status/logs (fetches poller status, triggers restart, fetches webhook logs, triggers retries, updates UI), and ensures all UI is live from Bridge (no cache). Triggers store list re-fetch after any relevant action. Handles errors and status with explicit banners/toasts, disables UI for failed actions, and integrates with session middleware for admin auth. |
| BrandingProfileManager | Fetches, injects, and applies public branding/profile data on all relevant UI surfaces: magic-link checkout/subscription pages, POS, dashboard, merchant/admin settings, emails. On every render or branding input change, fetches `/api/v1/stores/:storeId/public-profile` live from Bridge (no cache), parses branding fields (`displayName`, `logoUrl`, `brandColor`, `supportEmail`, `supportUrl`), and applies them into UI templates/components using DOM/JS or server template variables. Handles missing/incomplete fields gracefully, substituting defaults or omitting as needed to ensure robust UI and email rendering. Triggers UI updates on branding/profile change or via periodic polling. No persistent state; data is ephemeral per render. |
| EmailDeliveryHandler | Assembles, validates, and sends transactional emails for invoices and subscriptions via Postmark. On relevant events (invoice/subscription creation, merchant-triggered send/resend/preview), fetches latest invoice/subscription/branding/magic-link by calling Bridge, validates all input, constructs the magic-link (validates HMAC), renders email content using HTML/text templates, and triggers Postmark send via API. Handles synchronous Postmark responses, surfaces result to frontend/UI, and disables duplicate sends unless explicitly retried. Responds to validation errors (missing data, invalid recipient, etc) by aborting send and returning clear error to UI, blocking any status update. On Postmark API errors, returns HTTP 500+ error, does not update UI status, and logs error. Provides backend email preview on request (no send). All data is non-persistent, built per request or event. |
| ErrorHandler | Surfaces and relays all error events (validation, Bridge API, Postmark, internal) to the UI in a consistent, user-friendly, and non-technical manner. On error detection (backend or frontend), disables further relevant UI actions, injects minimal error UI (toasts, banners, disables controls), and ensures ambiguous or indeterminate states are never displayed. Handles backend error propagation via Express middleware, translating error objects to HTTP responses and triggers UI error state. Ensures duplicate or invalid actions are blocked from further attempts unless explicitly retried. Never logs or persists errors; all handling is immediate and transient. |
| SessionManager | Manages authentication and session state for merchants/admins; enforces access to protected areas (POS, merchant, admin consoles).<br>**System Boundaries & State Flow**Handles login/logout, session validation, and user context for protected routes (merchant POS, dashboard, admin). Does not manage business data, only user/session state.<br>**Responsibilities & Interactions**:<br>Configures and applies Express session middleware. On protected route, checks session validity; redirects or 403 on not authenticated. Stores session data in memory or store. Loads user/store context for downstream handlers.<br>**Event Flows**:<br>Binds to every HTTP request for protected routes via Express middleware. On session expiry or logout, clears session data.<br>**Data Ownership & Lifespan**:<br>Session data is transient, held in memory or session store for session duration.<br>**External Dependencies & Integration**:<br>Express.js, session middleware, cookies, dotenv |
| StaticAssetHandler | Serves static assets (JS, CSS, images, Tailwind output) for all web UIs.<br>**System Boundaries & State Flow**Exposes static file directory via Express. Integrates Tailwind output for styling. No state, no logic outside asset serving.<br>**Responsibilities & Interactions**:<br>Registers Express static middleware for /static or equivalent path. No business logic; only asset serving.<br>**Event Flows**:<br>Handles HTTP GET for /static/* and related paths. Express takes care of cache headers and delivery.<br>**Data Ownership & Lifespan**:<br>No state. Static files are read from disk per request or cached by Express.<br>**External Dependencies & Integration**:<br>Express.js, Node.js fs, Tailwind build artifacts |
| QRRenderer | Generates QR codes for magic-links in POS, invoice, and subscription UIs.<br>**System Boundaries & State Flow**Receives magic-link URL and renders as QR code in HTML (canvas/svg/img) for device scanning. Used in both server-rendered and client-rendered contexts.<br>**Responsibilities & Interactions**:<br>Receives magic-link from parent handler/component, generates QR image for rendering in UI modal or POS page. No business logic, only rendering.<br>**Event Flows**:<br>Called synchronously on request to render relevant UI section. Bound to invoice/subscription creation flows.<br>**Data Ownership & Lifespan**:<br>No state. Outputs ephemeral rendering (canvas/svg/img) only.<br>**External Dependencies & Integration**:<br>JS QR code library |
| WalletIntegration | Invokes @stacks/connect's `request('stx_callContract', ...)` for all payment, refund, cancel, subscription, and protocol actions requiring on-chain signature within the client context. Receives validated unsignedCall objects from server, attempts to open wallet (auto or on user gesture), disables all UI actions while signing, and on completion, invokes result handler to update UI, resume polling, or display broadcast status. Handles wallet errors/cancellations, re-enables UI, and surfaces errors via ErrorHandler. Listens for onSign events for cancel/refund/subscription flows, coordinates with status pollers for UI update, and ensures only one wallet operation is active at a time. Never alters unsignedCall, never exposes secrets. |
| InvoiceStatusPoller | Implements client-side polling (setInterval) for invoice and subscription status on all relevant payment UIs: magic-link checkout, POS, merchant/admin dashboards. Upon invoice creation or page render, sets up a 1-second polling interval to fetch `/i/:invoiceId` (CORS-enabled) or the subscription endpoint, parses status, and updates UI in real time to reflect status transitions ("paid", "expired", "canceled", etc). On state change, updates or disables UI controls, displays terminal state ("Paid ✓", "Expired"), and stops polling. Drives row updates in dashboards and status strips in POS/magic-link. All state is transient and local to poll session. |
| SubscriptionManager | Executes all subscription-related user actions on the merchant dashboard. Orchestrates modal form collection, local validation, and backend POST for subscription creation (triggering Bridge call and updating UI on response). Handles "Generate invoice now" (backend fetch for latest magic-link and unsignedCall, populates modal/success sheet with copy/email/QR actions). Triggers backend POST for sending subscription invoice email (fetches data, validates, assembles email, sends via Postmark, updates UI). Handles "Cancel subscription" (backend POST, if unsigned on-chain call returned, opens wallet via Connect for merchant sign and updates UI on completion). Manages opening linked invoice drawers, row-level copy-link and open-invoice actions, and starts polling for status updates of subscriptions and linked invoices (setInterval-based). All state is local to session/page. |
| PublicProfileFetcher | Fetches the public branding/profile for any store, used on all public UI surfaces (checkout, POS, emails, etc).<br>**System Boundaries & State Flow**On demand, fetches `/api/v1/stores/:storeId/public-profile` from Bridge. Injects branding into UI (logo, color, displayName, support fields). Used everywhere branding is shown publicly.<br>**Responsibilities & Interactions**:<br>Called by rendering components/pages on load, or by email rendering logic. Applies branding to UI layer or template variables. Handles missing fields by applying defaults or omitting gracefully.<br>**Event Flows**:<br>Triggered on render of public UI or email. May be called repeatedly by various pages or components.<br>**Data Ownership & Lifespan**:<br>No persistent state; branding info is ephemeral per page/email render.<br>**External Dependencies & Integration**:<br>BridgeApiClient, fetch/XHR |
| CorsPolicyEnforcer | - **[Offloading Class Names]**: ExpressServer<br>- **[Originating Method Ids]**: ESS-1<br><br>The `CorsPolicyEnforcer` delegate encapsulates all logic for dynamic CORS policy enforcement for merchant/store APIs. It is responsible for extracting the origin and target storeId from the request, fetching the live allowedOrigins from the Bridge API, and making authoritative decisions about whether to allow or block the request, as well as setting the appropriate HTTP headers.<br><br>This separation ensures that all policy, validation, and response logic for CORS is managed in a single domain, reducing complexity and conditional branching in the `ExpressServer` class, and making CORS enforcement implementation consistent and easily testable in isolation.<br><br>**Delegate State Owned:**<br>- None (stateless; all operations are per-request).<br><br>**Delegate Responsibilities Owned:**<br>- Determine the `Origin` and `storeId` for a given Express request.<br>- Fetch live `allowedOrigins` for a store using Bridge API.<br>- Decide if a request should be allowed or blocked based on policy.<br>- Set all necessary CORS HTTP headers for allowed requests.<br>- Handle both regular and preflight (`OPTIONS`) CORS requests.<br>- Block requests and respond with minimal errors on policy violation.<br>- Never cache allowedOrigins and never expose secrets.<br><br>**Responsibilities Removed from Parent Class:**<br>- All conditional logic for extracting the storeId from route, body, or query.<br>- All network interaction with Bridge API for allowedOrigins.<br>- All header setting and response logic for CORS approval/deny.<br>- All error handling associated with CORS policy enforcement.<br><br>**Delegate Public Interface:**<br>```typescript<br>constructor(bridgeApiClient: IBridgeApiClient);<br>enforceCorsPolicy(<br>  req: express.Request,<br>  res: express.Response,<br>  next: express.NextFunction<br>): Promise<void>;<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In ExpressServer constructor:<br>const corsPolicyEnforcer = new CorsPolicyEnforcer(this.bridgeApiClient);<br>this.app.use(corsPolicyEnforcer.enforceCorsPolicy.bind(corsPolicyEnforcer));<br>```<br><br>#### 🔁 Refactored Method: ExpressServer.corsMiddleware<br><br>**Responsibilities After Refactoring:**<br>- The `ExpressServer.corsMiddleware` method is now a thin wrapper/binding that delegates all CORS logic to `CorsPolicyEnforcer.enforceCorsPolicy`, passing through all original arguments.<br>- The only code in the method is the invocation of the delegate, preserving the full signature and async promise handling of the original.<br><br>**How the delegate is called:**<br>```typescript<br>// In ExpressServer class<br>async corsMiddleware(<br>  req: express.Request,<br>  res: express.Response,<br>  next: express.NextFunction<br>): Promise<void> {<br>  return this.corsPolicyEnforcer.enforceCorsPolicy(req, res, next);<br>}<br>```<br><br>#### 🔧 Delegate Method: enforceCorsPolicy<br><br>**Responsibility:**<br>- Handles the full logic of dynamic CORS enforcement for a request, including extraction of `Origin` and `storeId`, live fetch of policy, decision and header setting.<br><br>**Signature:**<br>```typescript<br>async enforceCorsPolicy(<br>  req: express.Request,<br>  res: express.Response,<br>  next: express.NextFunction<br>): Promise<void><br>```<br><br>**Step-by-step logic:**<br>1. Extract the `Origin` header from the request.<br>2. Determine the `storeId` from `req.params`, `req.body`, or `req.query`.<br>3. If no `Origin` is present, call `next()` to allow request.<br>4. If no `storeId`, call `next()`.<br>5. Fetch the store's `allowedOrigins` using the provided Bridge API client.<br>6. If `Origin` is not in `allowedOrigins`, respond with HTTP 403 and minimal error.<br>7. If allowed, set required CORS headers (`Access-Control-Allow-Origin`, `Vary`, etc.).<br>8. On `OPTIONS` requests, set preflight headers and end with 204.<br>9. On error, respond with HTTP 403 and error message.<br><br>**Production-grade code:**<br>```typescript<br>import { IBridgeApiClient } from '../contracts/interfaces';<br>import express from 'express';<br><br>export class CorsPolicyEnforcer {<br>  private bridgeApiClient: IBridgeApiClient;<br><br>  constructor(bridgeApiClient: IBridgeApiClient) {<br>    this.bridgeApiClient = bridgeApiClient;<br>  }<br><br>  /**<br>   * Enforces CORS policy for store APIs.<br>   * Extracts Origin and storeId, fetches live allowedOrigins, sets headers or blocks request.<br>   */<br>  async enforceCorsPolicy(<br>    req: express.Request,<br>    res: express.Response,<br>    next: express.NextFunction<br>  ): Promise<void> {<br>    const origin = req.headers.origin;<br>    if (!origin) {<br>      next();<br>      return;<br>    }<br><br>    let storeId: string or undefined = undefined;<br>    if (req.params && req.params.storeId) storeId = req.params.storeId;<br>    else if (req.body && req.body.storeId) storeId = req.body.storeId;<br>    else if (req.query && req.query.storeId) storeId = req.query.storeId;<br><br>    if (!storeId) {<br>      next();<br>      return;<br>    }<br><br>    try {<br>      const profile = await this.bridgeApiClient.getPublicProfile(storeId);<br>      const allowedOrigins: string[] = Array.isArray((profile as any).allowedOrigins)<br>        ? (profile as any).allowedOrigins<br>        : [];<br><br>      if (!allowedOrigins.includes(origin)) {<br>        res.status(403).send({ error: 'CORS not allowed' });<br>        return;<br>      }<br>      res.setHeader('Access-Control-Allow-Origin', origin);<br>      res.setHeader('Vary', 'Origin');<br>      if (req.method === 'OPTIONS') {<br>        res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PATCH,OPTIONS');<br>        res.setHeader('Access-Control-Allow-Headers', 'Content-Type,Authorization');<br>        res.setHeader('Access-Control-Allow-Credentials', 'true');<br>        res.status(204).end();<br>        return;<br>      }<br>      next();<br>    } catch (_err) {<br>      res.status(403).send({ error: 'CORS profile error' });<br>    }<br>  }<br>}<br>```<br><br>--- |
| MagicLinkUCanonicalSerializer | - **[Offloading Class Names]**: MagicLinkValidator<br>- **[Originating Method Ids]**: MCS-2<br><br>The `MagicLinkUCanonicalSerializer` delegate encapsulates the deterministic, canonical JSON serialization and base64url encoding/decoding logic required for cross-platform signature verification of magic-link `u` payloads. This is an isolated, pure computational concern that is critical for HMAC signature validation and is required to ensure byte-for-byte compatibility between issuer and validator.<br><br>This logic is entirely orthogonal to the main validation, error handling, and HTTP response handling in `MagicLinkValidator` and is thus extracted for clarity, maintainability, and ease of testability.<br><br>**Delegate State Owned:**<br>- None (pure, stateless utility methods).<br><br>**Delegate Responsibilities Owned:**<br>- Canonical JSON serialization with sorted keys for signature payloads.<br>- base64url encoding and decoding (with proper padding and alphabet).<br>- Constant-time Buffer equality checking for security.<br>- Construction of the signature payload object from variable fields.<br><br>**Responsibilities Removed from Parent Class:**<br>- All implementation of deterministic JSON serialization and encoding.<br>- All management of base64url encoding/decoding.<br>- All constant-time equality logic for signature comparison.<br><br>**Delegate Public Interface:**<br>```typescript<br>static canonicalJSONStringify(obj: any): string;<br>static base64urlDecode(str: string): Buffer;<br>static timingSafeEqual(a: Buffer, b: Buffer): boolean;<br>static buildSignaturePayload(decoded: any): any;<br>```<br><br>**Example Interaction:**<br>```typescript<br>const sigSrc = MagicLinkUCanonicalSerializer.canonicalJSONStringify(<br>  MagicLinkUCanonicalSerializer.buildSignaturePayload(decoded)<br>);<br>const calcSig = crypto.createHmac('sha256', Buffer.from(hmacSecret, 'utf8'))<br>  .update(sigSrc, 'utf8').digest();<br>const providedSig = MagicLinkUCanonicalSerializer.base64urlDecode(decoded.sig);<br>if (!MagicLinkUCanonicalSerializer.timingSafeEqual(calcSig, providedSig)) { ... }<br>```<br><br>#### 🔁 Refactored Method: MagicLinkValidator.validateU<br><br>**Responsibilities After Refactoring:**<br>- The method now delegates all serialization, encoding, and signature comparison logic to the `MagicLinkUCanonicalSerializer`.<br>- It focuses on HTTP request parsing, error response, and business validation, delegating all transformation and cryptographic comparison to the delegate.<br><br>**How the delegate is called:**<br>- For serialization:<br>  ```typescript<br>  const sigPayload = MagicLinkUCanonicalSerializer.buildSignaturePayload(decoded);<br>  const sigSrc = MagicLinkUCanonicalSerializer.canonicalJSONStringify(sigPayload);<br>  ```<br>- For base64url decoding:<br>  ```typescript<br>  const providedSig = MagicLinkUCanonicalSerializer.base64urlDecode(decoded.sig);<br>  ```<br>- For timing-safe comparison:<br>  ```typescript<br>  if (!MagicLinkUCanonicalSerializer.timingSafeEqual(calcSig, providedSig)) { ... }<br>  ```<br><br>#### 🔧 Delegate Method: canonicalJSONStringify<br><br>**Responsibility:**<br>- Recursively serializes an object into JSON with all keys sorted, no extra whitespace, to ensure deterministic output for HMAC signature computation across platforms.<br><br>**Signature:**<br>```typescript<br>static canonicalJSONStringify(obj: any): string<br>```<br><br>**Code:**<br>```typescript<br>static canonicalJSONStringify(obj: any): string {<br>  if (Array.isArray(obj)) {<br>    return '[' + obj.map(MagicLinkUCanonicalSerializer.canonicalJSONStringify).join(',') + ']';<br>  } else if (obj && typeof obj === 'object' && obj !== null) {<br>    const keys = Object.keys(obj).sort();<br>    return '{' + keys.map(k => JSON.stringify(k) + ':' + MagicLinkUCanonicalSerializer.canonicalJSONStringify(obj[k])).join(',') + '}';<br>  } else {<br>    return JSON.stringify(obj);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: base64urlDecode<br><br>**Responsibility:**<br>- Decodes a base64url string into a Buffer, handling URL alphabet and padding.<br><br>**Signature:**<br>```typescript<br>static base64urlDecode(str: string): Buffer<br>```<br><br>**Code:**<br>```typescript<br>static base64urlDecode(str: string): Buffer {<br>  let b64 = str.replace(/-/g, '+').replace(/_/g, '/');<br>  while (b64.length % 4 !== 0) b64 += '=';<br>  return Buffer.from(b64, 'base64');<br>}<br>```<br><br>#### 🔧 Delegate Method: timingSafeEqual<br><br>**Responsibility:**<br>- Performs a constant-time equality check between two Buffers for security.<br><br>**Signature:**<br>```typescript<br>static timingSafeEqual(a: Buffer, b: Buffer): boolean<br>```<br><br>**Code:**<br>```typescript<br>static timingSafeEqual(a: Buffer, b: Buffer): boolean {<br>  if (a.length !== b.length) return false;<br>  return require('crypto').timingSafeEqual(a, b);<br>}<br>```<br><br>#### 🔧 Delegate Method: buildSignaturePayload<br><br>**Responsibility:**<br>- Composes the canonical payload object for signature validation, including only the present fields (`invoiceId` or `subscriptionId`), as required by the signature contract.<br><br>**Signature:**<br>```typescript<br>static buildSignaturePayload(decoded: any): any<br>```<br><br>**Code:**<br>```typescript<br>static buildSignaturePayload(decoded: any): any {<br>  const payload: any = {<br>    v: decoded.v,<br>    storeId: decoded.storeId,<br>  };<br>  if (decoded.invoiceId) payload.invoiceId = decoded.invoiceId;<br>  if (decoded.subscriptionId) payload.subscriptionId = decoded.subscriptionId;<br>  payload.unsignedCall = decoded.unsignedCall;<br>  payload.exp = decoded.exp;<br>  return payload;<br>}<br>```<br><br>--- |
| MagicLinkPageBrandingBlock | - **[Offloading Class Names]**: MagicLinkPageRenderer<br>- **[Originating Method Ids]**: None<br><br>The `MagicLinkPageBrandingBlock` delegate is a pure visual/presentation subcomponent that renders the merchant branding block for a magic-link payment page. It is extracted from the inline HTML string in `MagicLinkPageRenderer` to reduce layout complexity and focus branding consistency in a single place.<br><br>This delegate receives a branding object with all required fields and returns a raw HTML string for the branding section (logo, displayName, brand bar, support info).<br><br>**Delegate State Owned:**<br>- None (pure functional rendering; all input passed as parameters).<br><br>**Delegate Responsibilities Owned:**<br>- Render the logo, display name, brand color bar, and support information for a merchant/store.<br>- Apply proper Tailwind/class styling and accessibility attributes.<br><br>**Responsibilities Removed from Parent Class:**<br>- All inline HTML string and logic for composing merchant branding visuals in the main layout.<br><br>**Delegate Public Interface:**<br>```typescript<br>static render(branding: {<br>  displayName: string,<br>  logoUrl?: string,<br>  brandColor: string,<br>  supportEmail?: string,<br>  supportUrl?: string<br>}): string<br>```<br><br>**Example Interaction:**<br>```typescript<br>const brandingHtml = MagicLinkPageBrandingBlock.render({<br>  displayName,<br>  logoUrl,<br>  brandColor,<br>  supportEmail,<br>  supportUrl<br>});<br>```<br><br>#### 🔧 Delegate Method: render<br><br>**Responsibility:**<br>- Render the branding block for a payment page, including logo image, display name, colored bar, and support info as HTML.<br><br>**Signature:**<br>```typescript<br>static render(branding: {<br>  displayName: string,<br>  logoUrl?: string,<br>  brandColor: string,<br>  supportEmail?: string,<br>  supportUrl?: string<br>}): string<br>```<br><br>**Production-grade code:**<br>```typescript<br>static render(branding: {<br>  displayName: string,<br>  logoUrl?: string,<br>  brandColor: string,<br>  supportEmail?: string,<br>  supportUrl?: string<br>}): string {<br>  const { displayName, logoUrl, brandColor, supportEmail, supportUrl } = branding;<br>  return `<br>    ${logoUrl<br>      ? `<img id="branding-logoImg" src="${logoUrl}" alt="${displayName} Logo" class="h-12 mb-3">`<br>      : `<div id="branding-logoImg" class="h-12 mb-3 hidden"></div>`<br>    }<br>    <h1 id="branding-displayName" class="text-2xl font-bold mb-1">${displayName}</h1><br>    <div id="branding-brandBar" class="w-20 h-1.5 rounded-full mb-4" style="background-color:${brandColor};"></div><br>    ${(supportEmail or supportUrl) ? `<br>      <div class="mt-4 text-xs text-gray-500"><br>        Need help?<br>        ${supportEmail ? `<span id="branding-supportEmail" class="ml-1">${supportEmail}</span>` : ''}<br>        ${supportUrl ? `<a id="branding-supportUrl" class="ml-2 underline" href="${supportUrl}" target="_blank">${supportUrl}</a>` : ''}<br>      </div><br>    ` : ''}<br>  `;<br>}<br>```<br><br>--- |
| PosPageQrSection | - **[Offloading Class Names]**: PosRouteHandler<br>- **[Originating Method Ids]**: None<br><br>The `PosPageQrSection` delegate is a pure UI rendering helper extracted from the inline HTML/JS in the POS terminal page. It renders (and optionally updates) the QR code visual section for an invoice's magic link, handling the correct Tailwind class composition and HTML layout.<br><br>This delegate is intended for reducing the clutter of inline HTML/JS for QR code placement and making it possible to update the QR code in a single place.<br><br>**Delegate State Owned:**<br>- None (pure functional render).<br><br>**Delegate Responsibilities Owned:**<br>- Render the QR code section for the POS page, including dynamic invoice magic link and Tailwind styling.<br><br>**Responsibilities Removed from Parent Class:**<br>- All inline HTML string for QR code placement and dynamic update logic.<br><br>**Delegate Public Interface:**<br>```typescript<br>static renderQrSection(magicLinkUrl: string): string<br>```<br><br>**Example Interaction:**<br>```typescript<br>const qrSectionHtml = PosPageQrSection.renderQrSection(magicLinkUrl);<br>```<br><br>#### 🔧 Delegate Method: renderQrSection<br><br>**Responsibility:**<br>- Generates HTML for the QR section for a given magic link URL.<br><br>**Signature:**<br>```typescript<br>static renderQrSection(magicLinkUrl: string): string<br>```<br><br>**Production-grade code:**<br>```typescript<br>static renderQrSection(magicLinkUrl: string): string {<br>  if (!magicLinkUrl) return '<div id="qrSection" class="mt-6 flex justify-center hidden"></div>';<br>  return `<br>    <div id="qrSection" class="mt-6 flex justify-center"><br>      <canvas id="invoice-qr-canvas"></canvas><br>      <script><br>        window.QRCode.toCanvas(<br>          document.getElementById('invoice-qr-canvas'),<br>          ${JSON.stringify(magicLinkUrl)},<br>          { width: 192, errorCorrectionLevel: 'M' }<br>        );<br>      </script><br>    </div><br>  `;<br>}<br>```<br><br>---<br><br>End of report.<br>```` |
| BridgeApiSecurityEnforcer | - **[Offloading Class Names]**: BridgeApiClient<br>- **[Originating Method Ids]**: BAC-1, BAC-8<br><br>**Delegate State Owned:**<br>- None (stateless utility, all state is transient and method-local)<br><br>**Delegate Responsibilities Owned:**<br>- Secure and exclusive retrieval of per-store API keys and secrets (apiKey, hmacSecret) from configuration.<br>- Enforcement that secrets are never exposed outside backend/server context.<br>- Centralization of domain-level input validation for sensitive Bridge API calls prior to invocation (to ensure secure, clean parameters before any network interaction).<br>- Handles all validation and access logic for key/secret retrieval and rotation (including one-time reveal enforcement).<br><br>**Responsibilities Removed from Parent Class:**<br>- Direct access and inline validation of sensitive credential material in BridgeApiClient.<br>- Inline domain-level validation of input for sensitive operations (e.g., prepareInvoice).<br>- The logic to ensure one-time reveal and non-leakage of secrets post-rotation.<br><br>**Delegate Public Interface:**<br>```typescript<br>getStoreApiKey(storeId: string): string<br>validatePrepareInvoicePayload(payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }): void<br>enforceOneTimeReveal(revealed: boolean): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>const apiKey = securityEnforcer.getStoreApiKey(storeId);<br>securityEnforcer.validatePrepareInvoicePayload(payload);<br>securityEnforcer.enforceOneTimeReveal(alreadyRevealed);<br>// Used inside BridgeApiClient methods prior to making Bridge API requests<br>```<br><br>#### 🔁 Refactored Method: BridgeApiClient.prepareInvoice<br><br>**Breakdown of responsibilities after refactoring:**<br>- The BridgeApiClient no longer contains inline logic for retrieving the store API key or validating the invoice payload.<br>- Instead, it delegates retrieval of the API key and payload validation to the BridgeApiSecurityEnforcer.<br>- The BridgeApiClient proceeds with the actual request logic only after validation passes and the correct key is securely retrieved.<br><br>**How the delegate is called:**<br>- BridgeApiClient receives `storeId` and `payload` as parameters.<br>- Calls `securityEnforcer.getStoreApiKey(storeId)` to retrieve the authenticated apiKey.<br>- Calls `securityEnforcer.validatePrepareInvoicePayload(payload)` for domain validation.<br>- Proceeds with the Bridge API request using the validated data.<br><br>```typescript<br>async prepareInvoice(<br>  storeId: string,<br>  payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }<br>): Promise<MagicLinkDTO> {<br>  const apiKey = this.securityEnforcer.getStoreApiKey(storeId);<br>  this.securityEnforcer.validatePrepareInvoicePayload(payload);<br>  const endpoint = `/api/v1/stores/${storeId}/prepare-invoice`;<br>  return await this.doRequest('POST', endpoint, { apiKey, body: payload });<br>}<br>```<br><br>#### 🔁 Refactored Method: BridgeApiClient.rotateKeys<br><br>**Breakdown of responsibilities after refactoring:**<br>- The BridgeApiClient no longer manages the logic that restricts secret retrieval to a one-time reveal; this is now enforced by the delegate before returning or handling secrets.<br>- The BridgeApiClient receives rotation result from Bridge, then invokes the delegate to enforce proper post-rotation secrecy rules.<br><br>**How the delegate is called:**<br>- After invoking the Bridge API rotation endpoint, the BridgeApiClient calls `securityEnforcer.enforceOneTimeReveal(revealed)` where `revealed` is true if secrets have previously been obtained.<br><br>```typescript<br>async rotateKeys(storeId: string): Promise<StoreSecrets> {<br>  const result = await this.doRequest('POST', `/api/admin/stores/${storeId}/rotate-keys`);<br>  this.securityEnforcer.enforceOneTimeReveal(result.alreadyRevealed);<br>  return result;<br>}<br>```<br><br>#### 🔧 Delegate Method: getStoreApiKey<br><br>**Responsibility:**<br>- Securely retrieves the API key for a given store from the process environment or secure config object.<br>- Throws if the apiKey is missing or undefined.<br><br>**Signature:**<br>```typescript<br>getStoreApiKey(storeId: string): string<br>```<br><br>**Code:**<br>```typescript<br>export class BridgeApiSecurityEnforcer {<br>  private storeSecrets: Record<string, { apiKey: string; hmacSecret: string }>;<br><br>  constructor(storeSecrets: Record<string, { apiKey: string; hmacSecret: string }>) {<br>    this.storeSecrets = storeSecrets;<br>  }<br><br>  getStoreApiKey(storeId: string): string {<br>    const secrets = this.storeSecrets[storeId];<br>    if (!secrets or !secrets.apiKey) {<br>      throw {<br>        statusCode: 500,<br>        message: `Missing API key for store ${storeId}`<br>      };<br>    }<br>    return secrets.apiKey;<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: validatePrepareInvoicePayload<br><br>**Responsibility:**<br>- Validates the shape and content of the invoice payload before passing it to the Bridge API to ensure basic domain integrity and to help prevent accidental leakage or malformed requests.<br><br>**Signature:**<br>```typescript<br>validatePrepareInvoicePayload(payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }): void<br>```<br><br>**Full code:**<br>```typescript<br>validatePrepareInvoicePayload(payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }): void {<br>  if (<br>    typeof payload.amount_sats !== 'number' or<br>    payload.amount_sats <= 0 or<br>    typeof payload.ttl_seconds !== 'number' or<br>    payload.ttl_seconds < 120 or<br>    payload.ttl_seconds > 1800 or<br>    typeof payload.memo !== 'string' or<br>    !payload.memo<br>  ) {<br>    throw {<br>      statusCode: 400,<br>      message: 'Invalid invoice creation parameters'<br>    };<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: enforceOneTimeReveal<br><br>**Responsibility:**<br>- Throws an error if an attempt is made to reveal secrets more than once after rotation, enforcing the one-time-reveal postcondition for API keys and HMAC secrets.<br><br>**Signature:**<br>```typescript<br>enforceOneTimeReveal(alreadyRevealed: boolean): void<br>```<br><br>**Full code:**<br>```typescript<br>enforceOneTimeReveal(alreadyRevealed: boolean): void {<br>  if (alreadyRevealed) {<br>    throw {<br>      statusCode: 403,<br>      message: 'Secret already revealed; further access forbidden'<br>    };<br>  }<br>}<br>```<br><br>--- |
| BridgeApiHttpRequestHelper | - **[Offloading Class Names]**: BridgeApiClient<br>- **[Originating Method Ids]**: BAC-1,BAC-2,BAC-3,BAC-4,BAC-5,BAC-6,BAC-7,BAC-8,BAC-9,BAC-10,BAC-11,BAC-12,BAC-13,BAC-14,BAC-15<br><br>**Delegate State Owned:**<br>- None (stateless; all data passed as arguments)<br><br>**Delegate Responsibilities Owned:**<br>- All low-level HTTP request construction, serialization, header building, execution, and JSON parsing for Bridge API requests.<br>- Handling query string composition, content-type enforcement, and error normalization in a centralized way.<br>- Ensures no data is persisted or cached; all requests are stateless and transient.<br><br>**Responsibilities Removed from Parent Class:**<br>- Inline HTTP request composition logic (URL, headers, fetch/axios, JSON parsing, error normalization).<br>- Query string construction.<br>- Error object construction and throwing for upstream error handling.<br><br>**Delegate Public Interface:**<br>```typescript<br>doRequest(<br>  method: 'GET' or 'POST' or 'PATCH',<br>  baseUrl: string,<br>  endpoint: string,<br>  opts: {<br>    apiKey?: string;<br>    body?: any;<br>    query?: Record<string, any>;<br>    headers?: Record<string, string>;<br>  }<br>): Promise<any><br>```<br><br>**Example Interaction:**<br>```typescript<br>const data = await httpRequestHelper.doRequest('POST', this.baseUrl, endpoint, { apiKey, body: payload });<br>```<br><br>#### 🔁 Refactored Method: BridgeApiClient.prepareInvoice<br><br>**Breakdown of responsibilities after refactoring:**<br>- The BridgeApiClient no longer manually composes URLs, sets headers, or parses JSON responses.<br>- Instead, it delegates all HTTP logic to BridgeApiHttpRequestHelper, only managing business-level inputs and outputs.<br><br>**How the delegate is called:**<br>- BridgeApiClient calls the helper's `doRequest` with all request details (method, baseUrl, endpoint, opts).<br>- Receives JSON or error as a return value.<br><br>```typescript<br>async prepareInvoice(<br>  storeId: string,<br>  payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }<br>): Promise<MagicLinkDTO> {<br>  const apiKey = this.securityEnforcer.getStoreApiKey(storeId);<br>  this.securityEnforcer.validatePrepareInvoicePayload(payload);<br>  const endpoint = `/api/v1/stores/${storeId}/prepare-invoice`;<br>  return await this.httpRequestHelper.doRequest('POST', this.baseUrl, endpoint, { apiKey, body: payload });<br>}<br>```<br><br>#### 🔧 Delegate Method: doRequest<br><br>**Responsibility:**<br>- Constructs and executes an HTTP request to the Bridge API.<br>- Handles query parameters, headers (including X-API-Key), JSON body serialization, and parses the JSON response (or throws normalized errors).<br>- Ensures statelessness, no side-effects, no caching, and no leakage of secrets.<br><br>**Signature:**<br>```typescript<br>doRequest(<br>  method: 'GET' or 'POST' or 'PATCH',<br>  baseUrl: string,<br>  endpoint: string,<br>  opts: {<br>    apiKey?: string;<br>    body?: any;<br>    query?: Record<string, any>;<br>    headers?: Record<string, string>;<br>  }<br>): Promise<any><br>```<br><br>**Full code:**<br>```typescript<br>export class BridgeApiHttpRequestHelper {<br>  async doRequest(<br>    method: 'GET' or 'POST' or 'PATCH',<br>    baseUrl: string,<br>    endpoint: string,<br>    opts: {<br>      apiKey?: string;<br>      body?: any;<br>      query?: Record<string, any>;<br>      headers?: Record<string, string>;<br>    } = {}<br>  ): Promise<any> {<br>    let url = baseUrl + endpoint;<br>    if (opts.query) {<br>      const qs = Object.entries(opts.query)<br>        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v as any)}`)<br>        .join('&');<br>      if (qs.length > 0) url += (url.includes('?') ? '&' : '?') + qs;<br>    }<br><br>    const headers: Record<string, string> = {<br>      'Content-Type': 'application/json',<br>      ...(opts.apiKey ? { 'X-API-Key': opts.apiKey } : {}),<br>      ...(opts.headers or {})<br>    };<br><br>    const fetchOpts: RequestInit = {<br>      method,<br>      headers,<br>      ...(method !== 'GET' ? { body: opts.body ? JSON.stringify(opts.body) : undefined } : {})<br>    };<br><br>    const resp = await fetch(url, fetchOpts);<br>    const respText = await resp.text();<br>    let data: any = undefined;<br>    try {<br>      data = respText ? JSON.parse(respText) : undefined;<br>    } catch (e) {<br>      throw {<br>        statusCode: resp.status,<br>        message: 'Invalid response from Bridge API'<br>      };<br>    }<br><br>    if (!resp.ok) {<br>      throw {<br>        statusCode: data && data.statusCode ? data.statusCode : resp.status,<br>        message: data && data.error ? data.error : data && data.message ? data.message : 'Bridge API Error'<br>      };<br>    }<br>    return data;<br>  }<br>}<br>```<br><br>--- |
| EmailBrandingFallbackHandler | - **[Offloading Class Names]**: BridgeApiClient<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless helper)<br><br>**Delegate Responsibilities Owned:**<br>- Gracefully handle missing or incomplete branding fields for email template rendering.<br>- Provide defaults or omit missing fields such that email content remains intact and user-friendly.<br>- Ensures that presentation mapping for emails is robust and never fails due to missing configuration.<br><br>**Responsibilities Removed from Parent Class:**<br>- Inline logic for checking branding fields or defaults in BridgeApiClient or email composition utilities.<br><br>**Delegate Public Interface:**<br>```typescript<br>applyBrandingFallbacks(branding: {<br>  logo?: string or null;<br>  brandColor?: string or null;<br>  displayName?: string or null;<br>  supportEmail?: string or null;<br>  supportUrl?: string or null;<br>}): {<br>  logo: string;<br>  brandColor: string;<br>  displayName: string;<br>  supportEmail: string;<br>  supportUrl: string;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const finalBranding = EmailBrandingFallbackHandler.applyBrandingFallbacks(rawBranding);<br>```<br><br>#### 🔧 Delegate Method: applyBrandingFallbacks<br><br>**Responsibility:**<br>- Returns branding object with omitted or defaulted fields as needed for robust email rendering.<br><br>**Signature:**<br>```typescript<br>applyBrandingFallbacks(branding: {<br>  logo?: string or null;<br>  brandColor?: string or null;<br>  displayName?: string or null;<br>  supportEmail?: string or null;<br>  supportUrl?: string or null;<br>}): {<br>  logo: string;<br>  brandColor: string;<br>  displayName: string;<br>  supportEmail: string;<br>  supportUrl: string;<br>}<br>```<br><br>**Full code:**<br>```typescript<br>export class EmailBrandingFallbackHandler {<br>  static applyBrandingFallbacks(branding: {<br>    logo?: string or null;<br>    brandColor?: string or null;<br>    displayName?: string or null;<br>    supportEmail?: string or null;<br>    supportUrl?: string or null;<br>  }): {<br>    logo: string;<br>    brandColor: string;<br>    displayName: string;<br>    supportEmail: string;<br>    supportUrl: string;<br>  } {<br>    return {<br>      logo: branding.logo or 'https://webpay.app/default-logo.png',<br>      brandColor: branding.brandColor or '#222222',<br>      displayName: branding.displayName or 'Merchant',<br>      supportEmail: branding.supportEmail or 'support@webpay.app',<br>      supportUrl: branding.supportUrl or 'https://webpay.app/support'<br>    };<br>  }<br>}<br>```<br>````<br><br>End of report. |
| InvoiceUiFeedbackRenderer | - **[Offloading Class Names]**: MerchantConsoleHandler<br>- **[Originating Method Ids]**: MCH-1, MCH-2, MCH-5, MCH-10, MCH-11, MCH-14<br><br>This delegate handles all ephemeral UI feedback and presentation logic for the merchant dashboard regarding invoice-related actions. Specifically, it manages the rendering and state updates for success sheets, toasts/banners, invoice row disables/hides, and copy-to-clipboard feedback, centralizing all presentational effects so they are not spread throughout the merchant console logic.<br><br>**Delegate State Owned:**<br>- None persistent; only manipulates DOM state/transient UI elements per action.<br><br>**Delegate Responsibilities Owned:**<br>- Rendering invoice creation success sheets (modal with all invoice details and action hooks).<br>- Showing/hiding Tailwind-styled toasts or banners for user feedback.<br>- Disabling, updating, or hiding invoice rows in the dashboard table.<br>- Copy-to-clipboard UI feedback and error/success messaging.<br>- Displaying UI results of cancel/archive/copy actions.<br><br>**Responsibilities Removed from Parent Class:**<br>- DOM selection, update, and display logic for invoice table rows.<br>- Rendering and updating ephemeral modals, banners, and toasts.<br>- UI feedback for copy/magic-link/archive/cancel actions.<br>- All transient interface feedback for invoice-related UI events.<br><br>**Delegate Public Interface:**<br>```typescript<br>class InvoiceUiFeedbackRenderer {<br>  renderInvoiceSuccessSheet(invoice: Invoice, magicLink: string, unsignedCall: any, emailHandler: (id: string) => void, qrHandler: (url: string) => void): void;<br>  showToast(msg: string): void;<br>  disableInvoiceRow(invoiceId: string, status: string): void;<br>  hideInvoiceRow(invoiceId: string): void;<br>  handleCopyLink(magicLink: string): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In MerchantConsoleHandler.handleCreateInvoice<br>this.uiFeedbackRenderer.renderInvoiceSuccessSheet(data.invoice, data.magicLink, data.unsignedCall, this.handleEmailInvoice, this.handleShowQr);<br><br>// In MerchantConsoleHandler.handleCopyLink<br>this.uiFeedbackRenderer.handleCopyLink(magicLink);<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.handleCreateInvoice<br>After refactoring, this method no longer manipulates modals or DOM directly. Instead, it delegates rendering the invoice creation success sheet and all presentation/feedback logic to `InvoiceUiFeedbackRenderer`. It collects form data, submits to backend, and passes results to the delegate, which updates the UI.<br><br>```typescript<br>public handleCreateInvoice(): void {<br>  // ...collect and validate input as before...<br>  fetch(`/api/v1/stores/${encodeURIComponent(storeId)}/prepare-invoice`, {<br>    method: 'POST',<br>    headers: { 'Content-Type': 'application/json' },<br>    body: JSON.stringify({<br>      amount_sats: amount,<br>      memo,<br>      ttl_seconds: ttl<br>    })<br>  })<br>    .then(async resp => {<br>      if (!resp.ok) throw await resp.json();<br>      return resp.json();<br>    })<br>    .then((data: MagicLinkDTO) => {<br>      this.uiFeedbackRenderer.renderInvoiceSuccessSheet(<br>        data.invoice,<br>        data.magicLink,<br>        data.unsignedCall,<br>        this.handleEmailInvoice.bind(this),<br>        this.handleShowQr.bind(this)<br>      );<br>    })<br>    .catch(err => {<br>      this.errorHandler.handleBridgeApiError(err);<br>    })<br>    .finally(() => {<br>      if (submitBtn) submitBtn.disabled = false;<br>    });<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.handleCopyLink<br>Delegates clipboard logic and all UI feedback to the InvoiceUiFeedbackRenderer.<br><br>```typescript<br>public handleCopyLink(magicLink: string): void {<br>  this.uiFeedbackRenderer.handleCopyLink(magicLink);<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.handleCancelInvoice<br>No longer disables invoice row directly. Delegates disabling of row and UI state to the renderer.<br><br>```typescript<br>public async handleCancelInvoice(invoiceId: string): Promise<void> {<br>  // ...POST to backend...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.disableInvoiceRow(invoiceId, 'Canceled');<br>    this.uiFeedbackRenderer.showToast('Invoice canceled.');<br>  }<br>  // ...<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.archiveInvoice<br>No longer hides row directly; delegates to renderer.<br><br>```typescript<br>public async archiveInvoice(invoiceId: string): Promise<void> {<br>  // ...try POST...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.hideInvoiceRow(invoiceId);<br>  } else {<br>    this.uiFeedbackRenderer.hideInvoiceRow(invoiceId);<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.resendInvoice<br>Delegates UI feedback for success/error to renderer.<br><br>```typescript<br>public async resendInvoice(invoiceId: string): Promise<void> {<br>  // ...POST to backend...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.showToast('Invoice email resent.');<br>  }<br>  // ...<br>}<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.handleCopyMagicLink<br>Delegates copy and UI feedback to renderer.<br><br>```typescript<br>public async handleCopyMagicLink(invoiceId: string): Promise<void> {<br>  // ...fetch magic link...<br>  await this.uiFeedbackRenderer.handleCopyLink(magicLink);<br>}<br>```<br><br>#### 🔧 Delegate Method: renderInvoiceSuccessSheet<br>Renders the invoice creation success modal, populates invoice data, and wires up action handlers for email and QR.<br><br>```typescript<br>public renderInvoiceSuccessSheet(<br>  invoice: Invoice,<br>  magicLink: string,<br>  unsignedCall: any,<br>  emailHandler: (id: string) => void,<br>  qrHandler: (url: string) => void<br>): void {<br>  const modal = document.getElementById('invoice-success-modal');<br>  if (modal) {<br>    const amt = modal.querySelector('.invoice-success-amount') as HTMLElement;<br>    const exp = modal.querySelector('.invoice-success-expiry') as HTMLElement;<br>    const link = modal.querySelector('.invoice-success-magiclink') as HTMLInputElement;<br>    const emailBtn = modal.querySelector('.invoice-success-email-btn') as HTMLButtonElement;<br>    const qrBtn = modal.querySelector('.invoice-success-qr-btn') as HTMLButtonElement;<br>    if (amt) amt.textContent = invoice.amountSats.toString();<br>    if (exp) exp.textContent = invoice.quoteExpiresAt;<br>    if (link) {<br>      link.value = magicLink;<br>      link.readOnly = true;<br>    }<br>    if (emailBtn) {<br>      emailBtn.onclick = () => emailHandler(invoice.invoiceId);<br>    }<br>    if (qrBtn) {<br>      qrBtn.onclick = () => qrHandler(magicLink);<br>    }<br>    modal.style.display = '';<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: showToast<br>Displays a Tailwind-styled toast at the top-right for 2 seconds, reusing or creating the toast DOM element as needed.<br><br>```typescript<br>public showToast(msg: string): void {<br>  let toast = document.getElementById('merchant-console-toast');<br>  if (!toast) {<br>    toast = document.createElement('div');<br>    toast.id = 'merchant-console-toast';<br>    toast.className = 'fixed top-4 right-4 bg-blue-700 text-white px-4 py-2 rounded shadow z-50';<br>    document.body.appendChild(toast);<br>  }<br>  toast.textContent = msg;<br>  toast.style.display = '';<br>  setTimeout(() => {<br>    toast.style.display = 'none';<br>  }, 2000);<br>}<br>```<br><br>#### 🔧 Delegate Method: disableInvoiceRow<br>Disables an invoice row visually and updates its status.<br><br>```typescript<br>public disableInvoiceRow(invoiceId: string, status: string): void {<br>  const row = document.querySelector(`[data-invoice-id="${invoiceId}"]`) as HTMLElement;<br>  if (row) {<br>    const statusCell = row.querySelector('.invoice-status') as HTMLElement;<br>    if (statusCell) statusCell.textContent = status;<br>    row.classList.add('opacity-50', 'pointer-events-none');<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: hideInvoiceRow<br>Hides the invoice row from the table.<br><br>```typescript<br>public hideInvoiceRow(invoiceId: string): void {<br>  const row = document.querySelector(`[data-invoice-id="${invoiceId}"]`) as HTMLElement;<br>  if (row) row.style.display = 'none';<br>}<br>```<br><br>#### 🔧 Delegate Method: handleCopyLink<br>Copies the provided magic link to clipboard and shows feedback. Returns a Promise for async handling.<br><br>```typescript<br>public async handleCopyLink(magicLink: string): Promise<void> {<br>  try {<br>    await navigator.clipboard.writeText(magicLink);<br>    this.showToast('Magic link copied to clipboard');<br>  } catch {<br>    this.showToast('Unable to copy link.');<br>  }<br>}<br>```<br><br>--- |
| QrModalRenderer | - **[Offloading Class Names]**: MerchantConsoleHandler<br>- **[Originating Method Ids]**: MCH-4<br><br>This delegate is responsible for all logic and DOM manipulation required to render and display QR codes for invoice magic links in the merchant UI using a third-party QR code library. It encapsulates the process of showing/hiding the QR modal, updating the QR code, and ensuring only the intended QR is visible at any time.<br><br>**Delegate State Owned:**<br>- None persistent. Uses transient DOM nodes for modal/canvas display.<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the QR modal and updating the QR canvas/image.<br>- Using a QR code library to generate and display QR for a given URL.<br>- Handling DOM visibility toggling for the QR modal.<br><br>**Responsibilities Removed from Parent Class:**<br>- All QR modal/canvas handling and rendering logic.<br>- Direct interaction with the QR code library and DOM for QR display.<br>- Showing/hiding the QR modal and ensuring correct QR is shown.<br><br>**Delegate Public Interface:**<br>```typescript<br>class QrModalRenderer {<br>  showQrModal(magicLink: string): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In MerchantConsoleHandler.handleShowQr<br>this.qrModalRenderer.showQrModal(magicLink);<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.handleShowQr<br>Simplified to delegate all QR rendering logic:<br><br>```typescript<br>public handleShowQr(magicLink: string): void {<br>  this.qrModalRenderer.showQrModal(magicLink);<br>}<br>```<br><br>#### 🔧 Delegate Method: showQrModal<br>Uses a QR code library (window.QRCode) and DOM modal/canvas to render the QR code for the provided link and display the modal. Ensures the modal is visible and uses fixed dimensions.<br><br>```typescript<br>public showQrModal(magicLink: string): void {<br>  const qrModal = document.getElementById('invoice-qr-modal');<br>  const qrCanvas = document.getElementById('invoice-qr-canvas') as HTMLCanvasElement;<br>  if (qrModal && qrCanvas && (window as any).QRCode) {<br>    qrModal.style.display = '';<br>    qrCanvas.width = 192;<br>    qrCanvas.height = 192;<br>    (window as any).QRCode.toCanvas(qrCanvas, magicLink, { width: 192, margin: 0 });<br>  }<br>}<br>```<br><br>--- |
| RefundDrawerManager | - **[Offloading Class Names]**: MerchantConsoleHandler<br>- **[Originating Method Ids]**: MCH-6<br><br>This delegate encapsulates all UI and input management for the refund drawer/modal, including UI state, value rendering, and input constraints. It receives invoice data and handles the presentation logic for refund amounts and available funds, ensuring that UI and input constraints are handled locally and consistently.<br><br>**Delegate State Owned:**<br>- Drawer/modal DOM node and its current content.<br><br>**Delegate Responsibilities Owned:**<br>- Opening/closing the refund drawer/modal.<br>- Populating refund UI fields (paid, refunded, remaining amounts).<br>- Enforcing maximum refundable limits on input.<br>- Handling all DOM updates for the refund UI.<br><br>**Responsibilities Removed from Parent Class:**<br>- UI logic for displaying and updating the refund drawer/modal.<br>- DOM queries and value setting for refund-related fields.<br>- Setting max constraints and displaying refundable balances in the input.<br><br>**Delegate Public Interface:**<br>```typescript<br>class RefundDrawerManager {<br>  openRefundDrawer(invoice: Invoice): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In MerchantConsoleHandler.openRefundDrawer<br>this.refundDrawerManager.openRefundDrawer(invoice);<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.openRefundDrawer<br>Now only fetches invoice and delegates drawer opening:<br><br>```typescript<br>public async openRefundDrawer(invoiceId: string): Promise<void> {<br>  // ...fetch invoice...<br>  this.refundDrawerManager.openRefundDrawer(invoice);<br>}<br>```<br><br>#### 🔧 Delegate Method: openRefundDrawer<br>Displays the refund drawer/modal, populates paid, refunded, and remaining fields, and sets input constraints. Ensures only valid refundable amounts are allowed.<br><br>```typescript<br>public openRefundDrawer(invoice: Invoice): void {<br>  const drawer = document.getElementById('refund-drawer');<br>  if (drawer) {<br>    drawer.style.display = '';<br>    const paidEl = drawer.querySelector('.refund-paid') as HTMLElement;<br>    const refundedEl = drawer.querySelector('.refund-refunded') as HTMLElement;<br>    const remainingEl = drawer.querySelector('.refund-remaining') as HTMLElement;<br>    const input = drawer.querySelector('.refund-amount') as HTMLInputElement;<br><br>    const paid = invoice.amountSats;<br>    const refunded = invoice.refundAmount or 0;<br>    const remaining = paid - refunded;<br><br>    if (paidEl) paidEl.textContent = paid.toString();<br>    if (refundedEl) refundedEl.textContent = refunded.toString();<br>    if (remainingEl) remainingEl.textContent = remaining.toString();<br>    if (input) {<br>      input.max = remaining.toString();<br>    }<br>  }<br>}<br>```<br><br>--- |
| InvoiceListUiRefresher | - **[Offloading Class Names]**: MerchantConsoleHandler<br>- **[Originating Method Ids]**: MCH-16<br><br>Encapsulates the polling and real-time UI update logic for invoices displayed on the merchant dashboard. Handles fetching the latest status for each invoice and updating the relevant DOM elements, enforcing the canonical invoice state in the UI.<br><br>**Delegate State Owned:**<br>- None persistent. Operates on DOM/UI for each poll cycle.<br><br>**Delegate Responsibilities Owned:**<br>- Polling displayed invoice rows by invoiceId.<br>- Fetching invoice data and updating status fields and enabled/disabled buttons.<br>- Ensuring only up-to-date UI is visible.<br><br>**Responsibilities Removed from Parent Class:**<br>- All repetitive polling and invoice table update logic.<br>- DOM queries and updates for invoice rows, statuses, and action buttons.<br>- Handling status and action enable/disable logic per row.<br><br>**Delegate Public Interface:**<br>```typescript<br>class InvoiceListUiRefresher {<br>  refreshInvoiceRows(): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In MerchantConsoleHandler.pollAndUpdateDashboardInvoices<br>await this.invoiceListUiRefresher.refreshInvoiceRows();<br>```<br><br>#### 🔁 Refactored Method: MerchantConsoleHandler.pollAndUpdateDashboardInvoices<br>Now only calls the refresher for actual UI polling:<br><br>```typescript<br>public async pollAndUpdateDashboardInvoices(): Promise<void> {<br>  await this.invoiceListUiRefresher.refreshInvoiceRows();<br>}<br>```<br><br>#### 🔧 Delegate Method: refreshInvoiceRows<br>Finds all invoice rows by data-invoice-id, fetches each invoice from backend, and updates status fields and buttons. Ensures UI reflects canonical Bridge data.<br><br>```typescript<br>public async refreshInvoiceRows(): Promise<void> {<br>  const rows = document.querySelectorAll('[data-invoice-id]');<br>  for (let i = 0; i < rows.length; i++) {<br>    const row = rows[i] as HTMLElement;<br>    const invoiceId = row.dataset['invoiceId'];<br>    if (!invoiceId) continue;<br>    try {<br>      const resp = await fetch(`/i/${encodeURIComponent(invoiceId)}`);<br>      if (!resp.ok) continue;<br>      const invoice: Invoice = await resp.json();<br>      const statusCell = row.querySelector('.invoice-status') as HTMLElement;<br>      if (statusCell) statusCell.textContent = invoice.status;<br>      if (['paid', 'expired', 'canceled'].includes(invoice.status)) {<br>        const payBtn = row.querySelector('.pay-btn') as HTMLButtonElement;<br>        if (payBtn) payBtn.disabled = true;<br>      }<br>    } catch {<br>      // Ignore polling errors for this row<br>    }<br>  }<br>}<br>```<br>End of report.<br>```` |
| StoreProfileFormDelegate | - **[Offloading Class Names]**: AdminConsoleHandler<br>- **[Originating Method Ids]**: ACH-4, ACH-5<br><br>**Delegate State Owned:**<br>- None (stateless; all data and transformations handled per invocation without internal persistence).<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the branding/profile form fields from a Store DTO, including mapping optional/null fields.<br>- Extracting, validating, and transforming input fields from the form on submission.<br>- Composing the update payload for Bridge API.<br>- Performing field-level validations (URLs, hex colors, allowed origins).<br>- Handling mapping between Store DTO structure and UI field names.<br><br>**Responsibilities Removed from Parent Class:**<br>- Field extraction and mapping from Store DTO to form fields.<br>- Input extraction and primary validation from submitted form.<br>- Assembly of payload for Bridge PATCH request.<br><br>**Delegate Public Interface:**<br>```typescript<br>renderFormFields(form: HTMLFormElement, data: Store): void<br>extractAndValidateFormInput(form: HTMLFormElement): { payload: Record<string, any> } or { error: string }<br>```<br><br>**Example Interaction:**<br>```typescript<br>// Rendering branding profile with delegate (ACH-4)<br>storeProfileFormDelegate.renderFormFields(form, storeDto);<br><br>// Extracting and validating form submission (ACH-5)<br>const result = storeProfileFormDelegate.extractAndValidateFormInput(form);<br>if ('error' in result) {<br>  errorHandler.handleValidationError(window, { error: result.error });<br>  return;<br>}<br>const payload = result.payload;<br>await bridgeApiClient.updateStoreProfile(storeId, payload);<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleHandler.renderBrandingProfilePage<br><br>**Responsibilities After Refactoring:**<br>- Calls the delegate’s `renderFormFields` method, passing the form DOM node and the Store DTO.<br>- Binds live preview/integration event handlers as needed (but all field mapping is performed in the delegate).<br><br>**Delegate Usage:**<br>```typescript<br>renderBrandingProfilePage(data: Store): void {<br>  const form = document.getElementById('branding-profile-form') as HTMLFormElement;<br>  if (!form) throw new Error('Branding profile form not found');<br>  this.storeProfileFormDelegate.renderFormFields(form, data);<br>  form.dataset['storeId'] = data.storeId;<br>  form.querySelectorAll('input').forEach(input => {<br>    input.addEventListener('input', (e) => {<br>      this.brandingProfileManager.handleInputChange(e);<br>    });<br>  });<br>}<br>```<br><br>#### 🔁 Refactored Method: AdminConsoleHandler.handleBrandingProfileFormSubmit<br><br>**Responsibilities After Refactoring:**<br>- Calls the delegate’s `extractAndValidateFormInput`, passing the form DOM node.<br>- On error, displays the error via ErrorHandler.<br>- On success, uses the returned payload for the Bridge PATCH request.<br><br>**Delegate Usage:**<br>```typescript<br>async handleBrandingProfileFormSubmit(event: Event): Promise<void> {<br>  event.preventDefault();<br>  const form = event.target as HTMLFormElement;<br>  const storeId = form.dataset['storeId']!;<br>  const result = this.storeProfileFormDelegate.extractAndValidateFormInput(form);<br>  if ('error' in result) {<br>    this.errorHandler.handleValidationError(window, { error: result.error });<br>    return;<br>  }<br>  try {<br>    const updated = await this.bridgeApiClient.updateStoreProfile(storeId, result.payload);<br>    this.renderBrandingProfilePage(updated);<br>  } catch (err) {<br>    this.errorHandler.handleBridgeApiError(err);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: renderFormFields<br><br>**Responsibility:**<br>- Maps all Store DTO fields to the relevant form fields, handling nulls, undefined, and formatting.<br>- Ensures that form fields are populated using exactly the right mapping for each Store attribute.<br><br>**Signature:**<br>```typescript<br>renderFormFields(form: HTMLFormElement, data: Store): void<br>```<br><br>**Code:**<br>```typescript<br>class StoreProfileFormDelegate {<br>  renderFormFields(form: HTMLFormElement, data: Store): void {<br>    (form.querySelector('[name="displayName"]') as HTMLInputElement).value = data.displayName or '';<br>    (form.querySelector('[name="logoUrl"]') as HTMLInputElement).value = data.logoUrl or '';<br>    (form.querySelector('[name="brandColor"]') as HTMLInputElement).value = data.brandColor or '';<br>    (form.querySelector('[name="allowedOrigins"]') as HTMLInputElement).value = Array.isArray(data.allowedOrigins) ? data.allowedOrigins.join(',') : '';<br>    (form.querySelector('[name="webhookUrl"]') as HTMLInputElement).value = data.webhookUrl or '';<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: extractAndValidateFormInput<br><br>**Responsibility:**<br>- Extracts all input values from the form.<br>- Validates them per URL pattern, hex color, required fields, and returns either a payload object (if valid) or an error string (if invalid).<br>- Handles nullables and trims array/string fields.<br><br>**Signature:**<br>```typescript<br>extractAndValidateFormInput(form: HTMLFormElement): { payload: Record<string, any> } or { error: string }<br>```<br><br>**Code:**<br>```typescript<br>class StoreProfileFormDelegate {<br>  extractAndValidateFormInput(form: HTMLFormElement): { payload: Record<string, any> } or { error: string } {<br>    const displayName = (form.querySelector('[name="displayName"]') as HTMLInputElement).value;<br>    const logoUrl = (form.querySelector('[name="logoUrl"]') as HTMLInputElement).value;<br>    const brandColor = (form.querySelector('[name="brandColor"]') as HTMLInputElement).value;<br>    const allowedOrigins = (form.querySelector('[name="allowedOrigins"]') as HTMLInputElement).value;<br>    const webhookUrl = (form.querySelector('[name="webhookUrl"]') as HTMLInputElement).value;<br><br>    if (logoUrl && !/^https?:\/\//.test(logoUrl)) {<br>      return { error: "logoUrl must be a valid URL." };<br>    }<br>    if (brandColor && !/^#[a-fA-F0-9]{6}$/.test(brandColor)) {<br>      return { error: "brandColor must be a hex color." };<br>    }<br>    const allowedOriginsArr = allowedOrigins<br>      ? allowedOrigins.split(',').map(s => s.trim()).filter(Boolean)<br>      : undefined;<br><br>    const payload: Record<string, any> = {};<br>    if (displayName) payload.displayName = displayName;<br>    if (logoUrl) payload.logoUrl = logoUrl;<br>    if (brandColor) payload.brandColor = brandColor;<br>    if (allowedOriginsArr && allowedOriginsArr.length > 0) payload.allowedOrigins = allowedOriginsArr;<br>    if (webhookUrl) payload.webhookUrl = webhookUrl;<br><br>    return { payload };<br>  }<br>}<br>```<br><br>--- |
| StoreListUiDelegate | - **[Offloading Class Names]**: AdminConsoleHandler<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (purely visual rendering, no internal state).<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the store list UI for the admin console from an array of Store DTOs.<br>- Generating and composing UI rows for each store, including all buttons (activate/deactivate, rotate keys, edit branding, set sBTC).<br>- Handling null/optional fields for display logic.<br>- Attaching event bindings to action buttons with explicit data propagation to parent.<br><br>**Responsibilities Removed from Parent Class:**<br>- All DOM composition, row formatting, and button layout for the store list page.<br>- All conditional class/label formatting for store attributes.<br><br>**Delegate Public Interface:**<br>```typescript<br>renderStoreList(container: HTMLElement, data: Store[], handlers: {<br>  onActivateToggle: (storeId: string, newState: boolean) => void,<br>  onRotateKeys: (storeId: string) => void,<br>  onEditBranding: (storeId: string) => void,<br>  onSetSbtc: (storeId: string) => void,<br>}): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In AdminConsoleHandler.renderStoreListPage()<br>this.storeListUiDelegate.renderStoreList(container, storeList, {<br>  onActivateToggle: (storeId, newState) => this.handleActivateStoreToggle(storeId, newState),<br>  onRotateKeys: (storeId) => this.handleRotateKeys(storeId),<br>  onEditBranding: (storeId) => {<br>    this.bridgeApiClient.getStoreProfile(storeId)<br>      .then(profile => this.renderBrandingProfilePage(profile))<br>      .catch(err => this.errorHandler.handleBridgeApiError(err));<br>  },<br>  onSetSbtc: (storeId) => {<br>    const sbtcForm = document.getElementById('set-sbtc-form') as HTMLFormElement;<br>    if (sbtcForm) sbtcForm.dataset['storeId'] = storeId;<br>    // trigger form/modal show logic here<br>  }<br>});<br>```<br><br>#### 🔧 Delegate Method: renderStoreList<br><br>**Responsibilities:**<br>- Receives container element, store DTO array, and a handlers object.<br>- Renders the entire store list, one row per store, with all required labels and buttons.<br>- Attaches all event handlers to corresponding buttons; ensures correct data propagation on click.<br><br>**Signature:**<br>```typescript<br>renderStoreList(<br>  container: HTMLElement,<br>  data: Store[],<br>  handlers: {<br>    onActivateToggle: (storeId: string, newState: boolean) => void,<br>    onRotateKeys: (storeId: string) => void,<br>    onEditBranding: (storeId: string) => void,<br>    onSetSbtc: (storeId: string) => void,<br>  }<br>): void<br>```<br><br>**Code:**<br>```typescript<br>class StoreListUiDelegate {<br>  renderStoreList(<br>    container: HTMLElement,<br>    data: Store[],<br>    handlers: {<br>      onActivateToggle: (storeId: string, newState: boolean) => void,<br>      onRotateKeys: (storeId: string) => void,<br>      onEditBranding: (storeId: string) => void,<br>      onSetSbtc: (storeId: string) => void,<br>    }<br>  ): void {<br>    container.innerHTML = '';<br>    for (const store of data) {<br>      const row = document.createElement('div');<br>      row.className = 'flex flex-row items-center border-b py-2';<br>      const display = store.displayName or store.name;<br>      row.innerHTML = `<br>        <div class="w-44 font-semibold">${display}</div><br>        <div class="w-48 truncate">${store.principal}</div><br>        <div class="w-36">${store.active ? '<span class="text-green-600">Active</span>' : '<span class="text-gray-400">Inactive</span>'}</div><br>        <div class="w-36">${store.sBTCContractAddress ? 'sBTC Configured' : '<span class="text-red-500">No sBTC</span>'}</div><br>        <div class="w-20"><br>          <button class="toggle-activate px-2 py-1 rounded ${store.active ? 'bg-gray-200' : 'bg-green-200'}" data-storeid="${store.storeId}" data-newstate="${store.active ? 'false' : 'true'}">${store.active ? 'Deactivate' : 'Activate'}</button><br>        </div><br>        <div class="w-20"><br>          <button class="rotate-keys px-2 py-1 bg-blue-400 rounded text-white" data-storeid="${store.storeId}">Rotate Keys</button><br>        </div><br>        <div class="w-20"><br>          <button class="edit-branding px-2 py-1 bg-yellow-300 rounded" data-storeid="${store.storeId}">Edit Branding</button><br>        </div><br>        <div class="w-20"><br>          <button class="set-sbtc px-2 py-1 bg-purple-400 rounded text-white" data-storeid="${store.storeId}">Set sBTC</button><br>        </div><br>      `;<br>      container.appendChild(row);<br>    }<br>    container.querySelectorAll('.toggle-activate').forEach(btn => {<br>      btn.addEventListener('click', (e) => {<br>        const tgt = e.currentTarget as HTMLButtonElement;<br>        handlers.onActivateToggle(tgt.getAttribute('data-storeid')!, tgt.getAttribute('data-newstate') === 'true');<br>      });<br>    });<br>    container.querySelectorAll('.rotate-keys').forEach(btn => {<br>      btn.addEventListener('click', (e) => {<br>        const tgt = e.currentTarget as HTMLButtonElement;<br>        handlers.onRotateKeys(tgt.getAttribute('data-storeid')!);<br>      });<br>    });<br>    container.querySelectorAll('.edit-branding').forEach(btn => {<br>      btn.addEventListener('click', (e) => {<br>        const tgt = e.currentTarget as HTMLButtonElement;<br>        handlers.onEditBranding(tgt.getAttribute('data-storeid')!);<br>      });<br>    });<br>    container.querySelectorAll('.set-sbtc').forEach(btn => {<br>      btn.addEventListener('click', (e) => {<br>        const tgt = e.currentTarget as HTMLButtonElement;<br>        handlers.onSetSbtc(tgt.getAttribute('data-storeid')!);<br>      });<br>    });<br>  }<br>}<br>```<br><br>--- |
| WebhookLogUiRenderer | - **[Offloading Class Names]**: AdminConsoleHandler<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless; renders output based on input data).<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the webhook delivery log page/table from an array of WebhookLog DTOs.<br>- Formatting log fields (status, timestamps, attempt count, payload).<br>- Attaching retry button event handler to each applicable row.<br><br>**Responsibilities Removed from Parent Class:**<br>- All DOM creation, field formatting, and event binding for the webhook log list.<br><br>**Delegate Public Interface:**<br>```typescript<br>renderWebhookLogTable(<br>  container: HTMLElement,<br>  logs: WebhookLog[],<br>  onRetry: (webhookLogId: string) => void<br>): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In AdminConsoleHandler.renderWebhookLogPage()<br>this.webhookLogUiRenderer.renderWebhookLogTable(container, logs, (logId) => this.handleWebhookRetry(logId));<br>```<br><br>#### 🔧 Delegate Method: renderWebhookLogTable<br><br>**Responsibilities:**<br>- Receives container, array of WebhookLog DTOs, and retry handler.<br>- Renders each log as a row with formatted status, timestamps, and payload.<br>- Binds retry click handler to buttons for failed logs.<br><br>**Signature:**<br>```typescript<br>renderWebhookLogTable(<br>  container: HTMLElement,<br>  logs: WebhookLog[],<br>  onRetry: (webhookLogId: string) => void<br>): void<br>```<br><br>**Code:**<br>```typescript<br>class WebhookLogUiRenderer {<br>  renderWebhookLogTable(<br>    container: HTMLElement,<br>    logs: WebhookLog[],<br>    onRetry: (webhookLogId: string) => void<br>  ): void {<br>    container.innerHTML = '';<br>    for (const log of logs) {<br>      const row = document.createElement('div');<br>      row.className = 'flex flex-row items-center border-b py-2';<br>      row.innerHTML = `<br>        <div class="w-52">${log.webhookLogId}</div><br>        <div class="w-32">${<br>          log.status === 'delivered'<br>            ? '<span class="text-green-600">Delivered</span>'<br>            : log.status === 'failed'<br>              ? '<span class="text-red-600">Failed</span>'<br>              : '<span class="text-yellow-600">Pending</span>'<br>        }</div><br>        <div class="w-40 text-xs truncate">${log.deliveredAt or log.failedAt or ''}</div><br>        <div class="w-16">${log.attemptCount}</div><br>        <div class="w-28"><br>          <button class="webhook-retry px-2 py-1 bg-blue-400 rounded text-white"<br>            data-logid="${log.webhookLogId}"<br>            ${log.status !== 'failed' ? 'disabled' : ''}>Retry</button><br>        </div><br>        <div class="flex-1 text-xs break-all">${JSON.stringify(log.payload)}</div><br>      `;<br>      container.appendChild(row);<br>    }<br>    container.querySelectorAll('.webhook-retry').forEach(btn => {<br>      btn.addEventListener('click', (e) => {<br>        const tgt = e.currentTarget as HTMLButtonElement;<br>        const logId = tgt.getAttribute('data-logid')!;<br>        onRetry(logId);<br>      });<br>    });<br>  }<br>}<br>```<br><br>--- |
| PollerStatusUiDelegate | - **[Offloading Class Names]**: AdminConsoleHandler<br>- **[Originating Method Ids]**: None<br><br>**Delegate State Owned:**<br>- None (stateless; renders output only from input data).<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the poller status page from a PollerStatus DTO.<br>- Formatting status, timestamps, heights, and lag blocks for display.<br>- Handling missing or undefined fields gracefully.<br><br>**Responsibilities Removed from Parent Class:**<br>- All DOM generation for poller status UI.<br><br>**Delegate Public Interface:**<br>```typescript<br>renderPollerStatus(container: HTMLElement, data: PollerStatus): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In AdminConsoleHandler.renderPollerStatusPage()<br>this.pollerStatusUiDelegate.renderPollerStatus(container, data);<br>```<br><br>#### 🔧 Delegate Method: renderPollerStatus<br><br>**Responsibilities:**<br>- Receives container and PollerStatus DTO.<br>- Renders the poller status in a structured layout, handling optional/absent fields.<br><br>**Signature:**<br>```typescript<br>renderPollerStatus(container: HTMLElement, data: PollerStatus): void<br>```<br><br>**Code:**<br>```typescript<br>class PollerStatusUiDelegate {<br>  renderPollerStatus(container: HTMLElement, data: PollerStatus): void {<br>    container.innerHTML = `<br>      <div class="flex flex-col gap-2"><br>        <div>Running: <span class="${data.running ? 'text-green-600' : 'text-red-600'}">${data.running ? 'Yes' : 'No'}</span></div><br>        <div>Last Run At: <span>${data.lastRunAt or ''}</span></div><br>        <div>Last Height: <span>${data.lastHeight}</span></div><br>        <div>Last TxId: <span>${data.lastTxId or ''}</span></div><br>        <div>Lag Blocks: <span>${data.lagBlocks}</span></div><br>      </div><br>    `;<br>  }<br>}<br>```<br>````<br><br>End of report. |
| MagicLinkValidator | - **[Offloading Class Names]**: EmailDeliveryHandler<br>- **[Originating Method Ids]**: EDH-1, EDH-2<br><br>**Delegate State Owned:**<br>- Stateless, operates fully per-call.<br><br>**Delegate Responsibilities Owned:**<br>- Validates magic-link HMAC signatures for invoices/subscriptions using the provided magic link, store id, and store secrets.<br>- Handles extraction of the `u` blob, base64url decoding, canonicalization, and HMAC computation/validation.<br><br>**Responsibilities Removed from Parent Class:**<br>- All logic for parsing and validating the magic-link signature is no longer present directly in `EmailDeliveryHandler`.<br>- Parent no longer needs to manage any part of the HMAC computation or signature comparison.<br><br>**Delegate Public Interface:**<br>```typescript<br>validateMagicLink(magicLink: string, storeId: string, storeSecrets: { hmacSecret: string }): void<br>```<br>- Throws on any error or invalid signature; otherwise, returns void.<br><br>**Example Interaction:**<br>```typescript<br>this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets);<br>```<br><br>#### 🔁 Refactored Method: EmailDeliveryHandler.handleInvoiceCreated<br>**Breakdown After Refactoring:**<br>- Fetches required data as before.<br>- Delegates all magic-link validation logic to `MagicLinkValidator`.<br>- Passes the magic link string, store id, and secrets object to the validator.<br>- If validation fails, the delegate throws and the error is handled as before.<br><br>**How the delegate is called:**<br>```typescript<br>// In handleInvoiceCreated<br>const secrets = config.STORE_SECRETS[storeId];<br>this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets);<br>// ...on success, continues with rendering and sending email<br>```<br><br>#### 🔁 Refactored Method: EmailDeliveryHandler.handleSubscriptionInvoiceCreated<br>**Breakdown After Refactoring:**<br>- Fetches required data as before.<br>- Delegates magic-link validation to the delegate with same call pattern.<br>- Parent method no longer deals with the parsing or HMAC logic.<br><br>**How the delegate is called:**<br>```typescript<br>const secrets = config.STORE_SECRETS[storeId];<br>this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets);<br>```<br><br>#### 🔧 Delegate Method: validateMagicLink<br>**Responsibility:**<br>- Accepts a magic-link URL, storeId, and secrets.<br>- Extracts the `u` query param from the URL.<br>- Decodes the base64url payload, extracts the signature and payload fields.<br>- Canonicalizes the unsigned payload and computes the HMAC-SHA256.<br>- Compares the computed digest to the signature; throws if they do not match.<br><br>**Signature:**<br>```typescript<br>validateMagicLink(magicLink: string, storeId: string, storeSecrets: { hmacSecret: string }): void<br>```<br><br>**Full Code Example:**<br>```typescript<br>export class MagicLinkValidator {<br>  validateMagicLink(magicLink: string, storeId: string, storeSecrets: { hmacSecret: string }): void {<br>    if (!magicLink or !storeId or !storeSecrets or !storeSecrets.hmacSecret) {<br>      throw new Error('Missing required fields for magic-link validation');<br>    }<br><br>    const url = new URL(magicLink);<br>    const uBlob = url.searchParams.get('u');<br>    if (!uBlob) throw new Error('Missing magic-link u blob');<br><br>    // base64url decode<br>    const buf = Buffer.from(uBlob.replace(/-/g, '+').replace(/_/g, '/'), 'base64');<br>    const payload = JSON.parse(buf.toString('utf8'));<br>    const sig = payload.sig;<br>    if (!sig) throw new Error('Missing signature in magic-link payload');<br><br>    // Remove sig for HMAC input<br>    const unsigned = { ...payload };<br>    delete unsigned.sig;<br>    const canonical = JSON.stringify(unsigned);<br><br>    const mac = require('crypto').createHmac('sha256', storeSecrets.hmacSecret);<br>    mac.update(canonical);<br>    const digest = mac.digest('base64')<br>      .replace(/\+/g, '-')<br>      .replace(/\//g, '_')<br>      .replace(/=+$/, '');<br>    if (digest !== sig) throw new Error('Invalid magic-link signature');<br>  }<br>}<br>```<br><br>--- |
| EmailTemplateRenderer | - **[Offloading Class Names]**: EmailDeliveryHandler<br>- **[Originating Method Ids]**: EDH-1, EDH-2<br><br>**Delegate State Owned:**<br>- Stateless, all rendering is pure and per-call.<br><br>**Delegate Responsibilities Owned:**<br>- Renders invoice or subscription HTML and text email content with correct branding, layout, and magic-link.<br>- Dynamically generates subject and sender fields using branding with safe fallbacks.<br>- Handles all logic for default text and omission of missing branding fields.<br>- Ensures that all rendered content is consistent, user-friendly, and gracefully handles incomplete branding info.<br><br>**Responsibilities Removed from Parent Class:**<br>- All inline string interpolation, branding fallback, and subject/from computation logic for emails.<br>- Parent no longer needs to be aware of defaults for missing branding, or have any rendering logic.<br><br>**Delegate Public Interface:**<br>```typescript<br>renderInvoiceEmail(invoice: Invoice, branding: PublicProfile, magicLink: string): string<br>renderInvoiceEmailText(invoice: Invoice, branding: PublicProfile, magicLink: string): string<br>getEmailSubject(branding: PublicProfile, type?: 'subscription' or 'invoice'): string<br>getEmailFrom(branding: PublicProfile, senderDomain: string): string<br>```<br><br>**Example Interaction:**<br>```typescript<br>const htmlBody = this.emailTemplateRenderer.renderInvoiceEmail(invoice, branding, magicLinkDTO.magicLink);<br>const textBody = this.emailTemplateRenderer.renderInvoiceEmailText(invoice, branding, magicLinkDTO.magicLink);<br>const subject = this.emailTemplateRenderer.getEmailSubject(branding, 'invoice');<br>const fromEmail = this.emailTemplateRenderer.getEmailFrom(branding, SENDER_DOMAIN);<br>```<br><br>#### 🔁 Refactored Method: EmailDeliveryHandler.handleInvoiceCreated<br>**Breakdown After Refactoring:**<br>- Calls delegate for all email content rendering and subject/from formatting.<br>- Parent passes invoice, branding, magic-link, and sender domain.<br>- No longer contains string interpolation or branding fallback logic.<br><br>**How the delegate is called:**<br>```typescript<br>const htmlBody = this.emailTemplateRenderer.renderInvoiceEmail(invoice, branding, magicLinkDTO.magicLink);<br>const textBody = this.emailTemplateRenderer.renderInvoiceEmailText(invoice, branding, magicLinkDTO.magicLink);<br>const subject = this.emailTemplateRenderer.getEmailSubject(branding, 'invoice');<br>const fromEmail = this.emailTemplateRenderer.getEmailFrom(branding, SENDER_DOMAIN);<br>```<br><br>#### 🔁 Refactored Method: EmailDeliveryHandler.handleSubscriptionInvoiceCreated<br>**Breakdown After Refactoring:**<br>- As above, now delegates to the renderer for all content and subject/from fields.<br><br>**How the delegate is called:**<br>```typescript<br>const htmlBody = this.emailTemplateRenderer.renderInvoiceEmail(invoice, branding, magicLinkDTO.magicLink);<br>const textBody = this.emailTemplateRenderer.renderInvoiceEmailText(invoice, branding, magicLinkDTO.magicLink);<br>const subject = this.emailTemplateRenderer.getEmailSubject(branding, 'subscription');<br>const fromEmail = this.emailTemplateRenderer.getEmailFrom(branding, SENDER_DOMAIN);<br>```<br><br>#### 🔧 Delegate Method: renderInvoiceEmail<br>**Responsibility:**<br>- Returns the HTML body of the invoice or subscription email, using branding for logos, colors, displayName, and support contact.<br>- If branding fields are missing, omits them or uses safe defaults.<br><br>**Signature:**<br>```typescript<br>renderInvoiceEmail(invoice: Invoice, branding: PublicProfile, magicLink: string): string<br>```<br><br>**Full Code Example:**<br>```typescript<br>export class EmailTemplateRenderer {<br>  renderInvoiceEmail(invoice: Invoice, branding: PublicProfile, magicLink: string): string {<br>    const logo = branding.logo ? `<img src="${branding.logo}" alt="${branding.displayName or 'Webpay'}" style="max-width:160px;"/>` : '';<br>    const color = branding.brandColor or '#2563eb';<br>    const name = branding.displayName or 'Webpay Merchant';<br>    const support = branding.supportContact ? `<p style="font-size:12px;">Need help? <a href="mailto:${branding.supportContact}">${branding.supportContact}</a></p>` : '';<br>    return `<br>      <div style="font-family:Inter,sans-serif;background:#fff;padding:24px 0;max-width:440px;margin:auto;"><br>        <div style="text-align:center;margin-bottom:18px;"><br>          ${logo}<br>        </div><br>        <h2 style="color:${color};margin:0 0 8px 0;">${name} Payment Request</h2><br>        <p style="font-size:16px;margin-bottom:12px;">You have a new payment request:</p><br>        <div style="background:#f8fafc;padding:16px;border-radius:8px;margin-bottom:10px;"><br>          <strong>Amount:</strong> ${invoice.amount} ${invoice.currency}<br/><br>          <strong>Due:</strong> ${invoice.dueDate or 'N/A'}<br/><br>          <strong>Invoice #:</strong> ${invoice.id}<br>        </div><br>        <a href="${magicLink}" style="background:${color};color:#fff;padding:12px 24px;text-decoration:none;border-radius:6px;font-weight:500;">Pay Now</a><br>        ${support}<br>      </div><br>    `;<br>  }<br><br>  renderInvoiceEmailText(invoice: Invoice, branding: PublicProfile, magicLink: string): string {<br>    const name = branding.displayName or 'Webpay Merchant';<br>    const support = branding.supportContact ? `Need help? ${branding.supportContact}` : '';<br>    return `<br>${name} Payment Request<br><br>You have a new payment request.<br>Amount: ${invoice.amount} ${invoice.currency}<br>Due: ${invoice.dueDate or 'N/A'}<br>Invoice #: ${invoice.id}<br><br>Open this link to pay:<br>${magicLink}<br><br>${support}<br>    `.trim();<br>  }<br><br>  getEmailSubject(branding: PublicProfile, type?: 'subscription' or 'invoice'): string {<br>    const name = branding.displayName or 'Webpay';<br>    if (type === 'subscription') {<br>      return `${name} Subscription Payment Request`;<br>    }<br>    return `${name} Payment Request`;<br>  }<br><br>  getEmailFrom(branding: PublicProfile, senderDomain: string): string {<br>    if (branding.displayName) {<br>      return `"${branding.displayName}" <${senderDomain}>`;<br>    }<br>    return `Webpay <${senderDomain}>`;<br>  }<br>}<br>```<br><br>--- |
| PostmarkApiClient | - **[Offloading Class Names]**: EmailDeliveryHandler<br>- **[Originating Method Ids]**: EDH-1, EDH-2<br><br>**Delegate State Owned:**<br>- Stateless, no internal state other than per-request temporary objects.<br><br>**Delegate Responsibilities Owned:**<br>- Handles all logic for invoking the Postmark API for sending emails.<br>- Deals with HTTP request, headers, error detection, and response parsing.<br><br>**Responsibilities Removed from Parent Class:**<br>- Parent no longer manages fetch/post logic, header configuration, or error detection for the Postmark API.<br><br>**Delegate Public Interface:**<br>```typescript<br>sendEmail(emailData: {<br>  To: string,<br>  From: string,<br>  Subject: string,<br>  HtmlBody: string,<br>  TextBody: string,<br>  MessageStream: string<br>}, postmarkApiKey: string): Promise<void><br>```<br><br>**Example Interaction:**<br>```typescript<br>await this.postmarkApiClient.sendEmail({<br>  To: data.recipientEmail,<br>  From: fromEmail,<br>  Subject: subject,<br>  HtmlBody: htmlBody,<br>  TextBody: textBody,<br>  MessageStream: 'outbound'<br>}, POSTMARK_API_KEY);<br>```<br><br>#### 🔁 Refactored Method: EmailDeliveryHandler.handleInvoiceCreated<br>**Breakdown After Refactoring:**<br>- After assembling all email data, calls the delegate's sendEmail method.<br>- Delegate manages all HTTP/networking and error throw/catch.<br>- Parent catches errors and handles them as before.<br><br>**How the delegate is called:**<br>```typescript<br>await this.postmarkApiClient.sendEmail({<br>  To: data.recipientEmail,<br>  From: fromEmail,<br>  Subject: subject,<br>  HtmlBody: htmlBody,<br>  TextBody: textBody,<br>  MessageStream: 'outbound'<br>}, POSTMARK_API_KEY);<br>```<br><br>#### 🔁 Refactored Method: EmailDeliveryHandler.handleSubscriptionInvoiceCreated<br>**Breakdown After Refactoring:**<br>- As above, now delegates all email delivery to the delegate class.<br><br>**How the delegate is called:**<br>```typescript<br>await this.postmarkApiClient.sendEmail({<br>  To: data.recipientEmail,<br>  From: fromEmail,<br>  Subject: subject,<br>  HtmlBody: htmlBody,<br>  TextBody: textBody,<br>  MessageStream: 'outbound'<br>}, POSTMARK_API_KEY);<br>```<br><br>#### 🔧 Delegate Method: sendEmail<br>**Responsibility:**<br>- Accepts a fully composed email data object and Postmark API key.<br>- Performs the HTTP POST to Postmark API endpoint with correct headers and body.<br>- Throws on any non-2xx response, including response body as needed.<br><br>**Signature:**<br>```typescript<br>sendEmail(emailData: {<br>  To: string,<br>  From: string,<br>  Subject: string,<br>  HtmlBody: string,<br>  TextBody: string,<br>  MessageStream: string<br>}, postmarkApiKey: string): Promise<void><br>```<br><br>**Full Code Example:**<br>```typescript<br>export class PostmarkApiClient {<br>  async sendEmail(emailData: {<br>    To: string,<br>    From: string,<br>    Subject: string,<br>    HtmlBody: string,<br>    TextBody: string,<br>    MessageStream: string<br>  }, postmarkApiKey: string): Promise<void> {<br>    const resp = await require('node-fetch')('https://api.postmarkapp.com/email', {<br>      method: 'POST',<br>      headers: {<br>        'X-Postmark-Server-Token': postmarkApiKey,<br>        'Content-Type': 'application/json'<br>      },<br>      body: JSON.stringify(emailData)<br>    });<br>    if (!resp.ok) {<br>      const errBody = await resp.text();<br>      throw new Error(`Postmark API error: ${resp.status} ${errBody}`);<br>    }<br>    // No data returned on success<br>  }<br>}<br>```<br><br>--- |
| EmailRecipientValidator | - **[Offloading Class Names]**: EmailDeliveryHandler<br>- **[Originating Method Ids]**: EDH-1, EDH-2<br><br>**Delegate State Owned:**<br>- Stateless, pure per-call validator.<br><br>**Delegate Responsibilities Owned:**<br>- Validates presence and format of recipient email addresses.<br>- Throws on missing or invalid addresses.<br><br>**Responsibilities Removed from Parent Class:**<br>- Parent no longer checks for missing/invalid emails inline.<br><br>**Delegate Public Interface:**<br>```typescript<br>validateRecipientEmail(email: string): void<br>```<br><br>**Example Interaction:**<br>```typescript<br>this.emailRecipientValidator.validateRecipientEmail(data.recipientEmail);<br>```<br><br>#### 🔁 Refactored Methods: EmailDeliveryHandler.handleInvoiceCreated & handleSubscriptionInvoiceCreated<br>**Breakdown After Refactoring:**<br>- Both parent methods call the delegate to validate the recipient email.<br>- On error, the delegate throws and is handled as before.<br><br>**How the delegate is called:**<br>```typescript<br>this.emailRecipientValidator.validateRecipientEmail(data.recipientEmail);<br>```<br><br>#### 🔧 Delegate Method: validateRecipientEmail<br>**Responsibility:**<br>- Checks that email is present and matches a basic format.<br>- Throws with clear error string on failure.<br><br>**Signature:**<br>```typescript<br>validateRecipientEmail(email: string): void<br>```<br><br>**Full Code Example:**<br>```typescript<br>export class EmailRecipientValidator {<br>  validateRecipientEmail(email: string): void {<br>    if (!email) throw new Error('Missing recipientEmail');<br>    if (typeof email !== 'string' or !/^[^@]+@[^@]+\.[^@]+$/.test(email)) {<br>      throw new Error('Invalid recipientEmail');<br>    }<br>  }<br>}<br>```<br><br>---<br><br>End of report.<br>```` |
| TerminalInvoiceStatusUiManager | - **[Offloading Class Names]**: InvoiceStatusPoller<br>- **[Originating Method Ids]**: ISP-3, ISP-4, ISP-5, ISP-6<br><br>**Delegate State Owned:**<br>- None (all state passed explicitly; operates on DOM/UI only).<br><br>**Delegate Responsibilities Owned:**<br>- Rendering and updating UI elements representing terminal invoice states: "paid", "expired", "canceled".<br>- Applying Tailwind classes and status text to relevant DOM elements.<br>- Enabling/disabling/hiding UI controls and buttons specific to terminal invoice state.<br>- Handling the reset or reveal logic for "New Sale" or "New Invoice" buttons, including binding UI event listeners.<br>- Ensuring no further payment or mutation actions are possible for the invoice upon terminal state.<br>- Mapping data from Invoice DTOs into the UI for visual feedback.<br>- Managing state reset of UI elements when "New Sale" or "New Invoice" is triggered.<br><br>**Responsibilities Removed from Parent Class:**<br>- Direct DOM/UI mutation code for status-specific rendering (text, classes, disables, hides).<br>- Button enable/disable, show/hide logic for terminal states.<br>- Click handler assignment for "New Sale" and "New Invoice" buttons.<br>- All Tailwind styling and message rendering for terminal invoice statuses.<br>- Hiding/collapsing payment-related UI elements upon terminal state.<br><br>**Delegate Public Interface:**<br>```typescript<br>class TerminalInvoiceStatusUiManager {<br>  handlePaid(invoiceId: string, statusData: Invoice): void;<br>  handleExpired(invoiceId: string, statusData: Invoice): void;<br>  handleCanceled(invoiceId: string, statusData: Invoice): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>const terminalUi = new TerminalInvoiceStatusUiManager();<br>terminalUi.handlePaid(invoiceId, invoiceData);<br>// ...or...<br>terminalUi.handleExpired(invoiceId, invoiceData);<br>// ...or...<br>terminalUi.handleCanceled(invoiceId, invoiceData);<br>```<br><br>---<br><br>#### 🔁 Refactored Method: InvoiceStatusPoller.handleTerminalStatus<br><br>**Breakdown:**<br>- Instead of handling all UI logic inline, the method now delegates to TerminalInvoiceStatusUiManager.<br>- Only clears polling and routes state to the delegate based on terminal status.<br>- Delegate is invoked with invoiceId and statusData; no further UI logic in parent.<br><br>**Refactored usage:**<br>```typescript<br>public handleTerminalStatus(invoiceId: string, status: TerminalStatus, statusData: Invoice): void {<br>  this.clearPolling(invoiceId);<br>  switch (status) {<br>    case 'paid':<br>      this.terminalUiManager.handlePaid(invoiceId, statusData);<br>      break;<br>    case 'expired':<br>      this.terminalUiManager.handleExpired(invoiceId, statusData);<br>      break;<br>    case 'canceled':<br>      this.terminalUiManager.handleCanceled(invoiceId, statusData);<br>      break;<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: InvoiceStatusPoller.handlePaidStatus<br><br>**Breakdown:**<br>- Directs all "paid" UI update responsibilities to the delegate.<br>- Passes invoiceId and statusData; parent does not directly manipulate DOM/UI.<br><br>**Refactored usage:**<br>```typescript<br>public handlePaidStatus(invoiceId: string, statusData: Invoice): void {<br>  this.terminalUiManager.handlePaid(invoiceId, statusData);<br>}<br>```<br><br>#### 🔁 Refactored Method: InvoiceStatusPoller.handleExpiredStatus<br><br>**Breakdown:**<br>- UI updates for "expired" state are fully delegated.<br>- Parent passes invoiceId and statusData to the delegate, which handles all DOM updates.<br><br>**Refactored usage:**<br>```typescript<br>public handleExpiredStatus(invoiceId: string, statusData: Invoice): void {<br>  this.terminalUiManager.handleExpired(invoiceId, statusData);<br>}<br>```<br><br>#### 🔁 Refactored Method: InvoiceStatusPoller.handleCanceledStatus<br><br>**Breakdown:**<br>- UI updates for "canceled" state are fully delegated.<br>- Parent passes invoiceId and statusData to the delegate, which handles all DOM updates.<br><br>**Refactored usage:**<br>```typescript<br>public handleCanceledStatus(invoiceId: string, statusData: Invoice): void {<br>  this.terminalUiManager.handleCanceled(invoiceId, statusData);<br>}<br>```<br><br>---<br><br>#### 🔧 Delegate Method: handlePaid<br><br>**Responsibility:**<br>- Apply Tailwind styling and text to status strip for "Paid ✓".<br>- Render txId if present.<br>- Enable/reveal "New Sale" button, bind click handler to reset UI/form.<br>- Hide/disable pay button and fade out QR code.<br>- All interactions are based on the supplied invoiceId and statusData.<br><br>**Signature:**<br>```typescript<br>handlePaid(invoiceId: string, statusData: Invoice): void;<br>```<br><br>**Production Implementation:**<br>```typescript<br>public handlePaid(invoiceId: string, statusData: Invoice): void {<br>  // Update status strip to show "Paid ✓"<br>  const statusEl = document.getElementById(`status-strip-${invoiceId}`);<br>  if (statusEl) {<br>    statusEl.textContent = 'Paid ✓';<br>    statusEl.className = 'rounded px-2 py-1 font-semibold text-green-700 bg-green-100 border border-green-400';<br>  }<br>  // Display txId if present<br>  if (statusData.txId) {<br>    const txEl = document.getElementById(`txid-${invoiceId}`);<br>    if (txEl) {<br>      txEl.textContent = `Tx: ${statusData.txId}`;<br>      txEl.className = 'block text-xs text-gray-600 mt-1';<br>    }<br>  }<br>  // Enable/reveal "New Sale" button<br>  const newSaleBtn = document.getElementById(`new-sale-btn-${invoiceId}`);<br>  if (newSaleBtn) {<br>    newSaleBtn.style.display = '';<br>    newSaleBtn.disabled = false;<br>    newSaleBtn.className = 'mt-4 px-4 py-2 rounded bg-blue-600 text-white font-semibold hover:bg-blue-700';<br>    newSaleBtn.onclick = () => {<br>      if (statusEl) statusEl.textContent = '';<br>      const txEl = document.getElementById(`txid-${invoiceId}`);<br>      if (txEl) txEl.textContent = '';<br>      newSaleBtn.style.display = 'none';<br>      const form = document.getElementById(`sale-form-${invoiceId}`) as HTMLFormElement or null;<br>      if (form) form.reset();<br>    };<br>  }<br>  // Hide pay button<br>  const payBtn = document.getElementById(`pay-btn-${invoiceId}`);<br>  if (payBtn) {<br>    payBtn.style.display = 'none';<br>    payBtn.disabled = true;<br>  }<br>  // Fade QR code<br>  const qrEl = document.getElementById(`qr-${invoiceId}`);<br>  if (qrEl) {<br>    qrEl.style.opacity = '0.5';<br>  }<br>}<br>```<br><br>---<br><br>#### 🔧 Delegate Method: handleExpired<br><br>**Responsibility:**<br>- Apply Tailwind styling and text to status strip for "Expired".<br>- Hide/disable payment actions.<br>- Fade QR code.<br>- Show "New Invoice" button, keeping previous form values for quick re-entry.<br>- No form reset unless required by parent.<br><br>**Signature:**<br>```typescript<br>handleExpired(invoiceId: string, statusData: Invoice): void;<br>```<br><br>**Production Implementation:**<br>```typescript<br>public handleExpired(invoiceId: string, statusData: Invoice): void {<br>  // Update status strip to show "Expired"<br>  const statusEl = document.getElementById(`status-strip-${invoiceId}`);<br>  if (statusEl) {<br>    statusEl.textContent = 'Expired';<br>    statusEl.className = 'rounded px-2 py-1 font-semibold text-yellow-900 bg-yellow-200 border border-yellow-400';<br>  }<br>  // Hide/disable pay button<br>  const payBtn = document.getElementById(`pay-btn-${invoiceId}`);<br>  if (payBtn) {<br>    payBtn.style.display = 'none';<br>    payBtn.disabled = true;<br>  }<br>  // Fade QR code<br>  const qrEl = document.getElementById(`qr-${invoiceId}`);<br>  if (qrEl) {<br>    qrEl.style.opacity = '0.2';<br>  }<br>  // Show "New Invoice" button<br>  const newInvBtn = document.getElementById(`new-invoice-btn-${invoiceId}`);<br>  if (newInvBtn) {<br>    newInvBtn.style.display = '';<br>    newInvBtn.disabled = false;<br>    newInvBtn.className = 'mt-4 px-4 py-2 rounded bg-blue-600 text-white font-semibold hover:bg-blue-700';<br>  }<br>  // Leave form fields as-is for quick repeat<br>}<br>```<br><br>---<br><br>#### 🔧 Delegate Method: handleCanceled<br><br>**Responsibility:**<br>- Hide/disable all payment/sale actions (buttons).<br>- Apply Tailwind styling and text to status strip for "Canceled".<br>- Fade QR code.<br>- Hide refund, cancel, or edit actions.<br>- Show canceled message if relevant.<br>- No further payment/mutation allowed for this invoice.<br><br>**Signature:**<br>```typescript<br>handleCanceled(invoiceId: string, statusData: Invoice): void;<br>```<br><br>**Production Implementation:**<br>```typescript<br>public handleCanceled(invoiceId: string, statusData: Invoice): void {<br>  // Hide/disable pay button<br>  const payBtn = document.getElementById(`pay-btn-${invoiceId}`);<br>  if (payBtn) {<br>    payBtn.style.display = 'none';<br>    payBtn.disabled = true;<br>  }<br>  // Update status strip to "Canceled"<br>  const statusEl = document.getElementById(`status-strip-${invoiceId}`);<br>  if (statusEl) {<br>    statusEl.textContent = 'Canceled';<br>    statusEl.className = 'rounded px-2 py-1 font-semibold text-gray-700 bg-gray-200 border border-gray-400';<br>  }<br>  // Fade QR code<br>  const qrEl = document.getElementById(`qr-${invoiceId}`);<br>  if (qrEl) {<br>    qrEl.style.opacity = '0.2';<br>  }<br>  // Hide refund button<br>  const refundBtn = document.getElementById(`refund-btn-${invoiceId}`);<br>  if (refundBtn) {<br>    refundBtn.style.display = 'none';<br>    refundBtn.disabled = true;<br>  }<br>  // Canceled message<br>  const canceledMsgEl = document.getElementById(`canceled-msg-${invoiceId}`);<br>  if (canceledMsgEl) {<br>    canceledMsgEl.innerHTML = 'This invoice has been canceled.';<br>    canceledMsgEl.className = 'text-sm mt-2 text-gray-500';<br>  }<br>}<br>```<br>---<br>End of report.<br>``` |
| SubscriptionModalFormStateDelegate | - **[Offloading Class Names]**: SubscriptionManager<br>- **[Originating Method Ids]**: SM-2, SM-3<br><br>**Delegate State Owned:**<br>- Local state of modal form inputs:<br>  - `subscriberPrincipal` (string)<br>  - `amountSats` (number)<br>  - `intervalBlocks` (number)<br>  - `errorMessage` (string)<br>- Handles input management, validation status, and error messages for the subscription modal.<br><br>**Delegate Responsibilities Owned:**<br>- Render and initialize the subscription modal form fields.<br>- Track and update values for each modal field as the user types.<br>- Validate the fields according to business requirements.<br>- Set and clear error messages in the modal context.<br>- Reset/clear all modal form fields and errors on modal open/close.<br><br>**Responsibilities Removed from Parent Class:**<br>- SubscriptionManager no longer manages direct handling of form field values, error banners, or validation logic for the modal.<br>- No longer responsible for clearing or resetting modal fields; the delegate now resets modal state.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SubscriptionModalFormStateDelegate {<br>  openModal(): void;<br>  getFormValues(): { subscriberPrincipal: string; amountSats: number; intervalBlocks: number };<br>  validateForm(): { valid: boolean; errorMessage: string };<br>  setError(message: string): void;<br>  reset(): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In SubscriptionManager:<br>modalDelegate.openModal();<br>// On submit button click:<br>const { valid, errorMessage } = modalDelegate.validateForm();<br>if (!valid) {<br>  modalDelegate.setError(errorMessage);<br>  return;<br>}<br>const values = modalDelegate.getFormValues();<br>// ...proceed to call backend API with values...<br>```<br><br>#### 🔁 Refactored Method: SubscriptionManager.openCreateSubscriptionModal<br>After refactoring, `openCreateSubscriptionModal` simply calls `modalDelegate.openModal()`, which is responsible for rendering the modal, clearing/resetting all fields, focusing the first input, and removing error banners. The SubscriptionManager no longer handles individual DOM manipulations or resets.<br><br>**New responsibilities:**<br>- Calls `modalDelegate.openModal()` to handle all modal field state, error cleanup, and focus management.<br>- Leaves all internal modal state handling to the delegate.<br><br>**Code Snippet:**<br>```typescript<br>openCreateSubscriptionModal(): void {<br>  this.modalDelegate.openModal();<br>}<br>```<br><br>#### 🔧 Delegate Method: openModal<br>**Responsibility:** Open the modal dialog, clear fields and errors, set focus.<br><br>```typescript<br>openModal(): void {<br>  const modal = document.getElementById('createSubscriptionModal');<br>  if (modal) {<br>    modal.classList.remove('hidden');<br>    (document.getElementById('subscription-subscriberPrincipal') as HTMLInputElement).value = '';<br>    (document.getElementById('subscription-amountSats') as HTMLInputElement).value = '';<br>    (document.getElementById('subscription-intervalBlocks') as HTMLInputElement).value = '';<br>    this.setError('');<br>  }<br>  const principalInput = document.getElementById('subscription-subscriberPrincipal') as HTMLInputElement;<br>  if (principalInput) principalInput.focus();<br>}<br>```<br><br>#### 🔁 Refactored Method: SubscriptionManager.handleSubmitSubscription<br>After refactoring, `handleSubmitSubscription` delegates form state access and validation to the delegate:<br>- Calls `modalDelegate.validateForm()`. If invalid, calls `modalDelegate.setError()`.<br>- Calls `modalDelegate.getFormValues()` to assemble the backend POST body.<br>- No longer needs to access DOM elements or regular expressions directly.<br><br>**Code Snippet:**<br>```typescript<br>async handleSubmitSubscription(): Promise<void> {<br>  const { valid, errorMessage } = this.modalDelegate.validateForm();<br>  if (!valid) {<br>    this.modalDelegate.setError(errorMessage);<br>    return;<br>  }<br>  const { subscriberPrincipal, amountSats, intervalBlocks } = this.modalDelegate.getFormValues();<br>  const storeId = ...; // Retrieve as before<br>  try {<br>    const resp = await fetch(`/api/v1/stores/${storeId}/subscriptions`, {<br>      method: 'POST',<br>      headers: { 'Content-Type': 'application/json' },<br>      body: JSON.stringify({ subscriberPrincipal, amountSats, intervalBlocks })<br>    });<br>    if (!resp.ok) {<br>      const err = await resp.json();<br>      this.errorHandler.handleBridgeApiError(err);<br>      this.modalDelegate.setError(err.error or 'Error creating subscription.');<br>      return;<br>    }<br>    await this.pollAndUpdateSubscriptionsTable();<br>    this.closeCreateSubscriptionModal();<br>    if (typeof (window as any).showToast === 'function') {<br>      (window as any).showToast('Subscription created.');<br>    }<br>  } catch (err: any) {<br>    this.errorHandler.handleBridgeApiError(err);<br>    this.modalDelegate.setError('Network or server error.');<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: validateForm<br>**Responsibility:** Validate modal fields for presence, numeric constraints, and principal format.<br><br>```typescript<br>validateForm(): { valid: boolean; errorMessage: string } {<br>  const principalInput = document.getElementById('subscription-subscriberPrincipal') as HTMLInputElement;<br>  const amountInput = document.getElementById('subscription-amountSats') as HTMLInputElement;<br>  const intervalInput = document.getElementById('subscription-intervalBlocks') as HTMLInputElement;<br>  const subscriberPrincipal = principalInput.value.trim();<br>  const amountSats = Number(amountInput.value);<br>  const intervalBlocks = Number(intervalInput.value);<br>  const principalRegex = /^S[A-Za-z0-9]{38,}$/;<br>  if (!subscriberPrincipal or !principalRegex.test(subscriberPrincipal)) {<br>    return { valid: false, errorMessage: 'Invalid subscriber principal.' };<br>  }<br>  if (!amountSats or amountSats <= 0) {<br>    return { valid: false, errorMessage: 'Amount must be greater than zero.' };<br>  }<br>  if (!intervalBlocks or intervalBlocks <= 0) {<br>    return { valid: false, errorMessage: 'Interval must be greater than zero.' };<br>  }<br>  return { valid: true, errorMessage: '' };<br>}<br>```<br><br>#### 🔧 Delegate Method: getFormValues<br>**Responsibility:** Retrieve current modal field values.<br><br>```typescript<br>getFormValues(): { subscriberPrincipal: string; amountSats: number; intervalBlocks: number } {<br>  const subscriberPrincipal = (document.getElementById('subscription-subscriberPrincipal') as HTMLInputElement).value.trim();<br>  const amountSats = Number((document.getElementById('subscription-amountSats') as HTMLInputElement).value);<br>  const intervalBlocks = Number((document.getElementById('subscription-intervalBlocks') as HTMLInputElement).value);<br>  return { subscriberPrincipal, amountSats, intervalBlocks };<br>}<br>```<br><br>#### 🔧 Delegate Method: setError<br>**Responsibility:** Show or hide the error banner/message in the modal.<br><br>```typescript<br>setError(msg: string): void {<br>  const errorBanner = document.getElementById('subscriptionModalError');<br>  if (errorBanner) {<br>    if (msg) {<br>      errorBanner.textContent = msg;<br>      errorBanner.classList.remove('hidden');<br>    } else {<br>      errorBanner.textContent = '';<br>      errorBanner.classList.add('hidden');<br>    }<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: reset<br>**Responsibility:** Reset all modal fields and error state.<br><br>```typescript<br>reset(): void {<br>  (document.getElementById('subscription-subscriberPrincipal') as HTMLInputElement).value = '';<br>  (document.getElementById('subscription-amountSats') as HTMLInputElement).value = '';<br>  (document.getElementById('subscription-intervalBlocks') as HTMLInputElement).value = '';<br>  this.setError('');<br>}<br>```<br><br>--- |
| InvoiceSuccessSheetUiDelegate | - **[Offloading Class Names]**: SubscriptionManager<br>- **[Originating Method Ids]**: SM-4<br><br>**Delegate State Owned:**<br>- None (stateless utility focused on UI rendering and event binding)<br><br>**Delegate Responsibilities Owned:**<br>- Rendering invoice details (amount, expiry, link) in the UI modal/sheet when an invoice is generated.<br>- Mapping `MagicLinkDTO` fields into the correct UI elements.<br>- Setting up event handlers for Copy, Send Email, and Show QR buttons.<br>- Ensuring UI elements are filled out and actionable buttons are correctly configured for the invoice context.<br><br>**Responsibilities Removed from Parent Class:**<br>- SubscriptionManager no longer manages UI rendering, mapping of DTO fields, nor event binding for the invoice success sheet/modal.<br><br>**Delegate Public Interface:**<br>```typescript<br>class InvoiceSuccessSheetUiDelegate {<br>  renderSuccessSheet(dto: MagicLinkDTO, handleCopy: (link: string) => void, handleSend: () => void): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In SubscriptionManager:<br>this.invoiceSheetDelegate.renderSuccessSheet(dto, this.handleCopyInvoiceLink.bind(this), this.handleSendEmail.bind(this));<br>```<br><br>#### 🔁 Refactored Method: SubscriptionManager.renderInvoiceSuccessSheet<br>After refactoring, the parent simply calls:<br>```typescript<br>this.invoiceSheetDelegate.renderSuccessSheet(dto, this.handleCopyInvoiceLink.bind(this), this.handleSendEmail.bind(this));<br>```<br>The delegate takes over modal rendering, field population, and button event binding.<br><br>#### 🔧 Delegate Method: renderSuccessSheet<br>**Responsibility:** Render invoice amount, expiry, magicLink in the modal; bind Copy, Send Email, and Show QR actions.<br><br>```typescript<br>renderSuccessSheet(dto: MagicLinkDTO, handleCopy: (link: string) => void, handleSend: () => void): void {<br>  const sheet = document.getElementById('subscriptionInvoiceSheet');<br>  if (!sheet) return;<br>  const amtElem = document.getElementById('subscriptionInvoice-amount');<br>  if (amtElem) amtElem.textContent = `${dto.invoice.amountSats} sats`;<br>  const expElem = document.getElementById('subscriptionInvoice-expiry');<br>  if (expElem) expElem.textContent = new Date(dto.invoice.quoteExpiresAt).toLocaleString();<br>  const linkElem = document.getElementById('subscriptionInvoice-magicLink');<br>  if (linkElem) {<br>    linkElem.textContent = dto.magicLink;<br>    (linkElem as HTMLAnchorElement).href = dto.magicLink;<br>  }<br>  const copyBtn = document.getElementById('subscriptionInvoice-copyBtn');<br>  if (copyBtn) copyBtn.onclick = () => handleCopy(dto.magicLink);<br>  const sendBtn = document.getElementById('subscriptionInvoice-sendEmailBtn');<br>  if (sendBtn) sendBtn.onclick = handleSend;<br>  const qrElem = document.getElementById('subscriptionInvoice-qr');<br>  if (qrElem && typeof (window as any).renderQR === 'function') {<br>    (window as any).renderQR(dto.magicLink, qrElem);<br>  }<br>  sheet.classList.remove('hidden');<br>}<br>```<br><br>--- |
| SubscriptionTablePollingDelegate | - **[Offloading Class Names]**: SubscriptionManager<br>- **[Originating Method Ids]**: SM-10, SM-11<br><br>**Delegate State Owned:**<br>- `currentStoreId` (string or null)<br>- `currentSubscriptionId` (string or null)<br>- `pollIntervals` (object mapping polling contexts to interval IDs)<br><br>**Delegate Responsibilities Owned:**<br>- Managing polling intervals for subscriptions table and linked invoices.<br>- Fetching updated data from the backend/Bridge API at configured intervals.<br>- Updating the UI for subscriptions and linked invoices based on returned DTOs.<br>- Enabling/disabling table and row actions according to subscription/invoice status.<br><br>**Responsibilities Removed from Parent Class:**<br>- SubscriptionManager no longer manages setInterval, poll interval IDs, or direct DOM updates for subscription/invoice tables and rows.<br><br>**Delegate Public Interface:**<br>```typescript<br>class SubscriptionTablePollingDelegate {<br>  startSubscriptionsPolling(storeId: string): void;<br>  stopSubscriptionsPolling(): void;<br>  pollAndUpdateSubscriptionsTable(): Promise<void>;<br>  startLinkedInvoicesPolling(subscriptionId: string, storeId: string): void;<br>  stopLinkedInvoicesPolling(): void;<br>  pollAndUpdateLinkedInvoices(): Promise<void>;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In SubscriptionManager:<br>this.tablePollingDelegate.startSubscriptionsPolling(storeId);<br>// When drawer opens:<br>this.tablePollingDelegate.startLinkedInvoicesPolling(subscriptionId, storeId);<br>```<br><br>#### 🔁 Refactored Method: SubscriptionManager.pollAndUpdateSubscriptionsTable<br>After refactoring, the polling logic for updating the subscriptions table is entirely owned by the delegate:<br>```typescript<br>async pollAndUpdateSubscriptionsTable(): Promise<void> {<br>  await this.tablePollingDelegate.pollAndUpdateSubscriptionsTable();<br>}<br>```<br><br>#### 🔧 Delegate Method: pollAndUpdateSubscriptionsTable<br>**Responsibility:** Fetch the latest subscriptions for the current store and update the subscriptions table UI.<br><br>```typescript<br>async pollAndUpdateSubscriptionsTable(): Promise<void> {<br>  if (!this.currentStoreId) return;<br>  try {<br>    const subs: Subscription[] = await this.bridgeApiClient.doRequest(<br>      'GET',<br>      `/api/v1/stores/${this.currentStoreId}/subscriptions`<br>    );<br>    subs.forEach(sub => {<br>      const row = document.getElementById(`subscriptionRow-${sub.subscriptionId}`);<br>      if (!row) return;<br>      (row.querySelector('.subscription-status') as HTMLElement).textContent = sub.status;<br>      (row.querySelector('.subscription-amount') as HTMLElement).textContent = `${sub.amountSats} sats`;<br>      (row.querySelector('.subscription-interval') as HTMLElement).textContent = `${sub.intervalBlocks} blocks`;<br>      (row.querySelector('.subscription-mode') as HTMLElement).textContent = sub.mode;<br>      (row.querySelector('.subscription-nextDue') as HTMLElement).textContent = sub.nextDue;<br>      (row.querySelector('.subscription-lastBilled') as HTMLElement).textContent = sub.lastBilled or '-';<br>      const genInvBtn = row.querySelector('.subscription-generateInvoiceBtn') as HTMLButtonElement;<br>      if (genInvBtn) genInvBtn.disabled = (sub.status !== 'active');<br>      const cancelBtn = row.querySelector('.subscription-cancelBtn') as HTMLButtonElement;<br>      if (cancelBtn) cancelBtn.disabled = (sub.status !== 'active');<br>    });<br>  } catch (err: any) {<br>    this.errorHandler.handleBridgeApiError(err);<br>  }<br>}<br>```<br><br>#### 🔁 Refactored Method: SubscriptionManager.pollAndUpdateLinkedInvoices<br>After refactoring, linked invoice polling and UI update is moved to the delegate:<br>```typescript<br>async pollAndUpdateLinkedInvoices(): Promise<void> {<br>  await this.tablePollingDelegate.pollAndUpdateLinkedInvoices();<br>}<br>```<br><br>#### 🔧 Delegate Method: pollAndUpdateLinkedInvoices<br>**Responsibility:** Fetch current subscription's linked invoices and update each row in the UI.<br><br>```typescript<br>async pollAndUpdateLinkedInvoices(): Promise<void> {<br>  if (!this.currentSubscriptionId or !this.currentStoreId) return;<br>  try {<br>    const sub: Subscription = await this.bridgeApiClient.doRequest(<br>      'GET',<br>      `/api/v1/stores/${this.currentStoreId}/subscriptions/${this.currentSubscriptionId}`<br>    );<br>    const invoices: SubscriptionLinkedInvoice[] = sub.linkedInvoices;<br>    invoices.forEach(inv => {<br>      const row = document.getElementById(`linkedInvoiceRow-${inv.invoiceId}`);<br>      if (!row) return;<br>      (row.querySelector('.linkedInvoice-status') as HTMLElement).textContent = inv.status;<br>      (row.querySelector('.linkedInvoice-amount') as HTMLElement).textContent = `${inv.amountSats} sats`;<br>      (row.querySelector('.linkedInvoice-expiry') as HTMLElement).textContent = new Date(inv.quoteExpiresAt).toLocaleString();<br>      const openBtn = row.querySelector('.linkedInvoice-openBtn') as HTMLButtonElement;<br>      if (openBtn) openBtn.disabled = (inv.status === 'expired' or inv.status === 'canceled');<br>      const copyBtn = row.querySelector('.linkedInvoice-copyBtn') as HTMLButtonElement;<br>      if (copyBtn) copyBtn.disabled = (inv.status !== 'unpaid' && inv.status !== 'pending');<br>    });<br>  } catch (err: any) {<br>    this.errorHandler.handleBridgeApiError(err);<br>  }<br>}<br>```<br><br>#### 🔧 Delegate Method: startSubscriptionsPolling<br>**Responsibility:** Begin polling the subscriptions table at 1s intervals.<br><br>```typescript<br>startSubscriptionsPolling(storeId: string): void {<br>  this.currentStoreId = storeId;<br>  if (this.pollIntervals['subscriptions']) clearInterval(this.pollIntervals['subscriptions']);<br>  this.pollIntervals['subscriptions'] = setInterval(() => this.pollAndUpdateSubscriptionsTable(), 1000);<br>}<br>```<br><br>#### 🔧 Delegate Method: stopSubscriptionsPolling<br>**Responsibility:** Stop polling the subscriptions table.<br><br>```typescript<br>stopSubscriptionsPolling(): void {<br>  if (this.pollIntervals['subscriptions']) clearInterval(this.pollIntervals['subscriptions']);<br>  this.pollIntervals['subscriptions'] = null;<br>}<br>```<br><br>#### 🔧 Delegate Method: startLinkedInvoicesPolling<br>**Responsibility:** Begin polling the linked invoices of a subscription at 1s intervals.<br><br>```typescript<br>startLinkedInvoicesPolling(subscriptionId: string, storeId: string): void {<br>  this.currentSubscriptionId = subscriptionId;<br>  this.currentStoreId = storeId;<br>  if (this.pollIntervals['linkedInvoices']) clearInterval(this.pollIntervals['linkedInvoices']);<br>  this.pollIntervals['linkedInvoices'] = setInterval(() => this.pollAndUpdateLinkedInvoices(), 1000);<br>}<br>```<br><br>#### 🔧 Delegate Method: stopLinkedInvoicesPolling<br>**Responsibility:** Stop polling the linked invoices.<br><br>```typescript<br>stopLinkedInvoicesPolling(): void {<br>  if (this.pollIntervals['linkedInvoices']) clearInterval(this.pollIntervals['linkedInvoices']);<br>  this.pollIntervals['linkedInvoices'] = null;<br>  this.currentSubscriptionId = null;<br>}<br>```<br><br>--- |
| InvoiceDrawerUiDelegate | - **[Offloading Class Names]**: SubscriptionManager<br>- **[Originating Method Ids]**: SM-7<br><br>**Delegate State Owned:**<br>- None (stateless; operates directly on UI elements)<br><br>**Delegate Responsibilities Owned:**<br>- Rendering the invoice detail drawer/modal whenever an invoice needs to be shown.<br>- Fetching invoice details (if not already present) and mapping Invoice DTO fields to UI elements.<br>- Managing enable/disable states of action buttons within the drawer according to current invoice status.<br><br>**Responsibilities Removed from Parent Class:**<br>- SubscriptionManager no longer handles DOM updates or state logic for invoice drawer display or action enablement.<br><br>**Delegate Public Interface:**<br>```typescript<br>class InvoiceDrawerUiDelegate {<br>  openDrawer(invoiceId: string): void;<br>}<br>```<br><br>**Example Interaction:**<br>```typescript<br>// In SubscriptionManager:<br>this.invoiceDrawerUiDelegate.openDrawer(invoiceId);<br>```<br><br>#### 🔁 Refactored Method: SubscriptionManager.openInvoiceDrawer<br>After refactoring:<br>- Calls `this.invoiceDrawerUiDelegate.openDrawer(invoiceId);`<br>- No longer touches DOM, fetches, or field mapping directly.<br><br>#### 🔧 Delegate Method: openDrawer<br>**Responsibility:** Fetch invoice details, populate UI drawer, enable/disable actions.<br><br>```typescript<br>openDrawer(invoiceId: string): void {<br>  const drawer = document.getElementById('invoiceDrawer');<br>  if (!drawer) return;<br>  drawer.classList.remove('hidden');<br>  fetch(`/i/${invoiceId}`)<br>    .then(resp => resp.json())<br>    .then((invoice: Invoice) => {<br>      (document.getElementById('invoiceDrawer-amount') as HTMLElement).textContent = `${invoice.amountSats} sats`;<br>      (document.getElementById('invoiceDrawer-status') as HTMLElement).textContent = invoice.status;<br>      (document.getElementById('invoiceDrawer-memo') as HTMLElement).textContent = invoice.memo;<br>      (document.getElementById('invoiceDrawer-expiry') as HTMLElement).textContent = new Date(invoice.quoteExpiresAt).toLocaleString();<br>      const refundBtn = document.getElementById('invoiceDrawer-refundBtn') as HTMLButtonElement;<br>      const copyBtn = document.getElementById('invoiceDrawer-copyBtn') as HTMLButtonElement;<br>      if (refundBtn) refundBtn.disabled = (invoice.status !== 'paid');<br>      if (copyBtn) copyBtn.disabled = !invoice.txId;<br>    });<br>}<br>```<br>````<br><br>End of report. |
| ApplicationBootstrapper | Orchestrates application startup: loads configuration, instantiates and injects all components and dependencies, ensures Express app and all DI dependencies are wired in correct order before server starts listening. Guards against missing config, preserves DI strictness, and assures all singleton components are available to route/middleware registration. |

### Component Methods definition:
| Component Name | Signature | Description | Implementation Details |
| -------------- | --------- | ----------- | ---------------------- |
| ExpressServer | corsMiddleware(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | <br><br>The method `corsMiddleware(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void` acts as the registered Express middleware for CORS policy enforcement for all incoming HTTP requests.<br><br>**Refactored Responsibilities and Implementation:**<br><br>After refactoring, the method no longer performs inline origin extraction, storeId determination, or CORS header setting. Instead, it:<br><br>1. Assumes that `this.corsPolicyEnforcer` is instantiated and ready before use.<br>2. Immediately delegates the entire CORS handling process to `this.corsPolicyEnforcer.enforceCorsPolicy`, passing all method arguments as-is.<br>3. Does not perform any fallback, error handling, or checks for delegate presence—any miswiring is considered a lifecycle bug.<br><br>**Code Contract and Example:**<br><br>```typescript<br>// ExpressServer method, after refactoring<br>async corsMiddleware(<br>  req: import('express').Request,<br>  res: import('express').Response,<br>  next: import('express').NextFunction<br>): Promise<void> {<br>  // All logic is offloaded to CorsPolicyEnforcer; parent class assumes delegate is present.<br>  return this.corsPolicyEnforcer.enforceCorsPolicy(req, res, next);<br>}<br>```<br><br>This ensures that all CORS policy logic—including dynamic origin checks, allowedOrigins fetch from Bridge, header setting, and error response—is fully encapsulated within the delegate. The parent class only acts as a thin pass-through. Any missing or invalid delegate configuration will throw immediately.<br><br>--- | ExpressServer.corsMiddleware:<br>- **Mechanics**:<br>  1. Assume `this.corsPolicyEnforcer` is instantiated and fully initialized before any request is handled.<br>  2. For every incoming HTTP request to the Express app, this method is executed as a middleware.<br>  3. **Immediately delegate**: The method directly calls `this.corsPolicyEnforcer.enforceCorsPolicy(req, res, next)` with all arguments.<br>  4. **No fallback or error handling**: There must not be any inline logic for extracting Origin, storeId, or setting CORS headers in the parent method.<br>  5. If `corsPolicyEnforcer` is missing or miswired, this is considered a lifecycle bug and should fail immediately.<br>- **Dependencies**:<br>  - `CorsPolicyEnforcer` must encapsulate all fetches to Bridge API for allowedOrigins, header setting, allow/deny decisions, and error responses.<br>  - The parent ExpressServer holds no CORS logic or state.<br>- **WHY**: Enforces strict, centralized, dynamic CORS policy per-store, according to the architectural requirement that all CORS logic is out-of-parent and dynamic per Bridge config .<br><br>--- |
| BridgeApiClient | prepareInvoice(storeId: string, payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }): Promise<MagicLinkDTO> | <br><br>The `prepareInvoice(storeId: string, payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }): Promise<MagicLinkDTO>` method is responsible for preparing a new invoice by orchestrating API key retrieval, payload validation, and Bridge API request.<br><br>**Refactored Responsibilities and Implementation:**<br><br>1. Directly calls `this.securityEnforcer.getStoreApiKey(storeId)` to obtain the per-store API key (no local secret lookup).<br>2. Calls `this.securityEnforcer.validatePrepareInvoicePayload(payload)` to validate the domain-level shape and constraints of the invoice creation payload.<br>3. Constructs the Bridge endpoint and uses `this.httpRequestHelper.doRequest` to perform the network request to Bridge, passing method, URL, headers, and payload as arguments.<br>4. Does not perform any HTTP logic, error normalization, or response parsing inline—all are handled in the delegate.<br>5. Does not defensively check for delegate presence; any missing delegate surfaces as an error.<br><br>**Code Contract and Example:**<br><br>```typescript<br>async prepareInvoice(<br>  storeId: string,<br>  payload: { amount_sats: number; ttl_seconds: number; memo: string; orderId?: string; payerPrincipal?: string }<br>): Promise<MagicLinkDTO> {<br>  const apiKey = this.securityEnforcer.getStoreApiKey(storeId);<br>  this.securityEnforcer.validatePrepareInvoicePayload(payload);<br>  const endpoint = `/api/v1/stores/${storeId}/prepare-invoice`;<br>  return await this.httpRequestHelper.doRequest('POST', this.baseUrl, endpoint, { apiKey, body: payload });<br>}<br>```<br><br>All validation and secure secret handling are offloaded; the parent only orchestrates the calls.<br><br> | BridgeApiClient.prepareInvoice:<br>- **Mechanics**:<br>  1. **API Key Retrieval**: Call `this.securityEnforcer.getStoreApiKey(storeId)` to obtain the correct per-store API key from secure backend storage (env/session only, never client).<br>  2. **Payload Validation**: Call `this.securityEnforcer.validatePrepareInvoicePayload(payload)`:<br>      - Ensure `amount_sats > 0`.<br>      - `ttl_seconds` ∈ [120, 1800].<br>      - Validate `memo` is string, `orderId` and `payerPrincipal` (if present) conform to expected patterns.<br>      - Any failure throws, must not proceed.<br>  3. **Construct Endpoint**: Build URL string `/api/v1/stores/${storeId}/prepare-invoice`.<br>  4. **Delegate HTTP**: Call `this.httpRequestHelper.doRequest('POST', this.baseUrl, endpoint, { apiKey, body: payload })`.<br>      - Only delegates handle HTTP logic, error normalization, and response parsing.<br>  5. **Return Value**: On success, return result as `MagicLinkDTO` (containing { invoice, magicLink, unsignedCall } object).<br>      - On error, propagate normalized error upstream.<br>- **Data/Secrets**:<br>  - API key is never exposed outside backend.<br>  - hmacSecret is used only for server-side magic-link validation, separate from this call.<br>- **WHY**: Fulfills secure, validated, atomic invoice creation for payment flows, with all security logic in delegates as required by system requirements. <br><br>--- |
| BridgeApiClient | createStore(payload: { principal: string; name: string; display_name?: string; logo_url?: string; brand_color?: string; allowed_origins?: string[]; webhook_url?: string }): Promise<Store> | Posts a new store definition to the Bridge `/api/admin/stores` endpoint (JSON body). Validates the input payload matches required fields (`principal`, `name`) and optional branding/config fields. On success, returns the Store DTO as provided by Bridge, which includes fields like `storeId`, `active`, branding, and config. If Bridge returns a 409/duplicate error (e.g., principal already exists), rejects with an error object that should be handled by ErrorHandler (allowing the UI to highlight the existing store). Performs no persistence or business logic locally. Ensures strict type adherence to domain Store model, and does not return any additional fields or local state. |  |
| BridgeApiClient | getStoreList(): Promise<Store[]> | Issues a GET request to the Bridge `/api/admin/stores` endpoint. Returns the list of Store DTOs as provided by the Bridge, containing all relevant profile, activation, branding, and config fields for each store. No local transformation or caching is performed—response is passed through as-is, matching the system-wide Store type. Used by AdminConsoleHandler and other management UI layers for rendering live store state. |  |
| BridgeApiClient | setStoreActiveState(storeId: string, newState: boolean): Promise<{ active: boolean }> | Sends a PATCH request to the Bridge `/api/admin/stores/:storeId/activate` endpoint with `{ active: newState }` as the body. Waits for Bridge response, which returns `{ active: boolean }` indicating new activation status. Ensures input `newState` is a boolean and `storeId` is a valid identifier. On Bridge error, propagates status and error body (e.g., 4xx if activation rules violated) to caller. Does not perform any business logic or state mutation locally, and never exposes secrets. Response is used to gate activation toggles/actions in AdminConsoleHandler UI. |  |
| BridgeApiClient | getStoreProfile(storeId: string): Promise<Store> | Sends a GET request to Bridge `/api/v1/stores/:storeId/profile`. Returns the full Store DTO for management/profile edit UI, including all branding, config, activation, and allowedOrigins fields. Performs no transformation—response must match Store type as per domain model. Used for populating profile edit forms in admin/merchant consoles. |  |
| BridgeApiClient | updateStoreProfile(storeId: string, payload: { displayName?: string; logoUrl?: string; brandColor?: string; allowedOrigins?: string[]; webhookUrl?: string }): Promise<Store> | Sends a PATCH request to Bridge `/api/v1/stores/:storeId/profile` with the provided payload, allowing updates to displayName, logoUrl, brandColor, allowedOrigins, and webhookUrl. Validates input types and formats (e.g., logoUrl must be a valid URI, brandColor matches hex color regex). On Bridge errors (validation, not found), propagates error for caller (ErrorHandler) to surface in UI. Returns the updated Store DTO on success, matching domain typing. No business logic or state mutation is performed locally. Ensures that branding updates and CORS allowedOrigins are always set from the latest server state and never cached. |  |
| BridgeApiClient | getPublicProfile(storeId: string): Promise<PublicProfile> | Fetches the branding/public profile for the given store from Bridge `/api/v1/stores/:storeId/public-profile`. Returns type-safe PublicProfile DTO (displayName, logoUrl, brandColor, supportEmail, supportUrl), all of which may be null or missing as per branding rules. Used by CORS middleware, email templates, and UI theming/rendering. No transformation or local mutation; always fetches live from Bridge. |  |
| BridgeApiClient | rotateKeys(storeId: string): Promise<StoreSecrets> | <br><br>The `rotateKeys(storeId: string): Promise<StoreSecrets>` method rotates the store's API and HMAC keys, returning one-time reveal secrets on first use.<br><br>**Refactored Responsibilities and Implementation:**<br><br>1. Executes the Bridge API POST to the rotation endpoint via `this.httpRequestHelper.doRequest`.<br>2. After receiving the Bridge response, invokes `this.securityEnforcer.enforceOneTimeReveal(result.alreadyRevealed)` to enforce the one-time reveal contract.<br>3. Returns the result as provided by Bridge.<br>4. All error handling, secret enforcement, and HTTP logic are handled in the delegates.<br>5. No conditional logic or guard checks for delegate presence.<br><br>**Code Contract and Example:**<br><br>```typescript<br>async rotateKeys(storeId: string): Promise<StoreSecrets> {<br>  const result = await this.httpRequestHelper.doRequest('POST', this.baseUrl, `/api/admin/stores/${storeId}/rotate-keys`);<br>  this.securityEnforcer.enforceOneTimeReveal(result.alreadyRevealed);<br>  return result;<br>}<br>```<br><br>--- | BridgeApiClient.rotateKeys:<br>- **Mechanics**:<br>  1. **Initiate Rotation**: Call `this.httpRequestHelper.doRequest('POST', this.baseUrl, '/api/admin/stores/' + storeId + '/rotate-keys')` to POST the key rotation request to the Bridge.<br>  2. **One-Time Reveal Enforcement**: After receiving the response, call `this.securityEnforcer.enforceOneTimeReveal(result.alreadyRevealed)` to ensure secrets are only returned on first use.<br>  3. **Return**: Return the result as-is (should contain new apiKey, hmacSecret if rotation is fresh).<br>  4. **Failure Handling**: If Bridge returns `alreadyRevealed`, enforce that secrets cannot be re-exposed in any response.<br>  5. **Atomicity**: Ensure local (Webpay) state and Bridge state are both updated before any further ops; in case of error, block store from payment actions until resolved (no partial updates).<br>- **WHY**: Enforces atomic, secure credentials rotation per requirements, preventing partial update or exposure of sensitive secrets beyond initial reveal. <br><br>--- |
| BridgeApiClient | setSbtcToken(payload: { contractAddress: string; contractName: string }): Promise<object> | Sends a POST request to Bridge `/api/admin/set-sbtc-token` with `{ contractAddress, contractName }` as body. Validates both fields are present and match contract address/name format. On Bridge response, if an unsigned call is returned (requires signing in wallet), returns this for UI handling. If Bridge returns 409 or other error (store not ready, validation error), propagates to ErrorHandler. Does not mutate local state or expose secrets. Only business logic is on Bridge side; this method only relays and validates request/response types. |  |
| BridgeApiClient | getWebhooksLog(query: { status: 'all' ¦ 'failed'; storeId?: string }): Promise<WebhookLog[]> | Issues a GET request to Bridge `/api/admin/webhooks?status=...&storeId=...` with query parameters as provided. Returns a list of WebhookLog DTOs, each representing a webhook delivery attempt (with status, payload, headers, timestamps, etc.). No transformation or filtering—response is passed as returned by Bridge API, matching domain types exactly. |  |
| BridgeApiClient | retryWebhook(webhookLogId: string): Promise<object> | Sends a POST request to Bridge `/api/admin/webhooks/retry` with `{ webhookLogId }` as body. Waits for Bridge response, which may indicate retry status and updated webhook log. No transformation, just passes result or error back to handler/UI. No secrets or local state are mutated. Used by AdminConsoleHandler in retry actions. |  |
| BridgeApiClient | getPollerStatus(): Promise<PollerStatus> | Issues a GET request to Bridge `/api/admin/poller`. Returns a PollerStatus DTO as defined in the domain model (running, lastRunAt, lastHeight, lastTxId, lagBlocks). No transformation or local mutation. Used for poller status UI in admin console. |  |
| BridgeApiClient | restartPoller(): Promise<{ running: boolean }> | Sends a POST request to Bridge `/api/admin/poller/restart`. Returns `{ running: boolean }` indicating poller process status. No local mutation; all state and business logic managed by Bridge. Errors are propagated to ErrorHandler/UI. |  |
| BridgeApiClient | bootstrapProtocol(): Promise<object> | Sends a POST request to Bridge `/api/admin/bootstrap`. Bridge may respond with an unsigned call for protocol initialization (to be signed by admin wallet), or with idempotent abort/result info. This method just relays and validates the response; all protocol initialization logic is externalized to Bridge and wallet. Returns object as provided by Bridge; error responses are propagated. |  |
| BridgeApiClient | syncOnchain(storeId: string): Promise<{ calls: UnsignedCall[] }> | Sends a POST request to Bridge `/api/admin/stores/:storeId/sync-onchain`. Returns an object containing an array of UnsignedCall objects, representing on-chain sync actions to be signed by admin wallet(s); or, in case of idempotent abort, returns the relevant abort info object. No local mutation; only relays the Bridge API response. |  |
| MagicLinkValidator | validateU(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | <br><br>The `validateU(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void` method validates the magic-link `u` payload for GET requests to invoice/subscription pages.<br><br>**Refactored Responsibilities and Implementation:**<br><br>1. All logic for canonical JSON stringification, base64url decoding, and timing-safe signature comparison is delegated to static methods on `MagicLinkUCanonicalSerializer`.<br>2. The parent method orchestrates only:<br>   - Parsing the HTTP request and extracting the `u` payload,<br>   - Calling the delegate for all transformations and cryptographic checks,<br>   - Handling business validation and error response,<br>   - Passing validated data to downstream handlers.<br>3. No inline serialization, decoding, or comparison code remains in the parent; all such logic is delegated.<br><br>**Code Contract and Example:**<br><br>```typescript<br>async validateU(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): Promise<void> {<br>  // Orchestration only: all serialization/decoding delegated<br>  const u = req.query.u;<br>  const decoded = MagicLinkUCanonicalSerializer.base64urlDecode(u);<br>  const sigPayload = MagicLinkUCanonicalSerializer.buildSignaturePayload(decoded);<br>  const sigSrc = MagicLinkUCanonicalSerializer.canonicalJSONStringify(sigPayload);<br>  const calcSig = require('crypto').createHmac('sha256', Buffer.from(hmacSecret, 'utf8'))<br>    .update(sigSrc, 'utf8').digest();<br>  const providedSig = MagicLinkUCanonicalSerializer.base64urlDecode(decoded.sig);<br>  if (!MagicLinkUCanonicalSerializer.timingSafeEqual(calcSig, providedSig)) {<br>    // Handle error...<br>  }<br>  // Continue with business validation, then call next()<br>}<br>```<br><br>--- | MagicLinkValidator.validateU:<br>- **Mechanics**:<br>  1. **Extract `u` Parameter**: From the incoming Express request, read the query parameter `u`.<br>  2. **Decode and Parse**: Use `MagicLinkUCanonicalSerializer.base64urlDecode(u)` to base64url-decode the blob, and parse as JSON.<br>  3. **Canonical Signature Payload**: Use `MagicLinkUCanonicalSerializer.buildSignaturePayload(decoded)` to extract `{v, storeId, invoiceId, unsignedCall, exp}`.<br>  4. **Canonical Stringify**: Call `MagicLinkUCanonicalSerializer.canonicalJSONStringify(sigPayload)` to guarantee deterministic byte order for signature.<br>  5. **Calculate MAC**: Compute `HMAC_SHA256(store.hmacSecret, sigSrc)` using the current store's hmacSecret (loaded server-side, never exposed). Use Node.js `crypto.createHmac`.<br>  6. **Signature Verification**: Compare the calculated HMAC with the provided `sig` in the blob using `MagicLinkUCanonicalSerializer.timingSafeEqual`.<br>      - If the signatures do not match, return HTTP 403 ("invalid signature").<br>  7. **Field Validations**:<br>      - `data.storeId === req.params.storeId`; `data.invoiceId === req.params.invoiceId`.<br>      - `exp > now` (unix timestamp in seconds); TTL not excessive.<br>      - `unsignedCall.function === "pay-invoice"` (or "pay-subscription" for subscription context).<br>      - `unsignedCall.postConditionMode === "deny"`.<br>      - Ensure at least one FT post-condition for sBTC asset exists, with payer principal and "eq" amount.<br>      - `unsignedCall.network` must match deployment mode (`mainnet`/`testnet`).<br>  8. **Cross-check Live State**: Call Bridge API `GET /i/:invoiceId` to confirm:<br>      - `status ∈ { PAY_READY, pending }`<br>      - `amountSats` equals FT post-condition amount.<br>      - `quoteExpiresAt ≥ now`.<br>      - Any mismatch returns HTTP 409 ("invalid_state").<br>  9. **On All Pass**: Call `next()` middleware with the validated decoded `u` payload attached for downstream rendering.<br>  10. **On Any Failure**: Immediately halt processing and render error/expired/invalid UI.<br>- **WHY**: Provides robust anti-tamper, anti-replay, and expiry enforcement for all magic-link payment flows, as mandated by requirements.  <br><br>--- |
| MagicLinkPageRenderer | renderCheckoutPage(req: import('express').Request, res: import('express').Response, validatedUData: MagicLinkU): void | Called after successful MagicLinkValidator.validateU. Composes and renders server-side HTML for invoice or subscription payment page. Injects validated payment data (amount, USD, expiry, branding/profile fetched via BrandingProfileManager.fetchBranding(storeId)). Generates QR code for the magic-link using QRRenderer.render. Embeds all data required by client-side script (`unsignedCall`, expiry, branding, invoiceId, etc.). Renders UI state: payment-ready (with wallet auto-open script), expired (with disabled actions/expired UI), or error (with reason). Ensures "Open wallet" button is disabled/hidden unless all checks pass. Uses Tailwind styling and minimal, user-friendly fallback states. Reuses logic for both invoice and subscription variants. Never persists data or exposes secrets on client. |  |
| MagicLinkClientScript | initMagicLinkPage(): void | Bound to browser `DOMContentLoaded`. On page load, extracts and parses `u` param from URL, calls MagicLinkClientScript.validateU(uBlob) to validate payload (re-checks expiry, postConditionMode, FT PC for sBTC). If valid, auto-invokes WalletIntegration.openWallet(unsignedCall) to open wallet; if browser blocks, injects "Open wallet" button (MLCS-3). Starts expiry countdown timer (`startCountdown(expiryTimestamp)`). Begins polling invoice/subscription status every second via `fetchAndUpdateInvoiceStatus`. On wallet broadcast, if `return` param is present in URL, calls handlePostWalletRedirect(txid) to redirect to merchant. Handles UI transitions for all statuses and disables wallet actions on expiry or invalid state. All state is ephemeral and page-local; does not persist or expose confidential data. | MagicLinkClientScript.initMagicLinkPage:<br>- **Mechanics**:<br>  1. On `DOMContentLoaded`, parse the URL for the `u` parameter.<br>  2. Call `MagicLinkClientScript.validateU(uBlob)`:<br>      - If expired/invalid, update UI to show expired/invalid state, hide wallet UI.<br>      - If valid, proceed.<br>  3. **Auto-Invoke Wallet**: Attempt `WalletIntegration.openWallet(unsignedCall)` (from u).<br>      - If wallet auto-open is blocked (by browser), call `MagicLinkClientScript.showOpenWalletButton()` to inject fallback button.<br>  4. **Start Countdown**: Call `MagicLinkClientScript.startCountdown(expiryTimestamp)` to start expiry timer.<br>  5. **Begin Invoice Polling**: Call `InvoiceStatusPoller.startPolling(invoiceId)` (or equivalent polling routine) to poll `/i/:invoiceId` every second.<br>  6. **After Wallet Broadcast**: If a `return` param is present, call `MagicLinkClientScript.handlePostWalletRedirect(txid)` to redirect with `?txid=...`.<br>  7. **UI Updates**: On status transitions (paid, expired, canceled), update UI accordingly using Tailwind CSS for all controls.<br>- **WHY**: Enforces defense-in-depth; ensures wallet is only called if all client- and server-side checks pass, with robust user feedback flows. <br><br>--- |
| MagicLinkClientScript | validateU(uBlob: string): boolean | Decodes and parses the provided base64url `u` blob from the URL. Validates presence and correct shape of required fields (exp, unsignedCall, etc.), checks expiry (`exp > now`), ensures `unsignedCall.postConditionMode === 'deny'` and that there is at least one FT post-condition with correct sBTC asset. If invalid or expired, sets UI to expired/invalid state and disables wallet actions (e.g., hides "Open wallet" button). Returns true if valid; false otherwise. All validation is defense-in-depth; checks mirror server-side checks but performed client-side before any wallet interaction. No secrets or sensitive data is exposed or persisted. | MagicLinkClientScript.validateU:<br>- **Mechanics**:<br>  1. **Decode**: Base64url-decode the `u` blob from the URL.<br>  2. **Parse JSON**: Parse as JSON, catch errors; if parse fails, set UI to invalid state, return false.<br>  3. **Check Field Validity**:<br>      - Verify presence of `exp`, `unsignedCall`, etc.<br>      - Ensure current time < `exp`; if expired, set UI to expired state, return false.<br>      - Check `unsignedCall.postConditionMode === 'deny'`.<br>      - Confirm at least one FT post-condition for sBTC asset, correct payer principal, and "eq" amount.<br>  4. **On All Pass**: Enable wallet actions (show "Open wallet" button if needed), return true.<br>  5. **On Any Fail**: Hide wallet controls, set UI to expired/invalid state, return false.<br>- **WHY**: Ensures client cannot invoke wallet with invalid/expired or tampered magic-link data, matching server-side checks. <br><br>--- |
| MagicLinkClientScript | showOpenWalletButton(): void | Injects an "Open wallet" button into the DOM (if not already present), binds its click handler to WalletIntegration.openWallet(unsignedCall) using the current validated unsigned call data from u. Ensures button is only shown when u is valid and not expired. Handles browser fallback for cases where auto-wallet open is blocked. Button is styled per minimal UI spec (e.g., Tailwind classes, accessible), and is disabled if u becomes expired/invalid during page session. | MagicLinkClientScript.showOpenWalletButton:<br>- **Mechanics**:<br>  1. Check if button already exists in DOM; if so, return.<br>  2. Create a button DOM element ("Open wallet"), style it with Tailwind classes per UI spec.<br>  3. Bind its click handler to call `WalletIntegration.openWallet(unsignedCall)` (using the current validated unsigned call).<br>  4. Insert button into UI at designated location.<br>  5. If magic-link (`u`) becomes expired or is invalidated during the session (timer or status update), disable and/or remove the button.<br>  6. If button is shown due to auto-open being blocked, ensure this is done only after validation passes.<br>- **WHY**: Provides fallback for browsers that block auto-wallet invocation and ensures button is only live if magic-link is valid .<br><br>--- |
| MagicLinkClientScript | startCountdown(expiryTimestamp: number): void | Initializes and updates the expiry countdown timer, displaying remaining time in the UI. Uses setInterval to decrement every second, updating DOM. When timer reaches 0, changes UI state to expired (disables wallet actions/buttons, displays "Expired" message), stops polling/status UI, and disables further wallet interaction. Ensures countdown is in sync with actual expiry from validated u. | MagicLinkClientScript.startCountdown:<br>- **Mechanics**:<br>  1. Initialize countdown timer from the given `expiryTimestamp` (unix seconds).<br>  2. SetInterval every 1 second:<br>      - Calculate remaining time: `expiryTimestamp - now`.<br>      - Update UI (e.g., show MM:SS format).<br>      - If timer reaches zero, set UI to expired state:<br>          - Disable/hide wallet actions (auto or button).<br>          - Display "Expired" message.<br>          - Stop status polling and any other active UI state.<br>  3. Ensure timer is always in sync with server-side expiry as given in `u`.<br>- **WHY**: Guarantees the payment window is accurate and user cannot pay after expiry .<br><br>--- |
| MagicLinkClientScript | handlePostWalletRedirect(txid: string): void | Called after successful wallet broadcast, if a `return` URL parameter is present. Constructs the redirect URL by appending `?txid=...` (or `&txid=...` if query string present) to the `return` URL, then sets `window.location.href` to trigger client-side navigation. Ensures correct encoding of txid and safe redirect. Used to complete checkout flow back to merchant. | MagicLinkClientScript.handlePostWalletRedirect:<br>- **Mechanics**:<br>  1. After wallet Connect returns `txid`, check for `return` param in the URL.<br>  2. If present, construct target URL as `${return}?txid=${encodeURIComponent(txid)}` (or use `&` if return already has query).<br>  3. Set `window.location.href` to the constructed URL, triggering redirect.<br>  4. If no `return` param, remain on the magic-link page and display broadcast UI.<br>- **WHY**: Ensures seamless shopper flow back to merchant after payment .<br><br>--- |
| MagicLinkClientScript | fetchAndUpdateInvoiceStatus(): Promise<void> | Called every second via setInterval polling. Fetches `/i/:invoiceId` via fetch/XHR (public, CORS-enabled endpoint), parses status (`unpaid`, `pending`, `paid`, `expired`, `canceled`, etc.), and updates the status strip/icons in the UI via DOM manipulation and Tailwind styling. On `paid`, disables further wallet actions and shows receipt. On `expired`/`canceled`, disables all actions and prompts for new invoice/refresh. Ensures UI is always in sync with on-chain/payment state as reported by Bridge. No state is persisted between sessions. | MagicLinkClientScript.fetchAndUpdateInvoiceStatus:<br>- **Mechanics**:<br>  1. Every second (or polling interval), call `fetch('/i/' + invoiceId)` (public CORS-enabled endpoint).<br>  2. Parse JSON response for `status` (`unpaid`, `pending`, `paid`, `expired`, `canceled`), `txId`, `payer`, etc.<br>  3. Update UI status strip/icons in real time:<br>      - If status is `paid`, show receipt, disable wallet actions.<br>      - If `expired` or `canceled`, hide/disable wallet controls, show prompt to regenerate invoice or retry.<br>      - For all status changes, use Tailwind CSS styling.<br>  4. Continue polling until status is `paid`, `expired`, or `canceled`, then stop polling.<br>- **WHY**: Provides live, authoritative invoice/payment status, prevents replay or double submission, and synchronizes UI to backend state at all times. <br><br>--- |
| CheckoutHandler | handleCheckoutPost(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | Express POST route handler for `/checkout/:storeId`. Validates request body shape (amount_sats > 0, ttl_seconds in [120,1800], memo present, orderId and payerPrincipal optional and matching patterns) using TypeScript schema or manual checks. On validation failure, calls ErrorHandler.handleValidationError to return HTTP 400/422. On success, calls BridgeApiClient.prepareInvoice(storeId, payload) with the securely loaded API key. On successful Bridge response, calls `res.redirect(302, magicLink)` to redirect shopper to the magic-link page. On Bridge error (e.g. store inactive), calls ErrorHandler.handleBridgeError with user-friendly error. No mutations or state are local; all data is passed through per domain models. | CheckoutHandler.handleCheckoutPost:<br>- **Mechanics**:<br>  1. On POST `/checkout/:storeId`, parse JSON body for `amount_sats`, `ttl_seconds`, `memo`, `orderId?`, `payerPrincipal?`.<br>  2. Validate:<br>      - `amount_sats > 0`<br>      - `ttl_seconds` ∈ [120,1800]<br>      - `memo` is present and a string.<br>      - Optional fields match patterns.<br>      - On validation fail: Call `ErrorHandler.handleValidationError(res, details)` to return HTTP 400/422.<br>  3. **Bridge API Call**: On success, call `BridgeApiClient.prepareInvoice(storeId, payload)`; injects API key server-side (never client).<br>  4. On Bridge API error (validation, store inactive, missing sBTC, etc.), call `ErrorHandler.handleBridgeError(res, bridgeError)` to return appropriate 4xx/409 response.<br>  5. On Bridge success (returns `{ invoice, magicLink, unsignedCall }`), call `res.redirect(302, magicLink)` to redirect shopper.<br>  6. No state is stored locally; no secrets leak into client context.<br>- **WHY**: Implements secure, validated, server-side invoice creation, redirect flow, and error propagation per the payment flow spec. <br><br>--- |
| PosRouteHandler | renderPosPage(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | Called by Express on GET `/pos/:storeId` after SessionManager.authMiddleware validates merchant session. Renders the POS terminal HTML page server-side, including fields for amount, memo, TTL, and relevant UI controls. Loads branding/profile info as needed for theming. No API key or sensitive data is injected into the client; all data is server-side only. The page includes JS to POST to backend for invoice creation and polling, but never exposes merchant secrets. Only page-local state is managed (e.g., for current sale/invoice). Uses Tailwind CSS for styling. |  |
| PosRouteHandler | handleCreateInvoice(): void (browser-side handler; typically bound as `onclick` or event listener in the POS page JS) | Client-side JS handler, bound to the "Create" button in the POS UI. On click, collects input values for amount, memo, and TTL from the DOM. Submits these via fetch/XHR as a POST request to `/api/v1/stores/:storeId/prepare-invoice` (handled by PRH-3). On backend response, receives `{ invoice, magicLink, unsignedCall }` as JSON, renders the QR code for magicLink (using a JS QR library), updates POS UI (e.g., showing timer, status strip), and starts polling for invoice status. At no point is the API key handled or exposed client-side. Ensures that UI is always reflecting latest backend/Bridge data. All error handling is via UI state and inline feedback. |  |
| PosRouteHandler | handlePrepareInvoicePost(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | Backend Express handler for `POST /api/v1/stores/:storeId/prepare-invoice`. Validates input payload (`amount > 0`, `ttl_seconds` in [120,1800], `memo` present, optional `orderId`). If `orderId` present, checks for idempotency (may check Bridge for existing invoice). Loads API key for store from server config; never exposes to client. Calls Bridge `/api/v1/stores/:storeId/prepare-invoice` with validated payload and API key. On success, returns `{ invoice, magicLink, unsignedCall }` to client as JSON. On Bridge error (e.g. validation, store inactive), relays error and HTTP code to frontend. No data is persisted locally; ensures types match domain models. Validates that all fields in JSON response are as expected for UI consumption. |  |
| PosRouteHandler | handleCancelInvoice(): void (browser-side handler; typically bound as `onclick` or event listener in the POS page JS) | Client-side JS handler for "Cancel" button in POS UI. On click, triggers a POST to backend `/api/v1/stores/:storeId/invoices/:invoiceId/cancel/create-tx` to request invoice cancellation (handled by PRH-5). On response, updates UI to canceled state (disables further actions, shows cancellation message, allows new sale). API key is never handled client-side. All state is ephemeral to the page. Handles errors by displaying inline UI messages. |  |
| PosRouteHandler | handleInvoiceCancelPost(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void | Express backend handler for `POST /api/v1/stores/:storeId/invoices/:invoiceId/cancel/create-tx`. Loads store API key. Calls Bridge `/api/v1/stores/:storeId/invoices/:invoiceId/cancel/create-tx` (or fallback DTO endpoint on failure) with API key. On Bridge response (canceled or error), returns result as JSON to client for UI update. Ensures canceled invoices are no longer payable (enforced by Bridge). Never exposes secrets or persists data locally. Handles all HTTP status codes and error propagation per domain models. |  |
| MerchantConsoleHandler | handleCreateInvoice(): void (browser-side handler; bound to "Create Invoice" button in merchant dashboard modal) | <br><br>`handleCreateInvoice(): void` collects modal input, submits the POST to backend, and now delegates all UI rendering and feedback to `InvoiceUiFeedbackRenderer`.<br><br>**Refactored Responsibilities and Implementation:**<br><br>1. After backend POST and receiving the invoice payload, calls:<br>   ```typescript<br>   this.uiFeedbackRenderer.renderInvoiceSuccessSheet(<br>     data.invoice,<br>     data.magicLink,<br>     data.unsignedCall,<br>     this.handleEmailInvoice.bind(this),<br>     this.handleShowQr.bind(this)<br>   );<br>   ```<br>2. Displays UI feedback exclusively using the delegate.<br>3. No modal or UI mutation logic remains in the parent.<br><br>**Code Snippet:**<br><br>```typescript<br>public handleCreateInvoice(): void {<br>  // ...collect and validate input as before...<br>  fetch(`/api/v1/stores/${encodeURIComponent(storeId)}/prepare-invoice`, {<br>    method: 'POST',<br>    headers: { 'Content-Type': 'application/json' },<br>    body: JSON.stringify({<br>      amount_sats: amount,<br>      memo,<br>      ttl_seconds: ttl<br>    })<br>  })<br>    .then(async resp => {<br>      if (!resp.ok) throw await resp.json();<br>      return resp.json();<br>    })<br>    .then((data: MagicLinkDTO) => {<br>      this.uiFeedbackRenderer.renderInvoiceSuccessSheet(<br>        data.invoice,<br>        data.magicLink,<br>        data.unsignedCall,<br>        this.handleEmailInvoice.bind(this),<br>        this.handleShowQr.bind(this)<br>      );<br>    })<br>    .catch(err => {<br>      this.errorHandler.handleBridgeApiError(err);<br>    })<br>    .finally(() => {<br>      if (submitBtn) submitBtn.disabled = false;<br>    });<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | handleCopyLink(magicLink: string): void | <br><br>`handleCopyLink(magicLink: string): void` now delegates all clipboard logic and UI feedback:<br><br>```typescript<br>public handleCopyLink(magicLink: string): void {<br>  this.uiFeedbackRenderer.handleCopyLink(magicLink);<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | handleEmailInvoice(invoiceId: string): Promise<void> | Bound to "Email" button. Receives invoiceId, sends POST to backend. The backend fetches latest invoice and branding from Bridge, regenerates magic-link, assembles email (using renderInvoiceEmail/renderInvoiceEmailText), validates recipient email, then sends via Postmark API (with MessageStream outbound, From derived from SENDER_DOMAIN, Subject/Html/Text bodies per template). Returns status to UI, which shows banner/toast for success/error. No email logic is on client; all assembly/sending/validation is server-side. Handles failures gracefully. | handleEmailInvoice(invoiceId: string): Promise<void><br>- **Step-by-step HOW**:<br>  1. When the "Email" button is clicked, the method receives `invoiceId`.<br>  2. Send a POST request to the backend endpoint (e.g., `/api/v1/invoices/:invoiceId/send-email`) with the `invoiceId` and (if required) recipient email.<br>  3. On the backend:<br>     - Fetch the latest invoice and branding data from the Bridge API, ensuring the invoice's state is still valid for sending (unpaid/ready).<br>     - Regenerate the magic-link via the Bridge, which signs a base64url-encoded JSON blob (`u`) using the per-store `hmacSecret`. The Bridge returns the `magic-link`, never exposes secrets to the client, and the `hmacSecret` is never sent to the browser.<br>     - Assemble the email body using `renderInvoiceEmail` (HTML) and `renderInvoiceEmailText` (plain text). These templates must handle missing branding fields gracefully—substitute defaults (e.g., fallback colors, support email), omit fields if not present, and ensure the layout is never broken by missing data.<br>     - Populate email fields: `From` is set as `billing@${SENDER_DOMAIN}` (from `.env`), `To` is the validated recipient email, `Subject` includes the brand and amount, and the magic-link is embedded in both HTML and text bodies.<br>     - Validate the recipient email (regex and length, as per RFC standards), ensuring it is not empty or malformed.<br>     - Send the email via the Postmark API (`MessageStream: 'outbound'`). Catch and handle any errors that occur during send (e.g., invalid email, API error).<br>     - Return the result (success or error) to the frontend.<br>  4. On the frontend:<br>     - Display a confirmation banner/toast on success using the UI delegate.<br>     - On error, display a minimal, user-friendly error message (never show technical details or stack traces).<br>     - The button must be re-enabled after the request completes (success or error).<br>     - Never expose or send any sensitive data (API keys, hmacSecret) in the UI, email, or magic-link.<br>  5. **Invariant**: Only the backend can access store credentials; all secrets are managed server-side. All interactions with Postmark and the Bridge are done via API calls; there is no direct SMTP logic or key material on the client.<br>  6. **Edge cases**:<br>     - If the invoice is expired, canceled, or already paid, the backend must reject the email request and surface a minimal error.<br>     - If the email send fails, the UI shows an error, and the button is re-enabled.<br>     - If branding fields are missing, use sensible defaults and never break email rendering.<br>  - **Example snippet (frontend):**<br>    ```typescript<br>    async handleEmailInvoice(invoiceId: string): Promise<void> {<br>      try {<br>        const res = await fetch(`/api/v1/invoices/${encodeURIComponent(invoiceId)}/send-email`, {<br>          method: 'POST',<br>          headers: { 'Content-Type': 'application/json' }<br>        });<br>        if (!res.ok) throw await res.json();<br>        this.uiFeedbackRenderer.showToast('Invoice email sent.');<br>      } catch (err) {<br>        this.uiFeedbackRenderer.showToast('Failed to send email. Please try again.');<br>      }<br>    }<br>    ```<br>  - **WHY**: Ensures secure, atomic email delivery using latest invoice and branding data, avoids replay/expiry edge cases, and guarantees secrets are never exposed per requirements   .<br><br>--- |
| MerchantConsoleHandler | handleShowQr(magicLink: string): void | <br><br>`handleShowQr(magicLink: string): void` now delegates all QR modal rendering:<br><br>```typescript<br>public handleShowQr(magicLink: string): void {<br>  this.qrModalRenderer.showQrModal(magicLink);<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | handleCancelInvoice(invoiceId: string): Promise<void> | <br><br>`handleCancelInvoice(invoiceId: string): Promise<void>` now delegates invoice row disable and toast feedback:<br><br>```typescript<br>public async handleCancelInvoice(invoiceId: string): Promise<void> {<br>  // ...POST to backend...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.disableInvoiceRow(invoiceId, 'Canceled');<br>    this.uiFeedbackRenderer.showToast('Invoice canceled.');<br>  }<br>  // ...<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | openRefundDrawer(invoiceId: string): Promise<void> | <br><br>`openRefundDrawer(invoiceId: string): Promise<void>` fetches invoice and delegates drawer opening:<br><br>```typescript<br>public async openRefundDrawer(invoiceId: string): Promise<void> {<br>  // ...fetch invoice...<br>  this.refundDrawerManager.openRefundDrawer(invoice);<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | handleSubmitRefund(invoiceId: string, amount_sats: number, memo: string): Promise<void> | Bound to refund drawer submit. Receives invoiceId, amount_sats, memo; sends POST to backend, which uses API key to call Bridge `/api/v1/stores/:storeId/refunds/create-tx` for unsigned refund-invoice call. Backend returns success (unsigned call for signing) or Bridge errors (e.g., u301 unpaid, u305 over-refund, u307 wrong token). UI surfaces result as banners/toasts. No business logic is in Webpay; all refund logic/validation is in Bridge. UI state is updated only based on backend response. | handleSubmitRefund(invoiceId: string, amount_sats: number, memo: string): Promise<void><br>- **Step-by-step HOW**:<br>  1. Bound to the refund drawer's submit action; receives `invoiceId`, `amount_sats`, and `memo`.<br>  2. Send a POST request to the backend endpoint `/api/v1/stores/:storeId/refunds/create-tx` with payload: `{ invoiceId, amount_sats, memo }`.<br>  3. Backend:<br>     - Uses the store's API key (from server-side secure storage) to call the Bridge API endpoint `/api/v1/stores/:storeId/refunds/create-tx`.<br>     - The Bridge validates that the invoice is `paid`, the refund amount does not exceed the remaining refundable amount, and the token matches the store's configured sBTC token. All business logic and constraints are enforced by the Bridge.<br>     - The Bridge generates and returns an unsigned `refund-invoice` contract call (payload).<br>     - If the request fails due to unpaid invoice (`u301`), over-refund (`u305`), or wrong token (`u307`), the Bridge returns an error code.<br>  4. Backend passes through the success or error directly to the frontend.<br>  5. Frontend:<br>     - On success, triggers the wallet Connect flow for signing and broadcasting the unsigned refund contract call (handled outside this method).<br>     - Displays banner/toast with a user-friendly message ("Refund ready to sign" on success, or "Refund failed: [minimal error]" on error).<br>     - Disables the refund drawer or the submit button upon error; never exposes technical error details, error codes, or stack traces to the user.<br>     - Ensures all UI state updates are performed only using the backend response; never persists or transforms local state.<br>  6. **Invariant**: No business logic is performed in Webpay; all validation and refund creation logic is in Bridge. All keys remain server-side.<br>  7. **Edge cases**:<br>     - If the backend returns a Bridge error code, display a minimal error and disable further refund attempts until UI refresh.<br>     - If network/API errors occur, display a retry message and re-enable the submit button.<br>  - **WHY**: This method enforces correct refund logic, aligns with atomicity and backend-only state transitions, and never leaks sensitive data or allows client-side replay/modification   .<br><br>--- |
| MerchantConsoleHandler | handleFilterChange(event: Event): Promise<void> | Triggered by input/change event on invoice list filter/search. Receives event, extracts filter/search params (status, subscriptionId, orderId), performs fetch/XHR to backend (which queries Bridge for filtered/paginated invoice list), and updates UI with new results using server-rendered templates or minimal DOM manipulation. No state library or client grid used. Ensures that all UI data matches Bridge's canonical state and that filters never exceed the query constraints defined in Static Report. |  |
| MerchantConsoleHandler | handleWebhookLogsPagination(event: Event): Promise<void> | Triggered by input/click event on webhook logs pagination controls. Receives event, determines requested log page, sends fetch/XHR to backend for the requested page, which queries Bridge for logs. UI is updated with new paginated log table and detail panel via DOM manipulation or server templates. No client-side log persistence; always fresh from Bridge. Ensures paginated content and page boundaries strictly follow Bridge API's returned capabilities. |  |
| MerchantConsoleHandler | archiveInvoice(invoiceId: string): Promise<void> | <br><br>`archiveInvoice(invoiceId: string): Promise<void>` delegates hiding the row:<br><br>```typescript<br>public async archiveInvoice(invoiceId: string): Promise<void> {<br>  // ...try POST...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.hideInvoiceRow(invoiceId);<br>  } else {<br>    this.uiFeedbackRenderer.hideInvoiceRow(invoiceId);<br>  }<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | resendInvoice | <br><br>`resendInvoice(invoiceId: string): Promise<void>` delegates UI feedback on success or error:<br><br>```typescript<br>public async resendInvoice(invoiceId: string): Promise<void> {<br>  // ...POST to backend...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.showToast('Invoice email resent.');<br>  }<br>  // ...<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | handleInvoiceDetailGet(req: Express.Request, res: Express.Response, next: Function): Promise<void> | Express route handler for `GET /api/v1/stores/:storeId/invoices/:invoiceId`. Receives Express req/res/next, validates route params, fetches invoice DTO from Bridge, renders invoice details drawer (Tailwind/Express template). If live updates required, injects JS into UI to poll `/i/:invoiceId` via setInterval. All DTO fields are mapped for rendering without transformation; UI gracefully handles missing/optional data (e.g., payer, txId). All errors are surfaced via ErrorHandler. No local/persistent state; rendering is based on latest Bridge data. |  |
| MerchantConsoleHandler | handlePreviewEmail(invoiceId: string): Promise<void> | Called on "Preview Email" click. Sends GET to backend (`/api/v1/invoices/:invoiceId/email-preview`). Server fetches current merchant branding and invoice data from Bridge, generates/validates magic-link, assembles HTML/plain-text email using renderInvoiceEmail/renderInvoiceEmailText, returns both formats in response. UI displays HTML in modal or preview panel. No email is sent. All preview logic uses the same pipeline as real sends, ensuring pixel-perfect preview. Handles any template errors by surfacing readable error in UI. | handlePreviewEmail(invoiceId: string): Promise<void><br>- **Step-by-step HOW**:<br>  1. On "Preview Email" click, receive `invoiceId`.<br>  2. Send a GET request to the backend endpoint (e.g., `/api/v1/invoices/:invoiceId/email-preview`).<br>  3. Backend:<br>     - Fetches current merchant branding and invoice/subscription data from the Bridge API.<br>     - Generates and validates the magic-link using Node.js HMAC (`crypto.createHmac`), never exposing secrets.<br>     - Assembles HTML and plain-text email content using `renderInvoiceEmail` and `renderInvoiceEmailText` templates, with all current branding and invoice data.<br>     - Handles missing branding fields by providing defaults or omitting fields as per template requirements.<br>     - Does not send any email; returns both HTML and plain-text preview in the response.<br>  4. Frontend:<br>     - Receives rendered HTML and plain-text previews.<br>     - Displays the HTML preview in a modal or preview panel.<br>     - Shows a minimal, user-friendly error if preview rendering fails (e.g., "Could not render email preview.").<br>     - Never exposes or sends any secrets, magic-link HMAC, or Bridge/internal error details to the UI.<br>  5. **Invariant**: All preview logic uses the same data and templates as real email sends, guaranteeing pixel-perfect match to production emails.<br>  6. **Edge cases**:<br>     - If invoice is missing or expired, backend must surface a minimal error and return a user-friendly message.<br>     - If rendering fails (e.g., malformed template), backend returns a user-friendly error to the frontend.<br>  - **WHY**: Guarantees that previews are always accurate, no user can trigger real emails, and no sensitive data or secrets are exposed in preview flows   .<br><br>--- |
| MerchantConsoleHandler | handleCopyMagicLink(invoiceId: string): Promise<void> | <br><br>`handleCopyMagicLink(invoiceId: string): Promise<void>` fetches magic link and delegates copy/feedback:<br><br>```typescript<br>public async handleCopyMagicLink(invoiceId: string): Promise<void> {<br>  // ...fetch magic link...<br>  await this.uiFeedbackRenderer.handleCopyLink(magicLink);<br>}<br>```<br><br> |  |
| MerchantConsoleHandler | handleSendEmail(invoiceId: string, recipientEmail: string): Promise<void> | Called when "Send Email" is clicked. Disables button, shows spinner; POSTs to backend (`/api/v1/invoices/:invoiceId/send-email`) with recipientEmail. Backend fetches latest branding and invoice data from Bridge, generates/validates magic-link, renders email using renderInvoiceEmail/renderInvoiceEmailText, assembles From/Subject fields using SENDER_DOMAIN. Validates recipient email; sends email via Postmark (MessageStream outbound). On success, re-enables button and shows result; on error, shows error. Ensures no email is sent if validation fails. All data transformations strictly match DTOs and email templates. | handleSendEmail(invoiceId: string, recipientEmail: string): Promise<void><br>- **Step-by-step HOW**:<br>  1. Receives `invoiceId` and `recipientEmail` when "Send Email" is clicked.<br>  2. Disables the button and displays a spinner to indicate progress.<br>  3. Sends a POST request to the backend (e.g., `/api/v1/invoices/:invoiceId/send-email`) with payload `{ recipientEmail }`.<br>  4. Backend:<br>     - Fetches the latest branding and invoice/subscription data from the Bridge API.<br>     - Validates the recipient email for proper format and non-empty (RFC regex).<br>     - Generates and validates the magic-link for the invoice, using HMAC with the store's `hmacSecret`.<br>     - Assembles the email using `renderInvoiceEmail` (HTML) and `renderInvoiceEmailText` (plain text), substituting default values for missing branding fields.<br>     - Sets email fields: `From` as `billing@${SENDER_DOMAIN}`, `To` as validated recipient, `Subject` as `${brand.displayName} — Invoice for ${invoice.amountSats} sats`, and inserts the `magic-link` into the email bodies.<br>     - Sends via the Postmark API (`MessageStream: 'outbound'`).<br>     - Returns status (success or error) to the frontend.<br>  5. Frontend:<br>     - On success, re-enables the button and shows a confirmation or success toast/banner using the UI delegate.<br>     - On error, re-enables the button and shows a minimal, user-friendly error message (no technical details).<br>  6. **Invariant**: No secrets, magic-link HMACs, or sensitive state are ever surfaced to the browser. All data transformations match DTOs and templates. The backend is the only place where secrets and email-sending logic exist.<br>  7. **Edge cases**:<br>     - If the recipient email is invalid or missing, backend should reject and return a user-friendly error.<br>     - If the invoice is expired, canceled, or paid, backend must reject and show a minimal error in the UI.<br>     - If Postmark/API fails, frontend shows a soft error and re-enables the button.<br>  - **WHY**: Ensures secure, atomically validated email delivery, prevents duplicate sends or expired invoice notifications, and protects all secret material in compliance with system requirements   .<br><br>--- |
| MerchantConsoleHandler | pollAndUpdateDashboardInvoices(): Promise<void> | <br><br>`pollAndUpdateDashboardInvoices(): Promise<void>` delegates full polling and row update logic:<br><br>```typescript<br>public async pollAndUpdateDashboardInvoices(): Promise<void> {<br>  await this.invoiceListUiRefresher.refreshInvoiceRows();<br>}<br>```<br><br>--- |  |
| MerchantConsoleHandler | resendInvoice(invoiceId: string): Promise<void> | <br><br>`resendInvoice(invoiceId: string): Promise<void>` delegates UI feedback on success or error:<br><br>```typescript<br>public async resendInvoice(invoiceId: string): Promise<void> {<br>  // ...POST to backend...<br>  if (res.ok) {<br>    this.uiFeedbackRenderer.showToast('Invoice email resent.');<br>  }<br>  // ...<br>}<br>```<br><br> |  |
| AdminConsoleHandler | handleCreateStoreFormSubmit(event: Event): Promise<void> | Called when the "Create Store" form is submitted in the Admin Console. The method receives the DOM form submit event. It prevents default behavior, extracts and validates input fields (`principal`, `name`, `display_name`, `logo_url`, `brand_color`, `allowed_origins`, `webhook_url`) against system validation rules (see Static Report, including type, presence, format, pattern for URLs/colors). On validation failure, invokes ErrorHandler.handleValidationError to surface error details to UI. On success, calls IBridgeApiClient.createStore(payload) to proxy data to Bridge API, ensuring the payload strictly matches the Store DTO (no internal state). Handles Bridge response: on 409 (duplicate), calls ErrorHandler.handleDuplicateStore to highlight/select existing row; on other errors, calls ErrorHandler.handleBridgeError; on success, updates UI via renderStoreListPage with returned store list. No data is persisted locally; all persistence is at the Bridge. Ensures all data transformations align with Bridge expectations. |  |
| AdminConsoleHandler | renderStoreListPage(data: Store[]): void | Called to render or refresh the Admin Console store list. Receives a list of Store DTOs (as returned by Bridge API). Renders each store’s profile, activation status, key rotation, and sBTC config. Ensures that UI state (badges, toggles, enabled actions) is strictly derived from live Bridge data; no local cache or mutation. Any UI controls for activating/deactivating, rotating keys, or editing branding/profile are enabled/disabled according to the current store status and constraints received. All rendering must conform to the subset of Store fields, gracefully handling missing/optional data (e.g., displayName, logoUrl). No transformation of the Store DTO structure; it is used as-is for UI templates. |  |
| AdminConsoleHandler | handleActivateStoreToggle(storeId: string, newState: boolean): Promise<void> | Called when the activate/deactivate toggle is clicked. Receives the target storeId and desired activation state. Sends a PATCH request to Express backend, which proxies via IBridgeApiClient.setStoreActiveState(storeId, newState) to Bridge. Validates that storeId is a string and newState is boolean. Handles Bridge responses: if successful, triggers a refresh of store list via renderStoreListPage; if error (4xx from Bridge), surfaces via ErrorHandler.handleBridgeError and disables or gates payment/invoice actions in the UI as needed. All business logic is enforced by Bridge; this handler's responsibility is to relay state and update UI, ensuring the activation status in UI is always derived from Bridge's canonical state. |  |
| AdminConsoleHandler | renderBrandingProfilePage(data: Store): void | <br><br>`renderBrandingProfilePage(data: Store): void` now delegates all form field population logic:<br><br>```typescript<br>renderBrandingProfilePage(data: Store): void {<br>  const form = document.getElementById('branding-profile-form') as HTMLFormElement;<br>  this.storeProfileFormDelegate.renderFormFields(form, data);<br>  form.dataset['storeId'] = data.storeId;<br>  form.querySelectorAll('input').forEach(input => {<br>    input.addEventListener('input', (e) => {<br>      this.brandingProfileManager.handleInputChange(e);<br>    });<br>  });<br>}<br>```<br><br> |  |
| AdminConsoleHandler | handleBrandingProfileFormSubmit(event: Event): Promise<void> | <br><br>`handleBrandingProfileFormSubmit(event: Event): Promise<void>` delegates extraction and validation:<br><br>```typescript<br>async handleBrandingProfileFormSubmit(event: Event): Promise<void> {<br>  event.preventDefault();<br>  const form = event.target as HTMLFormElement;<br>  const storeId = form.dataset['storeId']!;<br>  const result = this.storeProfileFormDelegate.extractAndValidateFormInput(form);<br>  if ('error' in result) {<br>    this.errorHandler.handleValidationError(window, { error: result.error });<br>    return;<br>  }<br>  try {<br>    const updated = await this.bridgeApiClient.updateStoreProfile(storeId, result.payload);<br>    this.renderBrandingProfilePage(updated);<br>  } catch (err) {<br>    this.errorHandler.handleBridgeApiError(err);<br>  }<br>}<br>```<br><br>--- |  |
| AdminConsoleHandler | handleRotateKeys(storeId: string): Promise<void> | Called when "Rotate Keys" is clicked. Receives storeId, sends POST to backend, which proxies to BridgeApiClient.rotateKeys(storeId). Handles Bridge response: on initial success, displays apiKey and hmacSecret in a one-time reveal UI (with copy-to-clipboard), warns that keys will not be returned again, and calls SecretManager.persistNewSecrets(storeId, apiKey, hmacSecret) for secure storage. On repeat (409/403), propagates error via ErrorHandler.handleBridgeError. All key material is only ever persisted server-side; no browser/local copy. All returned secrets must be securely handled to prevent exposure after reveal. Ensures no further key access is possible without explicit new rotation. | handleRotateKeys(storeId: string): Promise<void><br>- **Step-by-step HOW**:<br>  1. When "Rotate Keys" is clicked, receives `storeId`.<br>  2. Sends a POST request to the backend (Express route), which proxies to `BridgeApiClient.rotateKeys(storeId)` (the Bridge API).<br>  3. Bridge does the following:<br>     - Atomically generates new `apiKey` and `hmacSecret` for the store.<br>     - Ensures both keys are updated together; if any part fails, the store's keys must remain consistent and not partially updated.<br>     - Returns the new keys in a one-time-reveal payload; ensures keys cannot be fetched again after reveal (subsequent requests get 409/403).<br>  4. Backend:<br>     - Validates and persists the new secrets securely server-side (never exposes secrets to the browser or in email content).<br>     - Displays a one-time-reveal UI to the admin (modal/dialog) with both `apiKey` and `hmacSecret` (never shown again).<br>     - Warns the user that these keys will not be accessible again—user must copy/store now.<br>     - Uses `SecretManager.persistNewSecrets(storeId, apiKey, hmacSecret)` to save credentials to environment/session storage.<br>  5. UI:<br>     - Shows a "Copy to clipboard" control for each secret.<br>     - Clicking the copy control calls the clipboard API and shows a "Copied!" toast/badge.<br>     - After user interaction or modal close, disables or hides the secret fields.<br>     - Never allows secrets to persist in the DOM or client-side storage after the one-time event.<br>  6. Future backend operations (API calls, magic-link validation) must use only the newly rotated secrets.<br>  7. **Invariant**: The keys can never be revealed again after this event; all operations post-rotation must use the new keys.<br>  8. **Edge cases**:<br>     - If rotation fails (network, Bridge error), show a minimal error and do not update secrets.<br>     - If the user tries to rotate again before storing/copying, backend must return a one-time error and refuse to show keys again.<br>  - **WHY**: Enforces one-time secret reveal, protects keys, prevents leakage, and ensures atomic update per requirements. All key handling is in backend only, and UI disables access after use   .<br><br>--- |
| AdminConsoleHandler | handleCopySecret(secret: string): void | Called when a user clicks the copy-to-clipboard control for secret reveal (apiKey or hmacSecret). Uses the browser's Clipboard API (`navigator.clipboard.writeText(secret)`) to copy the value. On completion, updates UI state (e.g., shows "Copied!" badge/toast). Handles any clipboard errors gracefully (e.g., permissions). No backend calls or persistent state. Ensures secrets are not exposed after one-time UI event. |  |
| AdminConsoleHandler | handleSetSbtcTokenFormSubmit(event: Event): Promise<void> | Called on sBTC token configuration form submit. Receives DOM event, prevents default, extracts contractAddress and contractName, validates them per Static Report (required, string, address format). On success, sends POST via IBridgeApiClient.setSbtcToken(payload) to Bridge. If Bridge returns an unsigned call, renders UI to prompt user to sign via @stacks/connect. If Bridge returns 409 (store not ready), disables payment/invoice actions and displays "Store not ready for payments" UI message. No business logic is performed locally; all validation and state changes are enforced by Bridge. UI is updated based on Bridge response; all errors surfaced as user-friendly banners. |  |
| AdminConsoleHandler | renderWebhookLogPage(data: WebhookLog[]): void | Renders the webhook delivery log page. Receives an array of WebhookLog DTOs from Bridge. Renders each log's status, payload, headers, HMAC badge, delivery/failure time, and attempt count in a paginated table. UI must reflect status (delivered, failed, pending) as received. No local caching; every render is from live Bridge data. Data is used as-is for rendering, with no transformation beyond superficial UI formatting (e.g., JSON pretty-print for payloads). |  |
| AdminConsoleHandler | handleWebhookRetry(webhookLogId: string): Promise<void> | Called when the retry button for a failed webhook delivery is clicked. Receives webhookLogId, sends POST via IBridgeApiClient.retryWebhook(webhookLogId) to Bridge. On completion, triggers page refresh via renderWebhookLogPage with updated log data. Surfaces any errors via ErrorHandler.handleBridgeError. Ensures only valid webhookLogIds are submitted. No local data mutation; all retry logic is enforced by Bridge. |  |
| AdminConsoleHandler | renderPollerStatusPage(data: PollerStatus): void | Renders the poller status page. Receives PollerStatus DTO from Bridge, renders running state, lastRunAt, lastHeight, lastTxId, lagBlocks. All fields are rendered as-is, with any missing/optional data (e.g., absence of lastTxId) handled gracefully. No local status tracking is performed; UI always reflects Bridge status. |  |
| AdminConsoleHandler | handlePollerRestart(): Promise<void> | Called when the Restart Poller button is clicked. Sends POST via IBridgeApiClient.restartPoller() to Bridge. On success, triggers UI update via renderPollerStatusPage with latest status. On error, propagates via ErrorHandler.handleBridgeError. No local state mutation or polling logic; all operations are managed by Bridge and surfaced to UI. |  |
| AdminConsoleHandler | handleBootstrapProtocol(event: Event): Promise<void> | Called when the "Bootstrap Protocol" button is clicked in the Admin Console UI. The method prevents the default form/button action, then sends a POST request to the Express backend, which in turn invokes BridgeApiClient.bootstrapProtocol(). The backend passes along any returned unsigned call or idempotent abort status. If the response contains an unsigned call, the method triggers the UI logic for displaying the call and opening the @stacks/connect wallet flow for signing and broadcasting the transaction (using WalletIntegration.handleBootstrapProtocolResult afterwards). If the response is an idempotent abort, the UI displays an "already done" message. The data flow is: UI event → Express route → Bridge API → UI wallet integration. All error and status handling is delegated to the ErrorHandler component, which surfaces errors to the user and disables any affected UI. No local state is persisted; all data is ephemeral and derived from Bridge API responses. |  |
| AdminConsoleHandler | handleSyncOnchain(event: Event, storeId: string): Promise<void> | Called when the "Sync On-Chain" button is clicked in the Admin Console UI. The method prevents the default action, then sends a POST request to the Express backend, which proxies a call to BridgeApiClient.syncOnchain(storeId). The Bridge response contains either an array of unsigned calls (for on-chain sync actions) or an idempotent abort message. If unsigned calls are returned, the UI iterates over each one and triggers the @stacks/connect wallet flow (via WalletIntegration.handleSyncCallResult) for signing/broadcasting. If the abort message is returned, it displays "already done" in the UI. Error and status handling are managed by the ErrorHandler, surfacing feedback to the user and blocking duplicate/invalid actions. All business logic and state transitions reside in the Bridge; AdminConsoleHandler is responsible for event wiring, invoking API calls, interpreting responses, and updating the UI. |  |
| AdminConsoleHandler | fetchAndUpdateWebhookLogs(storeId: string): Promise<void> | Called every second via a JS setInterval on the Admin Console dashboard UI. The method fetches current webhook delivery logs from the Bridge endpoint (`/api/v1/stores/:storeId/webhooks`) using fetch/XHR. Upon receiving the array of WebhookLog DTOs, it parses and updates the dashboard's webhook logs table in the UI, rendering the latest delivery statuses, timestamps, and details for each webhook attempt. DOM manipulation or JS is used for UI updates; no client state library is used. The method handles any fetch or Bridge API errors by delegating to the ErrorHandler, which surfaces minimal error feedback in the UI and disables related controls if necessary. Data is not persisted locally; every call fetches fresh data from Bridge, ensuring logs reflect the current webhook delivery state. |  |
| BrandingProfileManager | fetchBranding(storeId: string): Promise<PublicProfile> | Fetches branding and public profile data for the specified store from the Bridge API (`/api/v1/stores/:storeId/public-profile`). Returns a PublicProfile object containing the fields: displayName, logoUrl, brandColor, supportEmail, and supportUrl. The method ensures no local/session cache is used; every call fetches live data. The PublicProfile DTO is used for theming UI surfaces (magic-link pages, POS, emails, dashboards). Handles missing/null fields gracefully—UI should display default or omit branding/support fields if absent. BridgeApiClient.getPublicProfile must be used as the canonical fetch mechanism. Any fetch or parse errors are surfaced via the ErrorHandler. The method enforces type compatibility with the PublicProfile interface. |  |
| BrandingProfileManager | handleInputChange(event: Event): Promise<void> | Bound to input/change DOM events on branding/profile form fields in the Admin/Merchant UI. On each event (with debounce), sends a fetch/XHR to the Express backend, which proxies a `GET /api/v1/stores/:storeId/public-profile` call to Bridge via BridgeApiClient.getPublicProfile. The latest branding data is injected into the live preview component using Tailwind CSS for styling. No local/session cache is used; each input results in a live fetch. The method ensures that every branding field update in the input form is reflected in real-time in the preview UI, matching the current values as returned by Bridge. Any errors encountered during fetch or update are propagated to the ErrorHandler, surfacing clear errors in the UI. No data is persisted locally; all updates are transient. |  |
| BrandingProfileManager | applyBrandingToUI(brandingData: PublicProfile): void | Called when a public UI surface (magic-link page, POS, dashboard, email) is rendered or loaded in the browser. Receives a PublicProfile DTO (typically from BridgeApiClient.getPublicProfile or a fetch to `/api/v1/stores/:storeId/public-profile`). The method injects displayName, logoUrl, brandColor, supportEmail, and supportUrl into the relevant UI components or templates, using Tailwind CSS classes for styling/branding. If any branding field is missing/null, the UI gracefully degrades (uses defaults or omits). The function does not persist data or use global state; it always renders the UI according to the latest branding info provided as input. No error or state is produced, but if brandingData is invalid/unparseable, ErrorHandler is called to update UI error state. Called from both server-rendered and client-rendered contexts to ensure consistent branding. |  |
| BrandingProfileManager | handlePublicProfileRequest(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express backend handler for `GET /api/v1/stores/:storeId/public-profile`. When invoked, extracts the `storeId` parameter from the request, then calls BridgeApiClient.getPublicProfile(storeId) to fetch the current PublicProfile data. The handler injects (as template variables in SSR, or as JSON in API responses) displayName, logoUrl, brandColor, supportEmail, and supportUrl fields into all relevant UI templates (POS, invoice creation, subscription, ledger, etc). No branding data is persisted locally; every request fetches data live from Bridge. If the Bridge API call fails, the error is passed to next() to be processed by ErrorHandler middleware, which returns an HTTP error. All responses conform to the PublicProfile interface, with nulls/defaults as needed for missing or incomplete fields. |  |
| BrandingProfileManager | fetchAndUpdateBrandingProfile(storeId: string): Promise<void> | Called periodically (e.g., via setInterval) or on a profile-change event for all relevant UI surfaces, including magic-link pages, POS, and dashboards. Fetches branding/profile data from Bridge API (`/api/v1/stores/:storeId/public-profile`) using BridgeApiClient.getPublicProfile, parses the returned PublicProfile fields, and injects values into the UI via DOM/JS manipulation or template update. No global state or cache is used; every call fetches the latest Bridge data. Any errors encountered during fetch or update are surfaced with ErrorHandler and shown in the UI as toasts or banners. The method enforces robust UI rendering matching the current branding state; missing/null fields are handled with graceful degradation. Designed for repeated, stateless invocation to keep branding live and current on all public/merchant/admin UI surfaces. |  |
| EmailDeliveryHandler | handleInvoiceCreated(data: { invoiceId: string; recipientEmail: string; }): Promise<void> | <br><br>`handleInvoiceCreated(data: { invoiceId: string; recipientEmail: string; }): Promise<void>` now:<br><br>1. Calls `this.emailRecipientValidator.validateRecipientEmail(data.recipientEmail)` to validate the email.<br>2. Calls `this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets)` to validate the magic link signature.<br>3. Uses `this.emailTemplateRenderer` to render all bodies and fields.<br>4. Sends via `this.postmarkApiClient.sendEmail`.<br><br>No such logic remains inline; all is delegated.<br><br>**Example:**<br><br>```typescript<br>async handleInvoiceCreated(data: { invoiceId: string; recipientEmail: string; }): Promise<void> {<br>  this.emailRecipientValidator.validateRecipientEmail(data.recipientEmail);<br>  const secrets = config.STORE_SECRETS[storeId];<br>  this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets);<br>  const htmlBody = this.emailTemplateRenderer.renderInvoiceEmail(invoice, branding, magicLinkDTO.magicLink);<br>  const textBody = this.emailTemplateRenderer.renderInvoiceEmailText(invoice, branding, magicLinkDTO.magicLink);<br>  const subject = this.emailTemplateRenderer.getEmailSubject(branding, 'invoice');<br>  const fromEmail = this.emailTemplateRenderer.getEmailFrom(branding, SENDER_DOMAIN);<br>  await this.postmarkApiClient.sendEmail({<br>    To: data.recipientEmail,<br>    From: fromEmail,<br>    Subject: subject,<br>    HtmlBody: htmlBody,<br>    TextBody: textBody,<br>    MessageStream: 'outbound'<br>  }, POSTMARK_API_KEY);<br>}<br>```<br><br> | EmailDeliveryHandler.handleInvoiceCreated HOW:<br><br>- **Step-by-step Implementation**:<br>  1. **Validate Recipient Email**:<br>     - Use `this.emailRecipientValidator.validateRecipientEmail(data.recipientEmail)` to check the format and presence of the recipient's email address.<br>     - If invalid, abort further processing and invoke the error handler to return HTTP 400+ (see EDH-4).<br><br>  2. **Fetch Invoice/Magic-Link/Branding Data**:<br>     - Retrieve invoice, branding, and magic-link DTOs by calling the Bridge API using the provided `invoiceId` and associated `storeId`.<br>     - Use secure backend calls; never expose secrets to the client.<br><br>  3. **Magic-Link Signature Validation**:<br>     - Obtain the per-store `hmacSecret` from secure environment/session storage (`config.STORE_SECRETS[storeId]`).<br>     - Validate the magic-link by calling `this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets)`, ensuring:<br>       - HMAC is computed using the canonical JSON stringified payload, with field order as `{v, storeId, invoiceId, unsignedCall, exp}`.<br>       - Use constant-time comparison to avoid timing attacks.<br>       - Check for expiration (`exp`) and field alignment.<br>       - If invalid/expired/tampered, abort and return error.<br><br>  4. **Render Email Content**:<br>     - Use `this.emailTemplateRenderer` to render all email bodies and fields:<br>       - `renderInvoiceEmail(invoice, branding, magicLinkDTO.magicLink)` returns the HTML body.<br>       - `renderInvoiceEmailText(invoice, branding, magicLinkDTO.magicLink)` for the plain text body.<br>       - `getEmailSubject(branding, 'invoice')` for the subject line.<br>       - `getEmailFrom(branding, SENDER_DOMAIN)` for the sender.<br>     - Handle missing/incomplete branding fields gracefully:<br>       - If branding fields (e.g., logo, displayName, brandColor) are missing, use default values or omit them in the email template (per DS-4-16).<br><br>  5. **Send Email via Postmark**:<br>     - Call `this.postmarkApiClient.sendEmail({ ... }, POSTMARK_API_KEY)`, providing:<br>       - `To`: recipient email.<br>       - `From`: sender email.<br>       - `Subject`: subject line.<br>       - `HtmlBody`: rendered HTML.<br>       - `TextBody`: rendered plain text.<br>       - `MessageStream`: "outbound".<br>     - Await the result; if successful, proceed to UI/api status update (see EDH-3).<br>     - If sending fails, invoke the error handler (see EDH-5).<br><br>- **Edge Cases/Gotchas**:<br>  - Never expose or log the hmacSecret or apiKey.<br>  - On key rotation, always use the latest secret (see DS-2-9, DS-2-10).<br>  - If any part fails (recipient invalid, magic-link invalid, Postmark error), abort and return error without marking invoice as notified.<br>  - No duplicate sends unless explicitly retried.<br>  - Email content must reflect the latest branding as fetched live; no local cache.<br><br>--- |
| EmailDeliveryHandler | handleSubscriptionInvoiceCreated(data: { invoiceId: string; subscriptionId: string; recipientEmail: string; }): Promise<void> | <br><br>`handleSubscriptionInvoiceCreated(data: { invoiceId: string; subscriptionId: string; recipientEmail: string; }): Promise<void>` uses the same delegation pattern as above, calling each delegate in turn for validation, content rendering, and delivery.<br><br>--- | EmailDeliveryHandler.handleSubscriptionInvoiceCreated HOW:<br><br>- **Step-by-step Implementation**:<br>  1. **Validate Recipient Email**:<br>     - Call `this.emailRecipientValidator.validateRecipientEmail(data.recipientEmail)`.<br><br>  2. **Fetch Subscription/Invoice/Magic-Link/Branding Data**:<br>     - Retrieve relevant subscription, invoice, branding, and magic-link info via Bridge API, using `subscriptionId`, `invoiceId`, and `storeId`.<br><br>  3. **Magic-Link Validation**:<br>     - Obtain the current `hmacSecret` for the store.<br>     - Validate the magic-link with `this.magicLinkValidator.validateMagicLink(magicLinkDTO.magicLink, storeId, secrets)`.<br><br>  4. **Render Email Content**:<br>     - Use `this.emailTemplateRenderer` to render the HTML and plain text bodies for the subscription invoice, handle missing branding as in EDH-1.<br>     - Use correct subject/from fields as per store branding.<br><br>  5. **Send Email via Postmark**:<br>     - Use `this.postmarkApiClient.sendEmail(...)` as above.<br>     - Await result, update UI (see EDH-3) or handle error (see EDH-5).<br><br>- **Edge Cases**:<br>  - No duplicate notifications unless explicitly retried.<br>  - If any validation fails, abort send and return error.<br><br>--- |
| EmailDeliveryHandler | handlePostmarkApiResponse(response: object): void | Called after the backend receives a synchronous response from the Postmark API following an email send attempt (Promise `.then()` or async/await result). If the send was successful, the method sets a flag or emits a status in the backend API response, allowing the frontend UI to display a "sent" status indicator (toast, badge, or similar), re-enables the send/resend button, and blocks further duplicate sends unless explicitly retried. If the send failed, ErrorHandler is called to update UI error state. No data persistence occurs; the state is ephemeral and used for UI feedback only. Ensures the send state is consistent with the actual Postmark API response. |  |
| EmailDeliveryHandler | handleEmailValidationFailure(error: Error): void | Invoked in backend when email validation fails before attempting a send (e.g., recipient email is missing/invalid, magic-link validation fails, required data is missing). Aborts the email send, returns a clear HTTP 400+ error to the frontend API/UI, and ensures the UI does not display a sent-status or mark the invoice/subscription as notified. The error is surfaced via ErrorHandler, which disables further relevant UI actions and informs the user with a toast/banner or inline message. Ensures that no transactional email is sent and no notification state is set for the invoice/subscription. |  |
| EmailDeliveryHandler | handlePostmarkApiError(error: Error): void | Called in backend when the Postmark API returns an error or exception during email transmission. Returns a clear HTTP 500+ error to the UI with an explanatory message, ensures the UI does not display a sent-status or update any "notified" state, and displays the error to the user through ErrorHandler. Ensures the invoice/subscription is not marked as notified. The method is only responsible for error reporting and does not attempt any retry or state update. All error-handling logic is backend-implemented; frontend UI simply interprets the response and updates send-status indicators accordingly. |  |
| ErrorHandler | handleValidationError(res: Express.Response, errorDetails: any): void | Sends an HTTP 400 or 422 response to the client using `res.status(400).json({ error: errorDetails })` or similar. Ensures proper error propagation and immediate termination of request processing. The errorDetails argument is expected to match the schema of the relevant validation error. Used throughout Express route handlers and validation middleware wherever structured validation failures occur (e.g., input type/constraint violations). No enrichment or logging is performed. |  |
| ErrorHandler | handleBridgeError(res: Express.Response, bridgeError: any): void | Interprets the error response from Bridge, sets the appropriate HTTP status code (e.g., 409 for invalid_state, 400 for bad request), and sends a user-friendly error message to the client using `res.status(errorCode).json({ error: message })`. No custom transformation or mapping is performed; the error is relayed as returned from Bridge. Used for surfacing all Bridge API errors to the UI or API clients, ensuring that error context is not lost in translation. Ensures UI receives the precise feedback from Bridge and disables further actions as needed. |  |
| ErrorHandler | handleDuplicateStore(res: Express.Response, context: { existingStore: Store }): void | Sends an HTTP 409 response to the UI with sufficient context to enable the frontend to highlight or select the existing store row in the Admin Console. The context argument contains the existing Store object as returned by Bridge. Used specifically after a duplicate principal/store is detected during store creation (POST /api/admin/stores). Ensures the UI can accurately reflect duplication and navigate to/select the conflicting store. No data persistence, only immediate feedback. |  |
| ErrorHandler | handleError(err: any, req: Express.Request, res: Express.Response, next: Express.NextFunction): void | Registered as Express error-handling middleware. Whenever an error occurs in Express route handlers (e.g., invalid input, unauthorized access, Bridge API business rule violation), Express passes the error to this method. The method extracts the HTTP status code and error message from the err object (as returned by the Bridge API), and sends the error code and message in the HTTP response as-is (`res.status(err.statusCode).json({ error: err.message })`). No custom mapping, logging, or enrichment is performed; this method is a transparent relay between Bridge and frontend/UI. Used for all error propagation on server routes, ensuring clients receive canonical error feedback. |  |
| ErrorHandler | handleBridgeApiError(error: any): void | Invoked whenever a Bridge API error is caught by Express middleware (server) or JS fetch handler (client). On the client side, displays a toast/banner or updates a UI state variable with error.message. On the server side, injects an error banner/message into rendered templates or returns a dedicated error page. Disables or sets to a safe state any UI actions affected by the error (e.g., disables failed invoice buttons). Ensures ambiguous or invalid UI states are never presented after an error, and allows user to retry where appropriate. Handles transient error reporting only; no logging or persistence is performed. |  |
| QRRenderer | render(qrData: { url: string }, options?: { size?: number; format?: 'canvas' ¦ 'svg' ¦ 'img' }): HTMLElement ¦ string ¦ void) | Takes the magic-link URL as input (in the qrData.url field) and generates a QR code as a canvas, SVG, or image element (depending on options), suitable for embedding in invoice, POS, or subscription UIs. Uses a JS QR code library to produce the graphic. The method does not perform any business logic, validation, or state updates; it is strictly a synchronous rendering function. Can be called from server-rendered or client-rendered contexts. If an error occurs (e.g., invalid/missing URL), returns void or an error element. |  |
| WalletIntegration | openWallet(unsignedCall: UnsignedCall): Promise<void> | Called when the "Open wallet" button is clicked (or auto-invoked) on checkout, refund, cancel, or protocol pages. Receives a validated UnsignedCall object (exactly matching the domain structure) parsed from the magic-link or API. Calls request('stx_callContract', unsignedCall) from the @stacks/connect library, passing contractId, functionName, functionArgs, postConditions, postConditionMode, and network exactly as provided. Does not modify or augment the unsignedCall object. On completion, invokes WalletIntegration.handleWalletResult(result) to process the wallet broadcast result, update UI, and (if present) trigger post-wallet redirection. Blocks further wallet actions while signing is in progress. Handles any errors by calling WalletIntegration.handleOnSignError. All wallet and blockchain logic is handled by @stacks/connect; the method is responsible for data passing, event wiring, and UI state. | WalletIntegration.openWallet HOW:<br><br>- **Step-by-step Implementation**:<br>  1. **Input**: Receives a validated `unsignedCall` object. This should have been parsed and verified for integrity (e.g., magic-link HMAC, expiry, correct FT post-condition, etc.) before invocation.<br>     - Object fields: `contractId`, `functionName`, `functionArgs`, `postConditions`, `postConditionMode`, `network`.<br>     - **Invariant**: `postConditionMode` must be `'deny'`, and must include an FT post-condition for the sBTC SIP-010 asset on the payer principal.<br><br>  2. **Call Stacks Connect**:<br>     - Use `@stacks/connect` library's `request('stx_callContract', unsignedCall)`.<br>     - Example:<br>       ```typescript<br>       import { request } from '@stacks/connect';<br>       await request('stx_callContract', unsignedCall);<br>       ```<br>     - Do not mutate or augment `unsignedCall`.<br><br>  3. **UI State**:<br>     - Disable further wallet actions (to prevent double invocation) while signing is in progress.<br>     - On completion, call `WalletIntegration.handleWalletResult(result)` to process the result.<br>     - On error or cancellation, call `WalletIntegration.handleOnSignError(error)`.<br><br>  4. **Side Effects**:<br>     - No data persistence or state mutation outside of UI.<br>     - No secrets or sensitive data are ever present on the client.<br><br>- **Edge Cases**:<br>  - If wallet fails to open or broadcast, ensure error handling and user feedback.<br>  - If the network or FT post-condition is misconfigured, abort and display an error.<br>  - One wallet operation at a time.<br><br>--- |
| WalletIntegration | handleWalletResult(result: { txid?: string; txId?: string; [key: string]: any }): void | Called when the promise from request('stx_callContract', unsignedCall) resolves. Extracts the txid or txId from the result object. Updates the checkout page UI to display "Broadcasted" status and shows the transaction ID to the user. If a return parameter is present in the page URL, invokes MagicLinkClientScript.handlePostWalletRedirect(txid) to perform post-broadcast redirection (passing txid as a query parameter). Handles UI state transitions and clears any "pending" indicators. Does not persist data or alter application state outside of the current page context. If broadcasting failed or no txid is present, triggers ErrorHandler.handleBridgeApiError to show user feedback. |  |
| WalletIntegration | handleSbtcTokenConfigResult(result: { txid?: string; txId?: string; [key: string]: any }): void | Called after receiving an unsigned call for sBTC token config from Bridge and completing the wallet sign/broadcast flow via @stacks/connect. On success, updates the UI state to reflect successful configuration, displays the transaction ID, and enables further store actions. On error, shows a clear error message or status in the UI. The method does not modify any contract or blockchain state; it is strictly concerned with updating UI/UX based on the result of the wallet operation. If an error is encountered (including user cancellation or wallet errors), calls ErrorHandler.handleBridgeApiError. Ensures the UI is always in a safe, non-ambiguous state after completion. |  |
| WalletIntegration | handleBootstrapProtocolResult(result: { txid?: string; txId?: string; [key: string]: any }): void | Called after the UI receives an unsigned protocol bootstrap call from Bridge and completes the wallet sign/broadcast flow via @stacks/connect. On success, updates the UI to reflect protocol initialization, displays the transaction ID (if present), and allows subsequent admin actions. On error, updates the UI to show a clear error state and disables or blocks further actions as needed. No contract or blockchain logic is implemented in Webpay; all business logic is externalized. Uses ErrorHandler.handleBridgeApiError for error reporting. Ensures only one wallet operation is active at a time and clears any signing-related UI state after completion. |  |
| WalletIntegration | handleSyncCallResult(result: { txid?: string; txId?: string; [key: string]: any }, callIndex: number, totalCalls: number): void | Called for each unsigned sync call returned by Bridge after a sync-onchain operation and completed via @stacks/connect. Receives the result object and indexing information (callIndex and totalCalls) for multi-call sync flows. Updates the UI to reflect the status/result of each individual sync operation, displays transaction ID, and marks the current sync step as complete. On successful completion of all calls, updates the UI to reflect "Sync complete". On error, disables further sync actions, displays error information, and allows retrying as appropriate. All error and status handling is performed via ErrorHandler and standard UI update routines; method does not perform blockchain logic or persistence. |  |
| WalletIntegration | handleRefundSignResult(result: { txid?: string; txId?: string; [key: string]: any }): void | Called when the Connect wallet emits a sign event (onSign) during a refund. Blocks user actions in the UI while signing (e.g., disables the refund drawer). Upon completion (success or error), resumes polling `/i/:invoiceId` to refresh the invoice's refund status (by triggering InvoiceStatusPoller.pollInvoiceStatus or similar). The refund drawer and invoice UI are updated with the latest refund status and refunded amount based on polling. Handles both success (shows "Refunded" or updated status) and error (calls ErrorHandler.handleBridgeApiError and re-enables drawer for retry). No blockchain or contract logic is implemented directly; strictly ties UI state to Connect events and polling results. |  |
| WalletIntegration | handleOnSignResult(result: { txid?: string; txId?: string; [key: string]: any }): void | Called when request('stx_callContract', {...}) resolves for cancel, refund, or subscription on-chain actions. Sets the internal signing state flag to false, re-enables any previously disabled UI controls, and initiates polling of the relevant Bridge endpoint (`/api/v1/stores/:storeId/invoices/:invoiceId` or `/api/v1/stores/:storeId/subscriptions/:id`) to update the action’s status in real time. UI is updated to reflect the result of the on-chain action (e.g. "Refunded", "Canceled", "Payment Complete"). If an error or cancellation occurred, handleOnSignError is called instead. No state is persisted; all logic is reactive to Connect events and polling outcomes. Ensures seamless update of UI based on the actual blockchain and Bridge state. |  |
| WalletIntegration | handleOnSignError(error: any): void | Called when request('stx_callContract', {...}) fails or is canceled for any sign/broadcast action (cancel, refund, subscription). Sets the signing state flag to false, re-enables any blocked UI controls, and calls ErrorHandler.handleBridgeApiError(error) to display an appropriate error message/toast/banner to the user. Ensures user can retry the wallet action and that the UI reflects the error state clearly. No business logic, persistence, or state mutation beyond error reporting and UI update. |  |
| InvoiceStatusPoller | startPolling(invoiceId: string): void | Sets up a polling interval (typically every 1 second) to repeatedly call InvoiceStatusPoller.pollInvoiceStatus(invoiceId). Ensures only one poller is active per invoice. Used on magic-link checkout, POS, merchant/admin dashboard UIs, etc. Polling is used to update UI in real time as invoice status transitions occur. No state is persisted beyond the interval handle and current polling context. |  |
| InvoiceStatusPoller | pollInvoiceStatus(invoiceId: string): Promise<void> | Called every second by an interval timer. Fetches the latest invoice status from Bridge (`GET /i/:invoiceId`) and parses the Invoice DTO from the response. The UI is updated as follows: If status is "paid", calls InvoiceStatusPoller.handlePaidStatus; if status is "expired" or "canceled", calls InvoiceStatusPoller.handleExpiredStatus; for any other open status, countdown and payment UI remain active. Handles error states by calling ErrorHandler.handleBridgeApiError and disabling further actions if needed. Distinguishes between invoice and subscription context as necessary. Ensures only robust, up-to-date status is shown in UI; no stale or ambiguous state is possible. |  |
| InvoiceStatusPoller | handleTerminalStatus(invoiceId: string, status: 'paid' ¦ 'expired' ¦ 'canceled'): void | <br><br>`handleTerminalStatus(invoiceId: string, status: 'paid' or 'expired' or 'canceled'): void` after polling detects a terminal status, clears polling and delegates UI updates:<br><br>```typescript<br>public handleTerminalStatus(invoiceId: string, status: TerminalStatus, statusData: Invoice): void {<br>  this.clearPolling(invoiceId);<br>  switch (status) {<br>    case 'paid':<br>      this.terminalUiManager.handlePaid(invoiceId, statusData);<br>      break;<br>    case 'expired':<br>      this.terminalUiManager.handleExpired(invoiceId, statusData);<br>      break;<br>    case 'canceled':<br>      this.terminalUiManager.handleCanceled(invoiceId, statusData);<br>      break;<br>  }<br>}<br>```<br><br> |  |
| InvoiceStatusPoller | handlePaidStatus(invoiceId: string, statusData: Invoice): void | <br><br>`handlePaidStatus(invoiceId: string, statusData: Invoice): void` delegates the UI update for "paid":<br><br>```typescript<br>public handlePaidStatus(invoiceId: string, statusData: Invoice): void {<br>  this.terminalUiManager.handlePaid(invoiceId, statusData);<br>}<br>```<br><br> |  |
| InvoiceStatusPoller | handleExpiredStatus(invoiceId: string, statusData: Invoice): void | <br><br>`handleExpiredStatus(invoiceId: string, statusData: Invoice): void` delegates the UI update for "expired":<br><br>```typescript<br>public handleExpiredStatus(invoiceId: string, statusData: Invoice): void {<br>  this.terminalUiManager.handleExpired(invoiceId, statusData);<br>}<br>```<br><br> |  |
| InvoiceStatusPoller | handleCanceledStatus(invoiceId: string, statusData: Invoice): void | <br><br>`handleCanceledStatus(invoiceId: string, statusData: Invoice): void` delegates the UI update for "canceled":<br><br>```typescript<br>public handleCanceledStatus(invoiceId: string, statusData: Invoice): void {<br>  this.terminalUiManager.handleCanceled(invoiceId, statusData);<br>}<br>```<br><br>--- |  |
| SubscriptionManager | openCreateSubscriptionModal(): void | <br><br>`openCreateSubscriptionModal(): void` now simply calls:<br><br>```typescript<br>openCreateSubscriptionModal(): void {<br>  this.modalDelegate.openModal();<br>}<br>```<br><br> |  |
| SubscriptionManager | handleSubmitSubscription(): Promise<void> | <br><br>`handleSubmitSubscription(): Promise<void>` delegates form validation and value extraction:<br><br>```typescript<br>async handleSubmitSubscription(): Promise<void> {<br>  const { valid, errorMessage } = this.modalDelegate.validateForm();<br>  if (!valid) {<br>    this.modalDelegate.setError(errorMessage);<br>    return;<br>  }<br>  const { subscriberPrincipal, amountSats, intervalBlocks } = this.modalDelegate.getFormValues();<br>  const storeId = ...; // Retrieve as before<br>  try {<br>    const resp = await fetch(`/api/v1/stores/${storeId}/subscriptions`, {<br>      method: 'POST',<br>      headers: { 'Content-Type': 'application/json' },<br>      body: JSON.stringify({ subscriberPrincipal, amountSats, intervalBlocks })<br>    });<br>    if (!resp.ok) {<br>      const err = await resp.json();<br>      this.errorHandler.handleBridgeApiError(err);<br>      this.modalDelegate.setError(err.error or 'Error creating subscription.');<br>      return;<br>    }<br>    await this.pollAndUpdateSubscriptionsTable();<br>    this.closeCreateSubscriptionModal();<br>    if (typeof (window as any).showToast === 'function') {<br>      (window as any).showToast('Subscription created.');<br>    }<br>  } catch (err: any) {<br>    this.errorHandler.handleBridgeApiError(err);<br>    this.modalDelegate.setError('Network or server error.');<br>  }<br>}<br>```<br><br> | SubscriptionManager.handleSubmitSubscription:<br>- **Mechanics**:<br>  1. Call `this.modalDelegate.validateForm()` to validate user input (fields: subscriberPrincipal, amountSats, intervalBlocks).<br>     - If invalid, call `this.modalDelegate.setError(errorMessage)` to display the error and exit.<br>  2. Extract values using `this.modalDelegate.getFormValues()`; assign to local variables.<br>  3. Retrieve `storeId` (from UI state, route param, or session context as appropriate).<br>  4. Send a `POST` request to `/api/v1/stores/${storeId}/subscriptions` with:<br>     - Headers: `{ 'Content-Type': 'application/json' }`<br>     - Body: `JSON.stringify({ subscriberPrincipal, amountSats, intervalBlocks })`<br>  5. Await response:<br>     - If response not ok, parse error JSON, call:<br>       - `this.errorHandler.handleBridgeApiError(err)`<br>       - `this.modalDelegate.setError(err.error or 'Error creating subscription.')`<br>       - Return.<br>  6. After a successful response:<br>     - Call `await this.pollAndUpdateSubscriptionsTable()` to refresh the UI with the new subscription.<br>     - Call `this.closeCreateSubscriptionModal()` to close the modal.<br>     - If `(window as any).showToast` exists, invoke to show "Subscription created." notification.<br>  7. Catch any thrown errors (network/server), handle with:<br>     - `this.errorHandler.handleBridgeApiError(err)`<br>     - `this.modalDelegate.setError('Network or server error.')`<br>- **WHY**: Ensures server-side validation of subscription creation, error surfacing, and real-time UI update for a robust, user-friendly experience.<br>- **Data/Side-effects**: Only sends minimal, non-sensitive subscription data server-side; no secret handling or direct wallet integration in this flow.<br>- **Edge cases**: All backend and Bridge errors are caught and surfaced to the modal.<br><br>--- |
| SubscriptionManager | handleGenerateInvoiceNow(): Promise<void> | <br><br>`handleGenerateInvoiceNow(): Promise<void>` after backend fetch, delegates invoice success sheet rendering:<br><br>```typescript<br>this.invoiceSheetDelegate.renderSuccessSheet(dto, this.handleCopyInvoiceLink.bind(this), this.handleSendEmail.bind(this));<br>```<br><br> | SubscriptionManager.handleGenerateInvoiceNow:<br>- **Mechanics**:<br>  1. On user click, initiate backend fetch to generate a new invoice for the subscription.<br>     - Call Bridge API `/api/v1/stores/:storeId/subscriptions/:id/invoice` (using fetch or helper):<br>       - Pass relevant subscription ID and storeId.<br>       - Await response with `{ invoice, magicLink, unsignedCall }`.<br>  2. On successful fetch:<br>     - Pass the resulting DTO (`invoice, magicLink, unsignedCall`) to `this.invoiceSheetDelegate.renderSuccessSheet` along with:<br>       - `this.handleCopyInvoiceLink.bind(this)` for copy-to-clipboard actions.<br>       - `this.handleSendEmail.bind(this)` for email actions.<br>     - The delegate is responsible for displaying invoice details (amount, expiry, magicLink, QR) and binding UI events for copy/email/QR.<br>  3. On error from Bridge/backend:<br>     - Surface the error via modal/banner/toast as needed.<br>- **WHY**: Clean separation between backend data-fetching and UI rendering, facilitating safe and correct invoice handling.<br>- **Edge cases**: If Bridge returns invoice errors (invalid state, canceled, expired), ensure they are not rendered in the success sheet.<br><br>--- |
| SubscriptionManager | handleSendEmail(): Promise<void> | Triggered by the "Send email" button on a subscription invoice (onclick event binding). This async method: 1) Collects context (e.g., recipient email, invoice/magicLink details) from UI or passed parameters. 2) Sends a POST request to the Express backend, which then calls the Postmark API (via Node.js HTTP/fetch) with the rendered email body (using the magic-link and branding data, as per Static Report template). 3) Awaits backend response: on success, surfaces a success banner/toast; on failure, displays a user-friendly error. 4) All email logic, error handling, and Postmark API integration is backend-only; the client never handles email payloads, only send status. 5) Data handling: ensures only minimal identifying data is sent in the POST; no sensitive data is exposed to the frontend. 6) Any branding fields missing/null are gracefully handled in the rendered template (backend concern, not this method). | SubscriptionManager.handleSendEmail:<br>- **Mechanics**:<br>  1. On click event, gather required context:<br>     - Recipient email (from UI or parameters).<br>     - Invoice/magicLink and branding (from current UI state or passed object).<br>  2. Send a `POST` request to the Express backend endpoint for sending subscription invoice emails.<br>     - Include minimal identifying data only:<br>       - e.g. `{ recipientEmail, magicLink, branding }`<br>     - Never expose secrets or sensitive data in POST body.<br>  3. Backend logic (per requirements, but not in this method):<br>     - Express backend calls the Postmark API with JSON body containing rendered email HTML/text, using `magicLink` and `branding`.<br>     - The backend ensures missing branding fields are handled gracefully (omitted or defaulted).<br>  4. Await backend response:<br>     - On success, show a success banner or toast.<br>     - On failure, display a user-friendly error in the UI (never expose raw error details).<br>  5. No client-side email logic; the client only reflects send status.<br>- **WHY**: Ensures all email logic, template rendering, and error handling is backend-only, never exposing sensitive logic or credentials to the frontend.<br>- **Edge cases**: If branding fields are missing/null, ensure backend template fails gracefully.<br><br>--- |
| SubscriptionManager | handleCancelSubscription(): Promise<void> | Invoked when the merchant clicks "Cancel subscription" in the subscription table (onclick event binding). This async method: 1) Gathers context (e.g., subscriptionId, storeId) from UI state/DOM. 2) Sends a POST request to the Express backend, which calls Bridge `/api/v1/stores/:storeId/subscriptions/:id/cancel`. 3) If backend/Bridge returns `{ canceled: true }`, updates the UI row for the subscription to "Cancelled" and disables further billing actions; if Bridge returns an unsigned on-chain UnsignedCall (for on-chain cancellation), the backend relays this to the client, which then opens Connect wallet for merchant signing and tracks completion. 4) After completion or confirmation via polling, updates the subscriptions table UI ("Cancelled" state, disables actions). 5) Handles backend/Bridge errors with UI banners/toasts. 6) No client-state persistence; all UI state is session-local and controlled by polling or fetch results. Data handling ensures request/response matches backend and Connect expectations, and only exposes proper fields to the UI. | SubscriptionManager.handleCancelSubscription:<br>- **Mechanics**:<br>  1. Gather `subscriptionId` and `storeId` from UI state/DOM.<br>  2. Send a `POST` request to Express backend: `/api/v1/stores/:storeId/subscriptions/:id/cancel`.<br>  3. Await backend/Bridge response:<br>     - If `{ canceled: true }`:<br>       - Mark subscription row in UI as "Cancelled".<br>       - Disable further billing/cancel actions.<br>     - If response contains an unsigned on-chain UnsignedCall (for on-chain cancellation):<br>       - Relay UnsignedCall to UI.<br>       - UI opens Connect wallet for merchant to sign and broadcast the cancellation transaction.<br>       - After wallet signing, monitor transaction status (via polling or callback).<br>       - On confirmation, update UI row to "Cancelled", disable actions.<br>  4. Handle backend and Bridge errors:<br>     - Surface error to UI via banner/toast.<br>     - UI state is only session-local, refreshed by polling/fetch.<br>  5. Data handling:<br>     - Only proper fields are exposed; request/response match backend and Connect expectations.<br>     - No persistence beyond UI session.<br>- **WHY**: Guarantees correct state propagation, prevents double billing, and follows security mandates (no direct key/secret handling).<br>- **Edge cases**: On incomplete or error responses from Bridge, ensure UI disables actions or prompts retry.<br><br>--- |
| SubscriptionManager | openInvoiceDrawer(invoiceId: string): void | <br><br>`openInvoiceDrawer(invoiceId: string): void` delegates invoice drawer rendering:<br><br>```typescript<br>this.invoiceDrawerUiDelegate.openDrawer(invoiceId);<br>```<br><br> |  |
| SubscriptionManager | handleCopyInvoiceLink(magicLink: string): void | Called when the "Copy Link" button is clicked for an invoice in the subscription details drawer (onclick binding). This method: 1) Receives the `magicLink` (string) to be copied. 2) Calls the browser Clipboard API (`navigator.clipboard.writeText(magicLink)`) to copy the link to the user’s clipboard. 3) On success, shows a confirmation toast or notification; on failure, displays a user-friendly error toast/badge. 4) No backend calls or state mutations are performed. 5) Data handling is limited to ensuring the correct magicLink string is passed and not exposing any sensitive information. 6) All error/success states are handled in the UI; no persistence. |  |
| SubscriptionManager | handleSubscriptionInvoiceGet(req: Express.Request, res: Express.Response, next: Express.NextFunction): Promise<void> | Express route handler for `GET /api/v1/stores/:storeId/subscriptions/:id/invoice`. This async handler: 1) Extracts `storeId` and `id` (subscriptionId) from the route parameters (validated for presence/format). 2) Calls the Bridge API to fetch the latest magic-link and unsignedCall for the requested subscription (GET/POST as per Bridge contract). 3) On success, returns a JSON response `{ invoice, magicLink, unsignedCall }` matching the MagicLinkDTO shape or, if rendering a view, injects these into the template context for downstream UI rendering (link, QR, wallet Connect). 4) On error from Bridge, uses the system ErrorHandler to propagate a proper HTTP error (400/409/500) with message. 5) Ensures that only allowed fields are exposed in the response (no secrets or unneeded internals). 6) Handles all required data transformations to map the Bridge API response into the expected frontend DTO shape, including field name normalization and filtering of extraneous data. | SubscriptionManager.handleSubscriptionInvoiceGet:<br>- **Mechanics**:<br>  1. Extract `storeId` and `id` (subscriptionId) from Express request route parameters.<br>     - Validate presence and format (string, not undefined/empty).<br>  2. Call the Bridge API to fetch latest invoice, magic-link, and unsignedCall for the subscription.<br>     - Likely: `GET /api/v1/stores/:storeId/subscriptions/:id/invoice` or as per Bridge contract.<br>  3. On Bridge response:<br>     - If successful, return JSON: `{ invoice, magicLink, unsignedCall }` matching MagicLinkDTO shape.<br>     - If rendering a view, inject these fields into the template context for downstream rendering (link, QR, wallet Connect).<br>  4. On Bridge error:<br>     - Pass error to system ErrorHandler to propagate an HTTP error (400/409/500) with descriptive message.<br>  5. Ensure response only includes allowed fields (no secrets, no internal fields).<br>  6. Perform any required transformation to map Bridge response to frontend DTO (normalize field names, filter extraneous data).<br>- **WHY**: Ensures safe, consistent, and secure API response for the frontend to render subscription invoice actions.<br>- **Edge cases**: Invalid/missing params → 400; Bridge errors → propagate; never expose sensitive data.<br><br>--- |
| SubscriptionManager | pollAndUpdateLinkedInvoices(): Promise<void> | <br><br>`pollAndUpdateLinkedInvoices(): Promise<void>` delegates all polling and UI update logic:<br><br>```typescript<br>async pollAndUpdateLinkedInvoices(): Promise<void> {<br>  await this.tablePollingDelegate.pollAndUpdateLinkedInvoices();<br>}<br>```<br><br> |  |
| SubscriptionManager | pollAndUpdateSubscriptionsTable(): Promise<void> | <br><br>`pollAndUpdateSubscriptionsTable(): Promise<void>` delegates all polling and UI update logic:<br><br>```typescript<br>async pollAndUpdateSubscriptionsTable(): Promise<void> {<br>  await this.tablePollingDelegate.pollAndUpdateSubscriptionsTable();<br>}<br>```<br><br>End of report.<br>```` |  |

# File Definitions:
| File Name | Components That Must Be Implemented Within The File | Static Definitions That Must Be Implemented Within The File |
| --------- | --------------------------------------------------- | ----------------------------------------------------------- |
| /src/contracts/interfaces.ts |  | IBridgeApiClient, IMagicLinkValidator, IMagicLinkPageRenderer, IBrandingProfileManager, IWalletIntegration, IMagicLinkClientScript, IErrorHandler, ISessionManager |
| /src/models/core.ts |  | Store, Invoice, InvoiceStoreBranding, UnsignedCall, FtPostCondition, MagicLinkU, MagicLinkDTO, Subscription, SubscriptionLinkedInvoice, RefundRequest, PublicProfile, StoreSecrets, WebhookLog, PollerStatus |
| /src/validation/validationRules.ts |  | Validation rules for checkout, magic-link, key rotation, refund, subscription create, branding/profile PATCH, email rendering (as listed) |
| /src/config/config.ts |  | .env template, env var access, configuration schema |
| /src/serialization/serializationFormats.ts |  | Serialization formats (JSON, base64url, MagicLink U blob, Invoice DTO, PublicProfile) |
| /src/error/ErrorHandler.ts | ErrorHandler |  |
| /src/session/SessionManager.ts | SessionManager |  |
| /src/static/StaticAssetHandler.ts | StaticAssetHandler |  |
| /src/qr/QRRenderer.ts | QRRenderer |  |
| /src/poller/InvoiceStatusPoller.ts | InvoiceStatusPoller |  |
| /src/views/TerminalInvoiceStatusUiManager.ts | TerminalInvoiceStatusUiManager |  |
| /src/profile/PublicProfileFetcher.ts | PublicProfileFetcher |  |
| /src/api/BridgeApiClient.ts | BridgeApiClient |  |
| /src/api/BridgeApiSecurityEnforcer.ts | BridgeApiSecurityEnforcer |  |
| /src/api/BridgeApiHttpRequestHelper.ts | BridgeApiHttpRequestHelper |  |
| /src/api/EmailBrandingFallbackHandler.ts | EmailBrandingFallbackHandler |  |
| /src/handlers/CheckoutHandler.ts | CheckoutHandler |  |
| /src/services/BrandingProfileManager.ts | BrandingProfileManager |  |
| /src/views/MagicLinkPageRenderer.ts | MagicLinkPageRenderer |  |
| /src/views/MagicLinkPageBrandingBlock.ts | MagicLinkPageBrandingBlock |  |
| /src/handlers/PosRouteHandler.ts | PosRouteHandler |  |
| /src/views/PosPageQrSection.ts | PosPageQrSection |  |
| /src/handlers/MerchantConsoleHandler.ts | MerchantConsoleHandler |  |
| /src/views/InvoiceUiFeedbackRenderer.ts | InvoiceUiFeedbackRenderer |  |
| /src/views/QrModalRenderer.ts | QrModalRenderer |  |
| /src/views/RefundDrawerManager.ts | RefundDrawerManager |  |
| /src/views/InvoiceListUiRefresher.ts | InvoiceListUiRefresher |  |
| /src/handlers/AdminConsoleHandler.ts | AdminConsoleHandler |  |
| /src/views/StoreProfileFormDelegate.ts | StoreProfileFormDelegate |  |
| /src/views/StoreListUiDelegate.ts | StoreListUiDelegate |  |
| /src/views/WebhookLogUiRenderer.ts | WebhookLogUiRenderer |  |
| /src/views/PollerStatusUiDelegate.ts | PollerStatusUiDelegate |  |
| /src/email/EmailDeliveryHandler.ts | EmailDeliveryHandler |  |
| /src/validation/MagicLinkValidator.ts | MagicLinkValidator |  |
| /src/email/EmailTemplateRenderer.ts | EmailTemplateRenderer |  |
| /src/email/PostmarkApiClient.ts | PostmarkApiClient |  |
| /src/email/EmailRecipientValidator.ts | EmailRecipientValidator |  |
| /src/subscriptions/SubscriptionManager.ts | SubscriptionManager |  |
| /src/views/SubscriptionModalFormStateDelegate.ts | SubscriptionModalFormStateDelegate |  |
| /src/views/InvoiceSuccessSheetUiDelegate.ts | InvoiceSuccessSheetUiDelegate |  |
| /src/views/SubscriptionTablePollingDelegate.ts | SubscriptionTablePollingDelegate |  |
| /src/views/InvoiceDrawerUiDelegate.ts | InvoiceDrawerUiDelegate |  |
| /src/server/ExpressServer.ts | ExpressServer |  |
| /src/middleware/CorsPolicyEnforcer.ts | CorsPolicyEnforcer |  |
| /src/wallet/WalletIntegration.ts | WalletIntegration |  |
| /src/client/MagicLinkClientScript.ts | MagicLinkClientScript |  |
| /src/bootstrap/ApplicationBootstrapper.ts | ApplicationBootstrapper |  |

# Static Report:
##### **Core Data Structures & Domain Models\n// --- Core Domain Models & DTOs (TypeScript-style) ---\n\n// Store (Admin and Merchant contexts)\ntype Store = {\n  storeId: string;\n  principal: string;\n  name: string;\n  displayName: string | null;\n  logoUrl: string | null;\n  brandColor: string | null;\n  allowedOrigins: string[];\n  webhookUrl: string | null;\n  active: boolean;\n  sBTCContractAddress?: string | null;\n  sBTCContractName?: string | null;\n};\n\n// Invoice DTO (Bridge API public interface)\ntype Invoice = {\n  invoiceId: string;\n  idHex: string;\n  storeId: string;\n  amountSats: number;\n  usdAtCreate: string;\n  quoteExpiresAt: string;\n  merchantPrincipal: string;\n  memo: string;\n  status: 'unpaid' | 'pending' | 'paid' | 'expired' | 'canceled' | 'PAY_READY';\n  payer?: string; // optional until known\n  txId?: string;  // optional until broadcast/known\n  subscriptionId?: string;\n  createdAt: string;\n  refundAmount?: number;\n  refundTxId?: string;\n  store: InvoiceStoreBranding;\n};\n\n// Branding portion embedded in invoice responses (subset of Store)\ntype InvoiceStoreBranding = {\n  displayName: string | null;\n  logoUrl: string | null;\n  brandColor: string | null;\n};\n\n// UnsignedCall object (for wallet connect)\ntype UnsignedCall = {\n  contractId: string;\n  function: string;\n  args: string[];\n  postConditions: FtPostCondition[];\n  postConditionMode: 'deny';\n  network: 'mainnet' | 'testnet';\n};\n\n// FT Postcondition object (inside UnsignedCall)\ntype FtPostCondition = {\n  type: 'ft-postcondition';\n  address: string;\n  asset: string;\n  condition: 'eq';\n  amount: string;\n};\n\n// Magic-link U blob (base64url-encoded JSON, validated)\ntype MagicLinkU = {\n  v: 1;\n  storeId: string;\n  invoiceId?: string;\n  subscriptionId?: string;\n  unsignedCall: UnsignedCall;\n  exp: number;\n  sig: string;\n};\n\n// MagicLinkDTO (surface by Bridge API and used by all flows)\ntype MagicLinkDTO = {\n  invoice: Invoice;\n  magicLink: string;\n  unsignedCall: UnsignedCall;\n};\n\n// Subscription DTO\ntype Subscription = {\n  subscriptionId: string;\n  storeId: string;\n  subscriberPrincipal: string;\n  amountSats: number;\n  intervalBlocks: number;\n  status: 'active' | 'cancelled';\n  nextDue: string;\n  lastBilled?: string;\n  mode: 'invoice';\n  createdAt: string;\n  linkedInvoices: SubscriptionLinkedInvoice[];\n};\n\n// Linked invoice for a subscription\ntype SubscriptionLinkedInvoice = {\n  invoiceId: string;\n  status: 'unpaid' | 'pending' | 'paid' | 'expired' | 'canceled';\n  createdAt: string;\n  quoteExpiresAt: string;\n  amountSats: number;\n};\n\n// Refund DTO (for refund actions)\ntype RefundRequest = {\n  invoiceId: string;\n  amount_sats: number;\n  memo: string;\n};\n\n// Branding/Public Profile DTO (fetched for theming, emails, etc)\ntype PublicProfile = {\n  displayName: string | null;\n  logoUrl: string | null;\n  brandColor: string | null;\n  supportEmail: string | null;\n  supportUrl: string | null;\n};\n\n// Key material for store (stored only server-side, one-time reveal)\ntype StoreSecrets = {\n  apiKey: string;\n  hmacSecret: string;\n};\n\n// WebhookLog DTO\ntype WebhookLog = {\n  webhookLogId: string;\n  storeId: string;\n  status: 'delivered' | 'failed' | 'pending';\n  payload: object;\n  headers: object;\n  deliveredAt: string | null;\n  failedAt: string | null;\n  attemptCount: number;\n};\n\n// Poller status DTO\ntype PollerStatus = {\n  running: boolean;\n  lastRunAt: string;\n  lastHeight: number;\n  lastTxId: string;\n  lagBlocks: number;\n};\n\n\n##### **State Store Interface\n// No global shared mutable state.\n// State is either:\n// - Request-scope (Express handler)\n// - Server-controlled session (merchant/admin login, via express-session)\n// - Ephemeral (browser-local, not persisted)\n// - External (Bridge API, .env)\n\nNone\n\n\n##### **Persistence & Data Access Interfaces\n// No direct persistence layer within this system.\n// All persistent storage is handled externally by Bridge API and configuration (.env).\n\nNone\n\n\n##### **Service & Component Communication Interfaces\n// --- Bridge API Contracts (REST, JSON payloads) ---\n// (All endpoints use JSON; see CoreDataStructures for models. Only explicitly listed endpoints are defined.)\n\ninterface IBridgeApiClient {\n  prepareInvoice(\n    storeId: string,\n    payload: {\n      amount_sats: number;\n      ttl_seconds: number;\n      memo: string;\n      orderId?: string;\n      payerPrincipal?: string;\n    }\n  ): Promise<MagicLinkDTO>;\n\n  createStore(\n    payload: {\n      principal: string;\n      name: string;\n      display_name?: string;\n      logo_url?: string;\n      brand_color?: string;\n      allowed_origins?: string[];\n      webhook_url?: string;\n    }\n  ): Promise<Store>;\n\n  getStoreList(): Promise<Store[]>;\n\n  setStoreActiveState(storeId: string, newState: boolean): Promise<{ active: boolean }>;\n\n  getStoreProfile(storeId: string): Promise<Store>;\n\n  updateStoreProfile(\n    storeId: string,\n    payload: {\n      displayName?: string;\n      logoUrl?: string;\n      brandColor?: string;\n      allowedOrigins?: string[];\n      webhookUrl?: string;\n    }\n  ): Promise<Store>;\n\n  getPublicProfile(storeId: string): Promise<PublicProfile>;\n\n  rotateKeys(storeId: string): Promise<StoreSecrets>;\n\n  setSbtcToken(payload: { contractAddress: string; contractName: string }): Promise<object>;\n\n  getWebhooksLog(query: { status: 'all' | 'failed'; storeId?: string }): Promise<WebhookLog[]>;\n\n  retryWebhook(webhookLogId: string): Promise<object>;\n\n  getPollerStatus(): Promise<PollerStatus>;\n\n  restartPoller(): Promise<{ running: boolean }>;\n\n  bootstrapProtocol(): Promise<object>;\n\n  syncOnchain(storeId: string): Promise<{ calls: UnsignedCall[] }>;\n}\n\n// Magic-link Validation Middleware\ninterface IMagicLinkValidator {\n  validateU(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void;\n}\n\n// MagicLink Page Renderer\ninterface IMagicLinkPageRenderer {\n  renderCheckoutPage(req: import('express').Request, res: import('express').Response, validatedUData: MagicLinkU): void;\n}\n\n// Branding/Public Profile\ninterface IBrandingProfileManager {\n  fetchBranding(storeId: string): Promise<PublicProfile>;\n  handleInputChange(event: Event): void;\n  applyBrandingToUI(brandingData: PublicProfile): void;\n  handlePublicProfileRequest(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): Promise<void>;\n  fetchAndUpdateBrandingProfile(storeId: string): Promise<void>;\n}\n\n// Wallet Integration (Client-side Connect)\ninterface IWalletIntegration {\n  openWallet(unsignedCall: UnsignedCall): Promise<void>;\n  handleWalletResult(result: { txid?: string; txId?: string; [key: string]: any }): void;\n  handleSbtcTokenConfigResult(result: object): void;\n  handleBootstrapProtocolResult(result: object): void;\n  handleSyncCallResult(result: object, callIndex: number, totalCalls: number): void;\n  handleRefundSignResult(result: object): void;\n  handleOnSignResult(result: object): void;\n  handleOnSignError(error: any): void;\n}\n\n// MagicLink Client Script (browser)\ninterface IMagicLinkClientScript {\n  validateU(uBlob: string): boolean;\n  handlePostWalletRedirect(txid: string): void;\n}\n\n// Error Handling\ninterface IErrorHandler {\n  handleValidationError(res: import('express').Response, errorDetails: any): void;\n  handleBridgeError(res: import('express').Response, bridgeError: any): void;\n  handleDuplicateStore(res: import('express').Response, context: { existingStore: Store }): void;\n  handleError(err: any, req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void;\n  handleBridgeApiError(error: any): void;\n}\n\n// Session Management\ninterface ISessionManager {\n  validateSession(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void;\n  authMiddleware: any; // Express middleware\n}\n\n// The rest of the communication is via browser-side event binding (DOM events) and direct HTTP fetch/XHR as described in the plan.\n\n\n##### **Configuration Management & Dependency Injection Contracts\n// All configuration is loaded via process.env (.env) and not mutated at runtime.\n\n.env template:\nSENDER_DOMAIN=webpay.com\nPOSTMARK_API_KEY=<string>\nWEBPAY_BASE_URL=https://example.webpay.com\nBRIDGE_API_BASE_URL=https://bridge.webpay.com\n# Per-store (created after rotate-keys, one-time reveal only):\n# STORE_<STOREID>_API_KEY=<string>\n# STORE_<STOREID>_HMAC_SECRET=<string>\n\nSample Dependency Injection Setup (Node.js/TypeScript):\n```typescript\nconst bridgeApiClient = new BridgeApiClient({\n  baseUrl: process.env.BRIDGE_API_BASE_URL,\n  errorHandler\n});\n// Inject dependencies as per component lifecycle ordering.\n```\n\n\n##### **Mandatory Dependency Injection Contracts\n// Interfaces to prevent circular dependencies and explicit DI contracts.\n\ninterface IBridgeApiClient { /* see CommunicationInterfaces above */ }\n// Imported by: MagicLinkValidator, BrandingProfileManager, ExpressServer, CheckoutHandler, MerchantConsoleHandler, AdminConsoleHandler, SubscriptionManager, EmailDeliveryHandler\n\ninterface IErrorHandler { /* see CommunicationInterfaces above */ }\n// Imported by: BridgeApiClient, CheckoutHandler, MerchantConsoleHandler, AdminConsoleHandler, WalletIntegration\n\ninterface IMagicLinkValidator { /* see CommunicationInterfaces above */ }\n// Imported by: MagicLinkPageRenderer\n\ninterface IMagicLinkPageRenderer { /* see CommunicationInterfaces above */ }\n// Imported by: MagicLinkValidator\n\ninterface IBrandingProfileManager { /* see CommunicationInterfaces above */ }\n// Imported by: MagicLinkPageRenderer, AdminConsoleHandler\n\ninterface IWalletIntegration { /* see CommunicationInterfaces above */ }\n// Imported by: MagicLinkClientScript, MerchantConsoleHandler, InvoiceStatusPoller\n\ninterface IMagicLinkClientScript { /* see CommunicationInterfaces above */ }\n// Imported by: WalletIntegration\n\ninterface ISessionManager { /* see CommunicationInterfaces above */ }\n// Imported by: ExpressServer, PosRouteHandler, MerchantConsoleHandler, AdminConsoleHandler, SubscriptionManager\n\n\n##### **Validation & Constraint Definitions\n// Validation for all externally-sourced data (user input, API params, query string, etc).\n\n// 1. Checkout POST /checkout/:storeId\n{\n  amount_sats: { type: 'number', minimum: 1, required: true },\n  ttl_seconds: { type: 'number', minimum: 120, maximum: 1800, required: true },\n  memo: { type: 'string', required: true },\n  orderId: { type: 'string', required: false },\n  payerPrincipal: { type: 'string', required: false, pattern: '^SP[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{38,}$' }\n}\n\n// 2. Magic-link U blob validation (server and client)\n{\n  u: { required: true, type: 'base64url-encoded JSON' },\n  u.v: { type: 'number', value: 1, required: true },\n  u.storeId: { type: 'string', required: true, mustMatch: 'req.params.storeId' },\n  u.invoiceId: { type: 'string', requiredIf: 'invoice flow', mustMatch: 'req.params.invoiceId' },\n  u.subscriptionId: { type: 'string', requiredIf: 'subscription flow', mustMatch: 'req.params.subscriptionId' },\n  u.unsignedCall: {\n    type: 'object',\n    required: true,\n    function: { type: 'string', required: true, enum: ['pay-invoice', 'pay-subscription'] },\n    postConditionMode: { type: 'string', required: true, value: 'deny' },\n    postConditions: {\n      type: 'array',\n      minItems: 1,\n      contains: {\n        type: 'object',\n        typeField: 'ft-postcondition',\n        asset: { type: 'string', required: true, mustMatch: '<SBTC_CONTRACT>::sbtc' },\n        condition: { type: 'string', value: 'eq' },\n        amount: { type: 'string', required: true }\n      }\n    },\n    network: { type: 'string', required: true, enum: ['mainnet', 'testnet'], mustMatch: 'deployment' }\n  },\n  u.exp: { type: 'number', required: true, minimum: Math.floor(Date.now()/1000), maximum: Math.floor(Date.now()/1000)+300 },\n  u.sig: { type: 'string', required: true }, // HMAC-SHA256 over canonical payload\n  signature: { mustValidate: true }\n}\n\n// 3. Store Key Rotation\n{\n  apiKey: { type: 'string', required: true },\n  hmacSecret: { type: 'string', required: true },\n  oneTimeReveal: { enforced: true }\n}\n\n// 4. Refund POST\n{\n  invoiceId: { type: 'string', required: true },\n  amount_sats: { type: 'number', minimum: 1, required: true },\n  memo: { type: 'string', required: true }\n}\n\n// 5. Subscription creation POST\n{\n  subscriberPrincipal: { type: 'string', required: true, pattern: '^SP[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{38,}$' },\n  amountSats: { type: 'number', minimum: 1, required: true },\n  intervalBlocks: { type: 'number', minimum: 1, required: true }\n}\n\n// 6. Branding/public-profile PATCH\n{\n  displayName: { type: 'string', required: false },\n  logoUrl: { type: 'string', format: 'uri', required: false },\n  brandColor: { type: 'string', pattern: '^#[0-9A-Fa-f]{6}$', required: false },\n  allowedOrigins: { type: 'array', items: { type: 'string', format: 'uri' }, required: false },\n  webhookUrl: { type: 'string', format: 'uri', required: false }\n}\n\n// 7. Email rendering\n// All branding fields may be null/missing; template must degrade gracefully, with defaults/omission as needed.\n\n\n##### **Lifecycle Contracts\n// - Store/Invoice/Subscription state is canonical in Bridge API (external system), never persisted in Webpay server.\n// - Session state (merchant/admin login) is memory/session-store (express-session), cleared on logout/expiry.\n// - Magic-link U blobs are ephemeral, validated per-request, never stored server-side.\n// - Branding info is always fetched live per-render, never cached/stored.\n// - Key material (apiKey, hmacSecret) is stored in process.env or secure session only; StoreSecrets are one-time reveal, never re-readable.\n\nNone\n\n\n##### **Event & Messaging Interfaces\n// No internal event bus or publish-subscribe mechanism.\n// All events are either: HTTP requests (Express), DOM events (browser), or external API/webhook payloads.\n// No custom or framework-internal message bus.\n\nNone\n\n\n##### **SerializationFormats\n// All external communication is via HTTP/HTTPS with strict JSON payloads (no other formats).\n// Serialization applies only to:\n// - Express ↔ Bridge API (JSON)\n// - Express ↔ Browser (JSON, HTML for SSR)\n// - Magic-link U blob (base64url-encoded JSON in query param)\n\nExample: Magic-link U blob (decoded)\n{\n  "v": 1,\n  "storeId": "store_abc",\n  "invoiceId": "inv_8x3...",\n  "unsignedCall": {\n    "contractId": "SP...webpay",\n    "function": "pay-invoice",\n    "args": ["0x...invoiceId", "u25000"],\n    "postConditions": [\n      {\n        "type": "ft-postcondition",\n        "address": "<TX_SENDER or payerPrincipal>",\n        "asset": "SP...sbtc-token::sbtc",\n        "condition": "eq",\n        "amount": "25000"\n      }\n    ],\n    "postConditionMode": "deny",\n    "network": "mainnet"\n  },\n  "exp": 1737324800,\n  "sig": "<base64url HMAC-SHA256 signature>"\n}\n\n// Example: Invoice DTO (GET /i/:invoiceId)\n{\n  "invoiceId": "inv_8x3...",\n  "idHex": "e3a1...9bc0",\n  "storeId": "store_abc",\n  "amountSats": 25000,\n  "usdAtCreate": "17.19",\n  "quoteExpiresAt": "2025-09-18T12:34:56Z",\n  "merchantPrincipal": "SP3...",\n  "status": "unpaid",\n  "payer": "SP2...",\n  "txId": "0xabc...",\n  "memo": "Order #123",\n  "subscriptionId": "sub_...",\n  "createdAt": "2025-09-18T12:00:01Z",\n  "refundAmount": 1000,\n  "refundTxId": "0xdef...",\n  "store": {\n    "displayName": "Acme",\n    "logoUrl": "https://...",\n    "brandColor": "#FF7A00"\n  }\n}\n\n// Example: PublicProfile (GET /api/v1/stores/:storeId/public-profile)\n{\n  "displayName": "Acme",\n  "logoUrl": "https://...",\n  "brandColor": "#FF7A00",\n  "supportEmail": "help@acme.com",\n  "supportUrl": "https://acme.com/support"\n}\n\n\n##### **Error Handling & Fault Tolerance\n// All error handling is via the ErrorHandler interface (see ::CommunicationInterfaces above).\n// - All errors from validation, Bridge API, or Postmark are propagated as HTTP responses (400/409/422/500) with { error: message } in JSON.\n// - No error logging/persistence within Webpay; errors are transient and surfaced only as response or UI state.\n// - UI surfaces errors as minimal, user-friendly states (no technical details exposed).\n// - Retry/rollback: for key rotation, atomicity is enforced by Bridge; no partial updates allowed. For all other operations, errors result in abort and clear user feedback; no retries unless user triggers again.\n\n\n##### **Concurrency & Synchronization Handling\nNone\n\n\n##### **Multi-User Environments & Authentication\ninterface SessionManager {\n  validateSession(req: import('express').Request, res: import('express').Response, next: import('express').NextFunction): void;\n  authMiddleware: any; // Express middleware\n}\n// Used only on protected routes (POS, merchant console, admin console).\n// - Only authenticated merchant/admin users may access management/console/POS endpoints.\n// - All payment, magic-link, and polling endpoints are public and require no session/auth.\n// - No RBAC/permission matrix beyond session-protected routes.\n\nEnd of report.\n```\n