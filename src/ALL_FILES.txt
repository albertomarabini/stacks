

---
# ./db/SqliteStore.ts

// src/db/SqliteStore.ts
import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';

import type { ISqliteStore } from '../contracts/dao';
import type {
  MerchantRow,
  InvoiceRow,
  SubscriptionRow,
  WebhookLogRow,
  InvoiceStatus,
  WebhookEventType,
  SubscriptionMode,
} from '../contracts/domain';
import { WebhookRetryQueryComposer } from '../delegates/WebhookRetryQueryComposer';
import { MerchantProjectionPolicy } from '../delegates/MerchantProjectionPolicy';
import { SqlInListBuilder } from '../delegates/SqlInListBuilder';
import type { IInvoiceIdCodec } from '../contracts/interfaces';

const nowSec = () => Math.floor(Date.now() / 1000);

export class SqliteStore implements ISqliteStore {
  private readonly db: Database.Database;
  private readonly webhookRetryComposer = new WebhookRetryQueryComposer({
    maxAttempts: 5,
    backoffSeconds: [0, 60, 120, 240, 480, 960],
  });
  private readonly merchantProjection = new MerchantProjectionPolicy();
  private readonly inListBuilder = new SqlInListBuilder();
  // Optional codec, kept for integrators; local guards are used otherwise.
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  private readonly codec?: IInvoiceIdCodec;

  constructor(db: Database.Database, codec?: IInvoiceIdCodec) {
    this.db = db;
    this.codec = codec;
  }

  migrate(): void {
    const migrationsPath = path.join(process.cwd(), 'db', 'migrations.sql');
    const sql = fs.readFileSync(migrationsPath, 'utf8');
    this.db.exec(sql);
  }

  // Merchants

  findActiveByApiKey(apiKey: string): MerchantRow | undefined {
    const stmt = this.db.prepare(
      `SELECT * FROM merchants WHERE api_key = ? AND active = 1 LIMIT 1`,
    );
    const row = stmt.get(apiKey) as MerchantRow | undefined;
    return row;
  }

  insertMerchant(row: MerchantRow): void {
    const stmt = this.db.prepare(`
      INSERT INTO merchants (
        id, principal, name, display_name, logo_url, brand_color,
        webhook_url, hmac_secret, api_key, active, support_email,
        support_url, allowed_origins, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      row.id,
      row.principal,
      row.name ?? null,
      row.display_name ?? null,
      row.logo_url ?? null,
      row.brand_color ?? null,
      row.webhook_url ?? null,
      row.hmac_secret,
      row.api_key,
      row.active,
      row.support_email ?? null,
      row.support_url ?? null,
      row.allowed_origins ?? null,
      row.created_at,
    );
  }

  updateMerchantActive(storeId: string, active: boolean): number {
    const stmt = this.db.prepare(`UPDATE merchants SET active = ? WHERE id = ?`);
    const info = stmt.run(active ? 1 : 0, storeId);
    return info.changes;
  }

  updateMerchantKeysTx(storeId: string, apiKey: string, hmacSecret: string): void {
    const tx = this.db.transaction((id: string, k: string, secret: string) => {
      this.db
        .prepare(`UPDATE merchants SET api_key = ?, hmac_secret = ? WHERE id = ?`)
        .run(k, secret, id);
    });
    tx(storeId, apiKey, hmacSecret);
  }

  listMerchantsProjection(): Omit<MerchantRow, 'api_key' | 'hmac_secret'>[] {
    const sql = this.merchantProjection.getListProjectionSQL();
    const dbRows = this.db.prepare(sql).all() as any[];
    return dbRows.map((r) => this.merchantProjection.mapListRow(r));
  }
  getMerchantById(storeId: string): MerchantRow | undefined {
    return this.db.prepare(`SELECT * FROM merchants WHERE id = ?`).get(storeId) as MerchantRow | undefined;
  }

  public updateMerchantProfile(
    storeId: string,
    patch: Partial<Pick<
      MerchantRow,
      | 'name'
      | 'display_name'
      | 'logo_url'
      | 'brand_color'
      | 'webhook_url'
      | 'support_email'
      | 'support_url'
      | 'allowed_origins'
    >>
  ): void {
    const allowed = [
      'name',
      'display_name',
      'logo_url',
      'brand_color',
      'webhook_url',
      'support_email',
      'support_url',
      'allowed_origins',
    ] as const;

    const keys = allowed.filter(k => (patch as any)[k] !== undefined);
    if (keys.length === 0) return; // nothing to update

    const setSql = keys.map(k => `${k} = ?`).join(', ');
    const values = keys.map(k => (patch as any)[k]);

    this.db.prepare(
      `UPDATE merchants SET ${setSql} WHERE id = ?`
    ).run(...values, storeId);
  }

  // 1) Rotate + bump version, clear revealed flag (atomic)
  rotateKeysPersist(storeId: string, apiKey: string, hmacSecret: string, now = nowSec()): number {
    const update = this.db.prepare(`
      UPDATE merchants
         SET api_key = ?,
             hmac_secret = ?,
             keys_rotation_version = keys_rotation_version + 1,
             keys_last_rotated_at = ?,
             keys_last_revealed_at = NULL,
             keys_dual_valid_until = NULL
       WHERE id = ?
    `);
    const fetchV = this.db.prepare(`SELECT keys_rotation_version AS v FROM merchants WHERE id = ?`);

    const tx = this.db.transaction((id: string) => {
      update.run(apiKey, hmacSecret, now, id);
      return fetchV.get(id) as { v: number } | undefined;
    });

    const row = tx(storeId);
    return row?.v ?? 0;
  }

  // 2) Exactly-once reveal for that version
  markKeysRevealedOnce(storeId: string, expectVersion: number, now = nowSec()): boolean {
    const stmt = this.db.prepare(`
      UPDATE merchants
         SET keys_last_revealed_at = ?
       WHERE id = ?
         AND keys_rotation_version = ?
         AND keys_last_revealed_at IS NULL
    `);
    const info = stmt.run(now, storeId, expectVersion);
    return info.changes === 1;
  }

  // Invoices

  public readonly invoices = {
    insert: (row: InvoiceRow): void => {
      SqliteStore.assertHex64(row.id_hex);
      if (!Number.isInteger(row.amount_sats) || row.amount_sats <= 0) {
        throw new TypeError('amount_sats must be positive int');
      }
      if (row.status !== 'unpaid') {
        throw new TypeError("status must be 'unpaid' on insert");
      }
      if (typeof row.merchant_principal !== 'string' || row.merchant_principal.length === 0) {
        throw new TypeError('merchant_principal required');
      }
      if (!Number.isInteger(row.quote_expires_at)) {
        throw new TypeError('quote_expires_at must be integer ms epoch');
      }
      if (!Number.isInteger(row.created_at)) {
        throw new TypeError('created_at must be integer epoch seconds');
      }

      const stmt = this.db.prepare(`
        INSERT INTO invoices (
          id_raw, id_hex, store_id, amount_sats, usd_at_create, quote_expires_at,
          merchant_principal, status, memo, webhook_url, created_at, subscription_id,
          refunded_at, refund_amount, refund_txid, refund_count, payer, txid, expired
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NULL, 0, NULL, 0, NULL, NULL, 0)
      `);
      stmt.run(
        row.id_raw,
        row.id_hex,
        row.store_id,
        row.amount_sats,
        row.usd_at_create,
        row.quote_expires_at,
        row.merchant_principal,
        'unpaid',
        row.memo ?? null,
        row.webhook_url ?? null,
        row.created_at,
        row.subscription_id ?? null,
      );
    },

    markCanceled: (storeId: string, idRaw: string): number => {
      const stmt = this.db.prepare(`
        UPDATE invoices
        SET status = 'canceled'
        WHERE store_id = ? AND id_raw = ? AND status = 'unpaid' AND IFNULL(expired, 0) = 0
      `);
      const info = stmt.run(storeId, idRaw);
      return info.changes ?? 0;
    },

    findByStoreAndIdRaw: (storeId: string, idRaw: string): InvoiceRow | undefined => {
      const stmt = this.db.prepare(
        `SELECT * FROM invoices WHERE store_id = ? AND id_raw = ? LIMIT 1`,
      );
      const row = stmt.get(storeId, idRaw) as InvoiceRow | undefined;
      return row;
    },
  };

  getInvoiceById(idRaw: string): InvoiceRow | undefined {
    const stmt = this.db.prepare(`SELECT * FROM invoices WHERE id_raw = ? LIMIT 1`);
    const row = stmt.get(idRaw) as InvoiceRow | undefined;
    return row;
  }

  getInvoiceWithStore(idRaw: string): (InvoiceRow & { store: MerchantRow }) | undefined {
    const inv = this.getInvoiceById(idRaw);
    if (!inv) return undefined;
    const m = this.db
      .prepare(`SELECT * FROM merchants WHERE id = ? LIMIT 1`)
      .get(inv.store_id) as MerchantRow | undefined;
    if (!m) return undefined;
    return Object.assign({}, inv, { store: m });
  }

  listInvoicesByStore(
    storeId: string,
    opts?: { status?: InvoiceStatus; orderByCreatedDesc?: boolean },
  ): InvoiceRow[] {
    if (opts?.status) {
      const stmt = this.db.prepare(
        `SELECT * FROM invoices WHERE store_id = ? AND status = ? ORDER BY created_at ${
          opts.orderByCreatedDesc ? 'DESC' : 'ASC'
        }`,
      );
      return stmt.all(storeId, opts.status) as InvoiceRow[];
    }
    const stmt = this.db.prepare(
      `SELECT * FROM invoices WHERE store_id = ? ORDER BY created_at ${
        opts?.orderByCreatedDesc ? 'DESC' : 'ASC'
      }`,
    );
    return stmt.all(storeId) as InvoiceRow[];
  }

  markInvoicePaid(idHex: string, payer: string, txId: string, _tx?: unknown): void {
    SqliteStore.assertHex64(idHex);
    this.db
      .prepare(
        `UPDATE invoices SET status = 'paid', payer = ?, txid = ? WHERE id_hex = ?`,
      )
      .run(payer, txId, idHex);
  }

  upsertInvoiceRefund(idHex: string, amountSats: number, refundTxId: string, _tx?: unknown): void {
    SqliteStore.assertHex64(idHex);
    if (!Number.isInteger(amountSats) || amountSats <= 0) {
      throw new TypeError('amountSats must be positive int');
    }
    const tx = this.db.transaction((hex: string, inc: number, rtx: string) => {
      const current = this.db
        .prepare(
          `SELECT amount_sats, refund_amount FROM invoices WHERE id_hex = ? LIMIT 1`,
        )
        .get(hex) as { amount_sats: number; refund_amount: number } | undefined;
      if (!current) return;
      const newTotal = (current.refund_amount ?? 0) + inc;
      const now = Math.floor(Date.now() / 1000);
      const newStatus: InvoiceStatus =
        newTotal >= current.amount_sats ? 'refunded' : 'partially_refunded';
      this.db
        .prepare(
          `UPDATE invoices
             SET refund_amount = ?, refund_txid = ?, refunded_at = ?, refund_count = refund_count + 1, status = ?
           WHERE id_hex = ?`,
        )
        .run(newTotal, rtx, now, newStatus, hex);
    });
    tx(idHex, amountSats, refundTxId);
  }

  markInvoiceCanceled(idHexOrIdRaw: string, _tx?: unknown): void {
    const info = this.db
      .prepare(`UPDATE invoices SET status = 'canceled' WHERE id_hex = ?`)
      .run(idHexOrIdRaw);
    if (info.changes === 0) {
      this.db
        .prepare(`UPDATE invoices SET status = 'canceled' WHERE id_raw = ?`)
        .run(idHexOrIdRaw);
    }
  }

  updateInvoiceStatus(idRaw: string, status: InvoiceStatus, expired?: 0 | 1): void {
    if (expired === undefined) {
      this.db
        .prepare(`UPDATE invoices SET status = ? WHERE id_raw = ?`)
        .run(status, idRaw);
      return;
    }
    this.db
      .prepare(`UPDATE invoices SET status = ?, expired = ? WHERE id_raw = ?`)
      .run(status, expired, idRaw);
  }

  ensureInvoiceIdHexUnique(idHex: string): boolean {
    SqliteStore.assertHex64(idHex);
    const row = this.db
      .prepare(`SELECT 1 AS one FROM invoices WHERE id_hex = ? LIMIT 1`)
      .get(idHex) as { one: number } | undefined;
    return !row;
  }

  invoiceExists(idHex: string): boolean {
    SqliteStore.assertHex64(idHex);
    const row = this.db
      .prepare(`SELECT 1 AS one FROM invoices WHERE id_hex = ? LIMIT 1`)
      .get(idHex) as { one: number } | undefined;
    return !!row;
  }

  bulkMarkExpired(idRawList: string[]): number {
    if (!idRawList.length) return 0;
    const { clause, params } = this.inListBuilder.buildInClause('id_raw', idRawList);
    const stmt = this.db.prepare(
      `UPDATE invoices SET status = 'expired', expired = 1 WHERE ${clause}`,
    );
    const info = stmt.run(...params);
    return info.changes;
  }

  // Subscriptions

  insertSubscription(row: SubscriptionRow): void {
    const stmt = this.db.prepare(`
      INSERT INTO subscriptions (
        id, id_hex, store_id, merchant_principal, subscriber,
        amount_sats, interval_blocks, active, created_at,
        last_billed_at, next_invoice_at, last_paid_invoice_id, mode
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      row.id,
      row.id_hex,
      row.store_id,
      row.merchant_principal,
      row.subscriber,
      row.amount_sats,
      row.interval_blocks,
      row.active,
      row.created_at,
      row.last_billed_at ?? null,
      row.next_invoice_at,
      row.last_paid_invoice_id ?? null,
      row.mode,
    );
  }

  getSubscriptionByIdForStore(id: string, storeId: string): SubscriptionRow | undefined {
    const stmt = this.db.prepare(
      `SELECT * FROM subscriptions WHERE id = ? AND store_id = ? LIMIT 1`,
    );
    const row = stmt.get(id, storeId) as SubscriptionRow | undefined;
    return row;
  }

  getActiveSubscription(id: string, storeId: string): SubscriptionRow | undefined {
    const stmt = this.db.prepare(
      `SELECT * FROM subscriptions WHERE id = ? AND store_id = ? AND active = 1 LIMIT 1`,
    );
    const row = stmt.get(id, storeId) as SubscriptionRow | undefined;
    return row;
  }

  updateSubscriptionMode(id: string, storeId: string, mode: SubscriptionMode): void {
    this.db
      .prepare(`UPDATE subscriptions SET mode = ? WHERE id = ? AND store_id = ?`)
      .run(mode, id, storeId);
  }

  deactivateSubscription(id: string, storeId: string, _tx?: unknown): void {
    this.db
      .prepare(`UPDATE subscriptions SET active = 0 WHERE id = ? AND store_id = ?`)
      .run(id, storeId);
  }

  setSubscriptionActive(input: { idHex: string; active: 0 | 1 }): void {
    SqliteStore.assertHex64(input.idHex);
    this.db
      .prepare(`UPDATE subscriptions SET active = ? WHERE id_hex = ?`)
      .run(input.active, input.idHex);
  }

  upsertSubscriptionByHex(input: {
    idHex: string;
    storeId: string;
    merchantPrincipal: string;
    subscriber: string;
    amountSats: number;
    intervalBlocks: number;
    active: 1;
  }): void {
    SqliteStore.assertHex64(input.idHex);
    const existing = this.db
      .prepare(
        `SELECT id, mode FROM subscriptions WHERE id_hex = ? AND store_id = ? LIMIT 1`,
      )
      .get(input.idHex, input.storeId) as { id: string; mode: SubscriptionMode } | undefined;

    if (existing) {
      this.db
        .prepare(
          `UPDATE subscriptions
             SET merchant_principal = ?,
                 subscriber = ?,
                 amount_sats = ?,
                 interval_blocks = ?,
                 active = ?
           WHERE id_hex = ? AND store_id = ?`,
        )
        .run(
          input.merchantPrincipal,
          input.subscriber,
          input.amountSats,
          input.intervalBlocks,
          1,
          input.idHex,
          input.storeId,
        );
      return;
    }

    const now = Math.floor(Date.now() / 1000);
    this.db
      .prepare(
        `INSERT INTO subscriptions (
           id, id_hex, store_id, merchant_principal, subscriber,
           amount_sats, interval_blocks, active, created_at, last_billed_at,
           next_invoice_at, last_paid_invoice_id, mode
         ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NULL, ?, NULL, ?)`,
      )
      .run(
        input.idHex,
        input.idHex,
        input.storeId,
        input.merchantPrincipal,
        input.subscriber,
        input.amountSats,
        input.intervalBlocks,
        1,
        now,
        0,
        'invoice',
      );
  }

  advanceSubscriptionSchedule(id: string): void {
    const now = Math.floor(Date.now() / 1000);
    this.db
      .prepare(
        `UPDATE subscriptions
           SET next_invoice_at = next_invoice_at + interval_blocks,
               last_billed_at = ?
         WHERE id = ?`,
      )
      .run(now, id);
  }

  updateSubscriptionLastPaid(input: { subscriptionId: string; lastPaidInvoiceId: string }): void {
    this.db
      .prepare(`UPDATE subscriptions SET last_paid_invoice_id = ? WHERE id_hex = ?`)
      .run(input.lastPaidInvoiceId, input.subscriptionId);
  }

  subscriptionExists(idHex: string): boolean {
    SqliteStore.assertHex64(idHex);
    const row = this.db
      .prepare(`SELECT 1 AS one FROM subscriptions WHERE id_hex = ? LIMIT 1`)
      .get(idHex) as { one: number } | undefined;
    return !!row;
  }

  selectDueSubscriptions(currentHeight: number): SubscriptionRow[] {
    const stmt = this.db.prepare(
      `SELECT * FROM subscriptions
         WHERE active = 1
           AND mode = 'invoice'
           AND next_invoice_at <= ?
       ORDER BY next_invoice_at ASC`,
    );
    return stmt.all(currentHeight) as SubscriptionRow[];
  }

  getStoreIdByPrincipal(merchantPrincipal: string): string | undefined {
    const row = this.db
      .prepare(`SELECT id FROM merchants WHERE principal = ? LIMIT 1`)
      .get(merchantPrincipal) as { id: string } | undefined;
    return row?.id;
  }

  // Webhooks

  insertWebhookAttempt(row: WebhookLogRow): string {
    const stmt = this.db.prepare(`
      INSERT INTO webhook_logs (
        id, store_id, invoice_id, subscription_id, event_type,
        payload, status_code, success, attempts, last_attempt_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      row.id,
      row.store_id,
      row.invoice_id ?? null,
      row.subscription_id ?? null,
      row.event_type,
      row.payload,
      row.status_code ?? null,
      row.success,
      row.attempts,
      row.last_attempt_at,
    );
    return row.id;
  }

  updateWebhookAttemptStatus(id: string, patch: { success: 0 | 1; statusCode?: number }): void {
    if (patch.statusCode === undefined) {
      this.db
        .prepare(`UPDATE webhook_logs SET success = ? WHERE id = ?`)
        .run(patch.success, id);
      return;
    }
    this.db
      .prepare(`UPDATE webhook_logs SET success = ?, status_code = ? WHERE id = ?`)
      .run(patch.success, patch.statusCode, id);
  }

  listWebhooksForStore(storeId: string): WebhookLogRow[] {
    const stmt = this.db.prepare(
      `SELECT * FROM webhook_logs WHERE store_id = ? ORDER BY last_attempt_at DESC`,
    );
    return stmt.all(storeId) as WebhookLogRow[];
  }

  listAdminWebhooks(storeId?: string, failedOnly?: boolean): WebhookLogRow[] {
    const parts: string[] = [`SELECT * FROM webhook_logs`];
    const wheres: string[] = [];
    const params: any[] = [];
    if (storeId) {
      wheres.push(`store_id = ?`);
      params.push(storeId);
    }
    if (failedOnly) {
      wheres.push(`success = 0`);
    }
    if (wheres.length) {
      parts.push(`WHERE ${wheres.join(' AND ')}`);
    }
    parts.push(`ORDER BY last_attempt_at DESC`);
    const sql = parts.join(' ');
    return this.db.prepare(sql).all(...params) as WebhookLogRow[];
  }

  getWebhookLogById(id: string): WebhookLogRow | undefined {
    const stmt = this.db.prepare(`SELECT * FROM webhook_logs WHERE id = ? LIMIT 1`);
    const row = stmt.get(id) as WebhookLogRow | undefined;
    return row;
  }

  existsSuccessfulDeliveryFor(ctx: {
    storeId: string;
    invoiceId?: string;
    subscriptionId?: string;
    eventType: WebhookEventType;
  }): boolean {
    const { sql, params } = this.webhookRetryComposer.composeExistsSuccessfulDeliverySQL({
      storeId: ctx.storeId,
      invoiceId: ctx.invoiceId,
      subscriptionId: ctx.subscriptionId,
      eventType: ctx.eventType as WebhookEventType,
    });
    const row = this.db.prepare(sql).get(...params) as { 1: number } | undefined;
    return !!row;
  }

  selectDueWebhookRetries(): WebhookLogRow[] {
    const { sql } = this.webhookRetryComposer.composeSelectDueRetriesSQL();
    const rows = this.db.prepare(sql).all() as WebhookLogRow[];
    return rows;
  }

  getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[] {
    const { sql, params } = this.webhookRetryComposer.composeGetDueAttemptsSQL(nowEpochSecs);
    const rows = this.db.prepare(sql).all(...params) as WebhookLogRow[];
    return rows;
  }

  hasSuccessfulExpiredWebhook(storeId: string, invoiceId: string): boolean {
    const { sql, params } = this.webhookRetryComposer.composeHasSuccessfulExpiredWebhookSQL(
      storeId,
      invoiceId,
    );
    const row = this.db.prepare(sql).get(...params) as { 1: number } | undefined;
    return !!row;
  }

  // Admin queries

  selectAdminInvoices(statuses?: InvoiceStatus[], storeId?: string): InvoiceRow[] {
    const parts: string[] = [`SELECT * FROM invoices`];
    const wheres: string[] = [];
    const params: any[] = [];
    if (storeId) {
      wheres.push(`store_id = ?`);
      params.push(storeId);
    }
    if (Array.isArray(statuses) && statuses.length > 0) {
      const placeholders = statuses.map(() => '?').join(',');
      wheres.push(`status IN (${placeholders})`);
      params.push(...statuses);
    }
    if (wheres.length) {
      parts.push(`WHERE ${wheres.join(' AND ')}`);
    }
    parts.push(`ORDER BY created_at DESC`);
    const sql = parts.join(' ');
    return this.db.prepare(sql).all(...params) as InvoiceRow[];
  }

  // Poller cursor

  getPollerCursor():
    | { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string }
    | null {
    const row = this.db
      .prepare(
        `SELECT last_run_at, last_height, last_txid, last_block_hash FROM poller_cursor WHERE id = 1`,
      )
      .get() as
      | { last_run_at: number; last_height: number; last_txid: string | null; last_block_hash: string | null }
      | undefined;
    if (!row) return null;
    return {
      lastRunAt: Number(row.last_run_at),
      lastHeight: Number(row.last_height),
      lastTxId: row.last_txid ?? undefined,
      lastBlockHash: row.last_block_hash ?? undefined,
    };
  }

  savePollerCursor(cursor: {
    lastRunAt: number;
    lastHeight: number;
    lastTxId?: string;
    lastBlockHash?: string;
  }): void {
    if (!Number.isInteger(cursor.lastRunAt) || cursor.lastRunAt <= 0) {
      throw new TypeError('lastRunAt must be positive integer');
    }
    if (!Number.isInteger(cursor.lastHeight) || cursor.lastHeight < 0) {
      throw new TypeError('lastHeight must be non-negative integer');
    }
    const stmt = this.db.prepare(`
      INSERT INTO poller_cursor (id, last_run_at, last_height, last_txid, last_block_hash)
      VALUES (1, ?, ?, ?, ?)
      ON CONFLICT(id) DO UPDATE SET
        last_run_at = excluded.last_run_at,
        last_height = excluded.last_height,
        last_txid = excluded.last_txid,
        last_block_hash = excluded.last_block_hash
    `);
    stmt.run(
      cursor.lastRunAt,
      cursor.lastHeight,
      cursor.lastTxId ?? null,
      cursor.lastBlockHash ?? null,
    );
  }

  // Utilities

  private static assertHex64(idHex: string): void {
    if (typeof idHex !== 'string' || idHex.length !== 64) {
      throw new Error('idHex must be a 64-character hex string');
    }
    if (!/^[0-9A-Fa-f]{64}$/.test(idHex)) {
      throw new Error('idHex must contain only hex characters');
    }
    const buf = Buffer.from(idHex, 'hex');
    if (buf.length !== 32) {
      throw new Error('idHex must decode to 32 bytes');
    }
    const roundTrip = Buffer.from(buf).toString('hex');
    if (roundTrip.length !== 64) {
      throw new Error('idHex round-trip failed');
    }
  }
}

export function openDatabaseAndMigrate(dbPath: string): ISqliteStore {
  if (process.env.GLOBAL_DEBUGGING === "1") {
    try {
      fs.rmSync(dbPath, { force: true });
      fs.rmSync(`${dbPath}-wal`, { force: true });
      fs.rmSync(`${dbPath}-shm`, { force: true });
    } catch { /* ignore */ }
  }

  const db = new Database(dbPath);
  const store = new SqliteStore(db);
  store.migrate();
  return store;
}


---
# ./factories/PostConditionFactory.ts

// src/factories/PostConditionFactory.ts
import { Pc } from '@stacks/transactions';
import { IPostConditionFactory } from '../contracts/interfaces';

type FtAsset = {
  contractAddress: string; // e.g. 'ST...'
  contractName: string;    // e.g. 'sbtc-token'
  assetName: string;       // e.g. 'sbtc'
};

// Stacks v7 Pc.ft expects a template-literal ContractId: `${string}.${string}`
type ContractId = `${string}.${string}`;

export class PostConditionFactory implements IPostConditionFactory {
  /**
   * Build post-conditions for paying an invoice.
   * NOTE: Post-conditions constrain the *sender* only. Recipient guarantees are enforced in Clarity.
   */
  forPayInvoice(payer: string, merchant: string, amountSats: number, asset: FtAsset): any[] {
    if (typeof payer !== 'string' || payer.length === 0) throw new Error('invalid_payer_principal');
    if (typeof merchant !== 'string' || merchant.length === 0) throw new Error('invalid_merchant_principal');
    if (typeof asset?.contractAddress !== 'string' || asset.contractAddress.length === 0) throw new Error('invalid_contract_address');
    if (typeof asset?.contractName !== 'string' || asset.contractName.length === 0) throw new Error('invalid_contract_name');
    if (typeof asset?.assetName !== 'string' || asset.assetName.length === 0) throw new Error('invalid_asset_name');

    const amt = BigInt(amountSats);
    if (amt <= 0n) throw new Error('invalid_amount');

    const contractId: ContractId = `${asset.contractAddress}.${asset.contractName}`;

    // Payer must send >= amount of the FT (sBTC)
    const payerSendsGte = Pc.principal(payer).willSendGte(amt).ft(contractId, asset.assetName);

    // Cannot assert merchant-gets-â‰¥ with post-conditions; enforced in Clarity.
    return [payerSendsGte];
  }

  /**
   * Build post-conditions for a refund (cap merchant outflow).
   */
  forRefund(merchant: string, amountSats: number, asset: FtAsset): any[] {
    if (typeof merchant !== 'string' || merchant.length === 0) throw new Error('invalid_merchant_principal');
    if (typeof asset?.contractAddress !== 'string' || asset.contractAddress.length === 0) throw new Error('invalid_contract_address');
    if (typeof asset?.contractName !== 'string' || asset.contractName.length === 0) throw new Error('invalid_contract_name');
    if (typeof asset?.assetName !== 'string' || asset.assetName.length === 0) throw new Error('invalid_asset_name');

    const amt = BigInt(amountSats);
    if (amt <= 0n) throw new Error('invalid_amount');

    const contractId: ContractId = `${asset.contractAddress}.${asset.contractName}`;

    // Merchant will send <= amount of the FT (sBTC)
    const capOutflow = Pc.principal(merchant).willSendLte(amt).ft(contractId, asset.assetName);

    return [capOutflow];
  }
}

export default PostConditionFactory;


---
# ./factories/AssetInfoFactory.ts

// src/factories/AssetInfoFactory.ts
import type { IAssetInfoFactory, IConfigService } from '../contracts/interfaces';

type SbtcAssetInfo = {
  contractAddress: string;
  contractName: string;
  assetName: string;
};

export class AssetInfoFactory implements IAssetInfoFactory {
  private readonly cfg: IConfigService;
  private cached?: SbtcAssetInfo;

  constructor(cfg: IConfigService) {
    this.cfg = cfg;
  }

  getSbtcAssetInfo(): SbtcAssetInfo {
    if (this.cached) return this.cached;

    const token = this.cfg.getSbtcContractId();
    if (!token) {
      throw new Error('sbtc_token_not_set');
    }

    const { contractAddress, contractName } = token;

    if (typeof contractAddress !== 'string' || !contractAddress.startsWith('S')) {
      throw new TypeError('invalid_sbtc_contract_address');
    }
    if (!contractName || typeof contractName !== 'string') {
      throw new TypeError('invalid_sbtc_contract_name');
    }

    const assetName = 'sbtc';

    this.cached = { contractAddress, contractName, assetName };
    return this.cached;
  }
}


---
# ./clients/StacksChainClient.ts

// src/clients/StacksChainClient.ts

import axios from 'axios';
import { fetchCallReadOnlyFunction as callReadOnlyFunction, bufferCV, cvToJSON } from '@stacks/transactions';
import type { IStacksChainClient, IConfigService } from '../contracts/interfaces';
import type { OnChainSubscription } from '../contracts/domain';
import { ClarityCvAdapter } from '../delegates/ClarityCvAdapter';

type NetworkName = 'mainnet' | 'testnet' | 'devnet' | 'mocknet';

export class StacksChainClient implements IStacksChainClient {
  private readonly cvAdapter = new ClarityCvAdapter();

  // v7: use simple network name + baseUrl (client), not @stacks/network classes
  private network!: NetworkName;
  private baseUrl!: string;

  private contractAddress!: string;
  private contractName!: string;

  constructor(cfg: IConfigService) {
    this.initializeNetwork(cfg);
  }

  initializeNetwork(cfg: IConfigService): void {
    const net = (cfg.getNetwork() as NetworkName) ?? 'testnet';
    const customApiUrl =
      // prefer config methods if present
      (cfg as any).getStacksApiBaseUrl?.() ??
      (cfg as any).getApiBaseUrl?.() ??
      // fallback to env override
      process.env.STACKS_API_URL ??
      // sane defaults per network
      (net === 'mainnet'
        ? 'https://api.hiro.so'
        : net === 'testnet'
        ? 'https://api.testnet.hiro.so'
        : 'http://localhost:3999');

    this.network = net;
    this.baseUrl = customApiUrl.replace(/\/+$/, ''); // trim trailing slash

    const { contractAddress, contractName } = cfg.getContractId();
    this.contractAddress = contractAddress;
    this.contractName = contractName;
  }

  async callReadOnly(functionName: string, functionArgs: any[]): Promise<any> {
    return callReadOnlyFunction({
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      functionName,
      functionArgs,
      // v7 shape: pass simple network name + client with baseUrl
      network: this.network,
      client: { baseUrl: this.baseUrl },
      // sender is required by some nodes; safe default: contract address
      senderAddress: this.contractAddress,
    });
  }

  async readInvoiceStatus(
    idHex: string,
  ): Promise<'not-found' | 'paid' | 'canceled' | 'expired' | 'unpaid'> {
    const idBuf = this.cvAdapter.guardHex32(idHex);
    const cv = await callReadOnlyFunction({
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      functionName: 'get-invoice-status',
      functionArgs: [bufferCV(idBuf)],
      network: this.network,
      client: { baseUrl: this.baseUrl },
      senderAddress: this.contractAddress,
    });
    const j: any = cvToJSON(cv);
    const val = String(j.value);
    return val as any;
  }

  async readSbtcToken(): Promise<{ contractAddress: string; contractName: string } | undefined> {
    const cv = await callReadOnlyFunction({
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      functionName: 'get-sbtc',
      functionArgs: [],
      network: this.network,
      client: { baseUrl: this.baseUrl },
      senderAddress: this.contractAddress,
    });
    return this.cvAdapter.decodeOptionalContractPrincipal(cv);
  }

  async readSubscription(idHex: string): Promise<OnChainSubscription | undefined> {
    const idBuf = this.cvAdapter.guardHex32(idHex);
    const cv = await callReadOnlyFunction({
      contractAddress: this.contractAddress,
      contractName: this.contractName,
      functionName: 'get-subscription',
      functionArgs: [bufferCV(idBuf)],
      network: this.network,
      client: { baseUrl: this.baseUrl },
      senderAddress: this.contractAddress,
    });
    return this.cvAdapter.decodeOptionalSubscriptionTuple(cv, idHex);
  }

  async getTip(): Promise<{ height: number; blockHash: string }> {
    const infoResp = await axios.get(`${this.baseUrl}/v2/info`);
    const height = Number(infoResp.data?.stacks_tip_height);
    const blkResp = await axios.get(`${this.baseUrl}/extended/v1/block/by_height/${height}`);
    const blockHash = String(blkResp.data?.hash);
    return { height, blockHash };
  }

  async getTipHeight(): Promise<number> {
    const tip = await this.getTip();
    return tip.height;
  }

  async getFungibleBalance(
    assetContract: { contractAddress: string; contractName: string },
    principal: string,
  ): Promise<bigint> {
    const url = `${this.baseUrl}/extended/v1/address/${encodeURIComponent(principal)}/balances`;
    const resp = await axios.get(url);
    const tokens: Record<string, any> = resp.data?.fungible_tokens ?? {};
    const fqPrefix = `${assetContract.contractAddress}.${assetContract.contractName}::`;
    let balanceStr = '0';
    for (const [key, entry] of Object.entries(tokens)) {
      if (key.startsWith(fqPrefix)) {
        balanceStr = String((entry as any)?.balance ?? '0');
        break;
      }
    }
    return BigInt(balanceStr);
  }

  async getContractCallEvents(params: { fromHeight: number }): Promise<any[]> {
    const contractId = `${this.contractAddress}.${this.contractName}`;
    const url = `${this.baseUrl}/extended/v1/contract/${contractId}/transactions`;
    const resp = await axios.get(url, { params: { from_height: params.fromHeight } });
    return resp.data?.results ?? [];
  }

  async getBlockHeader(
    height: number,
  ): Promise<{ parent_block_hash: string; block_hash: string }> {
    const url = `${this.baseUrl}/extended/v1/block/by_height/${height}`;
    const resp = await axios.get(url);
    return {
      parent_block_hash: String(resp.data?.parent_block_hash),
      block_hash: String(resp.data?.hash),
    };
  }

  async isMerchantRegisteredOnChain(_principal: string): Promise<boolean> {
    // Duck-typed helper used by MerchantOnchainSyncPlanner. Returning false ensures planner includes registration call.
    return false;
  }
}


---
# ./services/ExpirationMonitor.ts

// src/services/ExpirationMonitor.ts
import type { ISqliteStore } from '../contracts/dao';
import type { IStacksChainClient, IWebhookDispatcher } from '../contracts/interfaces';
import type { InvoiceRow } from '../contracts/domain';
import { Validation } from '../validation/rules';

export class ExpirationMonitor {
  async emitInvoiceExpiredWebhook(
    invoiceId: string,
    storeId: string,
    deps: { store: ISqliteStore; dispatcher: IWebhookDispatcher; nowEpochSecs?: number },
  ): Promise<boolean> {
    if (!invoiceId || !storeId) {
      throw new Error('invalid_args');
    }

    const already = deps.store.existsSuccessfulDeliveryFor({
      storeId,
      invoiceId,
      eventType: 'invoice-expired',
    });
    if (already) return false;

    const rawBody = JSON.stringify({ invoiceId, status: 'expired' as const });

    await deps.dispatcher.dispatch({
      storeId,
      invoiceId,
      eventType: 'invoice-expired',
      rawBody,
    });

    return true;
  }

  async sweepOnchainStatuses(
    candidateIdHexes: string[],
    deps: { store: ISqliteStore; chain: IStacksChainClient; dispatcher: IWebhookDispatcher },
  ): Promise<{ expiredIds: string[]; updated: number }> {
    const valid = Array.from(
      new Set(candidateIdHexes.filter((h) => typeof h === 'string' && Validation.idHex64.test(h))),
    );
    if (valid.length === 0) return { expiredIds: [], updated: 0 };

    const expiredHexSet = new Set<string>();
    for (const idHex of valid) {
      const status = await deps.chain.readInvoiceStatus(idHex);
      if (status === 'expired') expiredHexSet.add(idHex);
    }
    const expiredIds = Array.from(expiredHexSet);
    if (expiredIds.length === 0) return { expiredIds, updated: 0 };

    const allRows = deps.store.selectAdminInvoices();
    const eligible: InvoiceRow[] = allRows.filter(
      (r) =>
        expiredHexSet.has(r.id_hex) &&
        r.status !== 'paid' &&
        r.status !== 'canceled' &&
        Number(r.expired) === 0,
    );

    if (eligible.length === 0) return { expiredIds, updated: 0 };

    const idRawList = eligible.map((r) => r.id_raw);
    const updated = deps.store.bulkMarkExpired(idRawList);

    for (const row of eligible) {
      // eslint-disable-next-line no-await-in-loop
      await this.emitInvoiceExpiredWebhook(row.id_raw, row.store_id, {
        store: deps.store,
        dispatcher: deps.dispatcher,
      });
    }

    return { expiredIds, updated };
  }
}


---
# ./services/PricingCache.ts

export class PricingCache {
  private snapshot: number | null = null;
  private timestampMs = 0;
  private ttlMs: number;

  constructor(ttlMs: number) {
    this.ttlMs = ttlMs;
  }

  initCache(): void {
    this.snapshot = null;
    this.timestampMs = 0;
  }

  get(): number | null {
    return this.snapshot;
  }

  set(value: number, nowMs?: number): void {
    this.snapshot = value;
    this.timestampMs = nowMs !== undefined ? nowMs : Date.now();
  }

  isExpired(nowMs?: number): boolean {
    const now = nowMs !== undefined ? nowMs : Date.now();
    if (this.ttlMs <= 0) return true;
    if (this.timestampMs === 0) return true;
    return now - this.timestampMs >= this.ttlMs;
  }
}


---
# ./services/SubscriptionService.ts

// src/services/SubscriptionService.ts
import crypto from 'crypto';
import type { ISqliteStore } from '../contracts/dao';
import type {
  IContractCallBuilder,
  IStacksChainClient,
  IConfigService,
  IInvoiceIdCodec,
} from '../contracts/interfaces';
import { PricingService } from './PricingService';
import type {
  SubscriptionRow,
  PublicInvoiceDTO,
  UnsignedContractCall,
} from '../contracts/domain';

type CreateSubInput = {
  subscriber: string;
  amountSats: number;
  intervalBlocks: number;
  mode?: 'invoice' | 'direct';
};

export class SubscriptionService {
  private store!: ISqliteStore;
  private builder!: IContractCallBuilder;
  private chain!: IStacksChainClient;
  private cfg!: IConfigService;
  private codec!: IInvoiceIdCodec;
  private pricing!: PricingService;

  bindDependencies(deps: {
    store: ISqliteStore;
    builder: IContractCallBuilder;
    chain: IStacksChainClient;
    cfg: IConfigService;
    codec: IInvoiceIdCodec;
    pricing: PricingService;
  }): void {
    this.store = deps.store;
    this.builder = deps.builder;
    this.chain = deps.chain;
    this.cfg = deps.cfg;
    this.codec = deps.codec;
    this.pricing = deps.pricing;
  }

  async createSubscription(
    store: { id: string; principal: string },
    body: CreateSubInput,
  ): Promise<{ row: SubscriptionRow; unsignedCall?: UnsignedContractCall }> {
    const id = crypto.randomUUID();
    const idHex = this.generateUniqueSubHex();
    const now = Math.floor(Date.now() / 1000);
    const tip = await this.chain.getTip();
    const nextInvoiceAt = tip.height + body.intervalBlocks;
    const mode = body.mode ?? 'invoice';
    
    const row: SubscriptionRow = {
      id,
      id_hex: idHex,
      store_id: store.id,
      merchant_principal: store.principal,
      subscriber: body.subscriber,
      amount_sats: body.amountSats,
      interval_blocks: body.intervalBlocks,
      active: 1,
      created_at: now,
      last_billed_at: undefined,
      next_invoice_at: nextInvoiceAt,
      last_paid_invoice_id: undefined,
      mode,
    };

    this.store.insertSubscription(row);

    let unsignedCall: UnsignedContractCall | undefined;
    if (mode === 'direct') {
      unsignedCall = this.builder.buildCreateSubscription({
        idHex,
        merchant: store.principal,
        subscriber: body.subscriber,
        amountSats: body.amountSats,
        intervalBlocks: body.intervalBlocks,
      });
    }

    return { row, unsignedCall };
  }

  async generateInvoiceForSubscription(
    sub: SubscriptionRow,
    opts: {
      storeId: string;
      merchantPrincipal: string;
      ttlSeconds: number;
      memo?: string;
      webhookUrl?: string;
    },
  ): Promise<{ invoice: PublicInvoiceDTO; unsignedCall: UnsignedContractCall }> {
    const idHex = this.generateUniqueInvoiceHex();
    const nowMs = Date.now();
    const nowSecs = Math.floor(nowMs / 1000);
    const usdAtCreate = await this.pricing.getUsdPriceSnapshot();
    const tip = await this.chain.getTip();
    const avgBlockSecs = this.cfg.getAvgBlockSecs();
    const expiresAtBlocks = tip.height + Math.ceil(opts.ttlSeconds / avgBlockSecs);
    const quoteExpiresAt = nowMs + opts.ttlSeconds * 1000;

    const unsignedCall = this.builder.buildCreateInvoice({
      idHex,
      amountSats: sub.amount_sats,
      memo: opts.memo,
      expiresAtBlock: expiresAtBlocks,
    });

    const idRaw = crypto.randomUUID();

    this.store.invoices.insert({
      id_raw: idRaw,
      id_hex: idHex,
      store_id: opts.storeId,
      amount_sats: sub.amount_sats,
      usd_at_create: usdAtCreate,
      quote_expires_at: quoteExpiresAt,
      merchant_principal: opts.merchantPrincipal,
      status: 'unpaid',
      payer: undefined,
      txid: undefined,
      memo: opts.memo,
      webhook_url: opts.webhookUrl,
      created_at: nowSecs,
      refunded_at: undefined,
      refund_amount: 0,
      refund_txid: undefined,
      subscription_id: sub.id,
      refund_count: 0,
      expired: 0,
    });

    this.store.advanceSubscriptionSchedule(sub.id);

    const invoice: PublicInvoiceDTO = {
      invoiceId: idRaw,
      idHex,
      storeId: opts.storeId,
      amountSats: sub.amount_sats,
      usdAtCreate,
      quoteExpiresAt: quoteExpiresAt,
      merchantPrincipal: opts.merchantPrincipal,
      status: 'unpaid',
      payer: undefined,
      txId: undefined,
      memo: opts.memo ?? undefined,
      subscriptionId: sub.id,
      createdAt: nowSecs,
      refundAmount: undefined,
      refundTxId: undefined,
      store: undefined,
    };

    return { invoice, unsignedCall };
  }

  async setMode(
    sub: SubscriptionRow,
    mode: 'invoice' | 'direct',
  ): Promise<{ row: SubscriptionRow; unsignedCall?: UnsignedContractCall }> {
    this.store.updateSubscriptionMode(sub.id, sub.store_id, mode);
    let unsignedCall: UnsignedContractCall | undefined;

    if (mode === 'direct') {
      const onchain = await this.chain.readSubscription(sub.id_hex);
      if (!onchain) {
        unsignedCall = this.builder.buildCreateSubscription({
          idHex: sub.id_hex,
          merchant: sub.merchant_principal,
          subscriber: sub.subscriber,
          amountSats: sub.amount_sats,
          intervalBlocks: sub.interval_blocks,
        });
      }
    }

    const updated =
      this.store.getSubscriptionByIdForStore(sub.id, sub.store_id) ||
      ({ ...sub, mode } as SubscriptionRow);

    return { row: updated, unsignedCall };
  }

  async cancel(
    sub: SubscriptionRow,
  ): Promise<{ row: SubscriptionRow; unsignedCall: UnsignedContractCall }> {
    this.store.deactivateSubscription(sub.id, sub.store_id);
    const unsignedCall = this.builder.buildCancelSubscription({ idHex: sub.id_hex });
    const updated =
      this.store.getSubscriptionByIdForStore(sub.id, sub.store_id) ||
      ({ ...sub, active: 0 } as SubscriptionRow);
    return { row: updated, unsignedCall };
  }

  private generateUniqueSubHex(): string {
    let idHex: string;
    do {
      idHex = this.codec.generateRandomBuff32Hex();
      this.codec.assertHex64(idHex);
    } while (this.store.subscriptionExists(idHex));
    return idHex;
  }

  private generateUniqueInvoiceHex(): string {
    let idHex: string;
    do {
      idHex = this.codec.generateRandomBuff32Hex();
      this.codec.assertHex64(idHex);
    } while (!this.store.ensureInvoiceIdHexUnique(idHex));
    return idHex;
  }
}


---
# ./services/RefundService.ts

// src/services/RefundService.ts
import type {
  IStacksChainClient,
  IContractCallBuilder,
  IPostConditionFactory,
  IAssetInfoFactory,
  IInvoiceIdCodec,
  IConfigService,
} from '../contracts/interfaces';
import type {
  UnsignedContractCall,
  MerchantRow,
  InvoiceRow,
} from '../contracts/domain';

export class RefundService {
  private chain!: IStacksChainClient;
  private builder!: IContractCallBuilder;
  private pcf!: IPostConditionFactory;
  private aif!: IAssetInfoFactory;
  private codec!: IInvoiceIdCodec;
  private cfg!: IConfigService;

  bindDependencies(deps: {
    chain: IStacksChainClient;
    builder: IContractCallBuilder;
    pcf: IPostConditionFactory;
    aif: IAssetInfoFactory;
    codec: IInvoiceIdCodec;
    cfg: IConfigService;
  }): void {
    this.chain = deps.chain;
    this.builder = deps.builder;
    this.pcf = deps.pcf;
    this.aif = deps.aif;
    this.codec = deps.codec;
    this.cfg = deps.cfg;
  }

  async precheckBalance(merchantPrincipal: string, amountSats: number): Promise<boolean> {
    const token = this.cfg.getSbtcContractId();
    if (!token) return false;
    const bal = await this.chain.getFungibleBalance(token, merchantPrincipal);
    return bal >= BigInt(amountSats);
  }

  async buildRefundPayload(
    store: MerchantRow,
    invoice: InvoiceRow,
    amountSats: number,
    memo?: string,
  ): Promise<UnsignedContractCall> {
    if (!(invoice.status === 'paid' || invoice.status === 'partially_refunded')) {
      throw new Error('not_refundable');
    }

    this.codec.assertHex64(invoice.id_hex);

    const alreadyRefunded = Number(invoice.refund_amount ?? 0);
    const newTotal = alreadyRefunded + Number(amountSats);
    if (newTotal > Number(invoice.amount_sats)) {
      throw new Error('refund_cap_exceeded');
    }

    const payload = this.builder.buildRefundInvoice({
      idHex: invoice.id_hex,
      amountSats,
      memo,
      merchantPrincipal: store.principal,
    });

    return payload;
  }
}

export default RefundService;


---
# ./services/PricingService.ts

// src/services/PricingService.ts
import type { IConfigService } from '../contracts/interfaces';
import { PricingCache } from './PricingCache';

export class PricingService {
  private cache!: PricingCache;
  private cfg!: IConfigService;

  bindDependencies(cache: PricingCache, cfg: IConfigService): void {
    this.cache = cache;
    this.cfg = cfg;
  }

  async getUsdPriceSnapshot(): Promise<number> {
    const cached = this.cache.get();
    if (cached !== null && !this.cache.isExpired()) {
      return cached;
    }

    const url = this.cfg.getPriceApiUrl();
    if (!url) {
      throw new Error('PRICE_API_URL not configured');
    }

    const resp = await fetch(url);
    if (!resp.ok) {
      throw new Error(`pricing_http_${resp.status}`);
    }
    const data: any = await resp.json();

    const candidates: Array<unknown> = [
      data?.bitcoin?.usd,
      data?.USD,
      data?.price,
    ];

    let usd = NaN;
    for (const c of candidates) {
      const n = Number(c);
      if (Number.isFinite(n) && n > 0) {
        usd = n;
        break;
      }
    }

    if (!Number.isFinite(usd) || usd <= 0) {
      throw new Error('bad_price');
    }

    this.cache.set(usd);
    return usd;
  }
}


---
# ./services/InvoiceService.ts

// src/services/InvoiceService.ts
import crypto from 'crypto';
import type { ISqliteStore } from '../contracts/dao';
import type {
  IStacksChainClient,
  IContractCallBuilder,
  IConfigService,
  IInvoiceIdCodec,
} from '../contracts/interfaces';
import { PricingService } from './PricingService';
import type { PublicInvoiceDTO, UnsignedContractCall } from '../contracts/domain';

type StoreLike = { id: string; principal: string };

export class InvoiceService {
  private store!: ISqliteStore;
  private chain!: IStacksChainClient;
  private builder!: IContractCallBuilder;
  private cfg!: IConfigService;
  private pricing!: PricingService;
  private codec!: IInvoiceIdCodec;

  bindDependencies(deps: {
    store: ISqliteStore;
    chain: IStacksChainClient;
    builder: IContractCallBuilder;
    cfg: IConfigService;
    pricing: PricingService;
    codec: IInvoiceIdCodec;
  }): void {
    this.store = deps.store;
    this.chain = deps.chain;
    this.builder = deps.builder;
    this.cfg = deps.cfg;
    this.pricing = deps.pricing;
    this.codec = deps.codec;
  }

  async createInvoice(
    store: StoreLike,
    input: {
      amountSats: number;
      ttlSeconds: number;
      memo?: string;
      webhookUrl?: string;
    },
  ): Promise<PublicInvoiceDTO & { magicLink: string; unsignedTx?: UnsignedContractCall }> {
    this.assertPositiveInt(input.amountSats, 'amountSats');
    this.assertPositiveInt(input.ttlSeconds, 'ttlSeconds');

    const idHex = this.codec.generateRandomBuff32Hex();
    this.codec.assertHex64(idHex);

    const usdAtCreate = await this.pricing.getUsdPriceSnapshot();
    const tipHeight = await this.chain.getTipHeight();
    const avgBlockSecs = this.cfg.getAvgBlockSecs();
    const expiresAtBlock = tipHeight + Math.ceil(input.ttlSeconds / avgBlockSecs);

    const unsignedTx = this.builder.buildCreateInvoice({
      idHex,
      amountSats: input.amountSats,
      memo: input.memo,
      expiresAtBlock,
    });

    if (this.cfg.isAutoBroadcastEnabled()) {
      await this.broadcastCreateInvoice(unsignedTx);
    }

    const nowMs = Date.now();
    const nowSecs = Math.floor(nowMs / 1000);
    const quoteExpiresAt = nowMs + input.ttlSeconds * 1000;
    const idRaw = crypto.randomUUID();

    this.store.invoices.insert({
      id_raw: idRaw,
      id_hex: idHex,
      store_id: store.id,
      amount_sats: input.amountSats,
      usd_at_create: usdAtCreate,
      quote_expires_at: quoteExpiresAt,
      merchant_principal: store.principal,
      status: 'unpaid',
      payer: undefined,
      txid: undefined,
      memo: input.memo,
      webhook_url: input.webhookUrl,
      created_at: nowSecs,
      refunded_at: undefined,
      refund_amount: 0,
      refund_txid: undefined,
      subscription_id: undefined,
      refund_count: 0,
      expired: 0,
    } as any);

    const dto: PublicInvoiceDTO = {
      invoiceId: idRaw,
      idHex,
      storeId: store.id,
      amountSats: input.amountSats,
      usdAtCreate,
      quoteExpiresAt,
      merchantPrincipal: store.principal,
      status: 'unpaid',
      payer: undefined,
      txId: undefined,
      memo: input.memo,
      subscriptionId: undefined,
      createdAt: nowSecs,
      refundAmount: 0,
      refundTxId: undefined,
      store: undefined,
    };

    const magicLink = `/i/${idRaw}`;
    return { ...dto, magicLink, unsignedTx };
  }

  async broadcastCreateInvoice(_unsignedCall: UnsignedContractCall): Promise<string> {
    throw new Error('auto_broadcast_not_supported');
  }

  private assertPositiveInt(n: number, name: string): void {
    if (!Number.isInteger(n) || n <= 0) {
      throw new TypeError(`${name} must be a positive integer`);
    }
  }
}


---
# ./servers/AdminStaticServer.ts

import express, { Request, Response, RequestHandler } from 'express';
import path from 'path';

export class AdminStaticServer {
  private staticDirAbs?: string;
  private staticMiddleware?: RequestHandler;

  configureStaticDir(rootAbsPath: string): void {
    if (!path.isAbsolute(rootAbsPath)) {
      throw new TypeError('AdminStaticServer.configureStaticDir requires an absolute path.');
    }
    this.staticDirAbs = rootAbsPath;
    this.staticMiddleware = express.static(rootAbsPath);
  }

  serveStatic(): RequestHandler {
    if (!this.staticMiddleware) {
      throw new TypeError('AdminStaticServer.serveStatic called before configureStaticDir.');
    }
    return this.staticMiddleware;
  }

  serveIndex(_req: Request, res: Response): void {
    if (!this.staticDirAbs) {
      throw new TypeError('AdminStaticServer.serveIndex called before configureStaticDir.');
    }
    const indexFile = path.join(this.staticDirAbs, 'index.html');
    res.sendFile(indexFile);
  }
}


---
# ./middleware/RateLimitPolicy.ts

import rateLimit from 'express-rate-limit';

export class RateLimitPolicy {
  public publicInvoiceViewLimiter!: import('express').RequestHandler;
  public publicProfileLimiter!: import('express').RequestHandler;
  public publicCreateTxLimiter!: import('express').RequestHandler;
  public createInvoiceLimiter!: import('express').RequestHandler;
  public subInvoiceLimiter!: import('express').RequestHandler;

  initLimiters(): void {
    const publicWindowMs = 60_000;
    const publicMax = 30;

    const merchantWindowMs = 60_000;
    const merchantMax = 30;

    const subWindowMs = 60_000;
    const subMax = 30;

    this.publicInvoiceViewLimiter = this.buildPublicLimiter(
      this.publicInvoiceViewLimiterHandler.bind(this),
      publicWindowMs,
      publicMax
    );

    this.publicProfileLimiter = this.buildPublicLimiter(
      this.publicProfileLimiterHandler.bind(this),
      publicWindowMs,
      publicMax
    );

    this.publicCreateTxLimiter = this.buildPublicLimiter(
      this.publicCreateTxLimiterHandler.bind(this),
      publicWindowMs,
      publicMax
    );

    this.createInvoiceLimiter = this.buildMerchantLimiter(
      this.createInvoiceLimiterHandler.bind(this),
      merchantWindowMs,
      merchantMax
    );

    this.subInvoiceLimiter = this.buildSubInvoiceLimiter(subWindowMs, subMax);
  }

  publicInvoiceViewLimiterHandler(req: import('express').Request, res: import('express').Response): void {
    res.status(429).json({ reason: 'rateLimited' });
  }

  publicProfileLimiterHandler(req: import('express').Request, res: import('express').Response): void {
    res.status(429).json({ reason: 'rateLimited' });
  }

  publicCreateTxLimiterHandler(req: import('express').Request, res: import('express').Response): void {
    res.status(429).json({ reason: 'rateLimited' });
  }

  createTxLimiterHandler(req: import('express').Request, res: import('express').Response): void {
    res.status(429).json({ reason: 'rateLimited' });
  }

  createInvoiceLimiterHandler(req: import('express').Request, res: import('express').Response): void {
    res.status(429).json({ error: 'rate_limited' });
  }

  buildSubInvoiceLimiter(windowMs?: number, max?: number): import('express').RequestHandler {
    const handler = this.subInvoiceLimiterHandler.bind(this);
    return rateLimit({
      windowMs: windowMs ?? 60_000,
      max: max ?? 30,
      standardHeaders: true,
      legacyHeaders: false,
      handler,
      keyGenerator: (req) => {
        const anyReq = req as any;
        const storeId = String(anyReq.store.id);
        const apiKeyHeader = String(req.headers['x-api-key'] ?? (req.headers as any)['X-API-Key']);
        return `${storeId}|${apiKeyHeader}`;
      },
    });
  }

  subInvoiceLimiterHandler(req: import('express').Request, res: import('express').Response): void {
    res.status(429).json({ error: 'rate_limited' });
  }

  private buildPublicLimiter(
    handler: (req: import('express').Request, res: import('express').Response) => void,
    windowMs: number,
    max: number
  ): import('express').RequestHandler {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      handler,
    });
  }

  private buildMerchantLimiter(
    handler: (req: import('express').Request, res: import('express').Response) => void,
    windowMs: number,
    max: number
  ): import('express').RequestHandler {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      handler,
    });
  }
}


---
# ./middleware/StoreApiAuth.ts

// src/middleware/StoreApiAuth.ts
import type { Request, Response, NextFunction } from 'express';
import type { ISqliteStore } from '../contracts/dao';

declare global {
  namespace Express {
    interface Request {
      store?: any;
    }
  }
}

export class StoreApiAuth {
  private store?: ISqliteStore;

  bindStore(store: ISqliteStore): void {
    this.store = store;
  }

  verifyApiKey(req: Request, res: Response, next: NextFunction): void {
    if (!this.store) {
      res.status(401).end();
      return;
    }

    const apiKey =
      req.get('X-API-Key') ||
      req.get('x-api-key') ||
      (req.headers['x-api-key'] as string | undefined);

    if (!apiKey) {
      res.status(401).end();
      return;
    }

    const merchant = this.store.findActiveByApiKey(apiKey);
    if (!merchant) {
      res.status(401).end();
      return;
    }

    (req as any).store = merchant;
    next();
  }
}


---
# ./middleware/AdminAuth.ts

// src/middleware/AdminAuth.ts
import type { Request, Response, NextFunction } from 'express';
import type { IConfigService } from '../contracts/interfaces';
import crypto from 'crypto';

export class AdminAuth {
  private bearer?: string;
  private basicUser?: string;
  private basicPass?: string;

  bindCredentialsFromEnv(_cfg: IConfigService): void {
    this.bearer = process.env.ADMIN_TOKEN;
    this.basicUser = process.env.ADMIN_USER;
    this.basicPass = process.env.ADMIN_PASS;
  }

  authenticateAdmin(req: Request, res: Response, next: NextFunction): void {
    const header = req.headers['authorization'] as string | undefined;

    let ok = false;

    if (header && header.startsWith('Bearer ')) {
      const token = header.slice(7).trim();
      if (this.bearer && this.timingSafeEqualStr(token, this.bearer)) {
        ok = true;
      }
    } else if (header && header.startsWith('Basic ')) {
      const payload = header.slice(6).trim();
      const decoded = Buffer.from(payload, 'base64').toString('utf8');
      const idx = decoded.indexOf(':');
      const user = idx >= 0 ? decoded.slice(0, idx) : decoded;
      const pass = idx >= 0 ? decoded.slice(idx + 1) : '';
      if (
        this.basicUser &&
        this.basicPass &&
        this.timingSafeEqualStr(user, this.basicUser) &&
        this.timingSafeEqualStr(pass, this.basicPass)
      ) {
        ok = true;
      }
    }

    if (ok) {
      next();
      return;
    }

    res.status(401).send('Unauthorized');
  }

  private timingSafeEqualStr(a?: string, b?: string): boolean {
    if (typeof a !== 'string' || typeof b !== 'string') return false;
    const ab = Buffer.from(a, 'utf8');
    const bb = Buffer.from(b, 'utf8');
    if (ab.length !== bb.length) return false;
    return crypto.timingSafeEqual(ab, bb);
  }
}


---
# ./middleware/CrossTenantMask.ts

// src/middleware/CrossTenantMask.ts
import type { Request, Response, NextFunction } from 'express';

export class CrossTenantMask {
  enforce(req: Request, res: Response, next: NextFunction): void {
    const storeId = String((req as any).params.storeId);
    const merchant = (req as any).store;

    if (merchant.id !== storeId) {
      res.status(404).end();
      return;
    }

    next();
  }
}


---
# ./middleware/CorsPolicy.ts

// src/middleware/CorsPolicy.ts
import type { ISqliteStore } from '../contracts/dao';

/**
 * Public CORS policy
 * - Enforced ONLY for customer-facing routes:
 *   â€¢ GET  /i/:invoiceId
 *   â€¢ POST /create-tx
 *   â€¢ GET  /api/v1/stores/:storeId/public-profile
 *
 * Goals:
 * 1) Server-to-server (no Origin) must always pass (admin/merchant APIs, curl, Node fetch).
 * 2) Browser requests are allowed IFF their Origin is in the storeâ€™s allowed_origins CSV.
 * 3) OPTIONS preflights for public routes must pass (even when /create-tx has no query/body yet).
 * 4) If applied globally by mistake, non-public paths will:
 *    - allow if no Origin (server-to-server), or
 *    - reject when an Origin is present (browser) to avoid leaking CORS on private/admin APIs.
 *
 * Notes:
 * - This class only provides the `origin` validator. Use with `cors({ origin })`.
 * - Use `CorsPolicy.ALLOWED_HEADERS` in your CORS config for Access-Control-Allow-Headers.
 */
export class CorsPolicy {
  static readonly ALLOWED_HEADERS =
    'Content-Type,X-API-Key,X-Webhook-Timestamp,X-Webhook-Signature';

  private store!: ISqliteStore;

  bindStore(store: ISqliteStore): void {
    this.store = store;
  }

  /**
   * Origin validator compatible with `cors` package. We accept an extra `req` param
   * by wrapping this method in your middleware factory (capture `req` via closure).
   *
   * Example usage:
   *   const origin = (o: string | undefined, cb: any) =>
   *     policy.publicCorsOriginValidator(o, cb, req);
   *   app.use('/i/:invoiceId', cors({ origin }));
   */
  publicCorsOriginValidator(
    origin: string | undefined,
    cb: (err: Error | null, allow?: boolean) => void,
    req: import('express').Request,
  ): void {
    // (1) Server-to-server (no CORS): allow pass-through
    if (!origin) {
      cb(null, true);
      return;
    }

    // Normalize browser-provided Origin and path
    const normOrigin = this.normalizeOrigin(origin);
    const path = req.path;

    const isPublicInvoice = /^\/i\/[^/]+$/.test(path);
    const isPublicCreateTx = path === '/create-tx';
    const isPublicStoreProfile = /^\/api\/v1\/stores\/[^/]+\/public-profile$/.test(path);

    // (2) If not a public route: allow server-to-server (handled above), block browsers here.
    if (!isPublicInvoice && !isPublicCreateTx && !isPublicStoreProfile) {
      cb(new Error('Not allowed'), false);
      return;
    }

// (3) OPTIONS preflight for public routes: only allow if Origin is allow-listed.
if (req.method === 'OPTIONS') {
  const allowedCsv = this.lookupAllowedOriginsCsv(req, {
    isPublicInvoice,
    isPublicCreateTx,
    isPublicStoreProfile,
    origin: normOrigin,
  });

  // no allow-list found â†’ deny, but do NOT throw
  if (!allowedCsv) {
    cb(null, false);
    return;
  }

  const allowlist = this.parseAllowlist(allowedCsv);
  const ok = allowlist.has(normOrigin);

  // allow if in list; otherwise deny quietly (no error throw)
  cb(null, ok);
  return;
}




    // (4) Resolve store.allowed_origins for the route
    const allowedCsv = this.lookupAllowedOriginsCsv(req, {
      isPublicInvoice,
      isPublicCreateTx,
      isPublicStoreProfile,
      origin: normOrigin,
    });

    if (!allowedCsv) {
      cb(null, false);
      return;
    }

    const allowlist = this.parseAllowlist(allowedCsv);
    const ok = allowlist.has(normOrigin);

    if (ok) {
      cb(null, true);
      return;
    }
    cb(null, false);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private normalizeOrigin(o: string): string {
    // Lowercase and strip trailing slash to match CSV entries consistently
    try {
      const u = new URL(o);
      // Keep scheme + host + optional port (the canonical Origin form)
      const origin = `${u.protocol}//${u.host}`.toLowerCase();
      return origin.endsWith('/') ? origin.slice(0, -1) : origin;
    } catch {
      const s = (o || '').toLowerCase();
      return s.endsWith('/') ? s.slice(0, -1) : s;
    }
  }

  private parseAllowlist(csv: string): Set<string> {
    const out = new Set<string>();
    for (const raw of csv.split(',')) {
      const s = raw.trim();
      if (!s) continue;
      // Accept either full origin ("https://app.example.com") or with trailing slash
      const norm = this.normalizeOrigin(s);
      out.add(norm);
    }
    return out;
  }

  /**
   * Attempts to fetch the per-store allowed_origins CSV for the current request.
   * For /create-tx when we cannot extract an invoiceId (e.g., early CORS phase),
   * we fall back to: allow if the Origin appears in *any* store's allowlist.
   */
  private lookupAllowedOriginsCsv(
    req: import('express').Request,
    flags: {
      isPublicInvoice: boolean;
      isPublicCreateTx: boolean;
      isPublicStoreProfile: boolean;
      origin: string;
    },
  ): string | undefined {
    if (flags.isPublicInvoice) {
      const invoiceId = (req.params as any)?.invoiceId as string | undefined;
      if (!invoiceId) return undefined;
      const row = this.store.getInvoiceWithStore(invoiceId) as any;
      return row?.store?.allowed_origins as string | undefined;
    }

    if (flags.isPublicStoreProfile) {
      const storeId = (req.params as any)?.storeId as string | undefined;
      const rows = (this.store.listMerchantsProjection() as any[]) || [];

      // 1) Try direct store match first
      if (storeId) {
        const m = rows.find(r => r?.id === storeId);
        if (m?.allowed_origins) return m.allowed_origins as string;
      }

      // 2) Fallback: allow if Origin is present in any store's allowlist
      const origin = String(flags.origin || '');
      for (const r of rows) {
        const csv = (r?.allowed_origins ?? '') as string;
        if (!csv) continue;
        const set = this.parseAllowlist(csv);
        if (set.has(origin)) return csv;
      }
      return undefined;
    }




    // /create-tx
    if (flags.isPublicCreateTx) {
      // Best-effort invoiceId read from query (body likely not parsed here).
      const qInvoiceId = (req.query as any)?.invoiceId as string | undefined;
      if (qInvoiceId) {
        const row = this.store.getInvoiceWithStore(qInvoiceId) as any;
        return row?.store?.allowed_origins as string | undefined;
      }

      // Fallback (safe): allow only if this Origin is configured for any store.
      // This keeps /create-tx usable from known merchant frontends during preflight/early phases
      // without opening it to arbitrary sites.
      const rows = (this.store.listMerchantsProjection() as any[]) || [];
      for (const r of rows) {
        const csv = r?.allowed_origins as string | undefined;
        if (!csv) continue;
        const set = this.parseAllowlist(csv);
        if (set.has(flags.origin)) return csv;
      }
      return undefined;
    }

    return undefined;
  }
}


---
# ./builders/ContractCallBuilder.ts

// src/builders/ContractCallBuilder.ts
import type {
  IContractCallBuilder,
  IConfigService,
  IAssetInfoFactory,
  IPostConditionFactory,
  IInvoiceIdCodec,
} from '../contracts/interfaces';
import type { UnsignedContractCall } from '../contracts/domain';
import { PostConditionsComposer } from '../delegates/PostConditionsComposer';
import { OptionalBuff34Encoder } from '../delegates/OptionalBuff34Encoder';
import {
  bufferCV,
  uintCV,
  standardPrincipalCV,
  contractPrincipalCV,
  someCV,
  noneCV,
  trueCV,
  falseCV,
} from '@stacks/transactions';

export class ContractCallBuilder implements IContractCallBuilder {
  private readonly cfg: IConfigService;
  private readonly aif: IAssetInfoFactory;
  private readonly pcf: IPostConditionFactory;
  private readonly codec: IInvoiceIdCodec;

  private readonly pcc: PostConditionsComposer;
  private readonly opt34: OptionalBuff34Encoder;

  constructor(
    cfg: IConfigService,
    aif: IAssetInfoFactory,
    pcf: IPostConditionFactory,
    codec: IInvoiceIdCodec
  ) {
    this.cfg = cfg;
    this.aif = aif;
    this.pcf = pcf;
    this.codec = codec;
    this.pcc = new PostConditionsComposer(this.aif, this.pcf);
    this.opt34 = new OptionalBuff34Encoder();
  }

  buildCreateInvoice(args: {
    idHex: string;
    amountSats: number;
    memo?: string;
    expiresAtBlock?: number;
  }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    this.assertPositiveInt(args.amountSats, 'amountSats');
    if (args.expiresAtBlock !== undefined) {
      this.assertNonNegativeInt(args.expiresAtBlock, 'expiresAtBlock');
    }

    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const memoOpt = this.opt34.encodeOptionalUtf8ToBuff34(args.memo);

    const functionArgs = [
      bufferCV(idBuf),
      uintCV(args.amountSats),
      memoOpt,
      args.expiresAtBlock !== undefined ? someCV(uintCV(args.expiresAtBlock)) : noneCV(),
    ];

    return this.baseCall('create-invoice', functionArgs);
  }

  buildRefundInvoice(args: {
    idHex: string;
    amountSats: number;
    memo?: string;
    merchantPrincipal: string;
  }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    this.assertPositiveInt(args.amountSats, 'amountSats');
    // principal validation by CV construction
    void standardPrincipalCV(args.merchantPrincipal);

    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const memoOpt = this.opt34.encodeOptionalUtf8ToBuff34(args.memo);
    const pcs = this.pcc.forRefund(args.merchantPrincipal, args.amountSats);

    const functionArgs = [bufferCV(idBuf), uintCV(args.amountSats), memoOpt];
    return this.baseCall('refund-invoice', functionArgs, pcs);
  }

  buildPayInvoice(args: {
    idHex: string;
    amountSats: number;
    payerPrincipal: string;
    merchantPrincipal: string;
  }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    this.assertPositiveInt(args.amountSats, 'amountSats');
    void standardPrincipalCV(args.payerPrincipal);
    void standardPrincipalCV(args.merchantPrincipal);

    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const pcs = this.pcc.forPay(args.payerPrincipal, args.merchantPrincipal, args.amountSats);
    const functionArgs = [bufferCV(idBuf)];
    return this.baseCall('pay-invoice', functionArgs, pcs);
  }

  buildCancelInvoice(args: { idHex: string }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const functionArgs = [bufferCV(idBuf)];
    return this.baseCall('cancel-invoice', functionArgs);
  }

  buildCreateSubscription(args: {
    idHex: string;
    merchant: string;
    subscriber: string;
    amountSats: number;
    intervalBlocks: number;
  }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    void standardPrincipalCV(args.merchant);
    void standardPrincipalCV(args.subscriber);
    this.assertPositiveInt(args.amountSats, 'amountSats');
    this.assertPositiveInt(args.intervalBlocks, 'intervalBlocks');

    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const functionArgs = [
      bufferCV(idBuf),
      standardPrincipalCV(args.merchant),
      standardPrincipalCV(args.subscriber),
      uintCV(args.amountSats),
      uintCV(args.intervalBlocks),
    ];
    return this.baseCall('create-subscription', functionArgs);
  }

  buildPaySubscription(args: {
    idHex: string;
    amountSats: number;
    subscriber: string;
    merchant: string;
  }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    this.assertPositiveInt(args.amountSats, 'amountSats');
    void standardPrincipalCV(args.subscriber);
    void standardPrincipalCV(args.merchant);

    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const pcs = this.pcc.forPay(args.subscriber, args.merchant, args.amountSats);
    const functionArgs = [bufferCV(idBuf)];
    return this.baseCall('pay-subscription', functionArgs, pcs);
  }

  buildCancelSubscription(args: { idHex: string }): UnsignedContractCall {
    this.codec.assertHex64(args.idHex);
    const idBuf = this.codec.toBuff32Hex(args.idHex);
    const functionArgs = [bufferCV(idBuf)];
    return this.baseCall('cancel-subscription', functionArgs);
  }

  buildRegisterMerchant(args: { merchant: string; name?: string }): UnsignedContractCall {
    const merchantCv = standardPrincipalCV(args.merchant);
    const nameOpt = this.opt34.encodeOptionalUtf8ToBuff34(args.name);
    const functionArgs = [merchantCv, nameOpt];
    return this.baseCall('register-merchant', functionArgs);
  }

  buildSetMerchantActive(args: { merchant: string; active: boolean }): UnsignedContractCall {
    const merchantCv = standardPrincipalCV(args.merchant);
    const activeCv = args.active ? trueCV() : falseCV();
    const functionArgs = [merchantCv, activeCv];
    return this.baseCall('set-merchant-active', functionArgs);
  }

  buildSetSbtcToken(args: {
    contractAddress: string;
    contractName: string;
  }): UnsignedContractCall {
    const cp = contractPrincipalCV(args.contractAddress, args.contractName);
    const functionArgs = [cp];
    return this.baseCall('set-sbtc-token', functionArgs);
  }

  buildBootstrapAdmin(): UnsignedContractCall {
    return this.baseCall('bootstrap-admin', []);
  }

  private baseCall(
    functionName: string,
    functionArgs: any[],
    pcs?: { postConditionMode: 'deny'; postConditions: any[] }
  ): UnsignedContractCall {
    const { contractAddress, contractName } = this.cfg.getContractId();
    const base: UnsignedContractCall = {
      contractAddress,
      contractName,
      functionName,
      functionArgs,
      network: this.cfg.getNetwork(),
      anchorMode: 'any',
    };
    if (pcs) {
      base.postConditionMode = pcs.postConditionMode;
      base.postConditions = pcs.postConditions;
    }
    return base;
  }

  private assertPositiveInt(n: number, name: string): void {
    if (!Number.isInteger(n) || n <= 0) {
      throw new TypeError(`${name} must be a positive integer`);
    }
  }

  private assertNonNegativeInt(n: number, name: string): void {
    if (!Number.isInteger(n) || n < 0) {
      throw new TypeError(`${name} must be a non-negative integer`);
    }
  }
}


---
# ./bootstrap/ApplicationBootstrapper.ts

// src/bootstrap/ApplicationBootstrapper.ts
import path from 'path';
import express, { Express } from 'express';
import 'dotenv/config';

process.on('uncaughtException', (err) => {
  console.error('[FATAL] uncaughtException:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('[FATAL] unhandledRejection:', reason);
});

import { ConfigService } from '../config/ConfigService';
import { openDatabaseAndMigrate } from '../db/SqliteStore';
import { InvoiceIdCodec } from '../utils/InvoiceIdCodec';
import { PricingCache } from '../services/PricingCache';
import { PricingService } from '../services/PricingService';
import { AssetInfoFactory } from '../factories/AssetInfoFactory';
import { PostConditionFactory } from '../factories/PostConditionFactory';
import { StacksChainClient } from '../clients/StacksChainClient';
import { ContractCallBuilder } from '../builders/ContractCallBuilder';
import { WebhookRetryScheduler } from '../webhooks/WebhookRetryScheduler';
import { WebhookDispatcher } from '../webhooks/WebhookDispatcher';
import { ExpirationMonitor } from '../services/ExpirationMonitor';
import { PaymentPoller } from '../poller/PaymentPoller';
import { PollerAdminBridge } from '../poller/PollerAdminBridge';
import { SubscriptionScheduler } from '../schedulers/SubscriptionScheduler';
import { AdminAuth } from '../middleware/AdminAuth';
import { StoreApiAuth } from '../middleware/StoreApiAuth';
import { CrossTenantMask } from '../middleware/CrossTenantMask';
import { CorsPolicy } from '../middleware/CorsPolicy';
import { RateLimitPolicy } from '../middleware/RateLimitPolicy';
import { InvoiceService } from '../services/InvoiceService';
import { RefundService } from '../services/RefundService';
import { SubscriptionService } from '../services/SubscriptionService';
import { PublicApiController } from '../controllers/PublicApiController';
import { MerchantApiController } from '../controllers/MerchantApiController';
import { AdminApiController } from '../controllers/AdminApiController';
import { HealthController } from '../controllers/HealthController';
import { AdminStaticServer } from '../servers/AdminStaticServer';
import { HttpApiServer } from '../server/HttpApiServer';
import type { IConfigService } from '../contracts/interfaces';

function log(step: string, msg: string) {
  console.log(`[BOOT:${step}] ${msg}`);
}

export class ApplicationBootstrapper {
  private serverRef: import('http').Server | null = null;

  public async boot(): Promise<void> {
    log('START', 'startingâ€¦');

    // 1) Config
    const cfg = new ConfigService();
    const net = cfg.getNetwork();
    const { contractAddress, contractName } = cfg.getContractId();
    const poll = cfg.getPollingConfig();
    const avgBlockSecs = cfg.getAvgBlockSecs();
    log('CONFIG', `network=${net}`);
    log('CONFIG', `paymentContract=${contractAddress || '?'}.${contractName || '?'}`);
    // We donâ€™t assume a method for sBTC in ConfigService; log from env if present.
    if (process.env.SBTC_CONTRACT_ADDRESS && process.env.SBTC_CONTRACT_NAME) {
      log(
        'CONFIG',
        `sbtcToken=${process.env.SBTC_CONTRACT_ADDRESS}.${process.env.SBTC_CONTRACT_NAME}`,
      );
    } else {
      log('CONFIG', 'sbtcToken=<unset> (admin must call set-sbtc-token)');
    }
    log(
      'CONFIG',
      `confirmations=${poll.minConfirmations} reorgWindow=${poll.reorgWindowBlocks} pollInterval=${poll.pollIntervalSecs}s avgBlockSecs=${avgBlockSecs}`,
    );

    // 2) Database
    const dbPath = process.env.DB_PATH
      ? String(process.env.DB_PATH)
      : path.join(process.cwd(), 'data.sqlite');
    log('DB', `opening sqlite at ${dbPath}`);
    const store = openDatabaseAndMigrate(dbPath);
    log('DB', 'migrations up-to-date');

    // 3) Core helpers/services
    const codec = new InvoiceIdCodec();
    const corsPolicy = new CorsPolicy();
    corsPolicy.bindStore(store);

    const priceTtlMs = Number(process.env.PRICE_TTL_MS ?? 60_000);
    const pricingCache = new PricingCache(priceTtlMs);
    pricingCache.initCache();
    log('PRICING', `cache TTL = ${priceTtlMs}ms`);

    const pricing = new PricingService();
    pricing.bindDependencies(pricingCache, cfg);

    const aif = new AssetInfoFactory(cfg);
    const pcf = new PostConditionFactory();

    // 4) Chain client
    const chain = new StacksChainClient(cfg);
    log('CHAIN', 'StacksChainClient initialized');

    // 5) Builder
    const builder = new ContractCallBuilder(cfg, aif, pcf, codec);
    log('BUILDER', 'ContractCallBuilder ready');

    // 6) Webhooks / schedulers / poller
    const webhookRetry = new WebhookRetryScheduler();
    const dispatcher = new WebhookDispatcher();
    dispatcher.initCaches();
    dispatcher.bindStoreAndScheduler(store as any, webhookRetry as any);
    webhookRetry.bindDependencies(store as any, dispatcher as any);
    log('WEBHOOK', 'dispatcher + retry scheduler wired');

    const expirations = new ExpirationMonitor();

    const poller = new PaymentPoller();
    poller.bindDependencies(
      chain as any,
      store as any,
      dispatcher as any,
      expirations,
      cfg as IConfigService,
    );
    log('POLLER', 'PaymentPoller bound to deps');

    const pollerBridge = new PollerAdminBridge();
    pollerBridge.bindPoller(poller);

    const subScheduler = new SubscriptionScheduler();
    subScheduler.bindDependencies({
      chain: chain as any,
      builder,
      store: store as any,
      pricing,
      cfg: cfg as IConfigService,
      dispatcher: dispatcher as any,
      codec,
    });
    log('SCHED', 'SubscriptionScheduler wired');

    // 7) Middlewares/policies
    const adminAuth = new AdminAuth();
    adminAuth.bindCredentialsFromEnv(cfg);

    const storeAuth = new StoreApiAuth();
    storeAuth.bindStore(store as any);

    const crossTenant = new CrossTenantMask();


    const rateLimit = new RateLimitPolicy();
    rateLimit.initLimiters();

    // 8) Domain services
    const invService = new InvoiceService();
    invService.bindDependencies({
      store: store as any,
      chain: chain as any,
      builder,
      cfg: cfg as IConfigService,
      pricing,
      codec,
    });

    const refundService = new RefundService();
    refundService.bindDependencies({
      chain: chain as any,
      builder,
      pcf,
      aif,
      codec,
      cfg: cfg as IConfigService,
    });

    const subsService = new SubscriptionService();
    subsService.bindDependencies({
      store: store as any,
      builder,
      chain: chain as any,
      cfg: cfg as IConfigService,
      codec,
      pricing,
    });
    log('DOMAIN', 'Invoice/Refund/Subscription services bound');

    // 9) Controllers / static server
    const publicCtrl = new PublicApiController();
    publicCtrl.bindDependencies({
      store: store as any,
      chain: chain as any,
      builder,
      aif,
      cfg: cfg as IConfigService,
      codec,
    });
    publicCtrl.bindCorsPolicy(corsPolicy as any);

    const merchantCtrl = new MerchantApiController();
    merchantCtrl.bindDependencies({
      store: store as any,
      chain: chain as any,
      builder,
      pricing,
      cfg: cfg as IConfigService,
      codec,
      subs: subsService,
      inv: invService,
      refund: refundService,
    });

    const adminCtrl = new AdminApiController();
    adminCtrl.bindDependencies({
      store: store as any,
      chain: chain as any,
      builder,
      dispatcher: dispatcher as any,
      pollerBridge,
    });

    const healthCtrl = new HealthController();

    const staticServer = new AdminStaticServer();
    const adminStaticRoot = process.env.ADMIN_STATIC_DIR
      ? String(process.env.ADMIN_STATIC_DIR)
      : path.join(process.cwd(), 'admin');
    staticServer.configureStaticDir(adminStaticRoot);
    log('CTRL', `controllers + static server ready (admin dir: ${adminStaticRoot})`);

    // 10) HTTP composition
    const app: Express = express();
    const httpServer = new HttpApiServer();

    httpServer.composeRoutesAndMiddleware(app, {
      publicCtrl,
      merchantCtrl,
      adminCtrl,
      healthCtrl,
      adminAuth,
      storeAuth,
      crossTenantMask: crossTenant,
      rateLimit,
      corsPolicy,
      staticServer,
      webhookVerifier: dispatcher.verifyWebhookSignature.bind(dispatcher),
    });
    log('HTTP', 'routes and middleware composed');

    // 11) Start schedulers/poller & any server-managed services
    await poller.startPoller();
    log('POLLER', 'started');

    // Some HttpApiServer implementations may already bind a port; we handle that safely.
    await httpServer.start({
      app,
      poller,
      webhookRetry,
      subscriptionScheduler: subScheduler,
      config: cfg as IConfigService,
    });
    log('HTTP', 'HttpApiServer.start completed');

    // 12) Listen (single authoritative binding with EADDRINUSE fallback)
    const port = Number(process.env.PORT ?? 3000);
    const host = process.env.HOST ?? '0.0.0.0';

    await this.listenWithFallback(app, port, host);

    log('READY', 'service is up');
  }

  private async listenWithFallback(app: Express, port: number, host: string): Promise<void> {
    try {
      this.serverRef = await new Promise<import('http').Server>((resolve, reject) => {
        const srv = app
          .listen(port, host, () => {
            log('HTTP', `listening on http://${host}:${port}`);
            resolve(srv);
          })
          .on('error', (err: any) => reject(err));
      });
      this.installShutdownHooks();
    } catch (err: any) {
      if (err && err.code === 'EADDRINUSE') {
        log(
          'HTTP',
          `port ${port} already in use â€” assuming HttpApiServer already bound the port; skipping app.listen`,
        );
        this.installShutdownHooks();
        return;
      }
      throw err;
    }
  }

  private installShutdownHooks() {
    const shutdown = async (signal: string) => {
      log('SHUTDOWN', `received ${signal}, closingâ€¦`);
      try {
        if (this.serverRef) {
          await new Promise<void>((resolve) => this.serverRef!.close(() => resolve()));
          log('SHUTDOWN', 'HTTP server closed');
        }
      } catch (e) {
        console.error('[SHUTDOWN] error while closing HTTP server:', e);
      } finally {
        process.exit(0);
      }
    };

    (['SIGINT', 'SIGTERM'] as NodeJS.Signals[]).forEach((sig) => {
      process.on(sig, () => void shutdown(sig));
    });
  }
}

// run when executed directly
(async () => {
  try {
    await new ApplicationBootstrapper().boot();
    log('DONE', 'ready');
  } catch (e) {
    console.error('[BOOT] failed:', e);
    process.exit(1);
  }
})();


---
# ./ALL_FILES.txt



---
# ./validation/rules.ts

// Validation & Constraint Definitions; Error Handling & Fault Tolerance enums/types

export const Validation = {
  idHex64: /^[0-9A-Fa-f]{64}$/,
  url: /^(https?):\/\/[^\s]+$/i,
  colorHex: /^#[0-9A-Fa-f]{6}$/,
  uuid: /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/,
  stacksPrincipal: /^S[^\s]{10,}$/,

  // Rules
  createInvoice: {
    amount_sats: 'integer > 0',
    ttl_seconds: 'integer > 0',
    memoMaxUtf8Bytes: 34,
    webhook_url: 'optional URL',
  },
  refund: {
    invoice_id: 'uuid',
    amount_sats: 'integer > 0',
    memoMaxUtf8Bytes: 34,
    cap: 'refund_amount + request â‰¤ amount_sats',
  },
  subscription: {
    subscriber: 'stacks principal',
    amount_sats: 'integer > 0',
    interval_blocks: 'integer > 0',
    mode: ['invoice', 'direct'],
  },
  publicCreateTxGate: [
    'invoice exists',
    'merchant active',
    'status not in [paid,canceled,expired]',
    'TTL not expired',
    'on-chain status not expired',
    'id_hex valid 64-hex',
    'sBTC token configured',
  ],
  storeProfileUpdate: {
    brand_color: 'optional color hex #RRGGBB',
    allowed_origins: 'CSV string',
  },
} as const;

export type PublicErrorReason =
  | 'notFound'
  | 'invalidId'
  | 'expired'
  | 'invalidState'
  | 'rateLimited'
  | 'missingIdentifier'
  | 'missingSbtcToken';

export type MerchantAdminError =
  | 'rate_limited'
  | 'bad_status'
  | 'not_cancellable'
  | 'already_paid'
  | 'insufficient_balance'
  | 'validation_error';


---
# ./contracts/concurrency.ts

// ../contracts/concurrency.ts

// Concurrency & Synchronization Handling

/**
 * Single-flight guard to prevent re-entrant execution within a processing tick.
 * Returns false if an operation is already running and should be skipped.
 */
export interface ReentrancyGuard {
  guardReentrancy(): boolean;
}

/**
 * In-flight de-duplication for retryable operations (e.g., webhooks).
 * Key represents a logical context (storeId + invoiceId/subscriptionId + eventType).
 */
export interface RetryDeduper {
  isInflight(key: string): boolean;
  markInflight(key: string): void;
  clearInflight(key: string): void;
}

// Error Handling & Fault Tolerance

/**
 * Webhook retry backoff and attempt cap policy.
 * maxAttempts is a literal type of 5 to encode the fixed cap.
 */
export interface WebhookRetryPolicy {
  maxAttempts: 5;
  backoffSeconds: number[]; // e.g., [0, 60, 120, 240, 480, 960]
}

/**
 * Resilience configuration for the payment poller.
 * minConfirmations and reorgWindowBlocks come from configuration.
 * singleFlightPerTick is a literal true, enforcing reentrancy prevention per tick.
 */
export interface PollerResilience {
  minConfirmations: number;
  reorgWindowBlocks: number;
  singleFlightPerTick: true;
}


---
# ./contracts/interfaces.ts

// src/contracts/interfaces.ts
import type {
  OnChainSubscription,
  UnsignedContractCall,
  WebhookEventType,
} from './domain';

export interface IStacksChainClient {
  callReadOnly(fn: string, args: any[]): Promise<any>;
  readInvoiceStatus(
    idHex: string,
  ): Promise<'not-found' | 'paid' | 'canceled' | 'expired' | 'unpaid'>;
  readSbtcToken(): Promise<{ contractAddress: string; contractName: string } | undefined>;
  readSubscription(idHex: string): Promise<OnChainSubscription | undefined>;
  getTip(): Promise<{ height: number; blockHash: string }>;
  getTipHeight(): Promise<number>;
  getFungibleBalance(
    assetContract: { contractAddress: string; contractName: string },
    principal: string,
  ): Promise<bigint>;
  getContractCallEvents(params: { fromHeight: number }): Promise<any[]>;
  getBlockHeader(
    height: number,
  ): Promise<{ parent_block_hash: string; block_hash: string }>;
}

export interface IContractCallBuilder {
  buildCreateInvoice(args: {
    idHex: string;
    amountSats: number;
    memo?: string;
    expiresAtBlock?: number;
  }): UnsignedContractCall;

  buildRefundInvoice(args: {
    idHex: string;
    amountSats: number;
    memo?: string;
    merchantPrincipal: string;
  }): UnsignedContractCall;

  buildPayInvoice(args: {
    idHex: string;
    amountSats: number;
    payerPrincipal: string;
    merchantPrincipal: string;
  }): UnsignedContractCall;

  buildCancelInvoice(args: { idHex: string }): UnsignedContractCall;

  buildCreateSubscription(args: {
    idHex: string;
    merchant: string;
    subscriber: string;
    amountSats: number;
    intervalBlocks: number;
  }): UnsignedContractCall;

  buildPaySubscription(args: {
    idHex: string;
    amountSats: number;
    subscriber: string;
    merchant: string;
  }): UnsignedContractCall;

  buildCancelSubscription(args: { idHex: string }): UnsignedContractCall;

  buildRegisterMerchant(args: { merchant: string; name?: string }): UnsignedContractCall;

  buildSetMerchantActive(args: {
    merchant: string;
    active: boolean;
  }): UnsignedContractCall;

  buildSetSbtcToken(args: {
    contractAddress: string;
    contractName: string;
  }): UnsignedContractCall;

  buildBootstrapAdmin(): UnsignedContractCall;
}

export interface IAssetInfoFactory {
  getSbtcAssetInfo(): {
    contractAddress: string;
    contractName: string;
    assetName: string;
  };
}

export interface IPostConditionFactory {
  forPayInvoice(
    payer: string,
    merchant: string,
    amountSats: number,
    asset: any,
  ): any[];
  forRefund(merchant: string, amountSats: number, asset: any): any[];
}

export interface IInvoiceIdCodec {
  assertHex64(idHex: string): void;
  isValidHex64(idHex: string): boolean;
  toBuff32Hex(idHex: string): Uint8Array;
  hexFromBuff32(buf: Uint8Array): string;
  generateRandomBuff32Hex(): string;
}

export interface IConfigService {
  getNetwork(): 'mainnet' | 'testnet' | 'devnet';
  getContractId(): { contractAddress: string; contractName: string };
  getSbtcContractId():
    | { contractAddress: string; contractName: string }
    | undefined;
  getPollingConfig(): {
    minConfirmations: number;
    reorgWindowBlocks: number;
    pollIntervalSecs: number;
  };
  getAvgBlockSecs(): number;
  getPriceApiUrl(): string | undefined;
  isAutoBroadcastEnabled(): boolean;
}

export interface IWebhookDispatcher {
  dispatch(ctx: {
    storeId: string;
    invoiceId?: string;
    subscriptionId?: string;
    eventType: WebhookEventType;
    rawBody: string;
    attempts?: number;
  }): Promise<void>;
}

export interface IWebhookRetryScheduler {
  enqueueRetry(ctx: {
    storeId: string;
    invoiceId?: string;
    subscriptionId?: string;
    eventType: WebhookEventType;
    rawBody: string;
    attempts: number;
  }): void;
}


---
# ./contracts/state.ts

// src/contracts/state.ts

import type { PollerMetrics } from './domain';

// Global state access for poller metrics and control
export interface IPollerState {
  getMetrics(): PollerMetrics;
}

export interface IPollerControl {
  restart(): { running: boolean };
}

// Immutable configuration snapshot
export interface IConfigSnapshot {
  network: 'mainnet' | 'testnet' | 'devnet';
  contractAddress: string;
  contractName: string;
  sbtcContract?: { contractAddress: string; contractName: string };
  avgBlockSecs: number;
  minConfirmations: number;
  reorgWindowBlocks: number;
  pollIntervalSecs: number;
  priceApiUrl?: string;
  autoBroadcast: boolean;
}


---
# ./contracts/dao.ts

// src/contracts/dao.ts
import {
  MerchantRow,
  InvoiceRow,
  SubscriptionRow,
  WebhookLogRow,
  InvoiceStatus,
  WebhookEventType,
  SubscriptionMode,
} from '../contracts/domain';

export interface ISqliteStore {
  migrate(): void;

  // Merchants
  findActiveByApiKey(apiKey: string): MerchantRow | undefined;
  insertMerchant(row: MerchantRow): void;
  updateMerchantActive(storeId: string, active: boolean): number;
  updateMerchantKeysTx(storeId: string, apiKey: string, hmacSecret: string): void;
  listMerchantsProjection(): Omit<MerchantRow, 'api_key' | 'hmac_secret'>[];
  rotateKeysPersist(storeId: string, apiKey: string, hmacSecret: string, now: number):number;
  markKeysRevealedOnce(storeId: string, expectVersion: number, now: number):boolean;
  getMerchantById(storeId: string): MerchantRow | undefined;
  updateMerchantProfile(
    storeId: string,
    patch: Partial<Pick<
      MerchantRow,
      | 'name'
      | 'display_name'
      | 'logo_url'
      | 'brand_color'
      | 'webhook_url'
      | 'support_email'
      | 'support_url'
      | 'allowed_origins'
    >>
  ): void;
  
  // Invoices
  invoices: {
    insert(row: InvoiceRow): void;
    findByStoreAndIdRaw(storeId: string, idRaw: string): InvoiceRow | undefined;
  };
  getInvoiceById(idRaw: string): InvoiceRow | undefined;
  getInvoiceWithStore(idRaw: string): (InvoiceRow & { store: MerchantRow }) | undefined;
  listInvoicesByStore(
    storeId: string,
    opts?: { status?: InvoiceStatus; orderByCreatedDesc?: boolean },
  ): InvoiceRow[];
  markInvoicePaid(idHex: string, payer: string, txId: string, tx?: unknown): void;
  upsertInvoiceRefund(idHex: string, amountSats: number, refundTxId: string, tx?: unknown): void;
  markInvoiceCanceled(idHexOrIdRaw: string, tx?: unknown): void;
  updateInvoiceStatus(idRaw: string, status: InvoiceStatus, expired?: 0 | 1): void;
  ensureInvoiceIdHexUnique(idHex: string): boolean;
  invoiceExists(idHex: string): boolean;
  bulkMarkExpired(idRawList: string[]): number;

  // Subscriptions
  insertSubscription(row: SubscriptionRow): void;
  getSubscriptionByIdForStore(id: string, storeId: string): SubscriptionRow | undefined;
  getActiveSubscription(id: string, storeId: string): SubscriptionRow | undefined;
  updateSubscriptionMode(id: string, storeId: string, mode: SubscriptionMode): void;
  deactivateSubscription(id: string, storeId: string, tx?: unknown): void;
  setSubscriptionActive(input: { idHex: string; active: 0 | 1 }): void;
  upsertSubscriptionByHex(input: {
    idHex: string;
    storeId: string;
    merchantPrincipal: string;
    subscriber: string;
    amountSats: number;
    intervalBlocks: number;
    active: 1;
  }): void;
  advanceSubscriptionSchedule(id: string): void;
  updateSubscriptionLastPaid(input: { subscriptionId: string; lastPaidInvoiceId: string }): void;
  subscriptionExists(idHex: string): boolean;
  selectDueSubscriptions(currentHeight: number): SubscriptionRow[];
  getStoreIdByPrincipal(merchantPrincipal: string): string | undefined;

  // Webhooks
  insertWebhookAttempt(row: WebhookLogRow): string;
  updateWebhookAttemptStatus(id: string, patch: { success: 0 | 1; statusCode?: number }): void;
  listWebhooksForStore(storeId: string): WebhookLogRow[];
  listAdminWebhooks(storeId?: string, failedOnly?: boolean): WebhookLogRow[];
  getWebhookLogById(id: string): WebhookLogRow | undefined;
  existsSuccessfulDeliveryFor(ctx: {
    storeId: string;
    invoiceId?: string;
    subscriptionId?: string;
    eventType: WebhookEventType;
  }): boolean;
  selectDueWebhookRetries(): WebhookLogRow[];
  getDueWebhookAttempts(nowEpochSecs: number): WebhookLogRow[];

  // Admin queries
  selectAdminInvoices(statuses?: InvoiceStatus[], storeId?: string): InvoiceRow[];

  // Optional cursor persistence
  getPollerCursor():
    | { lastRunAt: number; lastHeight: number; lastTxId?: string; lastBlockHash?: string }
    | null;
  savePollerCursor(cursor: {
    lastRunAt: number;
    lastHeight: number;
    lastTxId?: string;
    lastBlockHash?: string;
  }): void;
}


---
# ./contracts/domain.ts

// src/contracts/domain.ts

// Enums
export type InvoiceStatus =
  | 'unpaid'
  | 'paid'
  | 'partially_refunded'
  | 'refunded'
  | 'canceled'
  | 'expired';

export type WebhookEventType =
  | 'paid'
  | 'refunded'
  | 'subscription'
  | 'subscription-created'
  | 'subscription-paid'
  | 'subscription-canceled'
  | 'invoice-expired'
  | 'invoice-canceled';

export type SubscriptionMode = 'invoice' | 'direct';

// On-chain mirrors (read-only DTOs)
export interface OnChainInvoice {
  idHex: string; // 64-hex for (buff 32)
  merchant: string; // principal
  amountSats: bigint;
  memo?: string; // â‰¤34 bytes utf8
  expiresAt?: bigint; // block height
  paid: boolean;
  canceled: boolean;
  refundAmountSats: bigint;
  payer?: string; // principal
}

export interface OnChainSubscription {
  idHex: string; // 64-hex
  merchant: string;
  subscriber: string;
  amountSats: bigint;
  intervalBlocks: bigint;
  active: boolean;
  nextDue: bigint;
}

export interface OnChainAdminState {
  admin?: string; // principal
  sbtcToken?: { contractAddress: string; contractName: string };
}

// SQLite rows (snake_case)
export interface MerchantRow {
  id: string;
  principal: string;
  name?: string;
  display_name?: string;
  logo_url?: string;
  brand_color?: string;
  webhook_url?: string;
  hmac_secret: string;
  api_key: string;
  active: number;              // 0/1
  support_email?: string;
  support_url?: string;
  allowed_origins?: string;    // CSV
  created_at: number;          // seconds

  // new rotation columns (persisted â€œshown onceâ€ guard)
  keys_rotation_version: number;       // NOT NULL DEFAULT 0
  keys_last_rotated_at?: number | null;
  keys_last_revealed_at?: number | null;
  keys_dual_valid_until?: number | null;
}

export interface InvoiceRow {
  id_raw: string;
  id_hex: string; // 64-hex, CHECK enforced
  store_id: string;
  amount_sats: number;
  usd_at_create: number;
  quote_expires_at: number; // ms
  merchant_principal: string;
  status: InvoiceStatus;
  payer?: string;
  txid?: string;
  memo?: string;
  webhook_url?: string;
  created_at: number; // seconds
  refunded_at?: number;
  refund_amount: number;
  refund_txid?: string;
  subscription_id?: string;
  refund_count: number;
  expired: number; // 0/1
}

export interface SubscriptionRow {
  id: string;
  id_hex: string; // 64-hex
  store_id: string;
  merchant_principal: string;
  subscriber: string;
  amount_sats: number;
  interval_blocks: number;
  active: number; // 0/1
  created_at: number;
  last_billed_at?: number;
  next_invoice_at: number; // block height
  last_paid_invoice_id?: string;
  mode: SubscriptionMode;
}

export interface WebhookLogRow {
  id: string;
  store_id: string;
  invoice_id?: string;
  subscription_id?: string;
  event_type: WebhookEventType;
  payload: string; // raw JSON
  status_code?: number;
  success: number; // 0/1
  attempts: number;
  last_attempt_at: number; // seconds
}

// Public DTOs (camelCase)
export interface PublicInvoiceDTO {
  invoiceId: string;
  idHex: string;
  storeId: string;
  amountSats: number;
  usdAtCreate: number;
  quoteExpiresAt: number; // ms
  merchantPrincipal: string;
  status: InvoiceStatus;
  payer?: string;
  txId?: string;
  memo?: string;
  subscriptionId?: string;
  createdAt: number; // seconds
  refundAmount?: number;
  refundTxId?: string;
  store?: StorePublicProfileDTO;
}

export interface StorePublicProfileDTO {
  displayName: string | null;
  logoUrl: string | null;
  brandColor: string | null;
  supportEmail: string | null;
  supportUrl: string | null;
}

export interface StorePrivateProfileDTO extends StorePublicProfileDTO {
  id: string;
  name?: string;
  webhookUrl?: string;
  allowedOrigins: string[];
  principal: string;
  active: boolean;
}

export interface AdminPollerStatusDTO {
  running: boolean;
  lastRunAt?: number;
  lastHeight?: number;
  lastTxId?: string;
  lastBlockHash?: string;
  lagBlocks?: number;
}

// Unsigned contract-call payload
export interface UnsignedContractCall {
  contractAddress: string;
  contractName: string;
  functionName: string;
  functionArgs: any[]; // Clarity CV descriptors
  postConditionMode?: 'deny' | 'allow';
  postConditions?: any[];
  anchorMode?: 'any' | 'onChainOnly' | 'offChainOnly';
  network: 'mainnet' | 'testnet' | 'devnet';
}

// Poller telemetry
export interface PollerMetrics {
  running: boolean;
  lastRunAt?: number;
  lastHeight?: number;
  lastTxId?: string;
  lastBlockHash?: string;
  lagBlocks?: number;
}

// Normalized chain event (for internal processing)
export type NormalizedEventType =
  | 'invoice-paid'
  | 'refund-invoice'
  | 'invoice-canceled'
  | 'create-subscription'
  | 'cancel-subscription'
  | 'pay-subscription';

export interface NormalizedEvent {
  type: NormalizedEventType;
  idHex: string;
  block_height: number;
  tx_id: string;
  tx_index: number;
  sender?: string;
  merchantPrincipal?: string;
  subscriber?: string;
  amountSats?: number;
  intervalBlocks?: number;
  refundAmountSats?: number;
}

// Outbound webhook payloads (camelCase JSON)
export type InvoicePaidEvent = {
  invoiceId: string;
  status: 'paid';
  txId: string;
  payer: string;
  amountSats: number;
};

export type InvoiceRefundedEvent = {
  invoiceId: string;
  status: 'refunded';
  refundTxId: string;
  refundAmount: number;
};

export type SubscriptionInvoiceCreatedEvent = {
  subscriptionId: string;
  invoiceId: string;
  amountSats: number;
  nextDue: number;
  subscriber: string;
};

export type SubscriptionCreatedEvent = {
  subscriptionId: string;
  merchant: string;
  subscriber: string;
  amountSats: number;
  intervalBlocks: number;
  nextDue: number;
};

export type SubscriptionPaidEvent = {
  subscriptionId: string;
  subscriber: string;
  amountSats: number;
  txId: string;
  nextDue: number;
};

export type SubscriptionCanceledEvent = {
  subscriptionId: string;
};

export type InvoiceExpiredEvent = {
  invoiceId: string;
  status: 'expired';
};

export type InvoiceCanceledEvent = {
  invoiceId: string;
};


---
# ./misc/ComponentName.ts

export class ComponentName {}


---
# ./controllers/HealthController.ts

import type { Request, Response } from 'express';

export class HealthController {
  public getRoot(_req: Request, res: Response): void {
    res.status(200).send('OK');
  }
}


---
# ./controllers/PublicApiController.ts

// src/controllers/PublicApiController.ts
import type { Request, Response } from 'express';
import type { ISqliteStore } from '../contracts/dao';
import type {
  IStacksChainClient,
  IContractCallBuilder,
  IAssetInfoFactory,
  IConfigService,
  IInvoiceIdCodec,
} from '../contracts/interfaces';
import type { PublicInvoiceDTO } from '../contracts/domain';
import { InvoiceIdGuard } from '../delegates/InvoiceIdGuard';
import { InvoiceStatusResolver } from '../delegates/InvoiceStatusResolver';
import { StorePublicProfileProjector } from '../delegates/StorePublicProfileProjector';
import { PayInvoiceTxAssembler, HttpError } from '../delegates/PayInvoiceTxAssembler';

const HttpStatusMap = {
  invalidPayload: 400,
  notFound: 404,
  conflict: 409,
  unprocessable: 422,
  upgradeRequired: 426,
} as const;

const PublicErrors = {
  notFound: { error: 'notFound' },
  invalidId: { error: 'invalidId' },
  expired: { error: 'expired' },
  invalidState: { error: 'invalidState' },
  missingIdentifier: { error: 'missingIdentifier' },
  missingSbtcToken: { error: 'missingSbtcToken' },
} as const;

const NonPayableStatuses = new Set([
  'paid',
  'canceled',
  'expired',
  'refunded',
  'partially_refunded',
]);

export class PublicApiController {
  private store!: ISqliteStore;
  private chain!: IStacksChainClient;
  private builder!: IContractCallBuilder;
  private aif!: IAssetInfoFactory;
  private cfg!: IConfigService;
  private codec!: IInvoiceIdCodec;

  private idGuard!: InvoiceIdGuard;
  private statusResolver!: InvoiceStatusResolver;
  private profileProjector!: StorePublicProfileProjector;
  private txAssembler!: PayInvoiceTxAssembler;

  private cors: any;

  bindDependencies(deps: {
    store: ISqliteStore;
    chain: IStacksChainClient;
    builder: IContractCallBuilder;
    aif: IAssetInfoFactory;
    cfg: IConfigService;
    codec: IInvoiceIdCodec;
  }): void {
    this.store = deps.store;
    this.chain = deps.chain;
    this.builder = deps.builder;
    this.aif = deps.aif;
    this.cfg = deps.cfg;
    this.codec = deps.codec;

    this.idGuard = new InvoiceIdGuard(this.codec);
    this.statusResolver = new InvoiceStatusResolver(this.chain, this.idGuard as any);
    this.profileProjector = new StorePublicProfileProjector();
    this.txAssembler = new PayInvoiceTxAssembler(
      this.builder,
      this.aif,
      this.cfg,
      this.chain,
      this.idGuard,
      NonPayableStatuses,
    );
  }

  bindCorsPolicy(corsMwFactory: any): void {
    this.cors = corsMwFactory;
  }

  async getInvoice(req: Request, res: Response): Promise<void> {
    const idRaw = req.params.invoiceId;
    const row = this.store.getInvoiceWithStore(idRaw);
    if (!row) {
      res.status(HttpStatusMap.notFound).json(PublicErrors.notFound);
      return;
    }

    try {
      this.idGuard.validateHexIdOrThrow(row.id_hex);
    } catch {
      res.status(HttpStatusMap.invalidPayload).json(PublicErrors.invalidId);
      return;
    }

    const onchain = await this.statusResolver.readOnchainStatus(row.id_hex);
    const status = this.statusResolver.computeDisplayStatus(
      { id_hex: row.id_hex, status: row.status as any, quote_expires_at: row.quote_expires_at },
      onchain as any,
      Date.now(),
    );

    const storeProfile = this.profileProjector.project(row.store as any);
    const dto: PublicInvoiceDTO = {
      invoiceId: row.id_raw,
      idHex: row.id_hex,
      storeId: row.store_id,
      amountSats: row.amount_sats,
      usdAtCreate: row.usd_at_create,
      quoteExpiresAt: row.quote_expires_at,
      merchantPrincipal: row.merchant_principal,
      status: status as any,
      payer: row.payer ?? undefined,
      txId: row.txid ?? undefined,
      memo: row.memo ?? undefined,
      subscriptionId: row.subscription_id ?? undefined,
      createdAt: row.created_at,
      refundAmount: row.refund_amount ? row.refund_amount : undefined,
      refundTxId: row.refund_txid ?? undefined,
      store: storeProfile,
    };

    res.json(dto);
  }

  async createTx(req: Request, res: Response): Promise<void> {
    const body = (req.body as any) || {};
    const invoiceId = body.invoiceId ? String(body.invoiceId) : '';
    const payerPrincipal = body.payerPrincipal ? String(body.payerPrincipal) : undefined;

    if (!invoiceId) {
      res.status(HttpStatusMap.invalidPayload).json(PublicErrors.missingIdentifier);
      return;
    }

    const row = this.store.getInvoiceWithStore(invoiceId);
    if (!row) {
      res.status(HttpStatusMap.notFound).json(PublicErrors.notFound);
      return;
    }

    try {
      const payload = await this.txAssembler.buildUnsignedPayInvoice(row as any, payerPrincipal);
      res.json(payload);
    } catch (e: any) {
      if (e instanceof HttpError) {
        if (e.code === 'merchant-inactive') {
          res.status(e.status).json(PublicErrors.invalidState);
        } else if (e.code === 'expired') {
          res.status(e.status).json(PublicErrors.expired);
        } else if (e.code === 'missing-token') {
          res.status(e.status).json(PublicErrors.missingSbtcToken);
        } else if (e.code === 'invalid-id') {
          res.status(e.status).json(PublicErrors.invalidId);
        } else {
          res.status(HttpStatusMap.conflict).json(PublicErrors.invalidState);
        }
        return;
      }
      res.status(HttpStatusMap.conflict).json(PublicErrors.invalidState);
    }
  }

  async getStorePublicProfile(req: Request, res: Response): Promise<void> {
    const storeId = req.params.storeId;
    const rows = this.store.listMerchantsProjection() as any[];
    const m = rows.find((r) => r.id === storeId);
    if (!m) {
      res.status(HttpStatusMap.notFound).json(PublicErrors.notFound);
      return;
    }
    const profile = this.profileProjector.project(m);
    res.json(profile);
  }
}


---
# ./controllers/AdminApiController.ts

// src/controllers/AdminApiController.ts
import type { Request, Response } from 'express';
import type { ISqliteStore } from '../contracts/dao';
import { randomBytes } from "node:crypto";
import type {
  IStacksChainClient,
  IContractCallBuilder,
  IWebhookDispatcher,
} from '../contracts/interfaces';
import { PollerAdminBridge } from '../poller/PollerAdminBridge';
import { AdminParamGuard } from '../delegates/AdminParamGuard';
import { AdminDtoProjector } from '../delegates/AdminDtoProjector';
import { MerchantKeyRotationService } from '../delegates/MerchantKeyRotationService';
import { MerchantOnchainSyncPlanner } from '../delegates/MerchantOnchainSyncPlanner';
import { WebhookAdminRetryService } from '../delegates/WebhookAdminRetryService';
import { MerchantCreationService } from '../delegates/MerchantCreationService';
import type { InvoiceStatus } from '../contracts/domain';

type Deps = {
  store: ISqliteStore;
  chain: IStacksChainClient;
  builder: IContractCallBuilder;
  dispatcher: IWebhookDispatcher;
  pollerBridge: PollerAdminBridge;
};

export class AdminApiController {
  private store!: ISqliteStore;
  private chain!: IStacksChainClient;
  private builder!: IContractCallBuilder;
  private dispatcher!: IWebhookDispatcher;
  private pollerBridge!: PollerAdminBridge;

  private readonly paramGuard = new AdminParamGuard();
  private readonly projector = new AdminDtoProjector();
  private readonly keyRotation = new MerchantKeyRotationService();
  private readonly syncPlanner = new MerchantOnchainSyncPlanner();
  private readonly webhookRetry = new WebhookAdminRetryService();
  private readonly merchantCreation = new MerchantCreationService();

  bindDependencies(deps: Deps): void {
    this.store = deps.store;
    this.chain = deps.chain;
    this.builder = deps.builder;
    this.dispatcher = deps.dispatcher;
    this.pollerBridge = deps.pollerBridge;
  }

  async createStore(req: Request, res: Response): Promise<void> {
    try {
      const body = (req.body && typeof req.body === 'object') ? req.body : {};
      const principal = String(body.principal ?? '').trim();
      if (!principal) {
        res.status(400).json({ error: 'principal-required' });
        return;
      }
      try {
        this.paramGuard.assertStacksPrincipal(principal);  // format check (SPâ€¦ or STâ€¦)
      } catch {
        res.status(400).json({ error: 'principal-invalid' });
        return;
      }
      const result = await this.merchantCreation.create(this.store, { ...body, principal });
      if (result.status === 'conflict') {
        res.status(409).end();
        return;
      }
      res.status(201).json(result.dto);
    } catch (err: any) {
      const msg = String(err?.message || "");
      // Handle re-runs: UNIQUE(principal) constraint â†’ return HTTP 409 (idempotent create)
      if (err?.code === "SQLITE_CONSTRAINT_UNIQUE" && msg.includes("merchants.principal")) {
        res.status(409).json({ error: "principal-already-exists" });
        return;
      }
      // Not a duplicate-principal error â†’ let your global error middleware handle it
      throw err;
    }
  }

  async listStores(_req: Request, res: Response): Promise<void> {
    const rows = this.store.listMerchantsProjection();
    res.json(rows.map((r) => this.projector.merchantToDto(r)));
  }


// POST /api/admin/stores/:storeId/rotate-keys
async rotateKeys(req: Request, res: Response): Promise<void> {
  const storeId = String(req.params.storeId ?? '');
  const m = this.store.getMerchantById(storeId);
  if (!m) { res.status(404).json({ error: 'store-not-found' }); return; }

  const now = Math.floor(Date.now() / 1000);

  // Guard: do NOT rotate again immediately â†’ prevents re-exposure on a 2nd call
  // (tune the 60s if you need a different idempotency window)
  const lastRotated = m.keys_last_rotated_at ?? 0;
  if (now - lastRotated < 60) {
    res.status(409).json({ error: 'already-rotated' });
    return;
  }

  // Generate fresh secrets
  const apiKey = randomBytes(32).toString('hex');
  const hmacSecret = randomBytes(32).toString('hex');

  // Persist: bump version + timestamp
  const version = this.store.rotateKeysPersist(storeId, apiKey, hmacSecret, now);

  // One-time reveal for this version
  const marked = this.store.markKeysRevealedOnce(storeId, version, now);
  if (!marked) {
    res.status(409).json({ error: 'already-revealed' });
    return;
  }

  res.status(200).json({ apiKey, hmacSecret });
}



  async syncOnchain(req: Request, res: Response): Promise<void> {
    const storeId = String(req.params.storeId);
    this.paramGuard.assertUuid(storeId);
    const result = await this.syncPlanner.planForStore(this.store, this.chain, this.builder, storeId);
    if ('notFound' in result) {
      res.status(404).end();
      return;
    }
    res.json({ calls: result.calls });
  }

  async setSbtcToken(req: Request, res: Response): Promise<void> {
    const body = (req.body || {}) as { contractAddress?: string; contractName?: string };
    const contractAddress = String(body.contractAddress ?? '');
    const contractName = String(body.contractName ?? '');
    this.paramGuard.assertStacksPrincipal(contractAddress);
    if (!contractName) {
      res.status(400).end();
      return;
    }
    const call = this.builder.buildSetSbtcToken({ contractAddress, contractName });
    res.json({ call });
  }

  async cancelInvoice(req: Request, res: Response): Promise<void> {
    const invoiceId = String(req.params.invoiceId);
    this.paramGuard.assertUuid(invoiceId);
    const row = this.store.getInvoiceById(invoiceId);
    if (!row) {
      res.status(404).end();
      return;
    }
    if (row.status === 'paid') {
      res.status(400).json({ error: 'already_paid' });
      return;
    }
    this.store.updateInvoiceStatus(invoiceId, 'canceled');
    res.json({ canceled: true, invoiceId });
  }

  async activateStore(req: Request, res: Response): Promise<void> {
    const storeId = String(req.params.storeId);
    this.paramGuard.assertUuid(storeId);
    const active = !!(req.body && (req.body as any).active);
    this.store.updateMerchantActive(storeId, active);
    const rows = this.store.listMerchantsProjection();
    const m = rows.find((r) => r.id === storeId);
    res.json(m ? this.projector.merchantToDto(m) : undefined);
  }

  async listAdminInvoices(req: Request, res: Response): Promise<void> {
    const statuses = this.paramGuard.parseInvoiceStatuses(req.query.status as any);
    const storeId = req.query.storeId ? String(req.query.storeId) : undefined;
    if (storeId) this.paramGuard.assertUuid(storeId);
    const rows = this.store.selectAdminInvoices(
      statuses.length ? (statuses as any) : undefined,
      storeId,
    );
    res.json(rows.map((r) => this.projector.invoiceToDto(r)));
  }

  async retryWebhook(req: Request, res: Response): Promise<void> {
    const body = (req.body || {}) as { webhookLogId?: string };
    const webhookLogId = String(body.webhookLogId ?? '');
    this.paramGuard.assertUuid(webhookLogId);
    const outcome = await this.webhookRetry.retry(this.store, this.dispatcher, webhookLogId);
    if (outcome.type === 'not-found') {
      res.status(404).end();
      return;
    }
    if (outcome.type === 'already-delivered') {
      res.status(200).json({ alreadyDelivered: true });
      return;
    }
    res.status(202).json({ enqueued: outcome.enqueued });
  }

  async getPoller(_req: Request, res: Response): Promise<void> {
    const s = this.pollerBridge.getState();
    res.json({
      running: !!s.running,
      lastRunAt: s.lastRunAt ?? null,
      lastHeight: s.lastHeight ?? 0,
      lastTxId: s.lastTxId ?? null,
      lagBlocks: s.lagBlocks ?? null,
    });
  }

  async restartPoller(_req: Request, res: Response): Promise<void> {
    const out = this.pollerBridge.restart();
    res.json(out);
  }

  async listWebhooks(req: Request, res: Response): Promise<void> {
    const q = (req.query || {}) as { storeId?: string; status?: string };
    const storeId = q.storeId ? String(q.storeId) : undefined;
    if (storeId) this.paramGuard.assertUuid(storeId);
    const failedOnly = String(q.status ?? 'all') === 'failed';
    const rows = this.store.listAdminWebhooks(storeId, failedOnly);
    res.json(rows.map((w) => this.projector.webhookToDto(w)));
  }

  async listInvoices(req: Request, res: Response): Promise<void> {
    const storeId = String((req.query || {}).storeId ?? '');
    if (!storeId) { res.json([]); return; }
    this.paramGuard.assertUuid(storeId);

    const rawStatus = String((req.query || {}).status ?? '').trim();
    const status = (rawStatus ? (rawStatus as InvoiceStatus) : undefined);

    const rows = this.store.listInvoicesByStore(storeId, {
      status,
      orderByCreatedDesc: true,
    });

    res.json(rows.map(r => this.projector.invoiceToDto(r)));
  }

}


---
# ./controllers/MerchantApiController.ts

// src/controllers/MerchantApiController.ts
import type { Request, Response } from 'express';
import crypto from 'crypto';
import type { ISqliteStore } from '../contracts/dao';
import type {
  IStacksChainClient,
  IContractCallBuilder,
  IConfigService,
  IInvoiceIdCodec,
} from '../contracts/interfaces';
import { PricingService } from '../services/PricingService';
import { InvoiceService } from '../services/InvoiceService';
import { SubscriptionService } from '../services/SubscriptionService';
import RefundService from '../services/RefundService';
import { ApiCaseAndDtoMapper } from '../delegates/ApiCaseAndDtoMapper';
import { MerchantInputValidator } from '../delegates/MerchantInputValidator';
import { RefundPolicyGuard } from '../delegates/RefundPolicyGuard';
import { DirectSubscriptionPaymentTxBuilder } from '../delegates/DirectSubscriptionPaymentTxBuilder';
import { Validation } from '../validation/rules';
import type {
  MerchantRow,
  InvoiceRow,
  SubscriptionRow,
  InvoiceStatus,
} from '../contracts/domain';

type AuthedRequest = Request & { store: MerchantRow };

export class MerchantApiController {
  private store!: ISqliteStore;
  private chain!: IStacksChainClient;
  private builder!: IContractCallBuilder;
  private pricing!: PricingService;
  private cfg!: IConfigService;
  private codec!: IInvoiceIdCodec;
  private subs!: SubscriptionService;
  private inv!: InvoiceService;
  private refund!: RefundService;

  private dtoMapper!: ApiCaseAndDtoMapper;
  private inputValidator!: MerchantInputValidator;
  private refundPolicy!: RefundPolicyGuard;
  private directSubPayBuilder!: DirectSubscriptionPaymentTxBuilder;

  private jsonSafe<T>(obj: T): T {
    return JSON.parse(
      JSON.stringify(obj, (_k, v) => (typeof v === 'bigint' ? v.toString() : v))
    );
  }

  bindDependencies(deps: {
    store: ISqliteStore;
    chain: IStacksChainClient;
    builder: IContractCallBuilder;
    pricing: PricingService;
    cfg: IConfigService;
    codec: IInvoiceIdCodec;
    subs: SubscriptionService;
    inv: InvoiceService;
    refund: RefundService;
  }): void {
    this.store = deps.store;
    this.chain = deps.chain;
    this.builder = deps.builder;
    this.pricing = deps.pricing;
    this.cfg = deps.cfg;
    this.codec = deps.codec;
    this.subs = deps.subs;
    this.inv = deps.inv;
    this.refund = deps.refund;

    this.dtoMapper = new ApiCaseAndDtoMapper();
    this.inputValidator = new MerchantInputValidator();
    this.refundPolicy = new RefundPolicyGuard(this.codec, this.refund);
    this.directSubPayBuilder = new DirectSubscriptionPaymentTxBuilder(
      this.chain,
      this.builder,
      this.codec,
    );
  }

  async getInvoice(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const idRaw = String(req.params.invoiceId);
    const row = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, idRaw);
    if (!row) {
      res.status(404).end();
      return;
    }
    const dto = this.dtoMapper.invoiceToPublicDto(row);
    res.json(dto);
  }

  async listInvoices(req: Request, res: Response): Promise<void> {
    // guard: missing auth should be a clean 401 (prevents "fetch failed")
    if (!(req as any).store) {
      res.status(401).json({ error: 'missing-api-key' });
      return;
    }
    const sreq = req as AuthedRequest;
    const statusQ = req.query.status ? String(req.query.status) : undefined;
    const allowed: InvoiceStatus[] = [
      'unpaid',
      'paid',
      'partially_refunded',
      'refunded',
      'canceled',
      'expired',
    ];
    if (statusQ && !allowed.includes(statusQ as InvoiceStatus)) {
      res.status(400).json({ error: 'bad_status' });
      return;
    }
    const rows = this.store.listInvoicesByStore(sreq.store.id, {
      status: statusQ as InvoiceStatus | undefined,
      orderByCreatedDesc: true,
    });
    res.json(rows.map((r) => this.dtoMapper.invoiceToPublicDto(r)));
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CANCEL (builder): returns unsigned call (used first by the test)
  // Route: POST /api/v1/stores/:storeId/invoices/:invoiceId/cancel/create-tx
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async cancelInvoiceCreateTx(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const idRaw = String(req.params.invoiceId);
    const invRow = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, idRaw);
    if (!invRow) { res.status(404).end(); return; }

    // Only unpaid & not expired are cancellable via builder/action
    if (invRow.status !== 'unpaid' || Number(invRow.expired ?? 0) === 1) {
      res.status(409).json({ error: 'not_cancellable' }); return;
    }

    // Build unsigned cancel call
    this.codec.assertHex64(invRow.id_hex);
    const unsignedCall = this.builder.buildCancelInvoice({ idHex: invRow.id_hex });
    res.json({ unsignedCall, unsignedPayload: unsignedCall });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CANCEL (action): flips mirror row to canceled (fallback path in the test)
  // Route: POST /api/v1/stores/:storeId/invoices/:invoiceId/cancel
  // NOTE: store.markInvoiceCanceled(idHex) returns void -> re-read to verify
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async cancelInvoice(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const idRaw = String(req.params.invoiceId);
    const invRow = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, idRaw);
    if (!invRow) { res.status(404).end(); return; }

    // Only unpaid & not expired are cancellable
    if (invRow.status !== 'unpaid' || Number(invRow.expired ?? 0) === 1) {
      res.status(409).json({ error: 'not_cancellable' }); return;
    }

    // Perform DB-side cancel (void return -> cannot test truthiness)
    this.codec.assertHex64(invRow.id_hex);
    this.store.markInvoiceCanceled(invRow.id_hex);

    // Re-read row to confirm outcome; if not canceled, report conflict
    const after = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, idRaw);
    if (!after || after.status !== 'canceled') {
      res.status(409).json({ error: 'not_cancellable' }); return;
    }

    res.json({ canceled: true, invoiceId: idRaw });
  }



  async getStoreProfile(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const dto = this.dtoMapper.storeToPrivateProfile(sreq.store);
    res.json({
      ...dto,
      apiKey: sreq.store.api_key ?? null,
      hmacSecret: sreq.store.hmac_secret ?? null,
    });
  }

  async updateStoreProfile(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const inb = (req.body ?? {}) as Record<string, unknown>;

    // accept both snake_case and camelCase
    const map: Record<string, string> = {
      name: 'name',
      display_name: 'display_name', displayName: 'display_name',
      logo_url: 'logo_url', logoUrl: 'logo_url',
      brand_color: 'brand_color', brandColor: 'brand_color',
      webhook_url: 'webhook_url', webhookUrl: 'webhook_url',
      support_email: 'support_email', supportEmail: 'support_email',
      support_url: 'support_url', supportUrl: 'support_url',
      allowed_origins: 'allowed_origins', allowedOrigins: 'allowed_origins',
    };

    const patch: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(map)) {
      if (Object.prototype.hasOwnProperty.call(inb, k) && !(v in patch)) {
        patch[v] = (inb as any)[k];
      }
    }

    if (patch['brand_color'] !== undefined) {
      const color = String(patch['brand_color']);
      if (!Validation.colorHex.test(color)) {
        res.status(400).json({ error: 'validation_error' });
        return;
      }
    }

    this.store.updateMerchantProfile(sreq.store.id, patch);

    const updated = this.store.getMerchantById(sreq.store.id) as MerchantRow | undefined;
    const dto = this.dtoMapper.storeToPrivateProfile(updated as MerchantRow);
    // include secrets in PATCH response too (test expects them)
    res.json({
      ...dto,
      apiKey: updated?.api_key ?? null,
      hmacSecret: updated?.hmac_secret ?? null,
    });
  }

  async createInvoice(req: Request, res: Response): Promise<void> {
    try {
      const sreq = req as AuthedRequest;

      // inactive store should be blocked cleanly
      if (!(sreq.store?.active === 1 || sreq.store?.active === true)) {
        res.status(403).json({ error: 'inactive' });
        return;
      }

      const normalized = this.validateCreateInvoiceBody(req.body);

      // Service may return either a DB row or a ready PublicInvoiceDTO
      const out: any = await this.inv.createInvoice(
        { id: sreq.store.id, principal: sreq.store.principal },
        normalized,
      );

      // If service already returned a PublicInvoiceDTO, just return it (ensure magicLink)
      if (out && typeof out === 'object' && 'invoiceId' in out) {
        const resp = out.magicLink ? out : { ...out, magicLink: `/i/${out.invoiceId}` };
        res.json(this.jsonSafe(resp));
        return;
      }

      // Otherwise it's a DB row: map to DTO and synthesize magicLink
      const dto = this.dtoMapper.invoiceToPublicDto(out as InvoiceRow);
      const magicLink = `/i/${dto.invoiceId}`;
      res.json(this.jsonSafe({ ...dto, magicLink }));
    } catch (e: any) {
      if (e && (e.code === 'SQLITE_CONSTRAINT' || e.errno === 19)) {
        res.status(409).json({ error: 'conflict' });
        return;
      }
      if (e instanceof TypeError) {
        res.status(400).json({ error: 'validation_error' });
        return;
      }
      res.status(400).json({ error: 'validation_error' });
    }
  }


  validateCreateInvoiceBody(body: any): {
    amountSats: number;
    ttlSeconds: number;
    memo?: string;
    webhookUrl?: string;
  } {
    const amountSats = Number(body?.amount_sats ?? body?.amountSats);
    const ttlSeconds = Number(body?.ttl_seconds ?? body?.ttlSeconds ?? 900);
    const memo =
      body?.memo !== undefined && body?.memo !== null ? String(body.memo) : undefined;
    const webhookUrl =
      body?.webhook_url !== undefined && body?.webhook_url !== null
        ? String(body.webhook_url)
        : undefined;

    this.inputValidator.assertPositiveInt(amountSats, 'amount_sats');
    this.inputValidator.assertPositiveInt(ttlSeconds, 'ttl_seconds');

    if (memo) {
      const bytes = Buffer.from(memo, 'utf8');
      if (bytes.length > 34) throw new TypeError('memo-too-long');
    }
    if (webhookUrl && !Validation.url.test(webhookUrl)) {
      throw new TypeError('bad-webhook');
    }

    return { amountSats, ttlSeconds, memo, webhookUrl };
  }

  async buildRefund(req: Request, res: Response): Promise<void> {
    try {
      const sreq = req as AuthedRequest;
      const { invoiceId, amountSats, memo } = this.inputValidator.validateRefundBody(req.body);
      const invRow = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, invoiceId);
      if (!invRow) {
        res.status(404).end();
        return;
      }
      try {
        const payload = await this.refundPolicy.enforceAndBuild(
          sreq.store,
          invRow as InvoiceRow,
          amountSats,
          memo,
        );
        res.json(this.jsonSafe(payload));
      } catch (err: any) {
        const code = err?.code as string;
        if (code === 'bad_status' || code === 'cap_violation') {
          res.status(409).json({ error: 'bad_status' });
          return;
        }
        if (code === 'insufficient_balance') {
          res.status(400).json({ error: 'insufficient_balance' });
          return;
        }
        res.status(400).json({ error: 'validation_error' });
      }
    } catch {
      res.status(400).json({ error: 'validation_error' });
    }
  }

// POST /api/v1/stores/:storeId/refunds/create-tx
async buildRefundTx(req: Request, res: Response): Promise<void> {
  try {
    const sreq = req as AuthedRequest;
    const { invoiceId, amountSats, memo } = this.validateRefundBody((req.body ?? {}) as any);

    const invRow = this.store.invoices.findByStoreAndIdRaw(sreq.store.id, invoiceId);
    if (!invRow) { res.status(404).json({ error: 'not_found' }); return; }

    // Only already-paid (or partially_refunded) invoices are refundable
    const status = String(invRow.status ?? '').toLowerCase();
    if (!(status === 'paid' || status === 'partially_refunded')) {
      res.status(409).json({ error: 'invalid_state' }); return;
    }

    // The RefundService already enforces refund cap and requires merchantPrincipal
    const unsigned = await this.refund.buildRefundPayload(
      sreq.store,
      invRow as any,
      amountSats,
      memo,
    );

    // Return the unsigned call â€” this is what the test expects to broadcast
    res.json(this.jsonSafe(unsigned));
  } catch {
    // Validation-style failures â†’ 400 per Steroids
    res.status(400).json({ error: 'validation_error' });
  }
}


// Accept snake_case or camelCase via the validator; keep camelCase in the controller.
private validateRefundBody(body: Record<string, unknown>): {
  invoiceId: string;
  amountSats: number;
  memo?: string;
} {
  return this.inputValidator.validateRefundBody(body);
}

  async rotateKeys(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const { apiKey, hmacSecret } = this.generateSecrets();
    this.store.updateMerchantKeysTx(sreq.store.id, apiKey, hmacSecret);
    res.json({ apiKey, hmacSecret });
  }

  generateSecrets(): { apiKey: string; hmacSecret: string } {
    return {
      apiKey: crypto.randomBytes(32).toString('hex'),
      hmacSecret: crypto.randomBytes(32).toString('hex'),
    };
  }

  async buildDirectSubscriptionPaymentTx(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const id = String(req.params.id);
    const sub = this.store.getSubscriptionByIdForStore(id, sreq.store.id);
    if (!sub) {
      res.status(404).end();
      return;
    }
    const payerPrincipal = String((req.body ?? {}).payerPrincipal ?? '');
    try {
      const payload = await this.directSubPayBuilder.assemble(
        sub as SubscriptionRow,
        payerPrincipal,
        sreq.store.principal,
      );
      res.json(this.jsonSafe(payload));
    } catch (err: any) {
      const code = err?.code as string;
      if (code === 'bad_status' || code === 'invalid_payer' || code === 'too_early') {
        res.status(409).json({ error: 'bad_status' });
        return;
      }
      if (code === 'missing_token') {
        res.status(422).json({ error: 'missingSbtcToken' });
        return;
      }
      res.status(400).json({ error: 'validation_error' });
    }
  }

  async createSubscription(req: Request, res: Response): Promise<void> {
    try {
      const sreq = req as AuthedRequest;
      const body = (req.body ?? {}) as Record<string, unknown>;
      const subscriber = String(body.subscriber ?? '');
      const amountSats = Number(body.amount_sats ?? body.amountSats);
      const intervalBlocks = Number(body.interval_blocks ?? body.intervalBlocks);
      const mode = body.mode ? (String(body.mode) as 'invoice' | 'direct') : undefined;

      if (!subscriber.trim()) {
        res.status(400).json({ error: 'validation_error' });
        return;
      }
      this.inputValidator.assertPositiveInt(amountSats, 'amount_sats');
      this.inputValidator.assertPositiveInt(intervalBlocks, 'interval_blocks');
      if (mode && !['invoice', 'direct'].includes(mode)) {
        res.status(400).json({ error: 'validation_error' });
        return;
      }

      const { row, unsignedCall } = await this.subs.createSubscription(
        { id: sreq.store.id, principal: sreq.store.principal },
        { subscriber, amountSats, intervalBlocks, mode },
      );

      res.json({
        id: row.id,
        idHex: row.id_hex,
        storeId: row.store_id,
        merchantPrincipal: row.merchant_principal,
        subscriber: row.subscriber,
        amountSats: row.amount_sats,
        intervalBlocks: row.interval_blocks,
        active: row.active === 1,
        createdAt: row.created_at,
        lastBilledAt: row.last_billed_at,
        nextInvoiceAt: row.next_invoice_at,
        lastPaidInvoiceId: row.last_paid_invoice_id,
        mode: row.mode,
        unsignedCall: this.jsonSafe(unsignedCall),
      });
    } catch {
      res.status(400).json({ error: 'validation_error' });
    }
  }

  async genSubscriptionInvoice(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const id = String(req.params.id);
    const sub = this.store.getSubscriptionByIdForStore(id, sreq.store.id);
    if (!sub) {
      res.status(404).end();
      return;
    }
    if (!(sub.active === 1 && sub.mode === 'invoice')) {
      res.status(409).json({ error: 'bad_status' });
      return;
    }
    const body = (req.body ?? {}) as Record<string, unknown>;
    const ttlSeconds = Number(body.ttl_seconds ?? body.ttlSeconds ?? 900);
    const memo =
      body.memo !== undefined && body.memo !== null ? String(body.memo) : undefined;
    const webhookUrl =
      body.webhook_url !== undefined && body.webhook_url !== null
        ? String(body.webhook_url)
        : body.webhookUrl !== undefined && body.webhookUrl !== null
          ? String(body.webhookUrl)
          : undefined;

    if (!Number.isInteger(ttlSeconds) || ttlSeconds <= 0) {
      res.status(400).json({ error: 'validation_error' });
      return;
    }
    if (memo) {
      const bytes = Buffer.from(memo, 'utf8');
      if (bytes.length > 34) {
        res.status(400).json({ error: 'validation_error' });
        return;
      }
    }
    if (webhookUrl && !Validation.url.test(webhookUrl)) {
      res.status(400).json({ error: 'validation_error' });
      return;
    }

    const { invoice, unsignedCall } =
      await this.subs.generateInvoiceForSubscription(sub as SubscriptionRow, {
        storeId: sreq.store.id,
        merchantPrincipal: sreq.store.principal,
        ttlSeconds,
        memo,
        webhookUrl,
      });

    const magicLink = `/i/${invoice.invoiceId}`;
    res.json({ invoice, magicLink, unsignedCall: this.jsonSafe(unsignedCall) });
  }

  async setSubscriptionMode(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const id = String(req.params.id);
    const sub = this.store.getSubscriptionByIdForStore(id, sreq.store.id);
    if (!sub) {
      res.status(404).end();
      return;
    }
    const body = (req.body ?? {}) as Record<string, unknown>;
    const mode = String(body.mode ?? '');
    if (!(mode === 'invoice' || mode === 'direct')) {
      res.status(400).json({ error: 'validation_error' });
      return;
    }
    const out = await this.subs.setMode(sub as SubscriptionRow, mode as 'invoice' | 'direct');
    res.json({ id: out.row.id, mode: out.row.mode, unsignedCall: this.jsonSafe(out.unsignedCall) });
  }

  async cancelSubscription(req: Request, res: Response): Promise<void> {
    const sreq = req as AuthedRequest;
    const id = String(req.params.id);
    const sub = this.store.getActiveSubscription(id, sreq.store.id);
    if (!sub) {
      res.status(404).end();
      return;
    }
    const out = await this.subs.cancel(sub as SubscriptionRow);
    res.json({ unsignedCall: this.jsonSafe(out.unsignedCall) });
  }

  async listWebhooks(req: Request, res: Response): Promise<void> {
    // guard: missing auth should be clean 401
    if (!(req as any).store) {
      res.status(401).json({ error: 'missing-api-key' });
      return;
    }
    const sreq = req as AuthedRequest;
    const rows = this.store.listWebhooksForStore(sreq.store.id);
    res.json(rows.map((w) => this.dtoMapper.webhookToDto(w)));
  }
}


---
# ./server/HttpApiServer.ts

// src/server/HttpApiServer.ts
import express, { Express, RequestHandler } from 'express';
import { PublicApiController } from '../controllers/PublicApiController';
import { MerchantApiController } from '../controllers/MerchantApiController';
import { AdminApiController } from '../controllers/AdminApiController';
import { HealthController } from '../controllers/HealthController';
import { AdminAuth } from '../middleware/AdminAuth';
import { StoreApiAuth } from '../middleware/StoreApiAuth';
import { CrossTenantMask } from '../middleware/CrossTenantMask';
import { RateLimitPolicy } from '../middleware/RateLimitPolicy';
import { CorsPolicy } from '../middleware/CorsPolicy';
import { AdminStaticServer } from '../servers/AdminStaticServer';
import { PaymentPoller } from '../poller/PaymentPoller';
import { WebhookRetryScheduler } from '../webhooks/WebhookRetryScheduler';
import { SubscriptionScheduler } from '../schedulers/SubscriptionScheduler';
import { AdminSurfaceBinder } from '../delegates/AdminSurfaceBinder';
import { WebhookInboundSurfaceBinder } from '../delegates/WebhookInboundSurfaceBinder';
import { RootRouteBinder } from '../delegates/RootRouteBinder';
import { SchedulerStartupCoordinator } from '../delegates/SchedulerStartupCoordinator';
import { CorsMiddlewareFactory } from '../delegates/CorsMiddlewareFactory';
import type { IConfigService } from '../contracts/interfaces';

type AdminGuard = { authenticateAdmin(req: any, res: any, next: any): void };



export class HttpApiServer {
  private readonly adminBinder = new AdminSurfaceBinder();
  private readonly inboundBinder = new WebhookInboundSurfaceBinder();
  private readonly rootBinder = new RootRouteBinder();
  private readonly schedulerCoordinator = new SchedulerStartupCoordinator();
  private readonly corsFactory = new CorsMiddlewareFactory();
  

  mountAdminAuth(app: Express, adminAuth: AdminGuard): void {
    this.adminBinder.bindAdminAuth(app, adminAuth);
  }

  mountAdminStatic(
    app: Express,
    adminAuth: AdminGuard,
    staticMiddleware: RequestHandler,
  ): void {
    this.adminBinder.bindAdminStatic(app, adminAuth, staticMiddleware);
  }

  mountRoot(app: Express, handler: { getRoot(req: any, res: any): void }): void {
    this.rootBinder.bindRoot(app, handler);
  }

  mountAdminIndex(
    app: Express,
    adminAuth: AdminGuard,
    serveIndex: (req: any, res: any) => void,
  ): void {
    this.adminBinder.bindAdminIndex(app, adminAuth, serveIndex);
  }

  mountInboundWebhookVerifier(app: Express, verifierMw: RequestHandler): void {
    this.inboundBinder.bind(app, verifierMw);
  }

  composeRoutesAndMiddleware(app: Express, deps: {
    publicCtrl: PublicApiController;
    merchantCtrl: MerchantApiController;
    adminCtrl: AdminApiController;
    healthCtrl: HealthController;
    adminAuth: AdminAuth;
    storeAuth: StoreApiAuth;
    crossTenantMask: CrossTenantMask;
    rateLimit: RateLimitPolicy;
    corsPolicy: CorsPolicy;
    staticServer: AdminStaticServer;
    webhookVerifier: RequestHandler;
  }): void {
    deps.rateLimit.initLimiters();

    this.mountAdminAuth(app, deps.adminAuth);
    this.mountInboundWebhookVerifier(app, deps.webhookVerifier);

    const corsGetInvoice = this.corsFactory.create(['GET', 'OPTIONS'], deps.corsPolicy as any);
    const corsCreateTx = this.corsFactory.create(['POST', 'OPTIONS'], deps.corsPolicy as any);
    const corsPublicProfile = this.corsFactory.create(['GET', 'OPTIONS'], deps.corsPolicy as any);

    // Public routes + preflights
    app.options('/i/:invoiceId', corsGetInvoice);
    app.get(
      '/i/:invoiceId',
      deps.rateLimit.publicInvoiceViewLimiter,
      corsGetInvoice,
      (req, res) => deps.publicCtrl.getInvoice(req, res),
    );

    app.options('/create-tx', corsCreateTx);
    app.post(
      '/create-tx',
      deps.rateLimit.publicCreateTxLimiter,
      corsCreateTx,
      express.json(),
      (req, res) => deps.publicCtrl.createTx(req, res),
    );

    app.get(
      '/api/v1/stores/:storeId/public-profile',
      deps.rateLimit.publicProfileLimiter,
      corsPublicProfile,
      (req, res) => deps.publicCtrl.getStorePublicProfile(req, res),
    );

    app.options('/api/v1/stores/:storeId/public-profile', corsPublicProfile);

    // Merchant-scoped routes
    const auth = (req: any, res: any, next: any) => deps.storeAuth.verifyApiKey(req, res, next);
    const mask = (req: any, res: any, next: any) => deps.crossTenantMask.enforce(req, res, next);

    app.post(
      '/api/v1/stores/:storeId/invoices',
      auth,
      mask,
      deps.rateLimit.createInvoiceLimiter,
      express.json(),
      (req, res) => deps.merchantCtrl.createInvoice(req, res),
    );

    app.get(
      '/api/v1/stores/:storeId/invoices',
      auth,
      mask,
      (req, res) => deps.merchantCtrl.listInvoices(req, res),
    );

    app.get(
      '/api/v1/stores/:storeId/invoices/:invoiceId',
      auth,
      mask,
      (req, res) => deps.merchantCtrl.getInvoice(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/invoices/:invoiceId/cancel',
      auth,
      mask,
      (req, res) => deps.merchantCtrl.cancelInvoice(req, res),
    );

    // Builder first (test tries this one initially)
    app.post(
      '/api/v1/stores/:storeId/invoices/:invoiceId/cancel/create-tx',
      auth, mask,
      (req, res) => deps.merchantCtrl.cancelInvoiceCreateTx(req, res),
    );


    app.post(
      '/api/v1/stores/:storeId/refunds',
      auth,
      mask,
      express.json(),
      (req, res) => deps.merchantCtrl.buildRefund(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/refunds/create-tx',
      auth, mask,
      deps.rateLimit.createInvoiceLimiter,
      express.json(),
      (req, res) => deps.merchantCtrl.buildRefundTx(req, res),
    );

    app.get(
      '/api/v1/stores/:storeId/webhooks',
      auth,
      mask,
      (req, res) => deps.merchantCtrl.listWebhooks(req, res),
    );

    app.get(
      '/api/v1/stores/:storeId/profile',
      auth,
      mask,
      (req, res) => deps.merchantCtrl.getStoreProfile(req, res),
    );

    app.patch(
      '/api/v1/stores/:storeId/profile',
      auth,
      mask,
      express.json(),
      (req, res) => deps.merchantCtrl.updateStoreProfile(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/rotate-keys',
      auth,
      mask,
      (req, res) => deps.merchantCtrl.rotateKeys(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/subscriptions',
      auth,
      mask,
      express.json(),
      (req, res) => deps.merchantCtrl.createSubscription(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/subscriptions/:id/invoice',
      auth,
      mask,
      deps.rateLimit.subInvoiceLimiter,
      express.json(),
      (req, res) => deps.merchantCtrl.genSubscriptionInvoice(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/subscriptions/:id/mode',
      auth,
      mask,
      express.json(),
      (req, res) => deps.merchantCtrl.setSubscriptionMode(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/subscriptions/:id/cancel',
      auth,
      mask,
      express.json(),
      (req, res) => deps.merchantCtrl.cancelSubscription(req, res),
    );

    app.post(
      '/api/v1/stores/:storeId/subscriptions/:id/create-tx',
      auth,
      mask,
      express.json(),
      (req, res) => deps.merchantCtrl.buildDirectSubscriptionPaymentTx(req, res),
    );


    // Admin API
    const adminGuard = (req: any, res: any, next: any) => deps.adminAuth.authenticateAdmin(req, res, next);

    // parse JSON first, then guard, and forward async errors
    app.post('/api/admin/stores',
      express.json(),
      adminGuard,
      (req, res, next) => deps.adminCtrl.createStore(req, res).catch(next)
    );


    app.get('/api/admin/stores', adminGuard, (req, res) =>
      deps.adminCtrl.listStores(req, res)
    );

    app.get('/api/admin/invoices', adminGuard, (req, res) => deps.adminCtrl.listInvoices(req, res));


    app.post(
      '/api/admin/stores',
      adminGuard,
      express.json(),
      (req, res) => deps.adminCtrl.createStore(req, res),
    );

    app.patch(
      '/api/admin/stores/:storeId/activate',
      adminGuard,
      express.json(),
      (req, res) => deps.adminCtrl.activateStore(req, res),
    );

    app.post(
      '/api/admin/stores/:storeId/rotate-keys',
      adminGuard,
      (req, res) => deps.adminCtrl.rotateKeys(req, res),
    );

    app.post(
      '/api/admin/stores/:storeId/sync-onchain',
      adminGuard,
      (req, res) => deps.adminCtrl.syncOnchain(req, res),
    );

    app.post(
      '/api/admin/set-sbtc-token',
      adminGuard,
      express.json(),
      (req, res) => deps.adminCtrl.setSbtcToken(req, res),
    );

    app.get('/api/admin/poller', adminGuard, (req, res) => deps.adminCtrl.getPoller(req, res));

    app.post(
      '/api/admin/poller/restart',
      adminGuard,
      (req, res) => deps.adminCtrl.restartPoller(req, res),
    );

    app.get(
      '/api/admin/webhooks',
      adminGuard,
      (req, res) => deps.adminCtrl.listWebhooks(req, res),
    );

    app.post(
      '/api/admin/webhooks/retry',
      adminGuard,
      express.json(),
      (req, res) => deps.adminCtrl.retryWebhook(req, res),
    );

    app.post(
      '/api/admin/invoices/:invoiceId/cancel',
      adminGuard,
      (req, res) => deps.adminCtrl.cancelInvoice(req, res),
    );

    // Admin SPA (static + index)
    this.mountAdminStatic(app, deps.adminAuth, deps.staticServer.serveStatic());
    this.mountAdminIndex(app, deps.adminAuth, (req, res) => deps.staticServer.serveIndex(req, res));

    // Health/root
    this.mountRoot(app, deps.healthCtrl);
  }

  async start(deps: {
    app: Express;
    poller: PaymentPoller;
    webhookRetry: WebhookRetryScheduler;
    subscriptionScheduler?: SubscriptionScheduler;
    config: IConfigService;
  }): Promise<void> {
    await this.schedulerCoordinator.startSchedulers({
      poller: deps.poller,
      webhookRetry: deps.webhookRetry,
      subscriptionScheduler: deps.subscriptionScheduler,
      config: deps.config,
    });
  }
}


---
# ./utils/InvoiceIdCodec.ts

// src/utils/InvoiceIdCodec.ts
import crypto from 'crypto';
import type { IInvoiceIdCodec } from '../contracts/interfaces';

export class InvoiceIdCodec implements IInvoiceIdCodec {
  assertHex64(idHex: string): void {
    if (typeof idHex !== 'string' || idHex.length !== 64) {
      throw new Error('idHex must be a 64-character hex string');
    }
    if (!/^[0-9A-Fa-f]{64}$/.test(idHex)) {
      throw new Error('idHex must contain only hexadecimal characters');
    }
    const buf = Buffer.from(idHex, 'hex');
    if (buf.length !== 32) {
      throw new Error('idHex must decode to exactly 32 bytes');
    }
    const roundTrip = Buffer.from(buf).toString('hex');
    if (roundTrip.length !== 64) {
      throw new Error('idHex round-trip failed to produce 64 chars');
    }
  }

  isValidHex64(idHex: string): boolean {
    try {
      this.assertHex64(idHex);
      return true;
    } catch {
      return false;
    }
  }

  toBuff32Hex(idHex: string): Uint8Array {
    this.assertHex64(idHex);
    return Buffer.from(idHex, 'hex');
  }

  hexFromBuff32(buf: Uint8Array): string {
    if (!(buf instanceof Uint8Array) || buf.length !== 32) {
      throw new Error('buf32 must be a 32-byte buffer');
    }
    const hex = Buffer.from(buf).toString('hex');
    if (hex.length !== 64) {
      throw new Error('hex round-trip failed to produce 64 chars');
    }
    if (Buffer.from(hex, 'hex').length !== 32) {
      throw new Error('hex did not round-trip to 32 bytes');
    }
    return hex;
  }

  generateRandomBuff32Hex(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  generateRandomBuff32(): Buffer {
    return crypto.randomBytes(32);
  }
}


---
# ./config/env.ts

// src/config/env.ts

import type { IConfigSnapshot } from '../contracts/state';

export function loadEnvSnapshot(): IConfigSnapshot {
  return Object.freeze({
    network: (process.env.STACKS_NETWORK as any) ?? 'testnet',
    contractAddress: String(process.env.CONTRACT_ADDRESS),
    contractName: String(process.env.CONTRACT_NAME),
    sbtcContract:
      process.env.SBTC_CONTRACT_ADDRESS && process.env.SBTC_CONTRACT_NAME
        ? {
            contractAddress: String(process.env.SBTC_CONTRACT_ADDRESS),
            contractName: String(process.env.SBTC_CONTRACT_NAME),
          }
        : undefined,
    avgBlockSecs: Number(process.env.AVG_BLOCK_SECONDS ?? 30),
    minConfirmations: Number(process.env.MIN_CONFIRMATIONS ?? 2),
    reorgWindowBlocks: Number(process.env.REORG_WINDOW_BLOCKS ?? 6),
    pollIntervalSecs: Number(process.env.POLL_INTERVAL_SECS ?? 30),
    priceApiUrl: process.env.PRICE_API_URL ? String(process.env.PRICE_API_URL) : undefined,
    autoBroadcast: String(process.env.AUTO_BROADCAST ?? 'false') === 'true',
  });
}


---
# ./config/ConfigService.ts

// src/config/ConfigService.ts

import type { IConfigService } from '../contracts/interfaces';
import type { IConfigSnapshot } from '../contracts/state';
import { loadEnvSnapshot } from './env';

export class ConfigService implements IConfigService {
  private readonly snap: IConfigSnapshot;

  constructor() {
    this.snap = loadEnvSnapshot();
  }

  getNetwork(): 'mainnet' | 'testnet' | 'devnet' {
    return this.snap.network;
  }

  getContractId(): { contractAddress: string; contractName: string } {
    return {
      contractAddress: this.snap.contractAddress,
      contractName: this.snap.contractName,
    };
  }

  getSbtcContractId():
    | { contractAddress: string; contractName: string }
    | undefined {
    return this.snap.sbtcContract;
  }

  getPollingConfig(): {
    minConfirmations: number;
    reorgWindowBlocks: number;
    pollIntervalSecs: number;
  } {
    return {
      minConfirmations: this.snap.minConfirmations,
      reorgWindowBlocks: this.snap.reorgWindowBlocks,
      pollIntervalSecs: this.snap.pollIntervalSecs,
    };
  }

  getAvgBlockSecs(): number {
    return this.snap.avgBlockSecs;
  }

  getPriceApiUrl(): string | undefined {
    return this.snap.priceApiUrl;
  }

  isAutoBroadcastEnabled(): boolean {
    return this.snap.autoBroadcast;
  }
}


---
# ./schedulers/SubscriptionScheduler.ts

// src/schedulers/SubscriptionScheduler.ts
import { makeContractCall, broadcastTransaction } from '@stacks/transactions';
import { STACKS_MAINNET, STACKS_TESTNET, STACKS_DEVNET, STACKS_MOCKNET } from '@stacks/network';

import type {
  IStacksChainClient,
  IContractCallBuilder,
  IConfigService,
  IInvoiceIdCodec,
  IWebhookDispatcher,
} from '../contracts/interfaces';
import type { ISqliteStore } from '../contracts/dao';
import type { SubscriptionRow } from '../contracts/domain';
import { PricingService } from '../services/PricingService';
import { SubscriptionInvoicePlanner } from '../delegates/SubscriptionInvoicePlanner';

type BroadcastInput = {
  idBuf32: Uint8Array;
  amountSats: number;
  memo?: string;
  expiresAtBlocks?: number;
};

export class SubscriptionScheduler {
  private chain!: IStacksChainClient;
  private builder!: IContractCallBuilder;
  private store!: ISqliteStore;
  private pricing!: PricingService;
  private cfg!: IConfigService;
  private dispatcher!: IWebhookDispatcher;
  private codec!: IInvoiceIdCodec;

  private intervalId: NodeJS.Timeout | undefined;

  bindDependencies(deps: {
    chain: IStacksChainClient;
    builder: IContractCallBuilder;
    store: ISqliteStore;
    pricing: PricingService;
    cfg: IConfigService;
    dispatcher: IWebhookDispatcher;
    codec: IInvoiceIdCodec;
  }): void {
    this.chain = deps.chain;
    this.builder = deps.builder;
    this.store = deps.store;
    this.pricing = deps.pricing;
    this.cfg = deps.cfg;
    this.dispatcher = deps.dispatcher;
    this.codec = deps.codec;
  }

  bootstrapScheduler(): void {
    if (this.intervalId) return;

    const avgBlockSecs = this.cfg.getAvgBlockSecs();
    const poll = this.cfg.getPollingConfig().pollIntervalSecs;
    const ttlSecs = Number(process.env.QUOTE_TTL_SECONDS);

    if (!Number.isFinite(avgBlockSecs) || avgBlockSecs <= 0) return;
    if (!Number.isFinite(poll) || poll <= 0) return;
    if (!Number.isFinite(ttlSecs) || ttlSecs <= 0) return;

    const intervalMs = poll * 1000;
    this.intervalId = setInterval(() => this.timerCallback(), intervalMs);
  }

  private timerCallback(): void {
    void this.tick().catch(() => {});
  }

  async tick(): Promise<void> {
    const tip = await this.chain.getTip();
    await this.processDueSubscriptions(tip.height);
  }

  async processDueSubscriptions(currentHeight: number): Promise<void> {
    const subs = this.store.selectDueSubscriptions(currentHeight);
    for (const sub of subs) {
      try {
        await this.onSubscriptionInvoiceCreated({ subscription: sub, currentHeight });
      } catch {
        // Skip failed item and continue with others
      }
    }
  }

  async onSubscriptionInvoiceCreated(ctx: {
    subscription: SubscriptionRow;
    currentHeight: number;
  }): Promise<void> {
    const sub = ctx.subscription;

    const planner = new SubscriptionInvoicePlanner(
      this.store,
      this.pricing,
      this.cfg,
      this.codec,
    );
    const planned = await planner.plan(sub, ctx.currentHeight);

    await this.broadcastCreateInvoiceTx({
      idBuf32: planned.idBuf32,
      amountSats: sub.amount_sats,
      memo: undefined,
      expiresAtBlocks: planned.expiresAtBlocks,
    });

    const nowSecs = Math.floor(Date.now() / 1000);
    this.store.invoices.insert({
      id_raw: planned.idRaw,
      id_hex: planned.idHex,
      store_id: sub.store_id,
      amount_sats: sub.amount_sats,
      usd_at_create: planned.usdAtCreate,
      quote_expires_at: planned.quoteExpiresAtMs,
      merchant_principal: sub.merchant_principal,
      status: 'unpaid',
      payer: undefined,
      txid: undefined,
      memo: undefined,
      webhook_url: undefined,
      created_at: nowSecs,
      refunded_at: undefined,
      refund_amount: 0,
      refund_txid: undefined,
      subscription_id: sub.id,
      refund_count: 0,
      expired: 0,
    });
    this.store.advanceSubscriptionSchedule(sub.id);

    const rawBody = planner.buildWebhookRawBody(planned, sub);
    await this.dispatcher.dispatch({
      storeId: sub.store_id,
      subscriptionId: sub.id,
      invoiceId: planned.idRaw,
      eventType: 'subscription',
      rawBody,
    });
  }

  async broadcastCreateInvoiceTx(input: BroadcastInput): Promise<string> {
    if (!(input.idBuf32 instanceof Uint8Array) || input.idBuf32.length !== 32) {
      throw new Error('idBuf32 must be 32 bytes');
    }
    if (!Number.isInteger(input.amountSats) || input.amountSats <= 0) {
      throw new TypeError('amountSats must be a positive integer');
    }

    const idHex = this.codec.hexFromBuff32(input.idBuf32);
    const payload = this.builder.buildCreateInvoice({
      idHex,
      amountSats: input.amountSats,
      memo: input.memo,
      expiresAtBlock: input.expiresAtBlocks,
    });

    if (!this.cfg.isAutoBroadcastEnabled()) {
      throw new Error('auto_broadcast_disabled');
    }

    const senderKey = String(process.env.SCHEDULER_SENDER_KEY ?? process.env.SIGNER_PRIVATE_KEY ?? '');
    const { contractAddress, contractName, functionName, functionArgs } = payload;
    const networkName = this.cfg.getNetwork();

    const network =
      networkName === 'mainnet' ? STACKS_MAINNET :
      networkName === 'testnet' ? STACKS_TESTNET :
      networkName === 'devnet'  ? STACKS_DEVNET  :
      STACKS_MOCKNET;

    const tx = await makeContractCall({
      contractAddress,
      contractName,
      functionName,
      functionArgs,
      senderKey,
      network
      // anchorMode removed â€” not part of SignedContractCallOptions in v7
    });

    const resp: any = await broadcastTransaction({ transaction: tx, network });
    if (typeof resp === 'string') return resp;
    if (resp && typeof resp.txid === 'string') return resp.txid;
    throw new Error('broadcast_failed');
  }
}


---
# ./delegates/AdminDtoProjector.ts

// src/delegates/AdminDtoProjector.ts
import type { MerchantRow, InvoiceRow, WebhookLogRow } from '../contracts/domain';

export type MerchantProjectionRow = Omit<MerchantRow, 'api_key' | 'hmac_secret'>;

export type MerchantDto = {
  id: string;
  principal: string;
  name?: string;
  displayName?: string;
  logoUrl?: string;
  brandColor?: string;
  webhookUrl?: string;
  active: boolean;
  supportEmail?: string;
  supportUrl?: string;
  allowedOrigins?: string;
  createdAt: number;
};

export type AdminInvoiceDto = {
  idRaw: string;
  idHex: string;
  storeId: string;
  amountSats: number;
  usdAtCreate: number;
  quoteExpiresAt: number;
  merchantPrincipal: string;
  status: string;
  payer?: string;
  txId?: string;
  memo?: string;
  webhookUrl?: string;
  createdAt: number;
  refundedAt?: number;
  refundAmount: number;
  refundTxId?: string;
  subscriptionId?: string;
  refundCount: number;
  expired: number;
};

export type AdminWebhookDto = {
  id: string;
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: string;
  payload: string;
  statusCode?: number;
  success: boolean;
  attempts: number;
  lastAttemptAt: number;
};

export class AdminDtoProjector {
  merchantToDto(r: MerchantProjectionRow): MerchantDto {
    return {
      id: r.id,
      principal: r.principal,
      name: r.name ?? undefined,
      displayName: r.display_name ?? undefined,
      logoUrl: r.logo_url ?? undefined,
      brandColor: r.brand_color ?? undefined,
      webhookUrl: r.webhook_url ?? undefined,
      active: !!r.active,
      supportEmail: r.support_email ?? undefined,
      supportUrl: r.support_url ?? undefined,
      allowedOrigins: r.allowed_origins ?? undefined,
      createdAt: r.created_at,
    };
  }

  invoiceToDto(r: InvoiceRow): AdminInvoiceDto {
    return {
      idRaw: r.id_raw,
      idHex: r.id_hex,
      storeId: r.store_id,
      amountSats: r.amount_sats,
      usdAtCreate: r.usd_at_create,
      quoteExpiresAt: r.quote_expires_at,
      merchantPrincipal: r.merchant_principal,
      status: r.status,
      payer: r.payer ?? undefined,
      txId: r.txid ?? undefined,
      memo: r.memo ?? undefined,
      webhookUrl: r.webhook_url ?? undefined,
      createdAt: r.created_at,
      refundedAt: r.refunded_at ?? undefined,
      refundAmount: r.refund_amount,
      refundTxId: r.refund_txid ?? undefined,
      subscriptionId: r.subscription_id ?? undefined,
      refundCount: r.refund_count,
      expired: r.expired,
    };
  }

  webhookToDto(w: WebhookLogRow): AdminWebhookDto {
    return {
      id: w.id,
      storeId: w.store_id,
      invoiceId: w.invoice_id ?? undefined,
      subscriptionId: w.subscription_id ?? undefined,
      eventType: w.event_type,
      payload: w.payload,
      statusCode: w.status_code ?? undefined,
      success: !!w.success,
      attempts: w.attempts,
      lastAttemptAt: w.last_attempt_at,
    };
  }
}


---
# ./delegates/MerchantCreationService.ts

// src/delegates/MerchantCreationService.ts
import crypto from 'crypto';
import type { ISqliteStore } from '../contracts/dao';
import type { MerchantRow } from '../contracts/domain';
import type { MerchantDto } from './AdminDtoProjector';

export class MerchantCreationService {
  async create(
    store: ISqliteStore,
    body: any
  ): Promise<{ status: 'created'; dto: MerchantDto } | { status: 'conflict' }> {
    const id = crypto.randomUUID();
    const createdAt = Math.floor(Date.now() / 1000);
    const apiKey = crypto.randomBytes(32).toString('hex');
    const hmacSecret = crypto.randomBytes(32).toString('hex');

    const insertRow: MerchantRow | any = {
      id,
      principal: String(body.principal),
      name: body.name ?? undefined,
      display_name: body.displayName ?? undefined,
      logo_url: body.logoUrl ?? undefined,
      brand_color: body.brandColor ?? undefined,
      webhook_url: body.webhookUrl ?? undefined,
      hmac_secret: hmacSecret,
      api_key: apiKey,
      active: 1,
      support_email: body.supportEmail ?? undefined,
      support_url: body.supportUrl ?? undefined,
      allowed_origins: body.allowedOrigins ?? undefined,
      created_at: createdAt,
    };

    try {
      store.insertMerchant(insertRow as MerchantRow);
    } catch (e: any) {
      if (e && (e.code === 'SQLITE_CONSTRAINT' || e.errno === 19)) {
        return { status: 'conflict' };
      }
      throw e;
    }

    const dto: MerchantDto = {
      id,
      principal: insertRow.principal,
      name: insertRow.name ?? undefined,
      displayName: insertRow.display_name ?? undefined,
      logoUrl: insertRow.logo_url ?? undefined,
      brandColor: insertRow.brand_color ?? undefined,
      webhookUrl: insertRow.webhook_url ?? undefined,
      active: true,
      supportEmail: insertRow.support_email ?? undefined,
      supportUrl: insertRow.support_url ?? undefined,
      allowedOrigins: insertRow.allowed_origins ?? undefined,
      createdAt,
    };

    return { status: 'created', dto };
  }
}


---
# ./delegates/PayInvoiceTxAssembler.ts

// src/delegates/PayInvoiceTxAssembler.ts
import type {
  IContractCallBuilder,
  IAssetInfoFactory,
  IConfigService,
  IStacksChainClient,
} from '../contracts/interfaces';
import { InvoiceIdGuard } from '../delegates/InvoiceIdGuard';
import { Validation } from '../validation/rules';

type InvoiceRowForTx = {
  id_hex: string;
  amount_sats: number;
  merchant_principal: string;
  status: string;
  quote_expires_at: number; // ms epoch
  store: { active: number | boolean };
};

export class HttpError extends Error {
  constructor(public status: number, public code: string, message?: string) {
    super(message ?? code);
  }
}

export class PayInvoiceTxAssembler {
  private readonly builder: IContractCallBuilder;
  private readonly aif: IAssetInfoFactory;
  private readonly cfg: IConfigService;
  private readonly chain: IStacksChainClient;
  private readonly idGuard: InvoiceIdGuard;
  private readonly nonPayableStatuses: Set<string>;

  constructor(
    builder: IContractCallBuilder,
    aif: IAssetInfoFactory,
    cfg: IConfigService,
    chain: IStacksChainClient,
    idGuard: InvoiceIdGuard,
    nonPayableStatuses: Set<string>,
  ) {
    this.builder = builder;
    this.aif = aif;
    this.cfg = cfg;
    this.chain = chain;
    this.idGuard = idGuard;
    this.nonPayableStatuses = nonPayableStatuses;
    void Validation; // imported per spec; no runtime use here
  }

  async buildUnsignedPayInvoice(
    row: InvoiceRowForTx,
    payerPrincipal?: string,
  ): Promise<any> {
    const isActive =
      typeof row.store.active === 'boolean'
        ? row.store.active
        : row.store.active === 1;
    if (!isActive) throw new HttpError(422, 'merchant-inactive');

    this.idGuard.validateHexIdOrThrow(row.id_hex);

    // â”€â”€ fail fast if the platform isn't configured with sBTC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const tokenId = this.cfg.getSbtcContractId();
    if (!tokenId) {
      // controller maps this to HTTP 422 â†’ { error: "missingSbtcToken" }
      throw new HttpError(422, 'missing-token');
    }
    // Surface misconfig early (throws if malformed)
    this.aif.getSbtcAssetInfo();

    // â”€â”€ Status/TTL checks AFTER config sanity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const onchain = await this.chain.readInvoiceStatus(row.id_hex);
    const ttlExpired = Date.now() > row.quote_expires_at;
    if (ttlExpired || onchain === 'expired') throw new HttpError(409, 'expired');
    if (
      onchain === 'paid' ||
      onchain === 'canceled' ||
      this.nonPayableStatuses.has(row.status)
    ) {
      throw new HttpError(409, 'invalid-state');
    }

    const effectivePayer =
      typeof payerPrincipal === 'string' && payerPrincipal.length > 0
        ? payerPrincipal
        : row.merchant_principal;

    return this.builder.buildPayInvoice({
      idHex: row.id_hex,
      amountSats: row.amount_sats,
      payerPrincipal: effectivePayer,
      merchantPrincipal: row.merchant_principal,
    });
  }
}


---
# ./delegates/ContractCallEventNormalizer.ts

// src/delegates/ContractCallEventNormalizer.ts
import type { IStacksChainClient } from '../contracts/interfaces';
import type { ISqliteStore } from '../contracts/dao';
import type { NormalizedEvent } from '../contracts/domain';

export class ContractCallEventNormalizer {
  async fetchAndFilterEvents(
    fromHeight: number,
    chain: IStacksChainClient,
    store: ISqliteStore,
  ): Promise<NormalizedEvent[]> {
    const raw = await chain.getContractCallEvents({ fromHeight });

    const allowed = new Set<string>([
      'pay-invoice',
      'refund-invoice',
      'cancel-invoice',
      'create-subscription',
      'cancel-subscription',
      'pay-subscription',
    ]);

    const normalizeHex64 = (arg: any): string => {
      const hex = String(arg?.hex ?? '').replace(/^0x/, '');
      return hex.toLowerCase();
    };

    const parseUInt = (arg: any): number => {
      const repr: string = String(arg?.repr ?? '');
      if (repr.startsWith('u')) return Number(repr.slice(1));
      return Number(repr);
    };

    const parsePrincipal = (arg: any): string => {
      return String(arg?.repr ?? '');
    };

    const out: NormalizedEvent[] = [];

    for (const tx of raw) {
      const fn = String(tx?.contract_call?.function_name ?? '');
      if (!allowed.has(fn)) continue;

      const args: any[] = tx?.contract_call?.function_args ?? [];
      const block_height: number = Number(tx.block_height);
      const tx_id: string = String(tx.tx_id);
      const tx_index: number = Number(tx.tx_index ?? 0);
      const sender: string = String(tx.sender_address ?? '');

      const idHex = args[0] ? normalizeHex64(args[0]) : '';
      if (!/^[0-9a-f]{64}$/.test(idHex)) continue;

      if (fn === 'pay-invoice') {
        if (store.invoiceExists(idHex)) {
          out.push({ type: 'invoice-paid', idHex, block_height, tx_id, tx_index, sender });
        }
        continue;
      }

      if (fn === 'refund-invoice') {
        if (store.invoiceExists(idHex)) {
          const refundAmountSats = parseUInt(args[1]);
          out.push({ type: 'refund-invoice', idHex, block_height, tx_id, tx_index, refundAmountSats });
        }
        continue;
      }

      if (fn === 'cancel-invoice') {
        if (store.invoiceExists(idHex)) {
          out.push({ type: 'invoice-canceled', idHex, block_height, tx_id, tx_index });
        }
        continue;
      }

      if (fn === 'create-subscription') {
        const merchantPrincipal = parsePrincipal(args[1]);
        const subscriber = parsePrincipal(args[2]);
        const amountSats = parseUInt(args[3]);
        const intervalBlocks = parseUInt(args[4]);
        out.push({
          type: 'create-subscription',
          idHex,
          block_height,
          tx_id,
          tx_index,
          merchantPrincipal,
          subscriber,
          amountSats,
          intervalBlocks,
        });
        continue;
      }

      if (fn === 'cancel-subscription') {
        out.push({ type: 'cancel-subscription', idHex, block_height, tx_id, tx_index });
        continue;
      }

      if (fn === 'pay-subscription') {
        out.push({ type: 'pay-subscription', idHex, block_height, tx_id, tx_index, sender });
        continue;
      }
    }

    out.sort((a, b) => {
      if (a.block_height !== b.block_height) return a.block_height - b.block_height;
      return a.tx_index - b.tx_index;
    });

    return out;
  }
}


---
# ./delegates/DirectSubscriptionPaymentTxBuilder.ts

// src/delegates/DirectSubscriptionPaymentTxBuilder.ts
import type { IStacksChainClient, IContractCallBuilder, IInvoiceIdCodec } from '../contracts/interfaces';
import type { SubscriptionRow, UnsignedContractCall } from '../contracts/domain';

export class DirectSubscriptionPaymentTxBuilder {
  constructor(
    private readonly chain: IStacksChainClient,
    private readonly builder: IContractCallBuilder,
    private readonly codec: IInvoiceIdCodec
  ) {}

  async assemble(
    sub: SubscriptionRow,
    payerPrincipal: string,
    merchantPrincipal: string
  ): Promise<UnsignedContractCall> {
    if (sub.active !== 1 || sub.mode !== 'direct') {
      const e: any = new Error('Subscription not payable in direct mode');
      e.code = 'bad_status';
      throw e;
    }

    this.codec.assertHex64(sub.id_hex);

    if (payerPrincipal !== sub.subscriber) {
      const e: any = new Error('Payer must equal subscriber');
      e.code = 'invalid_payer';
      throw e;
    }

    const tip = await this.chain.getTip();
    if (tip.height < sub.next_invoice_at) {
      const e: any = new Error('Current height below next invoice at');
      e.code = 'too_early';
      throw e;
    }

    const token = await this.chain.readSbtcToken();
    if (!token) {
      const e: any = new Error('sBTC token not set');
      e.code = 'missing_token';
      throw e;
    }

    return this.builder.buildPaySubscription({
      idHex: sub.id_hex,
      amountSats: sub.amount_sats,
      subscriber: payerPrincipal,
      merchant: merchantPrincipal,
    });
  }
}


---
# ./delegates/ApiCaseAndDtoMapper.ts

// src/delegates/ApiCaseAndDtoMapper.ts
import type {
  InvoiceRow,
  WebhookLogRow,
  MerchantRow,
  PublicInvoiceDTO,
  StorePrivateProfileDTO,
} from '../contracts/domain';


export class ApiCaseAndDtoMapper {
  invoiceToPublicDto(r: InvoiceRow): PublicInvoiceDTO {
    return {
      invoiceId: r.id_raw,
      idHex: r.id_hex,
      storeId: r.store_id,
      amountSats: r.amount_sats,
      usdAtCreate: r.usd_at_create,
      quoteExpiresAt: r.quote_expires_at,
      merchantPrincipal: r.merchant_principal,
      status: r.status,
      payer: r.payer ?? undefined,
      txId: r.txid ?? undefined,
      memo: r.memo ?? undefined,
      subscriptionId: r.subscription_id ?? undefined,
      createdAt: r.created_at,
      refundAmount: r.refund_amount ?? undefined,
      refundTxId: r.refund_txid ?? undefined,
      store: undefined,
    };
  }

  webhookToDto(w: WebhookLogRow): {
    id: string;
    storeId: string;
    invoiceId?: string | null;
    subscriptionId?: string | null;
    eventType: string;
    payload: string;
    statusCode: number | null;
    success: boolean;
    attempts: number;
    lastAttemptAt: number | null;
  } {
    return {
      id: w.id,
      storeId: w.store_id,
      invoiceId: w.invoice_id ?? null,
      subscriptionId: w.subscription_id ?? null,
      eventType: w.event_type,
      payload: w.payload,
      statusCode: w.status_code ?? null,
      success: w.success === 1,
      attempts: w.attempts,
      lastAttemptAt: w.last_attempt_at ?? null,
    };
  }

  storeToPrivateProfile(row: MerchantRow): StorePrivateProfileDTO {
    return {
      id: row.id,
      name: row.name ?? undefined,
      displayName: row.display_name ?? null,
      logoUrl: row.logo_url ?? null,
      brandColor: row.brand_color ?? null,
      webhookUrl: row.webhook_url ?? undefined,
      supportEmail: row.support_email ?? null,
      supportUrl: row.support_url ?? null,
      allowedOrigins: row.allowed_origins
        ? row.allowed_origins
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
        : [],
      principal: row.principal,
      active: !!row.active,
    };
  }

  toCamel<T = any>(input: any): T {
    if (input === null || typeof input !== 'object') return input as T;
    if (Array.isArray(input)) return input.map((v) => this.toCamel(v)) as any;
    const out: Record<string, any> = {};
    for (const [k, v] of Object.entries(input)) {
      const camel = k.replace(/_([a-z])/g, (_, c: string) => c.toUpperCase());
      out[camel] = this.toCamel(v);
    }
    return out as T;
  }

  toSnake<T extends Record<string, any> = Record<string, any>>(input: any): T {
    if (input === null || typeof input !== 'object') return input as T;
    if (Array.isArray(input)) return input.map((v) => this.toSnake(v)) as any;
    const out: Record<string, any> = {};
    for (const [k, v] of Object.entries(input)) {
      const snake = k.replace(/[A-Z]/g, (c) => `_${c.toLowerCase()}`);
      out[snake] = this.toSnake(v);
    }
    return out as T;
  }
}


---
# ./delegates/RefundPolicyGuard.ts

// src/delegates/RefundPolicyGuard.ts
import type { IInvoiceIdCodec } from '../contracts/interfaces';
import { RefundService } from '../services/RefundService';
import type { MerchantRow, InvoiceRow, UnsignedContractCall } from '../contracts/domain';

export class RefundPolicyGuard {
  constructor(private readonly codec: IInvoiceIdCodec, private readonly refund: RefundService) {}

  async enforceAndBuild(
    store: MerchantRow,
    invRow: InvoiceRow,
    amountSats: number,
    memo?: string,
  ): Promise<UnsignedContractCall> {
    if (invRow.status !== 'paid' && invRow.status !== 'partially_refunded') {
      const e: any = new Error('Invoice not refundable in current status');
      e.code = 'bad_status';
      throw e;
    }

    this.codec.assertHex64(invRow.id_hex);

    const alreadyRefunded = invRow.refund_amount ?? 0;
    const proposed = alreadyRefunded + amountSats;
    if (proposed > invRow.amount_sats) {
      const e: any = new Error('Refund cap exceeded');
      e.code = 'cap_violation';
      throw e;
    }

    const hasBalance = await this.refund.precheckBalance(store.principal, amountSats);
    if (!hasBalance) {
      const e: any = new Error('Insufficient sBTC balance');
      e.code = 'insufficient_balance';
      throw e;
    }

    return this.refund.buildRefundPayload(store, invRow, amountSats, memo);
  }
}


---
# ./delegates/MerchantProjectionPolicy.ts

// src/delegates/MerchantProjectionPolicy.ts
import type { MerchantRow } from '../contracts/domain';

export class MerchantProjectionPolicy {
  getListProjectionSQL(): string {
    return `
      SELECT
        id,
        principal,
        name,
        display_name,
        logo_url,
        brand_color,
        webhook_url,
        active,
        support_email,
        support_url,
        allowed_origins,
        created_at
      FROM merchants
      ORDER BY created_at DESC
    `;
  }

  mapListRow(raw: any): Omit<MerchantRow, 'api_key' | 'hmac_secret'> {
    return {
      id: raw.id as string,
      principal: raw.principal as string,
      name: raw.name ?? undefined,
      display_name: raw.display_name ?? undefined,
      logo_url: raw.logo_url ?? undefined,
      brand_color: raw.brand_color ?? undefined,
      webhook_url: raw.webhook_url ?? undefined,
      active: Number(raw.active),
      support_email: raw.support_email ?? undefined,
      support_url: raw.support_url ?? undefined,
      allowed_origins: raw.allowed_origins ?? undefined,
      created_at: Number(raw.created_at),

      // NEW: key-rotation columns
      keys_rotation_version: Number(raw.keys_rotation_version ?? 0),
      keys_last_rotated_at:
        raw.keys_last_rotated_at != null ? Number(raw.keys_last_rotated_at) : undefined,
      keys_last_revealed_at:
        raw.keys_last_revealed_at != null ? Number(raw.keys_last_revealed_at) : undefined,
      keys_dual_valid_until:
        raw.keys_dual_valid_until != null ? Number(raw.keys_dual_valid_until) : undefined,
    };
  }
}


---
# ./delegates/WebhookSignatureService.ts

// src/delegates/WebhookSignatureService.ts
import crypto from 'crypto';

type VerifyOk = { ok: true };
type VerifyFail = { ok: false; status: 401 | 409 };

export class WebhookSignatureService {
  private readonly maxSkewSeconds: number;
  private readonly replayTtlSeconds: number;
  private readonly replayCache = new Map<string, number>();

  constructor(maxSkewSeconds: number = 300, replayTtlSeconds: number = 600) {
    this.maxSkewSeconds = maxSkewSeconds;
    this.replayTtlSeconds = replayTtlSeconds;
  }

  buildOutboundHeaders(
    secret: string,
    rawBody: string,
    nowEpochSecs: number,
  ): { headers: Record<string, string>; signatureHex: string; timestamp: number } {
    const signatureHex = crypto
      .createHmac('sha256', secret)
      .update(`${nowEpochSecs}.${rawBody}`)
      .digest('hex');
    return {
      signatureHex,
      timestamp: nowEpochSecs,
      headers: {
        'Content-Type': 'application/json',
        'X-Webhook-Timestamp': String(nowEpochSecs),
        'X-Webhook-Signature': `v1=${signatureHex}`,
      },
    };
  }

  verifyInbound(
    tsHeader: string | undefined,
    sigHeader: string | undefined,
    rawBody: string,
    secret: string,
    nowEpochSecs: number,
  ): VerifyOk | VerifyFail {
    if (!tsHeader || !sigHeader) return { ok: false, status: 401 };

    const ts = Number(tsHeader);
    if (!Number.isFinite(ts) || Math.abs(nowEpochSecs - ts) > this.maxSkewSeconds) {
      return { ok: false, status: 401 };
    }

    const seenAt = this.replayCache.get(sigHeader);
    if (seenAt && nowEpochSecs - seenAt <= this.replayTtlSeconds) {
      return { ok: false, status: 409 };
    }

    const presented = sigHeader.startsWith('v1=') ? sigHeader.slice(3) : sigHeader;
    const expected = crypto.createHmac('sha256', secret).update(`${ts}.${rawBody}`).digest('hex');

    const a = Buffer.from(expected, 'hex');
    const b = Buffer.from(presented, 'hex');
    if (a.length !== b.length || !crypto.timingSafeEqual(a, b)) {
      return { ok: false, status: 401 };
    }

    this.replayCache.set(sigHeader, nowEpochSecs);
    for (const [sig, firstSeen] of this.replayCache.entries()) {
      if (nowEpochSecs - firstSeen > this.replayTtlSeconds) {
        this.replayCache.delete(sig);
      }
    }
    return { ok: true };
  }
}

export default WebhookSignatureService;


---
# ./delegates/InvoiceStatusResolver.ts

// src/delegates/InvoiceStatusResolver.ts
import type { IStacksChainClient } from '../contracts/interfaces';
import type { InvoiceIdGuard } from '../delegates/InvoiceIdGuard';

type OnchainInvoiceStatus = 'not-found' | 'paid' | 'canceled' | 'expired' | 'unpaid';
type PublicStatus = 'paid' | 'canceled' | 'expired' | 'unpaid' | 'pending';

type InvoiceRowMinimal = {
  id_hex: string;
  status: PublicStatus;
  quote_expires_at: number; // ms epoch
};

type InvoiceIdGuardLike = Pick<InvoiceIdGuard, 'validateHexIdOrThrow'>;

export class InvoiceStatusResolver {
  constructor(
    private readonly chain: IStacksChainClient,
    private readonly idGuard: InvoiceIdGuardLike
  ) { }

  private withTimeout<T>(p: Promise<T>, ms = 6000): Promise<T> {
    return new Promise((resolve, reject) => {
      const t = setTimeout(() => reject(new Error('read_timeout')), ms);
      p.then(v => { clearTimeout(t); resolve(v); }, e => { clearTimeout(t); reject(e); });
    });
  }

  async readOnchainStatus(idHex: string): Promise<OnchainInvoiceStatus> {
    this.idGuard.validateHexIdOrThrow(idHex);
    try {
      const status = await this.withTimeout(this.chain.readInvoiceStatus(idHex), 6000);
      return status as any;
    } catch {
      // Safe fallback: treat as not-visible on-chain yet
      return 'not-found';
    }
  }

  computeDisplayStatus(
    row: InvoiceRowMinimal,
    onchain: OnchainInvoiceStatus,
    nowMs: number
  ): PublicStatus {
    if (onchain === 'paid') return 'paid';
    if (onchain === 'canceled') return 'canceled';
    if (nowMs > row.quote_expires_at || onchain === 'expired') return 'expired';
    // Treat 'not-found' as whatever DB says (usually 'unpaid')
    return row.status === 'pending' ? 'unpaid' : row.status;
  }
}


---
# ./delegates/MerchantOnchainSyncPlanner.ts

// src/delegates/MerchantOnchainSyncPlanner.ts
import type { ISqliteStore } from '../contracts/dao';
import type { IStacksChainClient, IContractCallBuilder } from '../contracts/interfaces';
import type { UnsignedContractCall } from '../contracts/domain';

export class MerchantOnchainSyncPlanner {
  async planForStore(
    store: ISqliteStore,
    chain: IStacksChainClient,
    builder: IContractCallBuilder,
    storeId: string
  ): Promise<{ notFound: true } | { calls: UnsignedContractCall[] }> {
    const merchant = store.listMerchantsProjection().find((m: any) => m.id === storeId);
    if (!merchant) return { notFound: true };

    const principal: string = merchant.principal;
    const isRegistered: boolean = await (chain as any).isMerchantRegisteredOnChain(principal);

    const calls: UnsignedContractCall[] = [];
    if (!isRegistered) {
      calls.push(
        builder.buildRegisterMerchant({
          merchant: principal,
          name: merchant.name ?? undefined,
        }),
      );
    }
    calls.push(
      builder.buildSetMerchantActive({
        merchant: principal,
        active: !!merchant.active,
      }),
    );

    return { calls };
  }
}


---
# ./delegates/WebhookRetryQueryComposer.ts

// src/delegates/WebhookRetryQueryComposer.ts
import type { WebhookEventType } from '../contracts/domain';

export type ComposedQuery = { sql: string; params: any[] };

export interface WebhookRetryQueryComposerOptions {
  maxAttempts: number;
  backoffSeconds: number[];
}

export class WebhookRetryQueryComposer {
  private readonly maxAttempts: number;
  private readonly backoffSeconds: number[];

  constructor(opts: WebhookRetryQueryComposerOptions) {
    if (!opts || !Array.isArray(opts.backoffSeconds) || opts.backoffSeconds.length === 0) {
      throw new Error('backoffSeconds must be a non-empty array');
    }
    if (typeof opts.maxAttempts !== 'number' || opts.maxAttempts <= 0) {
      throw new Error('maxAttempts must be a positive number');
    }
    this.maxAttempts = opts.maxAttempts;
    this.backoffSeconds = opts.backoffSeconds;
  }

  composeSelectDueRetriesSQL(): ComposedQuery {
    const backoffCase = this.buildCaseExpr('w.attempts');
    const sql = `
      SELECT *
      FROM webhook_logs w
      WHERE w.success = 0
        AND w.attempts < ${this.maxAttempts}
        AND (
          (strftime('%s','now') - w.last_attempt_at) >= ${backoffCase}
        )
        AND w.last_attempt_at = (
          SELECT MAX(w2.last_attempt_at)
          FROM webhook_logs w2
          WHERE w2.store_id = w.store_id
            AND COALESCE(w2.invoice_id, '') = COALESCE(w.invoice_id, '')
            AND COALESCE(w2.subscription_id, '') = COALESCE(w.subscription_id, '')
            AND w2.event_type = w.event_type
        )
      ORDER BY w.last_attempt_at ASC
    `;
    return { sql, params: [] };
  }

  composeGetDueAttemptsSQL(nowEpochSecs: number): ComposedQuery {
    const backoffCase = this.buildCaseExpr('attempts');
    const sql = `
      SELECT *
      FROM webhook_logs
      WHERE success = 0
        AND attempts < ${this.maxAttempts}
        AND (? - last_attempt_at) >= ${backoffCase}
      ORDER BY last_attempt_at ASC
    `;
    return { sql, params: [nowEpochSecs] };
  }

  composeExistsSuccessfulDeliverySQL(ctx: {
    storeId: string;
    invoiceId?: string;
    subscriptionId?: string;
    eventType: WebhookEventType;
  }): ComposedQuery {
    const sql = `
      SELECT 1
      FROM webhook_logs
      WHERE store_id = ?
        AND event_type = ?
        AND (invoice_id IS ? OR invoice_id = ?)
        AND (subscription_id IS ? OR subscription_id = ?)
        AND success = 1
      LIMIT 1
    `;
    const params = [
      ctx.storeId,
      ctx.eventType,
      ctx.invoiceId ?? null,
      ctx.invoiceId ?? null,
      ctx.subscriptionId ?? null,
      ctx.subscriptionId ?? null,
    ];
    return { sql, params };
  }

  composeHasSuccessfulExpiredWebhookSQL(storeId: string, invoiceId: string): ComposedQuery {
    const sql = `
      SELECT 1
      FROM webhook_logs
      WHERE store_id = ?
        AND invoice_id = ?
        AND event_type = 'invoice-expired'
        AND success = 1
      LIMIT 1
    `;
    return { sql, params: [storeId, invoiceId] };
  }

  private buildCaseExpr(attemptsColumn: string): string {
    const whens = this.backoffSeconds.map((sec, idx) => `WHEN ${idx} THEN ${sec}`).join(' ');
    const last = this.backoffSeconds[this.backoffSeconds.length - 1];
    return `CASE ${attemptsColumn} ${whens} ELSE ${last} END`;
  }
}


---
# ./delegates/SchedulerStartupCoordinator.ts

// src/delegates/SchedulerStartupCoordinator.ts
import type { IConfigService } from '../contracts/interfaces';

export class SchedulerStartupCoordinator {
  private startedPoller = false;
  private startedRetry = false;
  private startedSubscription = false;

  public async startSchedulers(deps: {
    poller: { bootstrapPoller(): void };
    webhookRetry: { bootstrap(): void };
    subscriptionScheduler?: { bootstrapScheduler(): void };
    config: IConfigService;
  }): Promise<void> {
    if (!this.startedPoller) {
      deps.poller.bootstrapPoller();
      this.startedPoller = true;
    }
    if (!this.startedRetry) {
      deps.webhookRetry.bootstrap();
      this.startedRetry = true;
    }
    if (deps.subscriptionScheduler && !this.startedSubscription) {
      deps.subscriptionScheduler.bootstrapScheduler();
      this.startedSubscription = true;
    }
  }
}


---
# ./delegates/MerchantInputValidator.ts

// src/delegates/MerchantInputValidator.ts
import { Validation } from '../validation/rules';

export class MerchantInputValidator {
  validateCreateInvoiceBody(body: any): {
    amountSats: number;
    ttlSeconds: number;
    memo?: string;
    webhookUrl?: string;
  } {
    const amountSats = Number(body?.amount_sats);
    const ttlSeconds = Number(body?.ttl_seconds);

    if (!Number.isInteger(amountSats) || amountSats <= 0) {
      throw new TypeError('amount_sats must be positive int');
    }
    if (!Number.isInteger(ttlSeconds) || ttlSeconds <= 0) {
      throw new TypeError('ttl_seconds must be positive int');
    }

    let memo: string | undefined;
    if (body?.memo !== undefined && body.memo !== null) {
      const str = String(body.memo);
      const buf = Buffer.from(str, 'utf8').subarray(0, Validation.createInvoice.memoMaxUtf8Bytes);
      memo = buf.toString('utf8');
    }

    let webhookUrl: string | undefined;
    if (body?.webhook_url) {
      const url = String(body.webhook_url);
      if (!Validation.url.test(url)) {
        throw new TypeError('invalid webhook_url');
      }
      webhookUrl = url;
    }

    return { amountSats, ttlSeconds, memo, webhookUrl };
  }

  public validateRefundBody(body: Record<string, unknown>): {
    invoiceId: string;
    amountSats: number;
    memo?: string;
  } {
    const b = body || {};

    // accept snake_case or camelCase
    const invoiceId = String(
      (b as any).invoice_id ?? (b as any).invoiceId ?? ''
    ).trim();
    const amountSatsRaw = (b as any).amount_sats ?? (b as any).amountSats;
    const amountSats = Number(amountSatsRaw);

    // same memo handling (limit per Steroids)
    const memoMax = Validation.refund.memoMaxUtf8Bytes;
    let memo: string | undefined;
    if (typeof (b as any).memo === 'string') {
      const enc = new TextEncoder().encode((b as any).memo);
      memo = new TextDecoder().decode(enc.subarray(0, memoMax));
    }

    // current project uses regexes on Validation, not methods
    if (!invoiceId || !Validation.uuid.test(invoiceId)) {
      throw new TypeError('invalid invoice_id');
    }
    if (!Number.isInteger(amountSats) || amountSats <= 0) {
      throw new TypeError('invalid amount_sats');
    }

    // NOTICE: return **camelCase** (controller expects this)
    return { invoiceId, amountSats, memo };
  }


  assertStacksPrincipal(p: string): void {
    if (!Validation.stacksPrincipal.test(p)) {
      throw new TypeError('invalid principal');
    }
  }

  assertPositiveInt(n: number, name: string): void {
    if (!Number.isInteger(n) || n <= 0) {
      throw new TypeError(`${name} must be positive integer`);
    }
  }
}


---
# ./delegates/SubscriptionLifecycleProcessor.ts

// src/delegates/SubscriptionLifecycleProcessor.ts
import type { ISqliteStore } from '../contracts/dao';
import type { IStacksChainClient, IWebhookDispatcher } from '../contracts/interfaces';
import type { NormalizedEvent } from '../contracts/domain';

export class SubscriptionLifecycleProcessor {
  constructor(
    private store: ISqliteStore,
    private chain: IStacksChainClient,
    private dispatcher: IWebhookDispatcher,
  ) {}

  async processBatch(
    batch: NormalizedEvent[],
    tipHeight: number,
    minConfirmations: number,
  ): Promise<void> {
    // create-subscription
    for (const e of batch) {
      if (e.type !== 'create-subscription') continue;
      const conf = tipHeight - e.block_height + 1;
      if (conf < minConfirmations) continue;

      const storeId = this.store.getStoreIdByPrincipal(e.merchantPrincipal!);
      if (!storeId) continue;

      this.store.upsertSubscriptionByHex({
        idHex: e.idHex,
        storeId,
        merchantPrincipal: e.merchantPrincipal!,
        subscriber: e.subscriber!,
        amountSats: e.amountSats!,
        intervalBlocks: e.intervalBlocks!,
        active: 1,
      });

      const onchain = await this.chain.readSubscription(e.idHex);
      const nextDue = onchain?.nextDue ? Number(onchain.nextDue) : 0;

      const rawBody = JSON.stringify({
        subscriptionId: e.idHex,
        merchant: e.merchantPrincipal!,
        subscriber: e.subscriber!,
        amountSats: e.amountSats!,
        intervalBlocks: e.intervalBlocks!,
        nextDue,
      });

      await this.dispatcher.dispatch({
        storeId,
        subscriptionId: e.idHex,
        eventType: 'subscription-created',
        rawBody,
      });
    }

    // cancel-subscription
    for (const e of batch) {
      if (e.type !== 'cancel-subscription') continue;
      const conf = tipHeight - e.block_height + 1;
      if (conf < minConfirmations) continue;

      this.store.setSubscriptionActive({ idHex: e.idHex, active: 0 });

      const onchain = await this.chain.readSubscription(e.idHex);
      const storeId = onchain ? this.store.getStoreIdByPrincipal(onchain.merchant) : undefined;
      if (!storeId) continue;

      const rawBody = JSON.stringify({ subscriptionId: e.idHex });

      await this.dispatcher.dispatch({
        storeId,
        subscriptionId: e.idHex,
        eventType: 'subscription-canceled',
        rawBody,
      });
    }

    // pay-subscription
    for (const e of batch) {
      if (e.type !== 'pay-subscription') continue;
      const conf = tipHeight - e.block_height + 1;
      if (conf < minConfirmations) continue;

      const onchain = await this.chain.readSubscription(e.idHex);
      const amountSats = onchain ? Number(onchain.amountSats) : 0;
      const nextDue = onchain ? Number(onchain.nextDue) : 0;
      const merchant = onchain?.merchant;
      const storeId = merchant ? this.store.getStoreIdByPrincipal(merchant) : undefined;
      if (!storeId) continue;

      // DB linkage update (idempotency handled in DAO)
      this.store.updateSubscriptionLastPaid({ subscriptionId: e.idHex, lastPaidInvoiceId: '' });

      const rawBody = JSON.stringify({
        subscriptionId: e.idHex,
        subscriber: e.sender!,
        amountSats,
        txId: e.tx_id,
        nextDue,
      });

      await this.dispatcher.dispatch({
        storeId,
        subscriptionId: e.idHex,
        eventType: 'subscription-paid',
        rawBody,
      });
    }
  }
}


---
# ./delegates/MerchantKeyRotationService.ts

// src/delegates/MerchantKeyRotationService.ts
import { randomBytes } from 'crypto';
import type { ISqliteStore } from '../contracts/dao';

export class MerchantKeyRotationService {
  private deliveredOnce = new Set<string>();

  rotate(
    store: ISqliteStore,
    storeId: string
  ):
    | { ok: true; apiKey: string; hmacSecret: string }
    | { ok: false; notFound: true }
    | { ok: false; alreadyDelivered: true } {
    const exists = store.listMerchantsProjection().some((m: any) => m.id === storeId);
    if (!exists) return { ok: false, notFound: true };

    if (this.deliveredOnce.has(storeId)) {
      // Do not rotate again and do not leak again
      return { ok: false, alreadyDelivered: true };
    }

    const apiKey = randomBytes(32).toString('hex');
    const hmacSecret = randomBytes(32).toString('hex');

    store.updateMerchantKeysTx(storeId, apiKey, hmacSecret);
    this.deliveredOnce.add(storeId);

    return { ok: true, apiKey, hmacSecret };
  }
}


---
# ./delegates/SqlInListBuilder.ts

// src/delegates/SqlInListBuilder.ts

export class SqlInListBuilder {
  buildInClause(
    column: string,
    values: Array<string | number>,
  ): { clause: string; params: Array<string | number> } {
    if (!Array.isArray(values) || values.length === 0) {
      throw new Error('values must be a non-empty array');
    }
    for (const v of values) {
      const t = typeof v;
      if (t !== 'string' && t !== 'number') {
        throw new Error('values must contain only strings or numbers');
      }
    }
    const placeholders = values.map(() => '?').join(',');
    return {
      clause: `${column} IN (${placeholders})`,
      params: values,
    };
  }
}


---
# ./delegates/ClarityCvAdapter.ts

// src/delegates/ClarityCvAdapter.ts
import type { ClarityValue } from '@stacks/transactions';
import { cvToJSON, cvToString } from '@stacks/transactions';
import type { OnChainSubscription } from '../contracts/domain';

export class ClarityCvAdapter {
  guardHex32(idHex: string): Buffer {
    if (typeof idHex !== 'string' || idHex.length !== 64) {
      throw new Error('idHex must be 64 hex chars');
    }
    const buf = Buffer.from(idHex, 'hex');
    if (buf.length !== 32 || buf.toString('hex') !== idHex.toLowerCase()) {
      throw new Error('idHex must decode to 32 bytes and round-trip');
    }
    return buf;
  }

  decodeOptionalContractPrincipal(
    cv: ClarityValue,
  ): { contractAddress: string; contractName: string } | undefined {
    const asString = cvToString(cv);
    if (asString === 'none' || asString === '(none)') return undefined;
    const m = asString.match(/\(some\s+([A-Z0-9]{1,}\.[a-zA-Z0-9\-_]+)\)/);
    if (m && m[1]) {
      const [contractAddress, contractName] = m[1].split('.');
      return { contractAddress, contractName };
    }
    const j: any = cvToJSON(cv);
    if (j?.type === 'some' && j?.value) {
      const inner = j.value;
      const contractAddress = inner.address ?? inner.contractAddress;
      const contractName = inner.contractName ?? inner.name;
      if (contractAddress && contractName) return { contractAddress, contractName };
    }
    throw new Error(`Unexpected optional contract-principal shape: ${asString}`);
  }

  decodeOptionalSubscriptionTuple(cv: ClarityValue, idHex: string): OnChainSubscription | undefined {
    const j: any = cvToJSON(cv);
    if (j.type === 'none') return undefined;
    const t: any = j.value;
    const merchant = String(t['merchant']);
    const subscriber = String(t['subscriber']);
    const amountSats = BigInt(t['amount']);
    const intervalBlocks = BigInt(t['interval']);
    const active = Boolean(t['active']);
    const nextDue = BigInt(t['next-due']);
    return { idHex, merchant, subscriber, amountSats, intervalBlocks, active, nextDue };
  }
}

export default ClarityCvAdapter;


---
# ./delegates/AdditionalControllerUsagesOfAdminParamGuard.ts

// src/delegates/AdditionalControllerUsagesOfAdminParamGuard.ts
import { AdminParamGuard } from '../delegates/AdminParamGuard';

export class AdditionalControllerUsagesOfAdminParamGuard {
  private readonly guard = new AdminParamGuard();

  validateSetSbtcTokenBody(body: {
    contractAddress?: string;
    contractName?: string;
  }): { contractAddress: string; contractName: string } {
    const contractAddress = String(body.contractAddress ?? '');
    const contractName = String(body.contractName ?? '');
    this.guard.assertStacksPrincipal(contractAddress);
    if (!contractName) {
      throw new TypeError('Invalid contractName');
    }
    return { contractAddress, contractName };
  }

  validateActivateStoreParams(
    storeId: string,
    body: { active?: unknown },
  ): { storeId: string; active: boolean } {
    this.guard.assertUuid(storeId);
    const active = !!body.active;
    return { storeId, active };
  }

  validateCancelInvoiceParams(invoiceId: string): { invoiceId: string } {
    this.guard.assertUuid(invoiceId);
    return { invoiceId };
  }
}


---
# ./delegates/StorePublicProfileProjector.ts

// src/delegates/StorePublicProfileProjector.ts
import type { StorePublicProfileDTO } from '../contracts/domain';

export type StoreLike = {
  display_name?: string | null;
  logo_url?: string | null;
  brand_color?: string | null;
  support_email?: string | null;
  support_url?: string | null;
};

export class StorePublicProfileProjector {
  project(store: StoreLike): StorePublicProfileDTO {
    return {
      displayName: store.display_name ?? null,
      logoUrl: store.logo_url ?? null,
      brandColor: store.brand_color ?? null,
      supportEmail: store.support_email ?? null,
      supportUrl: store.support_url ?? null,
    };
  }
}


---
# ./delegates/WebhookInboundSurfaceBinder.ts

import type { Express, RequestHandler } from 'express';
import express from 'express';

export class WebhookInboundSurfaceBinder {
  private mounted = false;

  public bind(app: Express, verifierMw: RequestHandler): void {
    if (this.mounted) return;
    app.use(
      '/webhooks/inbound',
      express.raw({ type: 'application/json' }),
      verifierMw,
    );
    this.mounted = true;
  }
}


---
# ./delegates/RootRouteBinder.ts

// src/delegates/RootRouteBinder.ts
import type { Express } from 'express';

export class RootRouteBinder {
  private mounted = false;

  public bindRoot(app: Express, handler: { getRoot(req: any, res: any): void }): void {
    if (this.mounted) return;
    app.get('/', (req, res) => handler.getRoot(req, res));
    this.mounted = true;
  }
}


---
# ./delegates/WebhookAttemptPlanner.ts

// src/delegates/WebhookAttemptPlanner.ts
import crypto from 'crypto';
import type { ISqliteStore } from '../contracts/dao';
import type { WebhookLogRow } from '../contracts/domain';

type RecordCtx = {
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: string;
  rawBody: string;
  attempts: number;
  now: number; // epoch seconds
};

type FailureCtx = {
  attemptLogId: string;
  attempts: number;
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: string;
  rawBody: string;
  now: number; // epoch seconds
};

type PlanCtx = {
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: string;
  rawBody: string;
  attempts: number;
  now: number; // epoch seconds
};

const MAX_ATTEMPTS = 5;

export class WebhookAttemptPlanner {
  recordInitialAttempt(store: ISqliteStore, ctx: RecordCtx): string {
    const id = crypto.randomUUID();
    const row: WebhookLogRow = {
      id,
      store_id: ctx.storeId,
      invoice_id: ctx.invoiceId,
      subscription_id: ctx.subscriptionId,
      event_type: ctx.eventType as any,
      payload: ctx.rawBody,
      status_code: undefined,
      success: 0,
      attempts: ctx.attempts,
      last_attempt_at: ctx.now,
    };
    store.insertWebhookAttempt(row);
    return id;
  }

  markSuccess(store: ISqliteStore, attemptLogId: string, status: number): void {
    store.updateWebhookAttemptStatus(attemptLogId, { success: 1, statusCode: status });
  }

  async handleFailureAndPlanNext(
    store: ISqliteStore,
    ctx: FailureCtx,
    statusOrNull?: number,
  ): Promise<void> {
    store.updateWebhookAttemptStatus(ctx.attemptLogId, {
      success: 0,
      statusCode: typeof statusOrNull === 'number' ? statusOrNull : undefined,
    });
    if (ctx.attempts >= MAX_ATTEMPTS) return;
    await this.planNextAttempt(store, {
      storeId: ctx.storeId,
      invoiceId: ctx.invoiceId,
      subscriptionId: ctx.subscriptionId,
      eventType: ctx.eventType,
      rawBody: ctx.rawBody,
      attempts: ctx.attempts,
      now: ctx.now,
    });
  }

  async planNextAttempt(store: ISqliteStore, ctx: PlanCtx): Promise<void> {
    const nextAttempt = ctx.attempts + 1;
    if (nextAttempt > MAX_ATTEMPTS) return;
    const id = crypto.randomUUID();
    const row: WebhookLogRow = {
      id,
      store_id: ctx.storeId,
      invoice_id: ctx.invoiceId,
      subscription_id: ctx.subscriptionId,
      event_type: ctx.eventType as any,
      payload: ctx.rawBody,
      status_code: undefined,
      success: 0,
      attempts: nextAttempt,
      last_attempt_at: ctx.now,
    };
    store.insertWebhookAttempt(row);
  }
}

export default WebhookAttemptPlanner;


---
# ./delegates/OptionalBuff34Encoder.ts

// src/delegates/OptionalBuff34Encoder.ts
import type { ClarityValue } from '@stacks/transactions';
import { bufferCV, someCV, noneCV } from '@stacks/transactions';

export class OptionalBuff34Encoder {
  encodeOptionalUtf8ToBuff34(input?: string | null): ClarityValue {
    if (input === undefined || input === null || input === '') {
      return noneCV();
    }
    const buf = Buffer.from(input, 'utf8').subarray(0, 34);
    return someCV(bufferCV(buf));
  }
}


---
# ./delegates/InvoiceEventApplier.ts

// src/delegates/InvoiceEventApplier.ts
import type { ISqliteStore } from '../contracts/dao';
import type { IWebhookDispatcher } from '../contracts/interfaces';
import type { NormalizedEvent, InvoiceStatus } from '../contracts/domain';

export class InvoiceEventApplier {
  constructor(private store: ISqliteStore, private dispatcher: IWebhookDispatcher) {}

  async handlePaid(e: NormalizedEvent): Promise<void> {
    this.store.markInvoicePaid(e.idHex, e.sender!, e.tx_id);

    const rows = this.store.selectAdminInvoices(['paid'] as InvoiceStatus[]);
    const row = rows.find((r) => r.id_hex === e.idHex)!;

    const rawBody = JSON.stringify({
      invoiceId: row.id_raw,
      status: 'paid' as const,
      txId: e.tx_id,
      payer: e.sender!,
      amountSats: row.amount_sats,
    });

    await this.dispatcher.dispatch({
      storeId: row.store_id,
      invoiceId: row.id_raw,
      eventType: 'paid',
      rawBody,
    });
  }

  async handleRefund(e: NormalizedEvent): Promise<void> {
    const refundAmount = e.refundAmountSats!;
    this.store.upsertInvoiceRefund(e.idHex, refundAmount, e.tx_id);

    const rows = this.store.selectAdminInvoices(
      ['refunded', 'partially_refunded', 'paid'] as InvoiceStatus[],
    );
    const row = rows.find((r) => r.id_hex === e.idHex)!;

    const rawBody = JSON.stringify({
      invoiceId: row.id_raw,
      status: 'refunded' as const,
      refundTxId: e.tx_id,
      refundAmount: refundAmount,
    });

    await this.dispatcher.dispatch({
      storeId: row.store_id,
      invoiceId: row.id_raw,
      eventType: 'refunded',
      rawBody,
    });
  }

  async handleCanceled(e: NormalizedEvent): Promise<void> {
    this.store.markInvoiceCanceled(e.idHex);

    const rows = this.store.selectAdminInvoices(['canceled'] as InvoiceStatus[]);
    const row = rows.find((r) => r.id_hex === e.idHex)!;

    const rawBody = JSON.stringify({
      invoiceId: row.id_raw,
    });

    await this.dispatcher.dispatch({
      storeId: row.store_id,
      invoiceId: row.id_raw,
      eventType: 'invoice-canceled',
      rawBody,
    });
  }
}


---
# ./delegates/PostConditionsComposer.ts

// src/delegates/PostConditionsComposer.ts
import type { IAssetInfoFactory, IPostConditionFactory } from '../contracts/interfaces';

export class PostConditionsComposer {
  constructor(
    private aif: IAssetInfoFactory,
    private pcf: IPostConditionFactory
  ) {}

  forRefund(
    merchantPrincipal: string,
    amountSats: number
  ): { postConditionMode: 'deny'; postConditions: any[] } {
    const asset = this.aif.getSbtcAssetInfo();
    const postConditions = this.pcf.forRefund(merchantPrincipal, amountSats, asset);
    return {
      postConditionMode: 'deny',
      postConditions,
    };
  }

  forPay(
    payerPrincipal: string,
    merchantPrincipal: string,
    amountSats: number
  ): { postConditionMode: 'deny'; postConditions: any[] } {
    const asset = this.aif.getSbtcAssetInfo();
    const postConditions = this.pcf.forPayInvoice(payerPrincipal, merchantPrincipal, amountSats, asset);
    return {
      postConditionMode: 'deny',
      postConditions,
    };
  }
}


---
# ./delegates/CorsMiddlewareFactory.ts

import type { RequestHandler } from 'express';
import cors from 'cors';
import type { CorsOptions } from 'cors';

export class CorsMiddlewareFactory {
  public create(
    methods: string[],
    corsPolicy: {
      publicCorsOriginValidator(
        origin: string | undefined,
        cb: (err: Error | null, allow?: boolean) => void,
        req: any,
      ): void;
    },
  ): RequestHandler {
    return (req, res, next) =>
      cors({
        origin: (origin, cb) => corsPolicy.publicCorsOriginValidator(origin, cb, req),
        methods,
        allowedHeaders: [
          'Content-Type',
          'X-API-Key',
          'X-Webhook-Timestamp',
          'X-Webhook-Signature',
        ],
      })(req, res, next);
  }
}


---
# ./delegates/WebhookAdminRetryService.ts

// src/delegates/WebhookAdminRetryService.ts
import type { ISqliteStore } from '../contracts/dao';
import type { IWebhookDispatcher } from '../contracts/interfaces';
import type { WebhookLogRow } from '../contracts/domain';

export class WebhookAdminRetryService {
  async retry(
    store: ISqliteStore,
    dispatcher: IWebhookDispatcher,
    webhookLogId: string
  ): Promise<
    | { type: 'not-found' }
    | { type: 'already-delivered' }
    | { type: 'enqueued'; enqueued: boolean }
  > {
    const row = store.getWebhookLogById(webhookLogId);
    if (!row) return { type: 'not-found' };

    const successExists = store.existsSuccessfulDeliveryFor({
      storeId: row.store_id,
      invoiceId: row.invoice_id ?? undefined,
      subscriptionId: row.subscription_id ?? undefined,
      eventType: row.event_type as any,
    });
    if (successExists) return { type: 'already-delivered' };

    const enqueued = await (dispatcher as any).enqueueRetryIfNotInflight(row as WebhookLogRow);
    return { type: 'enqueued', enqueued: !!enqueued };
  }
}


---
# ./delegates/ReorgGuard.ts

// src/delegates/ReorgGuard.ts
import type { IStacksChainClient } from '../contracts/interfaces';

export type CursorSnapshot = { lastHeight: number; lastBlockHash?: string };

export class ReorgGuard {
  async detectReorg(
    firstBlockToProcessHeight: number,
    tipHeight: number,
    cursor: CursorSnapshot,
    chain: IStacksChainClient,
  ): Promise<boolean> {
    if (tipHeight < cursor.lastHeight) return true;
    if (cursor.lastHeight === 0) return false;
    const header = await chain.getBlockHeader(firstBlockToProcessHeight);
    const parent = header.parent_block_hash;
    return parent !== cursor.lastBlockHash;
  }

  computeRewindTarget(cursor: CursorSnapshot, reorgWindowBlocks: number): number {
    const back = Math.max(0, cursor.lastHeight - reorgWindowBlocks);
    return back;
  }
}


---
# ./delegates/AdminParamGuard.ts

// src/delegates/AdminParamGuard.ts
import type { InvoiceStatus } from '../contracts/domain';

export class AdminParamGuard {
  assertUuid(id: string): void {
    const re =
      /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;
    if (!re.test(id)) {
      throw new TypeError('Invalid UUID');
    }
  }

  assertStacksPrincipal(p: string) {
    // allow mainnet (SPâ€¦) and testnet (STâ€¦) standard principals
    if (!/^S[PT][0-9A-Z]{38,60}$/i.test(p)) throw new TypeError('Invalid Stacks principal/address');
      return true;
    }

  parseInvoiceStatuses(
    input: string | string[] | undefined,
  ): Array<'unpaid' | 'paid' | 'partially_refunded' | 'refunded' | 'canceled' | 'expired'> {
    const allowed = new Set<InvoiceStatus>([
      'unpaid',
      'paid',
      'partially_refunded',
      'refunded',
      'canceled',
      'expired',
    ]);
    if (!input) return [];
    const arr = Array.isArray(input)
      ? input
      : String(input)
          .split(',')
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
    const out: InvoiceStatus[] = [];
    for (const s of arr) {
      if (allowed.has(s as InvoiceStatus)) out.push(s as InvoiceStatus);
    }
    return out as Array<
      'unpaid' | 'paid' | 'partially_refunded' | 'refunded' | 'canceled' | 'expired'
    >;
  }
}


---
# ./delegates/InvoiceIdGuard.ts

// src/delegates/InvoiceIdGuard.ts
import type { IInvoiceIdCodec } from '../contracts/interfaces';

export class InvoiceIdGuard {
  constructor(private codec: IInvoiceIdCodec) {}

  validateHexIdOrThrow(idHex: string): void {
    this.codec.assertHex64(idHex);
  }
}


---
# ./delegates/AdminSurfaceBinder.ts

import type { Express, RequestHandler } from 'express';

export class AdminSurfaceBinder {
  private mountedAuth = false;
  private mountedStatic = false;
  private mountedIndex = false;

  public bindAdminAuth(
    app: Express,
    adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },
  ): void {
    if (this.mountedAuth) return;
    app.use(
      ['/admin', '/api/admin'],
      (req, res, next) => adminAuth.authenticateAdmin(req, res, next),
    );
    this.mountedAuth = true;
  }

  public bindAdminStatic(
    app: Express,
    adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },
    staticMiddleware: RequestHandler,
  ): void {
    this.bindAdminAuth(app, adminAuth);
    if (this.mountedStatic) return;
    app.use(
      '/admin',
      (req, res, next) => adminAuth.authenticateAdmin(req, res, next),
      staticMiddleware,
    );
    this.mountedStatic = true;
  }

  public bindAdminIndex(
    app: Express,
    adminAuth: { authenticateAdmin(req: any, res: any, next: any): void },
    serveIndex: (req: any, res: any) => void,
  ): void {
    this.bindAdminAuth(app, adminAuth);
    if (this.mountedIndex) return;
    app.get(
      '/admin',
      (req, res, next) => adminAuth.authenticateAdmin(req, res, next),
      (req, res) => serveIndex(req, res),
    );
    this.mountedIndex = true;
  }
}


---
# ./delegates/SubscriptionInvoicePlanner.ts

// src/delegates/SubscriptionInvoicePlanner.ts
import crypto from 'crypto';
import type { ISqliteStore } from '../contracts/dao';
import type { IInvoiceIdCodec, IConfigService } from '../contracts/interfaces';
import type { SubscriptionRow } from '../contracts/domain';
import { PricingService } from '../services/PricingService';

export type PlannedInvoice = {
  idHex: string;
  idBuf32: Uint8Array;
  idRaw: string;
  usdAtCreate: number;
  quoteExpiresAtMs: number;
  expiresAtBlocks: number;
  nextDue: number;
};

export class SubscriptionInvoicePlanner {
  constructor(
    private store: ISqliteStore,
    private pricing: PricingService,
    private cfg: IConfigService,
    private codec: IInvoiceIdCodec
  ) {}

  async plan(subscription: SubscriptionRow, currentHeight: number): Promise<PlannedInvoice> {
    const ttlSecs = Number(process.env.QUOTE_TTL_SECONDS);
    if (!Number.isFinite(ttlSecs) || ttlSecs <= 0) {
      throw new Error('Missing or invalid QUOTE_TTL_SECONDS.');
    }

    let idHex: string;
    do {
      idHex = this.codec.generateRandomBuff32Hex();
      this.codec.assertHex64(idHex);
    } while (!this.store.ensureInvoiceIdHexUnique(idHex));

    const idBuf32 = this.codec.toBuff32Hex(idHex);
    const idRaw = crypto.randomUUID();

    const usdAtCreate = await this.pricing.getUsdPriceSnapshot();
    const nowMs = Date.now();

    const avgBlockSecs = this.cfg.getAvgBlockSecs();
    const expiresAtBlocks = currentHeight + Math.ceil(ttlSecs / avgBlockSecs);
    const quoteExpiresAtMs = nowMs + ttlSecs * 1000;

    const nextDue = subscription.next_invoice_at + subscription.interval_blocks;

    return {
      idHex,
      idBuf32,
      idRaw,
      usdAtCreate,
      quoteExpiresAtMs,
      expiresAtBlocks,
      nextDue,
    };
  }

  buildWebhookRawBody(planned: PlannedInvoice, subscription: SubscriptionRow): string {
    return JSON.stringify({
      subscriptionId: subscription.id,
      invoiceId: planned.idRaw,
      amountSats: subscription.amount_sats,
      nextDue: planned.nextDue,
      subscriber: subscription.subscriber,
    });
  }
}


---
# ./webhooks/WebhookDispatcher.ts

// src/webhooks/WebhookDispatcher.ts
import axios from 'axios';
import type { Request, Response, NextFunction } from 'express';
import type { ISqliteStore } from '../contracts/dao';
import type { IWebhookRetryScheduler } from '../contracts/interfaces';
import { WebhookSignatureService } from '../delegates/WebhookSignatureService';
import { WebhookAttemptPlanner } from '../delegates/WebhookAttemptPlanner';
import type { WebhookLogRow, WebhookEventType } from '../contracts/domain';

type DispatchCtx = {
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: WebhookEventType;
  rawBody: string;
  attempts?: number;
};

type SuccessCtx = { attemptLogId: string; status: number };

type FailureCtx = {
  attemptLogId: string;
  attempts: number;
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: WebhookEventType;
  rawBody: string;
};

export class WebhookDispatcher {
  private store!: ISqliteStore;
  private scheduler!: IWebhookRetryScheduler;
  private readonly sigSvc = new WebhookSignatureService();
  private readonly attempts = new WebhookAttemptPlanner();
  private inflight: Set<string> = new Set();

  bindStoreAndScheduler(store: ISqliteStore, scheduler: IWebhookRetryScheduler): void {
    this.store = store;
    this.scheduler = scheduler;
  }

  initCaches(): void {
    this.inflight = new Set<string>();
  }

  verifyWebhookSignature(req: Request, res: Response, next: NextFunction): void {
    const tsHeader = req.header('X-Webhook-Timestamp') || req.header('x-webhook-timestamp');
    const sigHeader = req.header('X-Webhook-Signature') || req.header('x-webhook-signature');
    const rawBody =
      typeof req.body === 'string'
        ? req.body
        : Buffer.isBuffer(req.body)
        ? req.body.toString('utf8')
        : '';
    const secret: string = (this.store as any).getStoreHmacSecretForInbound(req);
    const now = Math.floor(Date.now() / 1000);
    const decision = this.sigSvc.verifyInbound(tsHeader, sigHeader, rawBody, secret, now);
    if (!decision.ok) {
      res.status(decision.status).end();
      return;
    }
    next();
  }

  async dispatch(ctx: DispatchCtx): Promise<void> {
    const dest = this.resolveDestinationAndSecret(ctx.storeId, ctx.invoiceId);
    if (!dest || !dest.url || !dest.secret) return;

    const attemptNumber = ctx.attempts ? ctx.attempts : 1;
    const now = Math.floor(Date.now() / 1000);

    const attemptId = this.attempts.recordInitialAttempt(this.store, {
      storeId: ctx.storeId,
      invoiceId: ctx.invoiceId,
      subscriptionId: ctx.subscriptionId,
      eventType: ctx.eventType,
      rawBody: ctx.rawBody,
      attempts: attemptNumber,
      now,
    });

    const { headers } = this.sigSvc.buildOutboundHeaders(dest.secret, ctx.rawBody, now);

    try {
      const resp = await axios.post(dest.url, ctx.rawBody, { headers, timeout: 10000 });
      if (resp.status >= 200 && resp.status < 300) {
        this.onHttpSuccess({ attemptLogId: attemptId, status: resp.status });
      } else {
        await this.onHttpFailure(
          {
            attemptLogId: attemptId,
            attempts: attemptNumber,
            storeId: ctx.storeId,
            invoiceId: ctx.invoiceId,
            subscriptionId: ctx.subscriptionId,
            eventType: ctx.eventType,
            rawBody: ctx.rawBody,
          },
          resp.status,
        );
      }
    } catch (err: any) {
      const status = err?.response?.status as number | undefined;
      await this.onHttpFailure(
        {
          attemptLogId: attemptId,
          attempts: attemptNumber,
          storeId: ctx.storeId,
          invoiceId: ctx.invoiceId,
          subscriptionId: ctx.subscriptionId,
          eventType: ctx.eventType,
          rawBody: ctx.rawBody,
        },
        status,
      );
    }
  }

  onHttpSuccess(ctx: SuccessCtx): void {
    this.attempts.markSuccess(this.store, ctx.attemptLogId, ctx.status);
  }

  async onHttpFailure(ctx: FailureCtx, statusOrNull?: number): Promise<void> {
    const now = Math.floor(Date.now() / 1000);
    await this.attempts.handleFailureAndPlanNext(
      this.store,
      {
        attemptLogId: ctx.attemptLogId,
        attempts: ctx.attempts,
        storeId: ctx.storeId,
        invoiceId: ctx.invoiceId,
        subscriptionId: ctx.subscriptionId,
        eventType: ctx.eventType,
        rawBody: ctx.rawBody,
        now,
      },
      statusOrNull,
    );

    this.scheduler.enqueueRetry({
      storeId: ctx.storeId,
      invoiceId: ctx.invoiceId,
      subscriptionId: ctx.subscriptionId,
      eventType: ctx.eventType,
      rawBody: ctx.rawBody,
      attempts: ctx.attempts,
    });
  }

  async planRetry(ctx: {
    storeId: string;
    invoiceId?: string;
    subscriptionId?: string;
    eventType: WebhookEventType;
    rawBody: string;
    attempts: number;
  }): Promise<void> {
    const now = Math.floor(Date.now() / 1000);
    await this.attempts.planNextAttempt(this.store, { ...ctx, now });
  }

  async enqueueRetryIfNotInflight(row: WebhookLogRow): Promise<boolean> {
    const entity = row.invoice_id ?? row.subscription_id ?? 'none';
    const key = `${row.store_id}:${entity}:${row.event_type}`;
    if (this.inflight.has(key)) return false;
    this.inflight.add(key);
    try {
      await this.dispatch({
        storeId: row.store_id,
        invoiceId: row.invoice_id ?? undefined,
        subscriptionId: row.subscription_id ?? undefined,
        eventType: row.event_type,
        rawBody: row.payload,
        attempts: (row.attempts ?? 0) + 1,
      });
    } finally {
      this.inflight.delete(key);
    }
    return true;
  }

  private resolveDestinationAndSecret(
    storeId: string,
    invoiceId?: string,
  ): { url: string; secret: string } | undefined {
    if (invoiceId) {
      const row = this.store.getInvoiceWithStore(invoiceId);
      if (!row) return undefined;
      const url = row.webhook_url ?? row.store.webhook_url ?? '';
      if (!url) return undefined;
      const secret = row.store.hmac_secret;
      return { url, secret };
    }
    const merchant: {
      webhook_url?: string | null;
      hmac_secret: string;
    } = (this.store as any).getMerchantById(storeId);
    if (!merchant || !merchant.webhook_url) return undefined;
    return { url: String(merchant.webhook_url), secret: merchant.hmac_secret };
  }
}


---
# ./webhooks/WebhookRetryScheduler.ts

// src/webhooks/WebhookRetryScheduler.ts
import type { ISqliteStore } from '../contracts/dao';
import type { IWebhookDispatcher, IWebhookRetryScheduler } from '../contracts/interfaces';
import type { WebhookLogRow, WebhookEventType } from '../contracts/domain';

type EnqueueCtx = {
  storeId: string;
  invoiceId?: string;
  subscriptionId?: string;
  eventType: WebhookEventType;
  rawBody: string;
  attempts: number;
};

export class WebhookRetryScheduler implements IWebhookRetryScheduler {
  private store!: ISqliteStore;
  private dispatcher!: IWebhookDispatcher;
  private timerId: NodeJS.Timeout | undefined;
  private readonly intervalMs = 30000;
  private readonly inflight = new Set<string>();

  bindDependencies(store: ISqliteStore, dispatcher: IWebhookDispatcher): void {
    this.store = store;
    this.dispatcher = dispatcher;
  }

  async bootstrap(): Promise<void> {
    if (this.timerId !== undefined) return;

    const _now = Math.floor(Date.now() / 1000);
    const rows: WebhookLogRow[] = this.store.selectDueWebhookRetries();
    const seen = new Set<string>();
    for (const r of rows) {
      const entity = r.invoice_id ?? r.subscription_id ?? 'none';
      const key = `${r.store_id}:${entity}:${r.event_type}`;
      if (seen.has(key)) continue;
      seen.add(key);
      this.enqueueRetry({
        storeId: r.store_id,
        invoiceId: r.invoice_id ?? undefined,
        subscriptionId: r.subscription_id ?? undefined,
        eventType: r.event_type,
        rawBody: r.payload,
        attempts: r.attempts,
      });
    }

    this.timerId = setInterval(() => this.onWake(), this.intervalMs);
  }

  onWake(): void {
    const now = Math.floor(Date.now() / 1000);
    void this.processDueRetries(now);
  }

  async processDueRetries(nowEpochSecs: number): Promise<void> {
    const rows: WebhookLogRow[] = this.store.getDueWebhookAttempts(nowEpochSecs);
    for (const r of rows) {
      await this.dispatcher.dispatch({
        storeId: r.store_id,
        invoiceId: r.invoice_id ?? undefined,
        subscriptionId: r.subscription_id ?? undefined,
        eventType: r.event_type,
        rawBody: r.payload,
        attempts: r.attempts,
      });
    }
  }

  enqueueRetry(ctx: EnqueueCtx): void {
    const id = ctx.invoiceId ?? ctx.subscriptionId ?? 'none';
    const key = `${ctx.storeId}:${id}:${ctx.eventType}`;
    if (this.inflight.has(key)) return;
    this.inflight.add(key);

    const backoff = [60, 120, 240, 480, 960];
    const idx = Math.min(Math.max(ctx.attempts, 1), backoff.length) - 1;
    const delayMs = backoff[idx] * 1000;

    setTimeout(async () => {
      try {
        await this.dispatcher.dispatch({
          storeId: ctx.storeId,
          invoiceId: ctx.invoiceId,
          subscriptionId: ctx.subscriptionId,
          eventType: ctx.eventType,
          rawBody: ctx.rawBody,
          attempts: ctx.attempts,
        });
      } finally {
        this.inflight.delete(key);
      }
    }, delayMs);
  }
}


---
# ./types/cors/index.d.ts

declare module 'cors' {
    import { RequestHandler } from 'express';
    export interface CorsOptions {
      origin?: boolean | string | RegExp | (string | RegExp)[]
        | ((origin: string | undefined, cb: (err: Error | null, allow?: boolean) => void) => void);
      methods?: string | string[];
      allowedHeaders?: string | string[];
      exposedHeaders?: string | string[];
      credentials?: boolean;
      maxAge?: number;
      preflightContinue?: boolean;
      optionsSuccessStatus?: number;
    }
    const cors: (options?: CorsOptions) => RequestHandler;
    export default cors;
  }


---
# ./poller/PaymentPoller.ts

// src/poller/PaymentPoller.ts
import type { ISqliteStore } from '../contracts/dao';
import type {
  IStacksChainClient,
  IConfigService,
  IWebhookDispatcher,
} from '../contracts/interfaces';
import type {
  PollerMetrics,
  NormalizedEvent,
  InvoiceStatus,
} from '../contracts/domain';
import { ContractCallEventNormalizer } from '../delegates/ContractCallEventNormalizer';
import { ReorgGuard } from '../delegates/ReorgGuard';
import { SubscriptionLifecycleProcessor } from '../delegates/SubscriptionLifecycleProcessor';
import { InvoiceEventApplier } from '../delegates/InvoiceEventApplier';
import { ExpirationMonitor } from '../services/ExpirationMonitor';

type CursorState = {
  lastHeight: number;
  lastTxId?: string;
  lastBlockHash?: string;
};

export class PaymentPoller {
  private chain!: IStacksChainClient;
  private store!: ISqliteStore;
  private dispatcher!: IWebhookDispatcher;
  private expirations!: ExpirationMonitor;
  private cfg!: IConfigService;

  private cursor: CursorState = { lastHeight: 0 };
  private metrics: PollerMetrics = {
    running: false,
    lastRunAt: undefined,
    lastHeight: 0,
    lastTxId: undefined,
    lastBlockHash: undefined,
    lagBlocks: undefined,
  };

  private pollHandle: NodeJS.Timeout | null = null;
  private currentIntervalMs = 0;
  private rewindToHeight: number | undefined;

  private eventNormalizer = new ContractCallEventNormalizer();
  private reorgGuard = new ReorgGuard();
  private subscriptionProcessor!: SubscriptionLifecycleProcessor;
  private invoiceApplier!: InvoiceEventApplier;

  bindDependencies(
    chain: IStacksChainClient,
    store: ISqliteStore,
    dispatcher: IWebhookDispatcher,
    expirations: ExpirationMonitor,
    cfg: IConfigService,
  ): void {
    this.chain = chain;
    this.store = store;
    this.dispatcher = dispatcher;
    this.expirations = expirations;
    this.cfg = cfg;

    this.subscriptionProcessor = new SubscriptionLifecycleProcessor(
      this.store,
      this.chain,
      this.dispatcher,
    );
    this.invoiceApplier = new InvoiceEventApplier(this.store, this.dispatcher);
  }

  bootstrapPoller(): void {
    if (this.pollHandle) return;
    const pollSecs = this.cfg.getPollingConfig().pollIntervalSecs;
    const avgBlockSecs = this.cfg.getAvgBlockSecs();
    const intervalSecs = Math.max(pollSecs, avgBlockSecs, 30);
    this.currentIntervalMs = intervalSecs * 1000;

    if (!this.cursor) {
      this.cursor = { lastHeight: 0, lastTxId: undefined, lastBlockHash: undefined };
    }
    this.metrics = {
      running: false,
      lastRunAt: undefined,
      lastHeight: 0,
      lastTxId: undefined,
      lastBlockHash: undefined,
      lagBlocks: undefined,
    };

    this.pollHandle = setInterval(() => void this.timerCallback(), this.currentIntervalMs);
  }

  timerCallback(): void {
    void this.pollTick().catch(() => {});
  }

  async startPoller(): Promise<void> {
    const saved =
      this.store.getPollerCursor() ??
      null;

    if (saved) {
      this.cursor = {
        lastHeight: saved.lastHeight,
        lastTxId: saved.lastTxId,
        lastBlockHash: saved.lastBlockHash,
      };
    } else {
      const tip = await this.chain.getTip();
      this.cursor = {
        lastHeight: tip.height,
        lastTxId: undefined,
        lastBlockHash: tip.blockHash,
      };
    }

    const pollSecs = this.cfg.getPollingConfig().pollIntervalSecs;
    this.currentIntervalMs = pollSecs * 1000;
    if (this.pollHandle) {
      clearInterval(this.pollHandle);
      this.pollHandle = null;
    }
    this.pollHandle = setInterval(() => void this.timerCallback(), this.currentIntervalMs);

    this.metrics = {
      running: false,
      lastRunAt: undefined,
      lastHeight: this.cursor.lastHeight,
      lastTxId: this.cursor.lastTxId,
      lastBlockHash: this.cursor.lastBlockHash,
      lagBlocks: 0,
    };
  }

  async pollTick(): Promise<void> {
    if (!this.guardReentrancy()) return;

    let tipHeight = 0;
    try {
      const { tipHeight: th, tipBlockHash, cursorRef } = await this.readChainTip();
      tipHeight = th;
      const fromHeight = this.rewindToHeight !== undefined ? this.rewindToHeight : cursorRef.lastHeight + 1;

      const batch = await this.fetchAndFilterEvents(fromHeight);

      const { minConfirmations } = this.cfg.getPollingConfig();
      await this.processSubscriptionEvents(batch, tipHeight, minConfirmations);

      for (const e of batch) {
        await this.processEvent(e, tipHeight, minConfirmations);
      }

      const unpaid: InvoiceStatus[] = ['unpaid'];
      const candidates = this.store
        .selectAdminInvoices(unpaid)
        .map((r) => r.id_hex);
      await this.expirations.sweepOnchainStatuses(candidates, {
        store: this.store,
        chain: this.chain,
        dispatcher: this.dispatcher,
      });

      const reorg = await this.detectReorg(fromHeight, tipHeight);
      if (reorg) {
        this.planRewindWindow();
        return;
      }

      const lastTxId = batch.length ? batch[batch.length - 1].tx_id : undefined;
      await this.updateCursorState(
        { height: tipHeight, blockHash: tipBlockHash, parentHash: '' },
        lastTxId,
      );
      this.rewindToHeight = undefined;
    } finally {
      this.refreshMetrics({ tipHeight });
    }
  }

  guardReentrancy(): boolean {
    if (this.metrics.running) return false;
    this.metrics.running = true;
    return true;
  }

  async readChainTip(): Promise<{
    tipHeight: number;
    tipBlockHash: string;
    cursorRef: CursorState;
  }> {
    const cursorRef = { ...this.cursor };
    const { height, blockHash } = await this.chain.getTip();
    return { tipHeight: height, tipBlockHash: blockHash, cursorRef };
  }

  async fetchAndFilterEvents(fromHeight: number): Promise<NormalizedEvent[]> {
    return this.eventNormalizer.fetchAndFilterEvents(fromHeight, this.chain, this.store);
  }

  async processSubscriptionEvents(
    eventBatch: NormalizedEvent[],
    tipHeight: number,
    minConfirmations: number,
  ): Promise<void> {
    await this.subscriptionProcessor.processBatch(eventBatch, tipHeight, minConfirmations);
  }

  async processEvent(
    e: NormalizedEvent,
    tipHeight: number,
    minConfirmations: number,
  ): Promise<void> {
    const confirmations = tipHeight - e.block_height + 1;
    if (confirmations < minConfirmations) return;

    if (e.type === 'invoice-paid') {
      await this.onInvoicePaidConfirmed(e);
      return;
    }
    if (e.type === 'refund-invoice') {
      await this.onRefundConfirmed(e);
      return;
    }
    if (e.type === 'invoice-canceled') {
      await this.invoiceApplier.handleCanceled(e);
      return;
    }
  }

  async detectReorg(firstBlockToProcessHeight: number, tipHeight: number): Promise<boolean> {
    return this.reorgGuard.detectReorg(
      firstBlockToProcessHeight,
      tipHeight,
      { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash },
      this.chain,
    );
  }

  planRewindWindow(): void {
    const { reorgWindowBlocks } = this.cfg.getPollingConfig();
    const target = this.reorgGuard.computeRewindTarget(
      { lastHeight: this.cursor.lastHeight, lastBlockHash: this.cursor.lastBlockHash },
      reorgWindowBlocks,
    );
    this.planRewind(target);
  }

  planRewind(targetHeight: number): void {
    this.rewindToHeight = targetHeight;
  }

  async updateCursorState(
    processedBlockHeader: { height: number; blockHash: string; parentHash: string },
    lastTxId?: string,
  ): Promise<void> {
    this.cursor = {
      lastHeight: processedBlockHeader.height,
      lastTxId,
      lastBlockHash: processedBlockHeader.blockHash,
    };
    const now = Math.floor(Date.now() / 1000);
    this.store.savePollerCursor({
      lastRunAt: now,
      lastHeight: this.cursor.lastHeight,
      lastTxId: this.cursor.lastTxId,
      lastBlockHash: this.cursor.lastBlockHash,
    });

    const tip = await this.chain.getTip();
    this.metrics.lastHeight = this.cursor.lastHeight;
    this.metrics.lastTxId = this.cursor.lastTxId;
    this.metrics.lastBlockHash = this.cursor.lastBlockHash;
    this.metrics.lagBlocks = Math.max(0, tip.height - this.cursor.lastHeight);
  }

  async onInvoicePaidConfirmed(event: NormalizedEvent): Promise<void> {
    await this.invoiceApplier.handlePaid(event);
  }

  async onRefundConfirmed(event: NormalizedEvent): Promise<void> {
    await this.invoiceApplier.handleRefund(event);
  }

  async onSubscriptionCreated(
    event: NormalizedEvent,
    tipHeight: number,
    minConfirmations: number,
  ): Promise<void> {
    const confirmations = tipHeight - event.block_height + 1;
    if (confirmations < minConfirmations) return;
    if (!/^[0-9A-Fa-f]{64}$/.test(event.idHex)) return;
    const storeId = this.store.getStoreIdByPrincipal(String(event.merchantPrincipal));
    if (!storeId) return;

    this.store.upsertSubscriptionByHex({
      idHex: event.idHex,
      storeId,
      merchantPrincipal: String(event.merchantPrincipal),
      subscriber: String(event.subscriber),
      amountSats: Number(event.amountSats),
      intervalBlocks: Number(event.intervalBlocks),
      active: 1,
    });

    const onchain = await this.chain.readSubscription(event.idHex);
    const nextDue =
      onchain?.nextDue !== undefined ? Number(onchain.nextDue) : tipHeight + Number(event.intervalBlocks ?? 0);

    const rawBody = JSON.stringify({
      subscriptionId: event.idHex,
      merchant: String(event.merchantPrincipal),
      subscriber: String(event.subscriber),
      amountSats: Number(event.amountSats),
      intervalBlocks: Number(event.intervalBlocks),
      nextDue,
    });

    await this.dispatcher.dispatch({
      storeId,
      subscriptionId: event.idHex,
      eventType: 'subscription-created',
      rawBody,
    });
  }

  async onSubscriptionPaid(
    event: NormalizedEvent,
    tipHeight: number,
    minConfirmations: number,
  ): Promise<void> {
    const confirmations = tipHeight - event.block_height + 1;
    if (confirmations < minConfirmations) return;

    const onchain = await this.chain.readSubscription(event.idHex);
    const amountSats = onchain ? Number(onchain.amountSats) : 0;
    const nextDue = onchain ? Number(onchain.nextDue) : tipHeight + Number(event.intervalBlocks ?? 0);
    const merchant = onchain?.merchant;
    const storeId = merchant ? this.store.getStoreIdByPrincipal(merchant) : undefined;
    if (!storeId) return;

    this.store.updateSubscriptionLastPaid({ subscriptionId: event.idHex, lastPaidInvoiceId: '' });

    const rawBody = JSON.stringify({
      subscriptionId: event.idHex,
      subscriber: String(event.sender),
      amountSats,
      txId: event.tx_id,
      nextDue,
    });

    await this.dispatcher.dispatch({
      storeId,
      subscriptionId: event.idHex,
      eventType: 'subscription-paid',
      rawBody,
    });
  }

  async onSubscriptionCanceled(
    event: NormalizedEvent,
    tipHeight: number,
    minConfirmations: number,
  ): Promise<void> {
    const confirmations = tipHeight - event.block_height + 1;
    if (confirmations < minConfirmations) return;

    this.store.setSubscriptionActive({ idHex: event.idHex, active: 0 });

    const onchain = await this.chain.readSubscription(event.idHex);
    const storeId = onchain ? this.store.getStoreIdByPrincipal(onchain.merchant) : undefined;
    if (!storeId) return;

    const rawBody = JSON.stringify({ subscriptionId: event.idHex });

    await this.dispatcher.dispatch({
      storeId,
      subscriptionId: event.idHex,
      eventType: 'subscription-canceled',
      rawBody,
    });
  }

  refreshMetrics(snapshot?: Partial<PollerMetrics> & { tipHeight?: number }): void {
    this.metrics.running = false;
    this.metrics.lastRunAt = Math.floor(Date.now() / 1000);
    this.metrics.lastHeight = this.cursor.lastHeight;
    this.metrics.lastTxId = this.cursor.lastTxId;
    this.metrics.lastBlockHash = this.cursor.lastBlockHash;
    if (typeof snapshot?.tipHeight === 'number') {
      this.metrics.lagBlocks = Math.max(0, snapshot.tipHeight - this.cursor.lastHeight);
    }
  }

  restartPoller(): { running: boolean } {
    if (this.pollHandle) {
      clearInterval(this.pollHandle);
      this.pollHandle = null;
    }
    this.metrics.running = false;
    const ms =
      this.currentIntervalMs ||
      this.cfg.getPollingConfig().pollIntervalSecs * 1000;
    this.currentIntervalMs = ms;
    this.pollHandle = setInterval(() => void this.timerCallback(), ms);
    return { running: !!this.pollHandle };
  }

  getState(): PollerMetrics {
    return { ...this.metrics };
  }
}


---
# ./poller/PollerAdminBridge.ts

// src/poller/PollerAdminBridge.ts
import type { PollerMetrics } from '../contracts/domain';
import { PaymentPoller } from '../poller/PaymentPoller';

export class PollerAdminBridge {
  private poller!: PaymentPoller;

  bindPoller(poller: PaymentPoller): void {
    this.poller = poller;
  }

  getState(): PollerMetrics {
    return this.poller.getState();
  }

  restart(): { running: boolean } {
    return this.poller.restartPoller();
  }
}
