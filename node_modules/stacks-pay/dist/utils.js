"use strict";
// src/utils.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateStacksAddress = void 0;
exports.isValidToken = isValidToken;
exports.isValidAmount = isValidAmount;
exports.isValidISODate = isValidISODate;
exports.bech32mEncode = bech32mEncode;
exports.bech32mDecode = bech32mDecode;
const bech32_1 = require("bech32");
const c32check_1 = require("c32check");
function isValidToken(token) {
    if (token === "STX" || token === "stx")
        return true;
    const parts = token.split(".");
    if (parts.length !== 2)
        return false;
    const [address, contractName] = parts;
    return (0, exports.validateStacksAddress)(address) && contractName.length > 0;
}
function isValidAmount(amount) {
    return /^[0-9]+(\.[0-9]+)?$/.test(amount);
}
function isValidISODate(dateStr) {
    const date = new Date(dateStr);
    return !isNaN(date.getTime());
}
// Bech32m encoding and decoding
function bech32mEncode(data) {
    const words = bech32_1.bech32m.toWords(Buffer.from(data, "utf8"));
    return bech32_1.bech32m.encode("stx", words, 512);
}
function bech32mDecode(bech32mEncoded) {
    const decoded = bech32_1.bech32m.decode(bech32mEncoded, 512);
    console.log("decoded prefix: ", decoded.prefix);
    if (decoded.prefix !== "stx") {
        throw new Error("Invalid HRP in Bech32m encoded string");
    }
    const bytes = Buffer.from(bech32_1.bech32m.fromWords(decoded.words));
    return bytes.toString("utf8");
}
// from @stacks/transactions
const validateStacksAddress = (address) => {
    try {
        (0, c32check_1.c32addressDecode)(address);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.validateStacksAddress = validateStacksAddress;
